<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0d11bde02f3f561ca8a89e5030ec90a292800502c3d9b7ce0d36324ee541f35713a1d4accf74006fa4aaa60749c230628462c234d10d8f721b4305d8272c28602cbf0642ac9ea548a5569b81ce435a18f22f409b1f4076b3b3fe57aaee422ff7923af806b4daa64b4c70be136add4e58ca0d69b299d1c07b7cb2c6f58c87f56f424f26c72922e6c4f8694f88f479a79fbf7eb97d8ba82ad91bdc63f389cebf45a35f71e8acb83aded08ccecd37fd75d18b1fac575082b3fcde70fe86a15c8445beeffa6d290a54d2c89c549e83ce4df1e03f0592187091c9c9a09a6a3b289c413e51a4baa4b531dcb26ff15c55dbdce968c09c78797a758a53f6e31e3b6a87c5036559bf50fc04b6c6ae19995ef236065824293628d4044da728b49dfa824e463053078adc1fc02421d321152b15feb76d95629365ea61c024bc7f7e7293d760cd47d29e9f3796b9edaa5e9c10a0a8642560ad859101356ba9bb5615e371cceca1adb333612f289ef580b5474fb0207e56ce5e011b2c50015d2c9a414409515cd6a7c45ed207e4d5d4b3a6059a660b3a0fd18dc6e0300818a8c02b9a57f80d90474d887d24e57abfb34bbdfa801b30f60e45c364d57647c41b1c9b23780de4e3c90d35d3fe8d1bb61427de68eb0163120d7778d2d71e941a3c25713faa003be67d2d47ded9791381973974b7511602703f815b1635b993dc6b92f254fc3b3164a0c36e5acab9203b585216d08043e357fb13d76f302ab351629dd372dddebbee0fdff40b5af58af70e03e6b6b7595f0bc20da9b9f4e7d8a5a467f220c495b41cd41428538afa891a262645d306b15e433e99178fac4f9fa317e19c403f4c9165884f8364f0305b57bf131afe8ab0d246c7ecec78216169f2d4fef5ded11a571025c27ff871c65c12a26bfa5b7891e22fad8448b99ed8847f05410812a4022b098fa86127c780641db3b071013a4a0cb00ba6e6c357216e2df9a9148a0524c269cd3946da427e7297ae64d85ee5dae917a95228c52bb79054638bdc4b42de8cba99490b387d1c445be28f8a142c0e1df121cd0c37d92397767670d9d9366a7838ee72460b5b3c992fe2465aaf04694c71f9b5d2b5c68d14619452e01c53a891021f23cfd7028cba1ea7745694b0706f98b28256c16da229b40d6a145cf6378070150553c1e1e4e8427cefb6781e5526a9778731cd473a220091911eaa5d125dabb22615e1ab7b9e3f51e9407e5aaca4fe429a49e37d5933f30830d80a662e755a80e01baf15c7ed49f0bc6d4bfa0f8cbc899d1544c7ff613d5de453352f060a8cbd6e9b5f9ac25ce1e4f4c9f5f6c505bd93c0b77c21e54911433299258a5d902ed3f59569bf2085c14d63d77a95fe5f17609815609f7aca34ad0b6691144ac4f0e5e43c2b8fabe01920e662f513e877c2cbde425922613fee9e944937944403420c390aa6ff8065a937afa855d07d895709814fc7e12f5b9c36155faec0774c59c4ecf890189378b07bcdcf474e4495cbc87d9c55081201f4816abe4831996a5afbbc6588c0a079ff5c8fc10b3280a4f3cb5d4aa66c3097e2d7fb5f361111923c225d5b84d51ce29b4a68dfeb87eab3a841f9134f7ae9fdf6064eb016304c17e51436dcd80900380fbf595ca10b49228eadf40582bc3ed088e21497e0f93bd1beefc6e5c7a6fe8c94500a54b9396b1821523a43f9c8b3ba812a7ce45badb624eca0d3f3bb4b4c01fecc33032ae9f86a0c5d1598400597d6583e68cd66e9020031148132f313612e2ea43ea743c85fa5bbf1618a302c5c66417f0e81969c4e3c8161f73ef14a0e5e594a3acb36c7f58cd06e8138826461b9d756d4f4ac6baea75b09ede28af0946f07a210bb19bf0855cd66189b1014d56855c62e88d24d93e3fb338b60953088d1b05ca2df15ba16b51e971979412490f99758b0ed53f538786141aea8d6750f3110cc34630fda9fa19196b3fffef45d0d32af335f7911426a5d102c50e9caa879b7a48aafadb2104a8200d6905a601ba600784aaf59ce5e6fac1877f1928e0ded21569b8e66aa05c5ce36300d74fedfdde0f8934ccaf3bd740f3291e7847412b21028856918eaf0f0fbbd0e44161a6485849a94ff0b69936235fc712f76eab3851b79a921b93b3424e9b5b30cb52129da856dfa6823d230a70ba59fd8643d323cc75b0a4df06b5e2930694d567b3856db8677fcf5b1ea04567761a01b2ef99e9a28b6230e604a27513a3f0633309797baf62bb024ce80016b5f6605b33f956f11a81436697558f4859b5d2f0e711b862282fb84ba3cfa40a6d536f111f627f7b86f8f02a872c7bb96201ef463b400ac9987d5b45f3552c7c44de3fec089729571c5e61e163369c544d2de7051b0bff90be8fb51778e4ee25ded29f2409171e8af7717eaa56f329a4a7ada18ac08f1b8716803d455cc7654c12ea3f25f1ce28d10f5c52d32ef0d41a32c6c9ff87f65ff4ae8fc9c75978b68c4eb18fb14d448ff55cd1ccb9306be0d5b6cae6e7e1cee750856e25a11adced1fc97e151ea62b8588d9b45a23f78a26f8561992ed32e4fd383cf82a05f30fac069bf3a094f9b97e1e8fcaaf4a819d97ff8b89b800ad9ab36d2996a3c5dd0525aaa8961d6067789407e103b90b94e884368eebbea64fae12ebeaf9446e7752f87de0fa0721b026e0d60ca30c56d8114b9fb360fbf8e7a20b7372d7a8ad4f3bdb071ebc821697e25103ffd9a86e826f28db76af5d0a5707a4c1a382c9e794f50b30997590e4cbfd5353e36b5ae13830d59237b84e834facb142d1443e7975c1497f48ee6e5f89eb5c10be001f4c3d3c775dff17465ad4cda53b2500588fa18a34feb73a2f476bd931d1846c6419bd17f8aa3fdb36aaa4e5ae2b5e76e3d813ff1e2f2a968ea3a01698e239ab43c7f165db18be37a3c50edf11b81bf4d3320607429ed9bf3bd5cee15fe1a29415b49d91b9c1c7cea9e1b63f64f91576facb6712a25c2bcddfd179544d383fde1eb8ebe9f162fa1392ef293c936b06fa514c6122038ffe4cde3a0739f97feef8fc4e253a67fc7bcc36c6ed13be159d7bfe5bb8826c1a26998fd616f0b6542af638df45176147deb8d2085cc7d14fe2bdef4dc570a13d3b62c566c953a38c7fa799fb7b8decfcd160ea608561184c54d8b9a636c3b1f0ee180885a99673e311e8bd60be646b55566a6558d4272ae854e6b015d50fbdeebd1ee71f339fda0e849378610bc9161c5b8e29908f39d0d8427325bf8109bc74100dc2f1f619ae518f4fe73e720d2dc3452f104a35ab52d7864b31fc16aefc3e511307da5c8c1b353d388891222c479203fad7d8fa61456b1c87259568cdd49ed40aa6cc790092218edb2d71ef4a1f0df7594795cc9a467f32559c9bf942fe8b311d9394de7990010765184c47521ad6aea70796d13ef04c2064ef203beebcb5e384913af4efc7494677b5f24b5385d3101ba17b80c77c5da9075525e632a6ec66763842ef4505ee561711ce2ceaf0aa97da054a704899656b16ae954bcbfce4b78d6c016e98b18ba6e61ce0940da4d73d0ba3d756e3b584eb4b8d802aa13bc4c9607cbc5947d881efc2da85b8459825b66327807b7fc70401c33b30ba2e9cefdf16a92eb2a6c5855d0320bcb1db8a5cde111902de6c713f80fc10b5992c1956fc6a94f8edc407869259049d9d3716a14f33ab162c1ea124d124b2de25e09845ce47b47ed844e75cb56df651d142cfa9f8dfe4808dee0cad5ff946609d1149e3d0a4508b8c669802ffd53927971ec0607b0cdc3b15f24a7c3c34df0356006e3f8076677e4d4ee7e54a262c865b7359a2be8a0a0e0415b2ad4ca43d14c0990d0e8e85439e8b5a08c116d4bfabbd727e9fbaa7897e7b99cfc00188ed4e1887b7250f3ef6181ba1341dce4881e78fa469ba8c40ba5ba968d78187675f88e23a87742027fb3e762aa9f0e05a9e9b52f66eeb5e719cd6b4ddf70cad8a6cc9fd17a22c18b441401c11276a63043fb7fc133866d64c765c2b0f1f3b7d135236cd1b3186c40cb308c8a6a6e7677523d7eff1cbe00f71ce0fe4c06bceecdf219d7d2f1c3aace20a4bc669a9e3b6f685e452c6e7a3d7d113a2817b639a707949d6bbd3d9660693c745c3cdecb4df36da92a67e6a6447981fbce02143eaa498e618e04aa734608eae7b2b2962c5c552876b1e62e3a3162b0121d83e01e000abed21c4db4c9b66367df65bc5563fe7969ef68aee7112ceb725fbe92dfda78ba8a735c765c67b08d5ae2aef4f7e6790ba15f24570daa772a201822653585e259138e761e55d037662a6110e3a3c12e790a048aa1f341f8d5cf9436db5f2758d99f23d3042e7df542aaf5101b3d38c0b996a46e3574df6491b5b72b2179254c712cd3c42b87e1e947d4602930bd354c93262db0d468d3853294b317042360087f70ddc7784a9a4589d743c0d0db776e1b8f6df3e9659497dff9ae98429ead119b829352e4e110e554d5843087b92b973fd498f95e6ee439c3b868e98690bcc9eb23049f47ad0dbbb7597c16cb2efbdad3dd9e843e889ea351a644bea7b2af1c1d5c21ae063ef3f1e61512dc78c392d75105eaa006364c48ef12f8ca1c0022697ddad323f3d268fcab1fa61484788e8b3865184c301350da3956b8ced2e305ac390f2f40aa32dbfb41decf4dfe167c9d4426b1a6ed91f425320433b8d71e7b7a78034ad39a65870edb72aac2d303609c48202e7338730a77c1bf29501cfa3e7b2aeaf2f697d550f699b2a3cbf69f460575c6e254e32d8b57646e33cd0ab473ca77553254d55f88859d7a8ced20459602bbcfec93fd32281cd259930ce4765c29aec0b4b55877d6bdf255240bb81213850fcd46f4da834fb507e5e4b3922cfb8cedf5dd8b6561959b91668d3be324fc2307db86ec76ff58f6add47c34f61a29a7409d482f18a50fd4a9adfdc076965e2e8885bdfe2fd4acc7ee16a62c7bad36301bbbd8d590ff73eaf00a6264fe609071127b372f1c3c1405c00a4800c89038566b9f67b7e162707e62d1a377ad6667a1f2f49e01a2106c86542cd1b6f86a998a06035ccc2b44178315c5515d34ce232a61454ffcffbbbc3014a9cbe62404b05eef5e093f01f01e2a74b10617b01afd139a38e105c8db2b42fe76dadaedc722e97ce5db6745f27c0c0b4b1ef0a2ee0a38bda5a70ce23ce61b2c91e7d89f47eeba2fb33d5601cb83b88ee5cd5e04f58c230135bc23aeeee4f42393a4af93e706c7ab754f91703fa5c1a87620705af23987c71fc63bdf54863aba0b6d359906c765e614493445ef324d641e62dd3becc12f63a601a4d1f7c4660d771d85c253357c5965f0350e11baf5bf04256bc3c82e774bba1e51fb79dfdcb10967645718364b40b0b97fef502305c4abd82b67023402dd71af46e4bba606b3d914727deb8ea506e0ab653f66b4524e7943b28ee47bdefc1692ebc0775e49114f0f95c0ec81f5314d407bf9beb0ac3692122f6854805e8aeed23345e9e0df468034767e0d2d29606394e7b2181e3b87bab89c172cd7a6cd977e1df3f3e4fd5e05936e9b9d9f932d38cba31c414e2cd659fbda8f4522c27e463a8cd543c506b8d377be14ba4bb61c332961cb4b5dd6a72becf5cf47ac2964c93b925154afe071b7217e7095ce3685e345fcb082f1dcd09c16dfe6f6d86ad5bcf1453108852118479aa6454d3a295692bb2abb8a1dfc8f50e03934daed0addd42df953f36449cb05368d048c1016535d09d404f418fa149d93cb99271f3c140ae2ee9fb96624ce10f186801f2f21a25d8ac0146620cb4ac249e1ba4cb5a4b88cda4f9a9ba13dc44ae580c60083730443150b45e9e393d0205e54ff617b0d5d9674be57bf273d4975f3664cef67b88b54630c87c53e2450476ec3fa2dfee8c1a134747fec9368e0b36c2ee50791164bd0d69ab6861550ed9e62d4ba808f199a3c021ef8479476695d438455364d536412e746467fcf87336937c6c37e18002044f60a98b19fb8f03474ac24865897074d2b6ec8e92f04d5ac92600acbc861576bf5c2019d81ef1333210d2b68c358ab0e7257a1918cf3c04db2760d99c9eb7eb696ff2a13ebbd7b4d6557edbb4a41d9b3e85de856689d2c7a7122174be884cae21a94bb490bae89b397c7426c65b695593c4907f10f99d31caa9153d3d8bbfcd6afea56a2c13423d820d6d28cb2a343a627f9efaf92b87b37b4e2fb88a97d1399e06c045d226d080fa67fae54e272c5bc180d1896a3877b84d8382795f67a467806b94ca03a669733ea01a05004bd676af1b22370524eb9d566845ba8c6aacabd7adfb651ce2afb9325abd7247971a39776d2d0429cffff97f7b5da54918bfd4b89c1a1e5770fde787909f3183d0ffea545bcbba083b1fdfabff4d612c30de37c0a9352f5073fca80e5e97114acf2d8162a22b1fd06ffea76d365c48fb6a9f29cb72404a95c652f714a7a155b1d053cb49fb083051383b384d85f3b2fe0a0437ce7534226981dd87c80f84889aa197144bdf7ffe208bd793ec5fff6bfaf03f179ccc856525cd617dda35b6fae8a8eeadb70fdde129e9a1def1b7e7f87bd25d3f2af8091783139a5fe8fb5502ededd9c7e052639a89f50ed5e95930850ab395246cc9cbea3317857c1e018ed2cfd5be2129e4a9bac842ac6f7f699098c7198d2fd4bc0091909b24cb97177cbf093cfa5a1e2680c2dbc0eb2a9212d156053d60dbdbb2dd5d6453454b77c5e32e2c6e0d42cb893834eb52f4057c9986cd1cd9adc519a514519fb5988be6f63422345428f8964f4cf3762a9d4a57cbc1c70449d3aea24a8424077d94923d8666b0c04de78ce7346058fe9c4fd2826e7f2919fc79c402365eee687c2c490630b5930a0f9488cd38d324c393a85cc160a0073bd3fbda2f1974765b3eac38ceb942751cfe4b7880059ccb410015b8e06669a7695bc871583bb1725d0cce15d92945a5d1a09551efa6c0e20f576052ee6ed17a8d942293e385530a6a680eb6109fed064b064b9951a06a665abb54844dbbce7d62a1715f5b5a938138a241a23fa479d96d99196d50c0eb906048151453401639eeeec6d66cab714878c5722de9593d6cbe7d436b30b5b158a4e0295679c93e207dbd5a6e6b543547a1115839ca342a06c71f2d1558d6ca6df65423a7336a38bfdd9b7e9665cdce5c2530d7940c6bcdea5636b7f5637cc1fabedf4259177376e4a9d75fc040734aa972a35433ed075ff292e42d5cfe02d4c972b85d1ee113c3fe0d4dfb26d99f93439ec67a8a5af62086e4e88b7c322fa6a4b36bde5d1234500619208b1413872a8c2adccbda81df38e83234c0b7c3aedfdb805f94881abe05f36566a2ac8ce96917d49304522c4bce1142980e876260aeead5218ac90f337c34cd06cb47a4c3db77f392d43eec3b82e964528c890e7d8ed450e53560c519af00ee9db574f9ef8a245a83d144aeb72617357648f4f00d016ceaa850725a04115c9decee3c3fcf785ce3c1093f91ed1b590f65f9cc994529c39252ef9d5b4e481135962fe578aedf9cc96ac7fb778978a5ebdb20185a74e995cef79a0f9584f7e6a539d7e18627095b3916707e88964f201c9014250690b00b6e09b0f85b1aaf7488e4b18059bf3e5aee8d1c3f5302b8335865164bb0fd3a0d54caba77121aa48fe3557ad20cf9fc932be27af6265bd924017e51296b737835f1ae0c7fb8b7ead0eec6d2273e9479f40ff599f18ff98a42d62ffb0ac22065b0ce6242f7b1761f090861087c2a54e93acdba84cfaa60e6f9693e7ea4e90244d76e1b73dca3ca7852a9acb1118cd87faf4696333b23dda8ea64518d82fb5981ffb93133e93fa824167607682cb5db169e95d639ba5f7bce5e87887ff1b0c9f60cbbd2b630c09debcb640e48e44c21d746070ef39250f0f8c81496402366328a33d82d876668df4f00ff0f7b66aa19cba5e52d82ffcf4be2cdb9c7e56fb46a2a68a408551b40cc39762daa5bcfe60f5ff5f61d0435af38ebbb723750c710b2b5da711926891738a25950069422ece2f96a9e9e5d62e450f43750709306f36e7674d50144f609e386e2e8fa3b97c0f37524f3e366a168f18f2cd6ce176419e88892e4ca345ddd0ba331ebc5733779aacf14ffbaaf34fd5d55392df19addd35900cc5c7a739fe1b7fd022093937f4c7ac2a08e13372c86a5da4addd041d569f737c4ea8ae19cc38422290ac4fa97edd3681ef4417fc35db4ccaa674853584f99b047d0a87dc78af87bbd2ce6b17e00155086e1a73f0bbfce0b1f1ccf1680d506c13d5a8bb460827ea98dc3e2f5e9a48a4525ca139b46b7fd7eacbfc1b3455d3682c99ce6fa8e0f80bb47dfca49e078675db579073aae236cf59bbe34f2a49b4403d59bab6a81b606e94546153c02322e605b01ff432938b77a5ec87ed97c86d1b44e9ad3d4423473233875bde6121b961184af0c038755bd2ef3565d56f7fc91eab964136ae3647a0aa7bab81fcc64b5db834e9f6a43f86489fc90edf118e19f25c1de925a74bdb0055c9a16dcee4c2011af415d52d1fcbb1c94959f9d6b726a36caf7038bffd876ce14d37e3f47d21a4e980c0995a8ecd93a855cf64786f77099d08b86cca30804b21ada8357f5a17060e769482352888d583712660e19321c92b48482ff7dd3b006c50d419ce2ed971c10fee07093a3c5cdd9d2e5ff1529ce904dc8a10f362a7c6919368388e9593d021301d97846d5229c85c90b1c33110cd74007dcd4ba72e6620c52287cceadef27725074d7b45fc4e938b1da0f3a3490541dcbb01f49d143f3562651d2cf2c7566a6d7d433f99dee34c613d19aa7337a363c23d9aa800e24a58485f2c4739298e05d5d62b151ef24ef915b3cbbf58285cf4310698f5690ea5696c74133dee21c561dc86860d95b4f3830d25aad48f2f5b62a402cd52ad12f57fb7a40352b735f7e756223176d702bde6044e58cd8940f208ddcc31905315b2a8e00a74c25fc0c8963fe83168f4bec2f9fdf3206aba81e13895b808ad4d089426ac612410341cc793678ece2c904e3068e1ebda2147a728b327e3c30ca2780b1b2288b56f750ff50b23d9e21f649d945118b4b4dd8f28504982f4ed672e4f443339296f937361e848857a88c38bbb5dbbee028a0cc9ff98ea910b63ba9daebec6673eb1a02fe6051b3236ffb9048a53cb7ac39280b317e5faf1c37844a51511f0de7ad1af8c0a604cb1652469d9ef119b4940fc01fe600a414851fa24aaef864765f787d46ed81bf52b1185a405494defe9f7922d69abdf35dc4a7bec23f4e7f7febbc01129bdb4b7fe819fbde50b95d3eafe43d2d39042a23afe3d193676b7b6f0ed72f1463392ff7e3bfaa75980b17ac4b10bc02d6af34c4f5ad46785489bd5ed32e97c94bdabafcd2b74df2ad2b7b00244904eb2aef39eeb1aa3cce43fe22ee6ce90a623c297f160db1075f638550f792f149c22fb2024b15f35ee9d03797f51df8198c0181ec3bd7c2a969b5ca7357b11b6cf87aa24c39e7cbe4e032469be5746582ba3300f485bb77624c8a20a99b41c5d0221744d49ebe14e6d37e9a892c0dbe493d8f8c99cca3b265d2952878776939c2e9ee4e1d3420cb851a68992b442c0fc39c8169b21f31bbf14ec8008756aa7e39da5ecc96e3c21ce1f1eea838867ff31b88b5f85c9806cb0c4ccb7df8649ad1657c3a727df1a019633761923724aae1e5e5353c0fec61d1cfa508ba3e363407b1533ecec3b6607b59686da79cfbc0a6b001ed7470f78d332da7d66740520196f6bfa170ec1dcd6dccd17fb60855937aed5f7b061cf3227459f3e0c5126e8397481b1d9a75eea9970d94f9a7396b7bbd2618d3b13b2648d70bd432133314f3a952ef179df9193c3528ef138323021297cb770eeea2f8c1ec733aa0a52d7f259fea938c995a3cb47d1e0cd7f261cb8fd837c6e2d934220645f7f674864f4a4ce16a5b4708792e22e1b2406a64d430bcdc60dbeb75e23b51a176f5bdc6c235434d2245e33719f0148c8f12150e43df2b6082568318558891b137ac7e04b926ad77f0f1b79021a573a57903601422ba52f8486eb5b0946af009b9c567a07c0b31cb170e75412f24380e7a7c251bd41eaf0fdb184037088109d5bd7e204b73bc5e165e776af0ffc031d9db1290fdc8d1b1daac90a11081ec08169fbf9586b9102901b7fda399d5bf5e3a991bf926ecdc56e34737e81c9afe386db22830bf375e6eaed9ef3e5b365dd32326b385f20be3eecaa84a2f2699b90d36b799621c6d8d9ea8981420f9aa49e12fb581cfa4a70918f9c7e8dc3bbf143638e48fe09ee8489f232052ebf56bf422a5c356c1bd17fb8196a72c6eddec0851128affba37392813730a0cf2dbeb8002781243cdb6cdcbf02622cc594a9c6a13c227cded46c75ae90086f1523756adf8d15e2d525c0de45a6aaf9b57ff9c1e30a7e8c2565b40f3f67fde496fc7ef70e1d2257e96e3dd42ee9b648335c566490df37ffa8f7ec317406ca379d3259198ed60f554ca0f7a8e8466fbb3926b89e0947ef87a6c0839c1242a9b5995d103a1737361f96fa176a5f32731c9f79d68bce876874ea8a50a5d519e16ef4664f77fb77960cc0152ac35adb0f5159583c2a3bff96875fefe38144f19069c9bd5c8dc12fc579a21a9d3180fba3f5f69307956574f5324ca389a85fa3f03d8fc706f505aeb4029f06963edfbcb5ea66d33c002b096618159ee2390eb5e343683ffc65cda0c4431f6144e4a853114aa74222b61bdcdf6994bff85abb6a103bd4e7d7235738b1687bbf5602c0c4f20dfe6b45401a30ab0eba0254281de0e969271793adc9f1ce36022a0e018988556cdf45180cb16b7ccc5bbede45cb5f20f52441f6dfbed563c8c8397cae129455827cf15617d8b4baf613348c5a703858ac4ff56f15213a96c00b79de6c66ed463b197cb7fa923374a60bdeca362a58880852de01576e630836527ed93d9f7b30ec9113389c4a245fe25e550e1ba11fa65a91b5ab0107522f8b9b35d88d8ff6e2bf22cb3bc1cc85bffa299ec23a1bccff580144cbd4aebec13cf830e59dfe11fa5b0d373026f529a09d8ca4cb840aac6fce0fd9b27d3f7c7e31444b661f5ed0e99c69c66b938b0b7b78c02974b541e5d99e04b430fde5b8073ca2132e278573c81b2905a076cd6b2ffc0b5dfc8092c674a076d874a98003560a758646c67d2b0b00f671d82411ba561c53d2b1f85b0446cae52e74602a9cca9c192090f74372175831fd972e1bd962b39d20567abc34f84dbc8bbb77dc23ebf6da1e9c5b3c98e46823ae462d83409a90143a2eb97142911f103593286a6fce35418ece2dfc6c9c52a4876cd6ad1da2d41237b52a22e2bbcdd0897d0e122e469230c40e31fe0ea5dd6d9a6064c0c133a4ce64c146ab418cd6378c4e63f11e721d46180d75760da339e28d06015e1e88c8c89ff053e161b4abc6693c66dd6d73b3c54b9e551888feb2e45276f37f7c574267d9832f0c50909fe15e955438a487c521269d56debd2269907f7321b0312f86f0380e4d7be384615cee5936a83c7bde079ca6dda6e927c346c494871ba44b45a6f60cddaf6ba812de4ea16b23a328c991304ba329b249689822488b0651517773afdf8a79a7da7cb665d08918da227658b74e73a7c6ffb29bea051fcf737994120e73e7bdd581cc682448f635acaffe5c2258b5a0938cadeb4ef9f6760b4aa0c2153e840152918cd6ae53895df1c3502a179a419957e53e49379ada9a742b126faf6cd69a77c0e7eba0569fa611235cab5f3d10d7a79256b239adfd1a8fa4bf470c65f3767a846fadf717cf89ca192748e8cf014e6a2705435ac7f144d760426fecf58cd122cd3f5f625dc04f7ade7388019505b58690960ec5ad081c0a0226df453d405bab80af63e38b82fd4a69e8289570b440381ddd86a12e20f8272708f4b6c6d3c4c4277a8441679b82ad24fa3d6dbd250a83decfb4e19033fe0f4c6471dac3fecbe58096ad1afac6cd47ea24d551991f3b301c4fc28e3831e74960e4ab80f4df9989e05b595d2cbea74855486bb968cdb65ba97dbf4336e05af9e03895d7aafdc294e78698bcc7ae0793dc1b57a37532d398cc47fa023c14b4b6489adcc6ab24e08bed86df1cee48245688b327505c2e01b9ee48646f948b8795c1e669c03afc0dd778fa0a0f8d9c971acce0ce43cff2502eb6a5d553bc8ec3ff2e6847c49f1afd942c58fa4b314b095e0e67af291be53317999f6063ab9e3f6bee39bd2650aed4fc9ae0521e4d1ba7b8f91a30348978dc63522190e7bea9e02193969e3aeb280534f874ed7251ade1e72cef69edcedd37b70b6e298e1031573fbed179c6fcfade991141e88f88f4b2da23832f0cf8f2d65176bb144e94dd4fdfaa0f7545efd47232d2a764e811d82387595caaba7e4a3292944c1440f526dc29a56ec50ecd0b5b6c33400295a0d9337e0cb1ba77ffdbc1fe101dabcec9841406a74afa22fb80ed85e1e8d66911ab2a5095d9036c598dd7d5afb9a31fc18ec69226f6c09054dc88b04cfd662800caadc6c446b7deb7b738fa544792415f9fd3a72cd9f38931a2734019714dc6d873c96c5f9e7e5f0412670f5f4a4133a335ad60b546f160ed4e253c40946ad5d889fa97724d93d5c0fde6e16c9d6dca8e06359ed8c3d6236a8c09dff1f413385ff402cd32b7e9238afb73b1a048c4ac1aedf1580192488b0e6e3038f7984cd6db0ea45c0f92d5af71fa25f467d7727353d57a14374c6507cfac7a24503af30034d1dedd16de48f455777c20ebb55540932c8a692c9831759803e91d2d243f4333dee5246013396e8a0a7e8cbfb050164f930d9c4632d3a5a74fed5290716bcf4a7613b0d370c63ed4fa79465d3fc533eed71d604bda7b411b3741016f9578498a067eaf76ad7039e0c021768dba6c1792e5bf8888cb658875f59d0ac5c00b2db00e4186d263c6e2b813a573a7995c6a6adb7d7e73fe563a47cd6161e76d4cf8494f0b3dbd0e45003c8303eb29c8ae0d77d722b17e24a04b580750d6c0a44173bb26310f73b7d333b887de5975a776e1cdf480850dc18dc32aa2cf348811549be266292565b5382dffe8911eeea55cea98691b7c5e96e1b2b781d0c4750ddc64e074c8b44de3b7893ac8c50bed08b102973b1b52b3e40bd6eba5cd4d0420ecb2bc72a9d9f2fbf9ddbb488c0a354e36618c4271a701b8aeed4419da8b9edcb6dea68913b1bd87612cb79cd90a0f12a48e42d3ee5dddc538c1f7d26e6d89bd7893c41d1a4719f2f0fb6d175c208cdb4a19a3a647dc0d21c5084947b63480ac612e24bb75e965a9f7a70a420cef2ab14c2167ee08a5c4094e1144a1465cef21803200d33285218bf1ed0f4cd71b02bb8aaa966b8b6d46537c504df1530c39f79c4df9adc601d9b4fb4cdac34b0a3d977a9d80fa4fe6993c3b017444f15028b8879ea49eb3f7db1e068a1b355a0c77609bbd3927191cea05d55d4f7f1e2ec5ab50f7896e34e945a19bf6386e164ea2264363c4ab3d9795a57a4c4a0fc674f1841b15360b2711a3e837d8ba47adf3b83648659db162970d87227660247d0b781c424cc763cf83989270f1bf253880f4c2e8c5eaf2baaa47233d381cf136204d794bf551f3e3c7f8cca4e6f19c1e4783578d456d0e1d45db1ffa64d6a7aa7ddca91a50fd99db3b0f84c2d66b9aa45db8c1f9449fceab9e6ac908a3ba9316614d3cfc94264760c6c81932799418e4edc558d4104e9263a52f9d4458690ca247c33f13cd1998692c8f504ef9883eabea23d159bcae58e99164c26ece714867dac522dae14598eeacede76cbff0356270857ca51e8b5a1b734b37ab74f863025fd1ad84093b27d32f86375f5930d579f635ccc670ddb5b5bf2d64e12d5b0d08ab9030dedb83b74f5d9257874df98e7df68fa83547ab4ce5c77b62aa62a05272adab882997bc7ecf0fba1a9a52c48b0c1d458c9b3d57949dd652981b9d4f715196785b0a2f6108cb072b9a54ca1e2db062c32b89a9d12935a4bee6daa542deb93fb64431793bf83c7d9e55de49bee7be78cc77cafb9b22b27fe5bf5ac77994860012ab488ce5c112c5db0b673fc11a7620fabef2bb87c41ca8c2efe460795449c761d965421d1015ce12ffa0a0835fdfd6fde6535b1ad0a0747bd4a92f85495b16d931ccee2325297e36e575c1fc165517382c50ac371a85db36a27a94a449aedb5de695ec42f1808de8f362d4a84f8d97cca317d711e07f60f8a179b40ba4076e192f5723a4f2823b95ee223f3e6d961f756c61693cc4121f13ab5b118851382a9b542a1e3ed39cbddbcc2802e2cde0c1cf73e54e97cc35839003430c310d0512dc272263eccb5a9a16013d4b791e6adff6b5a074ce99febfd966c93ac3c87289db484cacf28dec6360186332409ad36b32fb07fbd8b1dffe87bf97b8cf5e3fc8b882ff11ba67b8c6fdb074c2d71a7e9fecae810a5a8068615f9c9a2efd5eba75a144777e86ea103bccffaa0130bd5999bb3f68dd4fba853c41c30eccfb11cd505fa555c48b68a6aad0f255476181847b374631b9498c8f2fef8811cba804b234ca2a7c7774e8a5bc2e44c10cc807ac884f84d436f4af2094d9791e8783189f12e7549e7380c98aab6ffdc2c349d4575ab2caed7b09a4a1c2eeb355cf203bf48c939839589d979cee14e87a7b146aff98616bbce91a8a969e208ae3c41c521dc55a1a023b6a8c930a2136a92d8d58f6b2ed0fbfa02fb9a6974ccbec66c9068b613dd86b85f590c452bad6bff8466b6b9d35cdbc76007f263bd98e93ae7760a1fd8fd5ee7cebe6f6908d7499773e00ccecd928f96264f971bf03a1c916198803e8dc11590ca5f7e1ab7931165aecafc533cacd3dd57ddacbf616bcedd9b00ca2d9b293eebff2247520c97a9aa8c958067873faa75efbb9a9d9382a6a7328700bc8d654edfb89fbf10c6a5ea5b62f63344120f2b2e87bea5e21e5c3d295013368f1ad2d72e19bbd12306b6de2dbadb4013e291ed5b2143ef834bb66da360b0f13b4ccfa65b378c69bfb64bdd102172496d0a55ae364d97665a2c959a8da75543588852b8e161adb1d2956bc6f84bae9ef5c49944474964fe47c7a4c75d54c1e9b93778d989d41eda3795ae1d85b2c71b9906a32e844f4136ad3a75f19fea17a5d5bdc4e066684ab43337257cc153572d573ef952ad6defcdd268b7488d2020b601de8ba969b90f6f4d5ab3130ba2a8100555984ddda8c2e32e5ba535a414c34dbb9d700ce58c19a9d05d3935a2326bf9b43a977ed9882ac493f417560412a9e748569779a42fc3e9008c5129c3da6e7a280fc3a860a6a83712931fd693477f54331ab2cc01a83d17ed18ba6f09de74bfcbd5455aa4353053837b9e62765fc36b6b5286a6396503d979e3ad8a0f8442e349926721e7576f6bafa89d4e2490a953aff1f2205d5a048114f3a7e59a1b3bf2a80976f263513137470dc39e06b4d250c7bad74ddf19c285fa848166beaa6cc555d2a0d51f2479faf8f10f1ab7ea6418ed3ec2a54ec34789082eb57c1f6c79e397f9df00ad8cd1daec1ebb203ac504a84a1465d09ee3acf5ae24e12442183b9baef31394ad5124042b8d93bc671c740f86b461ce53774e690149d575766f273e4b336c235ae77a96f505ee06b7c10b4ff7c797609884edbc605830693fd7f88ef7eb33626fcea2cfb028bae4da68fca1bd5aa66006c1e9f7b5b967c7157e1d46a644b508fc8864912874fc2d6587a614bd7557b45940bef1e31cbb76982c5ac6148e653a1cf3fa10a7fcc4b64c4a02c48f90d97ed830883a133ea30df66dfde7e262adafb8b01bb8df4ec8e15699730b423b655433fff7c21f956074db5f1cae57dd117e934b10866746a26731c3c0a78b0dda7603789890a7dcb1b49604d1197c2b73a327d5cbacf8ed1da001a48f2f98d0a22b8394669ac5b816cd31e62b6431d40f73b27e0875fcf3924539c79049ee48b5769e0e2ca2beb389cde6e4138400a7de5302d04818c99ead57e9f3519669ffc0e5fcdbe96bc90b7a4736fd78ca2f200cb8eb2e601dd673bf13c4cc5ca8aa41bfbedfae9fca61ea2f9c6066405d81a722c50e96b7f2b110400792e1fac75cc49bf6036109ba94e307dfef0f9af6917a84dec715256fa9cf7acf9a0cde197d1a5af5cdeb6e10e6c999e9f853c6d5d027115b6dd235844c9b8fd2c77ad2b6d83af7d03d7fd794ed0b412a05ddad7a26e07546c17639269e631ffd2f46fb9b8d7387a39b8d41afd3dfe8756682e61220566c191843fc10a8115b224e0c0baf7833ad5b46a8c59ddc15725305f9254f521dd9a3816d8790f5fcf099fd594afe6348d1b120bcab271690db4dbd6ded36301cde6ea4d65196518a36a32f92dbc40c6cb65f9533f7c52d7dac57702b35d261860a1c9e3b023ee5d7ea44c09fb5768e88d0065dfe258d4ba164c631a5431deeee756e03d4351a080b14b3fb572df615c5e54485cb241a6eda9d6319bb8fb062f4c7a80ea21ade33f2969e64079c02e876a9516bc3c89768e92c81ea27b123624f79424d46d0cbf7fc16b9452dfb812412d55e055ef7c142452c9a932616d86b140209fb3ae29e4c8abc244c0d69297b42680e62a4736bad7f61401d4be2a72a1def3f625ece8b380352c686b9b822119ce5416cf354774c367d4e241c71a4715904a2f6eb46bda3498249294db035bad1e9b48181d067f3d2217011d9731be28697a65ab88a2b774a30fc633541f8816217bff895e74312fd41226a0cfaadd72a83db8ad294a1fdd59f743f76d9ce76acfe61daf9a556557573f3be2cabe947afc11cff50d9ff331b158f1211efbc8851d383e36251b1f5c792ab22803a5949d2a2c94d446bcda5fffebe75b7ba3574744b0345faac4bcbd35691e2824567bbb774ec80b35c0e96ef1db2d8983a1a13cddd219fdf180c668a9d10065486e5e3c335561bb1d5524d9092a997e1c5008fac19234545487efbc5cb5a621d3383d5c045bbfb48783f1c8faca1eba6ec62b3c4ccbd88eca9573037892a65d8cd57e662ab4d48d7508642e5601b7a816ac6cc2cf4d1c155a27b616076786dfc7e16c78f48ee5afbd5dc9efbeaffa2976054bdea3c68c457f97cb6fa535fafd9dd63f35232d82a241699385977bfa34d0238144164db614f04566aabf9f2bd5d1eb187a8032721f67ad30ac7e869de21bfcb5ef78a38d2b0b91a3c64b16caeaf89895b38e7d7896615b615630f0172b23ed88aea4bab5a13e817af0599d209c22660c549d18e82d5a2d61cbb5162a46762e5c7b0c95dd522501acbf95f021130df00a28bb95028488768880c9d8865912ed22a70358890e2fc2c5db19b52069e7ca2c459612dc02a26b3c9fc4841ce0221cee3515f55ebe1853190c03ab95ce2bbc7c8947342f9f0280a2ca42f9ff77b35a01910936f41071032136cef68145ea4d82f6601c075b5fe54e436fb364db18ffea164ec92ec49615fee3468dc52be9358a5372209d7433e23795d44978f28b7ac6548d3a553131a24c99e43522aa29d11ea2afbf15bbe307adaa447f35530e7c89e05d4a92231d18055baad0172f5b6f9af6ce926b7c7f13969f1f356b5cca688a3c9be7559ac51119dd99c77384064453ec8e8381cd773fe6966a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
