<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff18cdf2c778e2aae2f05926ba0e1ff022bdc9fcd9ed2bc67415d213e9296763fe0e8cb415b0f529dfe4c07680ecc392043906eb49c5caa4e61387bb1ad4787f85b49c23e49eeb5af4b6c1fa1b1fde9f5eccf51bc0a4e8b799d7ec544e9a8e1ec5aef757b0c5a3c925e82f1c17ea686f92043db2a1a1f27c61be62b2b6817cf8e1236e9cdd62eb701ba5fcab01eda0706b9743cb258d3934531b525164eae8844ef8b87ef2bc80f09ded9adb45e3b6797aef359d88e01b6f2921f31857e5b876f896045e6519d50b4f2cf5e4ed74b4165e522eb8ddd871bd753486f0eb34067633a8eec1f7b0d7f330d0815b43094131e669d4594f115e889e3ad0507631c1169b6bd632ea038dca77d0fdba1580044b9de0717f44c5c63fca0540b83a5006cf3156c770264075bd557df8f04019cd882239f06b4dd0714bf476f9b9a6df90b6ce88a0c57fd2f689fcce1b78698135dc15f9277cbd5674157bb39c6aa99b9ab964c131527b7d73485ce5e03e66a0cffcc54452c13ae93853c2842df3ba0374e15c481b1c75d8680269c3663ade7a648abdd7086d244dc7438070724e206af4c300bf55c80f8fc8ca6cb2d12275b9e79a8cc285fc498b82dfe3061a8ebab74aa5b28f084b0a9b748565467460c2e6f264dd3d5581fcf400acc5b3b0d69d4ed2a08435bd5718f2c2637769120d4546afffcba28956df18c4493fd345d7c2db4dee9e7049b5e4c484d4a2e05a3d6cf5e62c941540c0618d1f0e0870b03a089c744179e1e607a7d231f83526138fdb186dda23b5be77524e8d623ce96df69d07955789b4d332566bb70897ec3adb8c1dac2423ff8047e13492193fb0618d33c0ea951c6df0c794c37217d3736ba5de79602f53d1ea4959c2fd883604a93d45345495ea8b3e9e8f292146a08ada6fc676369858b2e57e1f2b99043360359599e6664bf1d044f07bcbfee0f86707beede18e436df45ebe2bba391ba5cd3ce0947f68b1019fe8b24fe14d2e25e67355bb290789ebaa6a27aeb0f10633239f2be92bde53a3a694b78a9d372dd7d3eb957814d1ee2516cf410cb7ecb45e4851d993aa90a78fe4afa1c0624ea817a402389c5fdefd428b895f19e0f6216aa03ecc8168aa37ef36ec8cb5143d38114aa21dd3c5b1a39f9d73875952cf2ad55fa0de9ded61cf76903728a7a1119d4abe964fb46c16c693d63597a1420c4306567735a3573b7d80f286648a320fde97ec14bf59d4be88ba7a728980fa74bbea085bc8d1a48b38d515f38f4507caeabe8e91822313592b116c90a1758bce5baf55b3ccee53082213c1cfd9ed634c343f8f21996c3b26895020ad79f88153ef6214e87760fe1bce6d3d5d0c3516baea57b4262e53e9ab931a72e77cb35237fce31194dec9ddcfba1f2416c255407c5d77da9dd47e1acc9ba0e77009af177364ca151c1886ec5891449235d285dfd58994fb2efda27e52267df6a15021aa2e05bb402d37d5868207f035b2694c4816a204a0ee604eb0eff304b9bc7e8d156abf172d0b0316cadbb52c696c2c49e94132346054843cced33f0fbd059b48bd1fcaf78a92b10565785d67e2bf72bd379a54d5d2fb3c7457a662d1432cff457aed2a8b5c8868a346f348150fd69aa2727c309065c3bbc22dd7011da1fb68adf64d168bad06d55e62df622686eeafbaba3edb69890ca514be21ecbc1997d7c4a92e693c854812976e6c1e01c45431dbe914530b6dd645c32e2b4737455f25c4f23c3102fed50240c843c66f6fd324e82e43c03ce8d16455cbb88cace91ca72d67eef8ed15d060d659d44eda208441262a78b2fe5980013b84582cf0ff1c6fa8fe6d100484db04a6942801e3be7e4fb553757eacb734afb174e40994bdb283866ad69d8dee90d6b51cca7b8fddddbd0b9b724c07480f92b71883b774db580d9dc0242cb892052f7430cc3fa48916f8d56f5d1a0eb48eb4d51d7259275d60d24e364f84a2837bfdfc13187c3893c33bd60830caa6775a9de82afeb47ba5c4dfbb7ae35aa3855406fac501df977cfaa3289e4c9e679c88e395660fa084e7929d2198c4c7d987f6303746b9aa0166f04cc6e88edb655cabb615dcd3de74a1bf9f54399be266040b3f864908cd5d8ac7ff4cf7bb4d92b58becb3437bdae6303fae7802461bd0332337b09fc03afbdc3fa76f61ec4c5e887d98326fd95948afaf378b874efd987242c38c90a03f2699d5aa8e3eeb3195bfe2e4a43dc4f4efa91a23fd9b2abf323cf8243573b2e79eed5a0c936798e83cdf9c8287c77973c9467c08bd7db5f6cf78732a0a0a833ad061fc1673ff118125343a0e75eb52850200545fa7d0cf95fb0fde82ae49d5f515d0cfa6761886441553990d03278a81c4ff3117ce47ed80a98266607805ca225f6408de05a1ad0ffde806cbd855f58236d7e02c487cd556ef4ea2beae380f20ddf72e184ebdee0cbfbede402ad7e9135362de2c44955980a017a23bd75214eb9b3af9315c00ff10facbaafe83a1934029758fd5977ce8db25540361d2baf939e848c6237b6b8b86b86025d721c918a4cc70a992f9ec1ee5d9cfd067f84ed4d8d6782b79c31676cbae309c80202c25c65a230f59843fdfd9a7999a2a3febc3ab2de1ded5bbeddf3dc5d96533df6b03f8948e102beb66c3e989853107ab847779e0e821b516d112707b301dca620d78e6fa11246731664cb8fe8d5c2b3ffecbf42168987f9e118d7c98931eeec6dc464a7fc8d6f1157d01639d7bbe90d1c84a5af3a11756a80bbfff9a0aa6c7a866b73678d29ae5b15aed6e63734408951f034cc14bcba44069483285630924ef481fa1273b8d99155cd07042be8b7fe8ab0f856062af0d5a63d42c1bb563dadf2a0d873367ba3eb461d4403e5f6a8bccd18da56d2f3638b50fb01fa05852a37fae6a461f632ff1762a3bc7cb3357d9b4755d71cd7554e9e45a80e6956fd4d8b95adf9c9aefe2050bfd1e9bc99accceef448d37af61001a24284ccc2ef4331a16fa28d2df3d1684a955a6b120ba60119b6ce0d10f6386617d7785f800464d98f8c26dbbfb4f90568b2b64d190518361ff4aa9bbd29ad043ad8195b9864a269f03146c3d73052f86d4da7fde35f94b8a37308c8ce5c1d91e55fd7d284b3f3ce5a42784fbb868006e6cd8c5c570476db15d2f80d61718b7afd00dc57234cb4683ca5707a97c277e0e2127c091aa05c3a435de2990efeee566a73ad646fbc0a52b1d74fcd6a299685587877adcb752bde2f812c1e0487bf7bd045d1fa79f5b9712a28455059e5a6b3433ea0986b7c8ae0fb48d218ac7b594ede55791b08c9ef9a1fa3e36193c46b6d68758e919b8c5f680e6df7d026f72ad3579f039b8357fcccc9b4cc8293f79902de986c96c98e1a4b1a56b93fcd3faa55a49cec34841f4eb2d13ee80f897f3b680292aea0c8411a3bfc2c1477cc2834bcb35ccfa35f2e69052897a545b6e71797f4b949dace2d67bcf2f7a6766c5090a69eaaa0fe9df1675c81df49eda9e9bde52167644413401c103d38777cfe8d887ae4f4fc05c85a7a4d9b69b4298e4d07d1e206724ba496f4144a307e027e3ed6049d27669f3c4d3f23ff53aec77cfe32feed7f2e1b595ed2b2d0a1c90690f4d8b651da1671b0ba5e7ea5c3cfbf33c63fa63ecd53770937d6a808cf984d56187e3fd61b886be5cd45930f2d878e76d63ae46c64c043cdd503e842696f32dbb9fe60255614993b97d793f23f55cd7bffcd0e9060eaf6941e44fedd5ad6317bd9a23deff15e3f81537b94342b7e382bdc76e2c604ed29bc1f0e9299d07b34ddfa652f4cd060021959966bfef80d1f22c2c316010a27e3e3352a3fdbc243c931ec7f9951a4c26e482dc1f329600379a709329762132a7f8972f469fa3489d8e3c2fb213683759f93fe8f3994c9375da430cb04b69a26eb37b6ed85b6ad254f1351cd2e5ffd4002ed39ea4fb75ff7d500259bfdf08a4ea93f43ef7ba3963196c3fa1e6dbfbbf06a6d39f7fabcdcd7f8adf09e52f5e3a98536a18408941a8b53c520d9d78347522e5b04ee6235b4d0b21403a7e05851eadc9dbb9a18fe92eba55366bb618baa6cfbe8d51fc4b12e5e0419606b9a86bd30a840b2868d44cf1417f96a359297d26e5d7eafff0ae806a15e40b48c063db0f2d4990c36fbb224d9e9241bbdbaa8a9506bee53cdaaa246004276050ffdf399d29266d339735c5fb49dee7ff82adba5b673da12001b436de1eacde070455e91b0f4db4cee354207bf2dd5e68c5f746ef07a94412aed4920c0e3838d0b1c501d28f0d14909b0d1037c24491acf3993851fe4b6035acc3f826ea9695dd027b7f61a4d7e09b358917e020c48d5b66a9f63534bf5edb096f10505e4745764fb52eb6c80937ae66dc1fd11b3d3aa7118796b1509c1af170e8e1a0cdd0d2cc374ff123303cb53445b44b35236d4bccdc3b70257db04210f6bd44745b16820da45ad60f650f757ea6891f45481c8f3b71db48bb5988fb164c1146aae6060a6add5ea828e2dc323b1e7ea423a5ca4b115dc6fdc8570110bb0af543f2fa9d7222625572c9555bbcc02bf464dbb481a3b1df732b938d9925307b686b9bcb71d3a7790043a59a145db3f70a05a09a603244638b8d9cf00f7e7962b93c87f1ef1d7292c7f9d9dc12b32ed425ad1bb174ebebf9a3171dfaa68c9503ae6913f6c06ea35e1d6cea7eb5dd211c36c4d9f4a4d4a591350013cb5b6cf146093631acb15fea5d95c7d7af00ce2b3a8619195bf24e7559471660dacc6f6143bd717d5d20b434d4640421be36026916395870730138039dbd35d3393a60167ccdce5fd2331ad5d83d2f35c4228b159eec37fd9fc6eff4861225ff8804a7eefe51e2addeb8d35e5c9fb07fc6ca56cb5be4c2d762a342ba687657e27fe92d91848ba21e2bb7238b1a371e5243be2c729bf4d775d10b29b9d58c6183f9a980feb24b5552f5d7a8edff137c12c5d705d1f424013da93d6ae25975c945df2307e8d90a1d9b36537e167d4bffc8b80e141b974bbd9bc4dfc3c3daa3c98bbe9fd1061f344cbfac300b47806c82653eccf3a5ef52b4901dbeedfb8fe444d061edf37e07a67b102da782b8dca6122b7d1fb8d5ceab3e1c8a71797c5e4395a60da5314ce4916b065ad9dbca4f7904b539b1608d0423c54c06ee4870d4ee8f5af0ae7bbebe3ec6b38eec6dd03e53b080980626ce3a4d0236fda04b4a92b4fb8b5eb722cbe89053f16d2cafb67b86c21434bf8c8ee8e5b368a89b92e3e538dca965269bdb3c9242aa611425e3715ce2b425e6ff48fb5bbcb573e88c9fdd1bef1fa8ebf4fd117b56c5d1ab63ac3c63941aa97f1eaec873254cb6c60a580c8b00a53d9810af3461e7c797aee4c7acf9aa529f94fbb2ed6cff108566397e55adf1b6d71b4f1ff6f1b15f6aaa81abcc0c0dc848ddb696544a6adbd32510389a1c320e9a1bed574b0381c6e21245f27c6f42ba7f1f9bb34f56cdb5cfc10bf94e05efffe17fb60e4a2e77954eec4144e6bcd84011866af04e73ffaf4239df8fba7a31080e445b898181c51d6dec13ff93a1249e99c4063cf6ffea7b9df82e4f75fbedf1a9ac4c0dab931fab6bdc0f092a0d737d3d665564b5cd4adf5199951664da6836189b774e83f929137d4f5c513177e4813155e7e2aa954be0c81e20e3cae9c775266da26f87b6fc5c655bb438fe850b67b3b17013747eb5300fca39da05c394816ebd56406220391032b0662068ed532307a3b5e6ab2f4b2ef4928bd4948935c11e7058f2fc9174ca68ef141c335044a14dd49d11f59833a8ba9fc70582d42ac08bdb74fb50ae8a9ce7c530778eea660154db162b2c6b13636bbb1eae899beea4612f1d3cd6a297cf952346d4d13f1ba7bd43afb087a71b9a0ed1564cb97fa913ba012336848d780bf580b87d7aac1875efcc782afa4191ff6de35d15aaca85eaf8ee3a36866e2ff238a9516ec543683620de4b990a5065b860bb97f69af55759d334e17acc6541d87831220bcdec97bfc9f37f8297eb253bba9597a185bf3643f334dfdb2bbde92b1265342421245d8aae3134ea319af266de997de75b9913663777e73f2597eb6fab03ecf3393f2ad67ccf297df84b668ddf144b182d4ae7f89f1d950792563070fbbdbd4659cfa704f1bfea41025fbb92a1b40e6fbbf10cf46e5b413c21e5cfd62d4ba48a3b5f19eec57caece5d8da55897fe3e93d9c7d2d177813ffe7671c98c12d3e00b8f24a323fc8dca08f8122dd82e8d319a6b706ffebb36a10661e38d65d4cdd07d7888cc0e16184289c2cb0080b83988da314ebb1719d92cc35fd299499a6962bb6a2f9cfdc0f3fc439470fe3351d47b03e450c4063f93518742b43bdec454796d2360f6f7ef6b2953d0d5f185b0645074ce4c97e3a9b4e63381d48fe42201253effc95cf10f972cfc27422aa6bbe7b175fe06edc0ee6562041df5a9354feef57158648e2e929fdd4fe5a4d7334fd4bea1450e0f360487ad9cd4bfc8059ac3ab1725d7480eb88fac11ce246c54f3dd84d33128b9fc5f03cbf4801690596a5d7cf0f30e57d6715f3ccc81f084794e508d3d5c01e0317669993d8a475e27d587a3b8e9ab3924a724be7bd4105e8a55e2af34d5fb0a675d4fcc8c71fc46d746d7909731281ccd4c3bbdde369f038612597001a1436e6153269a167e2cff3397081b313d9c7d6354fbd2a3e3a832d0ae5a32faafd00cb96ed4dfb2e80ea341e225c95f36922ecdf1acf3070889573ff181e48025ec6af29ec54dfcbd7c86949f42c81be1616ffcecd4491c6eab61ca847b2546fa33653de2c4dc5d3753bdcb6afb03711c08ea97688505084b86a57d584c2ae70c00ed4a35e3d53d5932f93cd2d2f34163bbbdbc867717ec14ffe3a7e58f3ef4152bff4d81a2d3004626d3aa1edac3c0d3e2b15c6b45cbf1a1d8ae484fdbf700a8763d94e3d77d80501574feed1ae62d40293c849d9795e371775e0974472faffbfcadd794dc4d87ab4fb2bb575b8da3e74d641ec7a80003d17bf2009fddfaa7fadbd314243eedb6c77b6b8cc14ca2947adbc38367e6e7854c3fba7037c39f31e8c2dac41e4198a109c40fb75162a68c06d671c62b7abd3e198dc6fa98bd927f07022111a1ebceaf1d85e6c6bff7bec6e3f0f5ea10681113bd7dcdf3d0560d562b86321bd3c3759660b4fe8ce1ff14d2fde6f093e11fa52c41e6a4f8165edd5226b3d2ad51cdfa034e7e423fb6178c3951663c5eea61fb5debb23d947ae9c882fc9d3f957bfb6331ce8e5495c0398d1efa62f55980a6ebc95e1f90d4227063daac81c801a3fdc85df98a7c69540de49af7d4f733988d1525e32e9ed63e2990f2da7c5c21ed381a393502892734e836c3e16be12f5cd2b084ecc2e9954f4bda2a729697c914c4c2a8d21e63848e57f981ffb2ea815215a2c5f669c65309b022f7528a3a123ff3fbaab1d00b54b3213e386cd4cc3de1e191e0b1eedaaae850e946cfea5b1bf60f167f1a4ef4acee91f3665f75bc4fba9026c8b3aeef641ae01489f1d8204f3f3aaf582074e848c7dabf64a92c9c086134e120362b45c87ad863f799c7f56c6efdcebc2959fce25030bca0611d0134d05102de215a63160109cfe2473e538cb043500af5786aec23814aee7a8fb754e9f9c3ad55962d5505d04d7738a49f2a031dbbd55bb22048d1f9873fbf435db93fc4beb2dfcd539e12a9adcb2af1db718438f6f458ccaea1624238a1ee1eef5ba8eb4be3f53bbfe8a2344e35a7033fffad0f1707690668572638b7a87668e219ff3c11594b04a397c9744c6e8c6481da04670b6fcea07b8379fb3279ddfd568b405f6f1cf67655aa9b630640a50afbdb4d07ab2ff68ec5bc674005e9e8c066499066b48a84259b39da91a1f0a78768c0fe230c8ea1c43952597ea1c1e8522acbf5187fee3d7662a427d1a9602afae168a5b84075661cf0f20416191a2a181a606ac54b222da51062902b1b002a1bdffb9dbe2df06df4a5bbc4eacd7f74822c02d0bbfa68ec95aa64923380ff90ac3f2cd3187a86f0520938d6d459179e8c6edfa0be89c68a9b092628a42b269a0f7977e779bcb49f2d818305d72ba822797cdeca54a297e934955c5c934be3f3ccae39429851ce935aa364921b088473ae27c46a5855c9962350cacf672b1a68b6f6a2336dd0f976678b301819df2a26147c3377997f6622b5ba196c7e348ef182f0fc8cffff6dfa66be0c223c6f2eb2a90f934bca27325752e9214ff6954090213f59b3feee2776c95b2bad3cf08491394cc6cf9b3016081030d5bf0386727e74f4edd738c11ff0fe66bed97f8051e0f9a333ec53eca93c7a41ee555ec6220020958ce91e15341a08a272f8e8c2c644954a9796f9cccd768ad27505ce358b6e04dc3a813fe96ded1055550d9a3eb10fda40cd9dd0fa72d9670c66835bd27c5e919e6831b5962c187cfac93a6618ce8c6e9a3b5a6ea2f513bab16f7b0f55475882e84daca744be5b0c2bd8a6637becbe7466664298c56a5676893d56c58223ac741b2fc9d1e05c24ba09fbdf34b198fbf9fab2513da3ce532e026784f25149d302dd48338628ba29d86809196683b611baab00aa2d41f00645018ac6a5040403261e35f7e109ecf0220ee06acb957d7aac437ceac1badc3b3af54972202c5dd33217dc79c27170b01d835bf06bfe82eaa457854bfa5e7b91fea5ca3e833ccb92faf96fcf0c9bdd7d07ed8b6b885f88206f41b456f3b434e4ce8754da0856ecfcb2ce020cf29144994dcc8653e7b152c14416843338c594fbe170ea59c687350da7332e8f5270bd398ae815b75ba2ecd4b5ded4c64b1731a747165b633ec93b99bbbb02773fc12a94479713db52310379b1ffb621dd37377caa107a4f56b00fc5a66a51e1fe266ef2dc94f3c8f8f7de3dd23e0d8a9b61111302f67f8f7ec4c270f8d981a07b49a39e5a74e7f4555f14f61c177d5f1181aa4483cea2dcf3dca7d6c0800caa3cce838baea10313469a7fcebae561931afce3f7317494935aeb8d79c063e24a4a4137ed8af78df24138864db37cbd54af4fce7c8deb5f85967d204a79d04f2e9a3d8824a970b03fedaaabc68ad0401e62abd8d4880f1172b5df4b1c71ff235d14842a2fa6abaf7ed132940e35955128c39301df1a3ee6ea9b77697ab90388b596b7b4cae0bacb75c065ea47f1f2e24e6e090cc1f64c0f2c1743dcbe1ee62143ca72446826eabc640a8819f157e9d3299dece05fa146de5f83f13a2a153902cbb85402793dae064ee08258681ff038a11002020d25577255f452eb4b1e8de8d00c722fbe5bfa62bd58c23f46620e540909425205fe55a279a3702d4cf4e1ad8efbf8ea0cfe9e1cfb3bd12c0f97eecc4543744ef6b21695759a90e4ce4024ad7faa91e60b9c695eaf23f8b9d9d0a8cd6e281687335996b6838bb9a39b3cd8f6f102b40a7b3c23c1e88166052d0bfb3750ae5db18d028cada88cd9fa3fb96c2c592bdfde21efcf0fc344d7df3e1740c3d97d4919071ce7520c03889991029ecd5e00710404f269cf394e6c983dd35ad0ef56d5b910279ea7fee351da9bfa2437205c43ac3b5e6fccb582daba50a3ad0dd90996078582f998778a0341f1141b0c5de39f46bca8e23f67183ebfe4bdd1058ef4b51512adf218492b07fb0e5dfb3610cc63b7897971e529cce0ae99cd586c56d48de29834d39f49bda598e1713c937cfe822bdcf93a06427a3595741e91670524af7b7242274451e3db4daa78785295b34a16ec5ae26419df0a3c6e27a4e4e8f6027096cec60aba426f68bb35310e0711f4ed9baa688420c9f91389dccca00b7b444fccc55658074e8223794ad6da6e134e74598122f45ba3d3b714e28ec5cf5d5a9e817476ce099c06ca5fa6d88ce4ccf605b9c776dfd01586b6635487c10f658085546d979322ee9fb60f33a88ef62c5f145aaf934a98169e19dfb1cfcb75346979fbfcc9ef76d53ef0e59f0bcb27b04ae6db574d58f1adee9f876de28a260c8e2915699f283fc287b8f74eada575788579fcf44686bd6565745bb6ccd4be856a89ca5d2d65ed27c6e3e733582b8a1484174179e910c9695426a8fb08a3f72a035b7cbd3db10cb66d9724f9737dd07985fd8884c3e786bddc464ec02621c00c42f02d86a493afadbc40236a581abbd7d7fcbe3f286f03473aab1ae44f6ee5c682c66bd12e82cc9afd89e69b4c8de02a547544a8430bb5ad6b8fd25838e100a97c758d106d624a137376bc52ea36f68d33e178563f49bbd4c308842115ed321cb1781a11fbe9fb1aaea18b82f99afac1c5debc9b6974fcb60bdabe9cf15f6e34a65f6e799881b72574fa5684a5cca3429aed5244113b2dde087706675a41766fa4038d3d95619c01188a2a4b5349e95ab8fe900501ba300693b7b27a1f68c3b8f36cc326fd6485ae1f92a2dbcafd5071d78c0dca7e986a55ecba9f45abc2da6154ff52c9551aa10178052c84caac988f7c538a21b9db32fc245667f86da7dcb7a42b4685171e50909fd86879945a7acd771bdc90c06f7cf43fcb89aa390d7dfc2dab74d4045b3540e27ea3792c618275ec9cd494453b9ff5cac078878ce5afc40a44bbc2e52b4635c93a1364070ceb4b914249c2d4857b9e2cd6f93c8cec7af165fb8f07cdcdc8eae20003557a05132e13b039e0f6305eeea30c14e5bd225dccc7a7b45d740d819241b80116b65b0a2df847df9afbd244898fcf995f4dcee89470c877372377cf5b28d94377632fafffbfc159e89aa239bbbe33296cfe49f29fa44c26219691d8c5d5c59b5612f84ea05c2a059ab5c75eab3db27af7efc117302b8d2965309d9af0a3a58a18aa59af1d59ec6346a967d616f01651581c043f9df222e90fe2159fb55c02af16891f069b3a7fc040a87ab2c3d973d577566581a028b3f50ede6df8d9753d4adf134d6d7201906b8ddae0c28adc395974a60cabaf05815246b13ba4eb7b2f57184ec413a8981b68b99fb43429c1b6bcb76b98a6d85055bf6a1e6242893371f962f79c8e1b8c85e051dc68b52f664f1e5cdf1c636412a389392cf7dee676b1cc71674630208c383cae0c3632396d68dad7dde5c68731fa955a067639c4aef9fe212e45af064885d3593e8f3267617ac126e03d3f93a347dca5442a1836b3e86833156ed4dffb343b4d019c8d2d77ca7d7fda1b6ff8330099d1e2b4c6228aa346d0e20ef6c6ca3dad8186a285860786f3244e53e155300ffaaeffe504b0436c629d74e521c9590d934068b980df1879688bbeb0ab6a7d5c93c42c96b6fbbafed13e89fc9970a4388ba32a136a3465cc4b22a3054d3a9dbe3a95df9722581feb6981648a68f33a1a73f4f221b4ec786432e19331d4095c87e3d925f2f787e42067359e8f8afa0fee05817f3fe13592464b14a656e60198cfe1de2d5f5455bed9a23d21bd85fee67526a6d228ea83466b9e6b8be861fe8244a8db28a902e69bebeb793b17ef531a593510c138338e162691bbbaba6021dc79a187558f51e650be82043294ff370c8ce237dccd37571a1d81762d1e23a433a98e8db1b833c95e77d7dce54f6a4a66b2802a8de28cbb5b7e74f7aba73b8c521d8b9405b35817b061622621cf913ecc10b227a8e4dd65e11c653d68ed749f635110b90c101d812edec530dfae98003ec0a6a65c782a99aa5a3dc9c8a96137921ed87c93fe211bd67ba30a8e259c8ea4f7e9d9801085d694103d0cae94792d86077e28595f8d35a9322664b29c4c0a4d59b798012298aca7d656c697cc18c1785dd0eaa95d18c406af257009111583e0aed70b0e656b7e1fe523c50b0f9d6344fc192e85a9ab7e192c8af9efbe0898b31d5eac0bfac2b9665bc644689e208c691b9e5c2860c7e4a8e6f4b65c9cebe350a4629adf5b6e301e0a9d744965331ccd9c5195967d5a18b9367a60c46aca592ed62ecbd3d500d340c20caf48943932be22a910d6b5cb69094dced8a004ef96cf41a64cf1a06b28ca1b4867377a590bef060b68a5e1c110040ec458e35a9776c241a83429d8441516a52ffe7df6810542a5cac0051a7b7371a21147e643111de39ebc8a73cfd25ed0b802d4e668d535b94b3fa3b6d65001fe1337b1fb2af3dc795f786b2f93017c0e5869f63b9a971e119992edd595592064e365cc5ad5882a9b00e5ed135834a687bb0478bcd531ad551d5c3ab3df91baf7e6aea4c1a1f2d2c6eab96297cf34a817380a1aafe80e76d97eddfb370f04bb819b2659b4de63ef5563a4b293fcd50be9d4677234170cc830852ca6d6783716baf557d2631747626f8c6c1fc022e3081727079e75c616f5259bcb6ef86d796402a5f5c6a164308dbc743c31fb6a352e8fee5c34e1910fa286255fe28d732e3fef241ecfd8a98efc0c594381c90e6af75631f9dc7b9bec71a1f7272c9ebf9353338005d75730b9f5e429de03751aace863313a5bea7c9e76be8d358405fb8030568021ad4fd5749f9b931e4edb1ebd6fc72925c248770eba335810878ebd76c83b0ca7378f8153a7ffd879a74228eb9d655da41147b49bcedf15d66ff52a2ac6ccfa5f3b56dc60640446f01b6f95a4ab61a9fa687771aa351fc23f2bba2d417bfbc8be499517f1dd75cd44eedd5854c0401c21636f741dfd6c7a2f030b9952b3bd5faeb13b2b82aa7e73ca98367907668c51854a2709de61fd24cdf697f3780dc2f11cefc3cacc3456a34be0074be5796a7ab4e8396692010386d195a010152d897590c545179e537a64ca8fecb30f732f7b64525dceea9c78eb064d62a55d53c3d43f44566c04b78e5d3e5cda517749ae168459f9de2f4448218eca97bc129801aa27623cdb331d12d28b20d14842918cefba727d8f3186c7a993a6cf8232849eeef5590ab92b3de5e52a013c68629f19683bae1dcb0e7e3f8a2241ed676264163216b034ba8466a95cdada52b60368284d8b9b311c960e46d42ed73cdd04bf623d084c179550b34a4283ae40affe61dcd5e0bf53c88161e12783c2b8a7b288581b3c7ff68bae423eb0c4d90035bd4c6adb7b524cdf2157abb33860527ff04caa0003be095efced4ea0bc51292446cbfbba4590e5a5b004900142610c1753f05255bfb2c70bd62c5846792d94a9b90749f9fdccbdefba2c20338f83b87637b5b8537ecefbe220b443cdf56e276913a1ec1248a56a27f64249a23655e2faaa0672a309b3d7158b293abf02dda4461efc25f0b21169aebacaea6568dddeb24f0ce3c22b90a3c73bc971e2f5ffcaad61140e26f4ed5524b77bae4c838f25310d7e8e09970f56fc313cd52271d07154b9378e028aa1d40f6609fea5ef583048298da1954050cad487e1c86345a77bdc1d3822218f22d312c1f6da28b50d3be90c2ff0bc9aae5bae7c3398055e8f34c00408d061e4c05f545068f302d38632623ff429b936d95c660cb900cec4a572dfcfc0f3cc0ed74bab37c88e7c183abf5006f2d5906477da54350efbcc1e1b8c01b17ae317143c2ad40e7af6206a7e6ca2b1d1713c365a4669b339f2c4a4ed82f2901f8de08789f2224123835835acd49c044834cbd5df83a75f2b673809ea9470c3fe583cb4aced9c77d2f06ac5dc416ea2c95ea2a35c21be687ca629730441ae3e46d3086a6aa959b8850d059eff59400408211a09cda714a729c3c00672854aa9b70bd7be0448687b1cfe3ac4adf8cd08a272cd7a557ecc43da16f5bcdf5e34d749260a1ab95ee00b59ab381d71b50f5ac8f2c95fb17e2c6926c326202a54b510bb6408620647ae550e08755c50c85dcc1b5ec2bda6e78c36c261afb8bbb8eb1ff1874568b380160b6c3418a8189a246e3daa7cc4ada7afb55381a44afe48ac649f4a31108662dce3be3cab57c478f1c05b7c957e770d46eec4f751523fca87de9a80a09411e1839a4a423e576bc3ba8b8780ffff3c898cf72234d258c560be3e78981ccabf39be0dc227824627be4c039df0c5e67f6424dfee9e9cc36787c57f39d9c2399e483145f07a7858a317771dc0675447be047f695b403d3c66e6797da4d0d53eeaa52053ea05e9acf86407c0387e69a682053d1c79756ad7cca3e73235cce299f643a5042d8dd5ff9413078a08405fc9e62cb9aa693114252d0ad5e4adee35297170d011046221068f4ec2b6e50ecd30ed9705ba1257e79cebc62b5a802f1374afe52e99eed846b4d5dab9dc28b35ba8adac0b0050609bdac3a75861b1e4bb9e7712a615c4be162cf8cf56babbb3c74af712cc759c8681baf7b623116e1cc4b9a0f7a8c636a7a972842d0845c35c3ee01818b68c90552726d5fb02fbe2f1393a37d98e972149360a459d30ca7399f07eae16f073b1bd6c56277450a3cb56e54a470f04937fcd51c63a475bcb0bcee988903896bdae58da029480eb2d00f7313c798608a83db04d111f089d880f1f7e93515111fc7cc3e92d20c3bbfbcc88b53bd9b76ed09516fd0c480a7eff20055338e1ac1ac4de6d713063d5d2469c25861ae4d59fd8a7ce7f832ec434a6eded07d81a27361dc010ef464409ca8767819c82ea1dfb42b09c9b48f2b73e8994efefb136e53b7943ec721c711ecc61e7f16aec4a4a5fcf8f7b0364428f001f5a8ac5fdc351f6ccf11e4c2edb8808d597c9f9f1852e8caffd129440bf321097cc9637d739b5e08ec36933751d9a1dd477fe7ec04a6335de5423b4e6e93296c9ac56c96f782bfd8e4f81f4463cc856b183c7905db981c01c7e0f4c61be2535fb580903b1697443b05f6f092b9b70b263bf952aa7931256469cd14c5b9febd80310e7d6188ff59d0ee0bcd3b4fae55eb0ac6577886527e6fdb06b6652ee9b8e2aa9471323907f9b26aa6c2bd73c92a434dfa664419e11dd28bb39ac5af80a70394775c11380e6869d779132f235477e4dd450e129c3f72391b98bbccdc514c72b340da4c362079046a2ab3e9dcac299d90a38eb78c567d3679f548d32fabdee3b65e1d4cdd3d6a0455e6e035af63cf055347b85b32f38ddbd2d21bb90f3d4b8f1be663c8ad590238a2d28764e0e43a9b0a565d51fa85ba223e1b08153dcfb1353457ccb790e2dedc899aef3d822cf11aa6bcc88fa0fc1fe08b5c78836e5b30caac00e4d223dd4383de6c0c9b1e589789e80e8974962a0b4658a0f7d2df45d859bb9abae877ac66c22f8333963860a66f93cc7649313186e16a1712702a54c2513d8cf916c8623d5a40365195a08e61265a4bf05062f9ce120b92ad977cce86320ca4a284f3d1c437f87c60f1d7f06381a07d8be364ef3c293a8dd0cf1462ff3df9df6a17f32e4cc9e6de11f2739e00f147c732a7c8be6bcc06e836683045fdbba2ec4e695bc3386f83900d00e18473c6f4ecac509238eac232a3b212d646e717d6e06ebce93b645fc4f84c3ad72557038d0613a410127c8673115172e0cb1f137578d480d047ca61b3c51530eb5dd3726e448dddb9e4fda57d1543ba6670450c4edbe82435b37d4cd8d8f785e13e3436173716fa81e89c515d4de7498125bcd63b37f014497a7ad99ede0aac76b2a5935e4ebe7c211823328557582f4210a972a97e05d31c48f047274ecc4df1429075360f24e5c6f307690cb182d7c51688135ea06aceca8c61354c109dfc7002cf60bf525a7b3a4220efec5f6b1aea86f255329f2a975ea08c36e9da52054269e6e1e3645de87d10f3c36c682094a132db471ffaed72ef96bfbe42b5d5d8c9e94dd665287e87681957fb1ff25a68fd2df76769c4efaa73049f2a475cab7785b0a73feb637895e0fdcf073e0e778ff381948e4ebc854361f77ef5bde232457b25c44fe9c566fdc933d22108beeffa7028ce3544d662071f2436cf482c486d899d7070dbc1dec24aad63c44c8387dd30a397228e88016b3e8df38419a25d31712d4c3a548f30ed8056f7c79c6890a2130d42cd25e456bfe1f4e5b01225e291893ac1a55d3fd927bd408e1d68e73b40ac187ddd510c76256d3f4c93035b0a8beacfb3ef124f13a317c9c2ae04495fb9013b12754b9f1ed73760f9010c03f01bf740f0dbfa6ad7f8c763c4c8474d8e18635f2edba300335a2cd34e67a042e327743b421b474f4d0f66afc7cf641cc1135bc166d88af704443ba2fa9ed68999fc7590984972a631931ac23cdd5b31a511da65160c7d165525002f389b9f465e402432ba48f5b3a9cf62932574084441bb6bbe0aae2dc023f5b6be4bc23ed0b417986ad1b1cbcc1f030958e637d5e4db6df27705214e211eabe3b5909f0fad045f6067c8c19d45eebbe05aaaecf5efc287fc90db5948a75e71c92ef625d25dffcb2bcdade410c5d6b44b28403975a76f93b14e55fb29f324603a64dacccc6a13bd0d6e82317d3a21bde2702ecb957d4f0232b59864a754cc61fb33ee5d8d07121e6fd234aa71553acd0679896bbb76fce4dc928f753f5459cbaf305350a3058c4cf07d80065fb229b1366ef86f12bb8fec06a67623d77a0c94ab5176e330fe6793024936bfd1c8595639955a177a7770a8c64aacf0b3ce73100ee796c2ecf0f7adc2d34298f7920e7b990390953b0da832247bc76b64b76711f6ad8d895f67fa245a98bf1b2815af00d2308e1802ab924c8e38389908b120f8151d81e0b90472426a9ea477367910822e0682e76b7d7d9402617120839bd5609f270fc2edf6b1f4307ce368f8205ba341d4184d2d76ef63fb3e2147f66a881535bebf87c3b304d30598f06ffd82662e4420b42fcb68ac52e4b3a98382e366e30a58557dad49b2d599380d933edb352cc6cbd13abd9a1214ba931937a704bca2187474c7cf19e93264520c76f1eae902d7b91acec1577737eb6b3607e129bf5fc15889d3dca8318fdb19cda563586598a693a55cc90c4fdf396854d1ffe22ba7a7704b1d21252d33e289db56434a9e3274a8db11d7690c436b6946ff9cd797da25c47282ee6d47ba18fab5b4ff7b281f157a1c23483c0f9ba2ba3768a0572ed96c1d3b7e05c6a12a5c581a627f82422d44c4fb2360ef79edec7134daf48ad090af0e2a75daa09d854b116d161da06d7e1df966987ce5976643803a02a390d00ee97d04e3923e7f469bf27d146cb4cd9461d446b79fb52290e02cbc4902d681cb1e2bce13eff3cade9b2c5441d4e20593de3bfb63425e6408c1ef02aaaf946ebddb768012a33e6b02f1d16af839ad2bf6bf575718eeb7010438a4d59017de4fcd3c70f6b6a1f059fb441ec351b04e01cef5ce1b94938133c365002a818b8780a75ebe42c7e4cbf15c8fb0802a9eb884983260ca86a1056660efea8ae00606d167b45b5bf5656351794d775bb525b0ebc08d20d1c16c249226af298fa3f3e8856fe289b85878d820ba4385d2d39faa583f5bbb208428e0889ba6dc23f79f5f0c997dd81a93342992a6d962306b5ffcafdcc08e153acbefd3a8ad0111aa73a59cf98c6f0f894aa25c88f86b421697b7a211e08e8434cc1fadac2546a8064a86a7e03235e8a892cf1c774d67fcb3335626ccd5eb8a0cdaa2198164acb1745ef138b0557d47e2b1e85335551f0b3230926d3b454e769b96d4297fb2955685b0162e284efc64ad42cfeb69d3d287fcbf9d9d4cf67cca3554cffc03717bbd66f4914070d3e5a8b313ba38f7ca69ef7121148d2377963a97a5ec7f1faaa70313beeeb0133151b75cb3d577e1ee3b7445168","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
