<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84e0ee1e027c10f98705bb96260f0532969960a5e84e6f9417123f5b0a0636cef708402c110c858c9576cf77303e49734ebed4d378edcf5cfde296e7511f12d1550e4f05a53d4f3585e65bf33c7818f129b95273355d746d8c01457078d6659fb39ce30e0fc06c927b5e1a45243c4d166c4a068131fa860aee4fd61e7062056a8bebc8191697e996e084c2b85a122b9a8ba31752ca457dc07b279595a53e5a62f49fa5deebafed3ea9ec811c0a848dd1ae9cf87b7a64f11fe502369f8885148db7525149f450c03ff3f6d0631c6685588e8983837869299d6b6ff43ea623f384ce44b2e4990d14476432a60b8981441ca0a71ea92aeccc95dbca6a767440e75892c5957d043b630bc7f06a48a0f3b4355e3989510807ce77affcc84505c0f0b5f5cb2e0df1e05361b2e74c5be845436aeeadd9061a21c17f14f3769e59a2c905fbf327161a015659d8c71f15e8bf7d8781747eacda1f36fb0184601cd5dc2627cba599683f76ff3191f20f40d668512b52210d32c33de6c6d4e647f502a63888a4ba8e3997e3735d813731924a035ffb4d30f62119ec171ba9f5848fea4a5b21622001a4cd0c51eba7a28a24cece94ca784254fad31f8fbff00fc0e6c67ca983eb3e7bf0f496613ea9073a51f414bbe90a95e2aaccaf257cfb483677fe69b7f85eb64a8d1b6197276f892dacf6bb3df28b455824096eb38b922cc886105aefd74dd720e4bbce11fde3cffdcfe4e724a1e2dfaf5d0f0f111de652f36702fc92fbcc3ce057a21553cd3dcad89b242a7552c9175d8b4f18569f7eefecf250316a51d991965bca7e2e68f939fe6822719627a20d4ada0c2559c8fe3472ccc74314835ca331c2b59840052726254c5dd6f2f2cde991c9cc88cfddd412c333a229ba9b61da87282397c223cee7b0fc4ff7d3caf397b650b31774bc6181f744b265ba15e8ef7dfbbe4c6b90019282d772562fa075dbb1dd3f80f7ab4c2f7abd1c8cc67e057c4c5c58c72e769220d4105831cb5ba7575406cba1fbfcba81a00ec958d54c33ce69d0b22ee05dbc677c3b716557cf2f7c1f9820f04ad6f2aead6fa62e48037971437bd59fbc34c26644cbd873285d3c45e9e1aa291a71eca331f55db7b55f5a57b882f7c26fc4c5bfd7b56ae0ab73ad80f5015b21648f73bcaf6d8b0e3476a4dfe5efb65f45c4d739a4d0ff01760353e4b6f19712d519bbd7440ff8c2e536f20ad2135223d8402ed9c26a0669c77a3259bd5598cce95362e16254067e00515f37de16c1497c3ab241193b1ef4e9fd4a59371566f3267ebfb3b734cf9ae7fd0e4c842d7191ed20d6e66250bdfd3f1c12473899c80f60471a3d08f50d9bc613d4eaaedca5f3f52627639802b65525831bb4b50df3b1d813f24be2bf9d95e870685f7cb58c6dc43045bb1653486405c4d2131abb0c5161da919a9a3bf8bccdf4b7de99ca95a2f873b3e0b45de90492d1b08a4a06894a6526c490b3744bb4837c105467ba4133735b0d2b30bda2c466c8fe1dbe765cd21b416c5f80b66d3b728f9494bc06fd7fa05fa2f928726798cfb3b1f7af0b6b6e21414def7e12300f580b93b9814a775108b3de5ccfc8313dc4f6d0b426626b856cb739b6aefc1e04a6395f41f70ee872bb8cd218f86e318805a99ff23ceed368694adf558efd4d0947e51569508416bcb8ef1cad31959e230b4680d4dfc9aa0e27424c831b64644de576510827137c0eedc31d0b0ec0c65c4c323c7909200377f11076c2a7490b930961c86f0ecc7d25b72070c42b78e79403f172b6f5254fa15fe68dd33e19017f04a097cd4db8671359a48bba5a987cc3276bcd66164f5035176e740ac1b320774310226794026bddee2be09f069a4851a35b7fef4eadb0aff595dc56ec2387bdfa5afbe8e7be3e2e23d8a9d441641acbd35cf5374b1467a8fee415a79504d880a7e2c80c658d187a4b52a3bbc1da6456111e16d272e24f109ae3115c8abdfbee2321dbdaa1b42634157849d75d768a400c9074e7b0c6d538962795a16161926945426e97cde932474e0a35637d60911e5cbbc5ea4d57b05e4ec582b6722c8d573046fc6364ee488b6df8574cf05c2b0af9eab38c51bdd6058573621068903412c286040c2f94658dc72a09934d593357b75ac168202e4a3d60470a5d1b7fff607c42887b377db2c82f2a8c87cb6daf1b1930b06b0b556d75fad7980980abe7d3152970a4948b35cb044dc1968f2c17e1ae16a251ef8cd0c59842ec3a1ce357cb4d926bbd53f75f56c96c64b54fe4127eb39b3541abc52ee5c3721fdc26e67ad7c78d68673a53d42196212f1e5087cbf736cc5fbad298c3f5ec5b61bbe9c93407368debfffd59dfdb4a58a01f8720dbc9b548fdfbb407b18979a1894db5e417fdf13afaa0dc05ca8315141a62db0b40d312025b8114f4328c0b87fc2aaa4b6d6ae53d50dade96103023283cb9f27809e262805d5b9327ac0149caa4a45efab1cef162dd1aa9c0d04a79350204197caccb236efa41520e5a820d8020d369529ee5c4af7c041f2bed788ce0884ac9f5765c2701a99866aff477f03b91b48528c05519b7a91b38cfc1e2781de6362a944b9df0ef5e2f63716377efe1450b75c1bc1565ed6a959bfe7e8d86b21ba44df0f5a1a1c558bb7d82e962ff4061cd790f14d2a57186723830da09f94616041b5eb31195dbcf4c061290405ed5b7d371315d3729fbb80972ba53f583d4dfe893ff91531c4150d9d60789636ed95c36a4d4300136347ec78c9d97177f588b70bc9c40ccf73834cd4e656c3f4220221fab141f2fd4b73400f1223864620e9d66acde465505d1e276a692a6000818427dbddfa762f1986935bb59035608159af286445c74a2b9ed1b2954d837ad22e97f6e2e39d028fefc340a4965af9ddcc1e992448babdb3be1a026efd0961e6e619306cbf27c68f03b0f00bd494deb895f60de906466fbea74749c644e152ee929d53f70e4e663954ae7020115c5c647983021289ebb726c0e020b87c8472763e3adc2c296a2703bb29f2d2394f3d21de34a22c601543cc87b03139d1e70791af8de93290e417aa195c1bc987ed84ff39529d27efe227d018576d68e655d1e0dc4588c71e5913965a989f4ddc6e56c18d622843ac6a8761993baeb919857ae12fb158acd147b8564d20859297df4cde3ad3d8386ed2c21b236a19ccbb78a9828449a3bae2e2466e76936b493e74e4b47a464447ebd0ce115d50f77092c8bcfb513b685aa2328bbf326286ae601154512a200d730eeaba4cfd86cbe5d7cdd4eff1aa93f45e898e4acb0f8accd5976dd77cb61656cddb5e0538ef5cfa9de45cea6c64ad09c29cd6e2f104bbc9c9669a6a7798a2bec3a496b951be2021cbe05745600acd7e11533baac121a62166d23680c39ebf9a0eade93debf80a8069a0b45c5ebb36ab6c4c469a6263e6edc0032881c1aea35d8caab8cb51097c9bf4b7f7ad462336d3d8f2fecd2e57a87c49ae9284a1c38b4fa7cb11e890e01fa0c2f925962c6a4c85074bb9f5163b2cb57f77c1ff45ecd04d4763351620545d58a0b390427a1d29a3ec9574329784e9a4dca0295360a594ffbd195c9a0976b11e25953db6d49d639370cba2863c9820dd56e0c0dede4bcdaeeb8923f0ffba9d33517df9824c899dc40a5cea9912ecefe032d0e3036397e7caaf18b2fa5b9f6139feb9d83c52aa381644c98d6736c5842004341e018214bd4ffbfc5e9d5322bc2cda9edba35b5bf77fba8e56abc429d5c89adef42acba345d2b9e83817b3ee5afc190c3690a5bf42bf65b5e02720df642feccec62ae5755b7b8a3b505598f6510be14295fbbb8af543f5cca233b220f82e916b23d1f6f55bfaa6c6db96d2b2501aa6637fd2e942205e0478e2dec9dae5e0603b29fcce400e2ecfdde77e8ca82d617de4254602f92b7617c9a3c7cf4222f46680704fade9a1a16d15570618f7f5ca79ef8ec77270cb301b322f5610ba5a12489f0e4e2b3630a6901fcb2d300ea021d7a04c483d49cbf6509df9e30028e4e863b655a93441367bb0b41f4a901c5f33c070f02f6224293ad8dee3ee16fbf3bef8d38116371d51e6544520fe8374d7376b5ceaaca4ec3cfa94c7cc8e3b542f14a2736df1a333588f1f0f278f518dee3d5b24e668443eadc51678fa627081bbc1606bd9120ad9af7be0c9d45d3b4ad8f468bd72e92157e4d609f7fc17be99a8a003bd37771e93f7cc624a20b2b93bb6e0e5f4c8703735c2e66c5b688ae467f3c80d55eea6e2763dc0aac70048557c14e76038d7aa3c3e85b85af24cda889b32256a4e199ca51e1df3758ba304522b3ff10b8ca783a481549bbe54358aff5324db66c933283847613e12692f924f86420e99587620b53c235583c580e33437c68da535cd94d787c571b2a41cacce00a01e6c30f1504b760be9654f822136ef64c18c19d0c0f529ab2422fb097a11b210b3b4e4cb270dc7f1635b2efe8843e85d8f3365cf465a8ef0725997dfbadcdfaeaf4ae279fce84e195dfe8b7460723bf35260553518e41ed87d7790336b80cb127eb6c66ea422ef1888d245bc4d8d2ff6df3e1e63a1f4083e7d047b05d23fb0859f4fde1a072ce14ed6153c5b5d7b1defda3a9b525d4faeb27f36a63454055a66fd12584ee2c99551f447a4389db1974e0e933e57954cb4785217cb985c84db93b91d678a508ed5b2e7cc8d841c6c904003f696b92a65518cacdfd7e2f24d3c8b3f150868851f7bba1f45dce55b7e3c96af15785b6b1c3532c731581f8ae75cfb40964b7659f56eeab122afee919d729b0e0a7162e600f6046b58333a3787aca88ce8da3315d12e5442bb0b2d62f4e388809c568c2e08d2f2e3593f9fc0ac3e74127cb864e777ce6cc972995dc863129503b040f91953f7bcbefee901fce40f286b3a8d8d40337163260bc7189196f6503acafa920074b250f979660b2d3788b6776187acc6c50fd00353b0b111bb919b3cadcb1412fa0cdc2aff060edd8d94909ebcda12464ac0c1357c70bbe295cdf51251d83a0d1df80a311ab5ea6c9dcb6900b4ef0875cd76c9490e5e32f6cee600a679c0ab206ef03cf809b0fca44d4891290f9b2db858811b91a6a04b6d1bd62989287349c9d194e07abd491db4205015cc3089b8ecf79b51b03a2e750b3e7f65abdfe92c5fdfdbefc25ba422c030489cc97fa275f894918ed660eb9a9c8bc6b46d802976e4bb5f5b872326951d6502dfedcd6b037628ce8f7a3a1fabfb9ca11658f93d7d9a5da5c70a2f761cf1be41ce13d6afb70d9c87338ae268d42ef5c309d1b5b228f0585db93032cec4e0b09ddb01553aca0312af2a7762c4fe563e19d170c0fff5d43d44d2a01197410f0519d9ce87e70ca21c603f0195dac07179ac3ad022337fc1a1732a6d8f48f3faf6b89c7b87268f263a2fe5080792a9fc033b2d1e0dfb889fbc1e46180289563e070b422cb2d16d7fc0827faa05b0163a860a2ab496ec07a7a043b978e05c728c893b925a016983358c755cafb077a782a38726cd9560212326d7cef4f25c419166804809c55240adac186f6aec74ca9137fa73371a81c97179aee960b4455b15a10d92fa0f387282c05b38f405277f851705b8473bad0e6cccc41a196e4250e028acd52a9357134742a6d8bd3c02c4930fc15ca8bfb4f36b77108ce7147f79cdb9237829ea0e4e2e23031fa92478c13f7ebc99f30537f55e578f83e3e5de76f426c7bbfb701e04626652bb1f7f870f0851373a6b5e60c5407d8c1e99fabcefe1c6e02043a78b873900d29db482af3de5207b64f7d84c43cced209d069f43605eb575925acb28ef49e9ce6f89ff4cc294f034fbf9648c75e05d1d2638404d296d1b50bc491fc5f5468b6c7cf37e42dd03e478d5500da3e0bfc87f3385047dffa4a87be298b0223c08a9f4d8c95ae6af0bce70a1f802029d782c83ddb34bc7830beef84b62ef17febb7c8a920a47c4677be038c62c0951fd59187bb4ec9ae4fc8ee2c574bad3043dca18d57ebc9532550b3a05ff5b9aeb5a3edf5daf3cc8c4daa2e40450e2167c12fed3af1e8cad0769b292a9e1fd56f88fd4ea84c3b030ba264ed350a60d53ba8d1a5136ce1e59291c3233816855103d9fa007a6b9b116b8fe89ea172091ac06d9f9048f3acfc48ac0c71c5ea3a26280921b6bf35c6a04c8177d71a35fbf9365f7f64b9f69f3983531df4de4c7682730d3c86f5e5b5a4e209345cab0a702963251a67e7eff4ba55789c32335fbb50cc8f5f2de7b37600a093025bdfc7542f24a0ed0a8a68dad869dc66da90a139e407af749b6b3021b35e4a81e73e210c3fa9683d0ba4a9e5ffe6c74d5c36bf77226ba5f79ac2cac1c76fd7833adac3ff04011eab84943e44436cb7d967cf1f6be76ac3fc4ba179dc8d8d43edb784f228e53de264bc2f5c32fb91e8d4c6f6b956d53f4500dd134f8457b173d04fb480d22aa92253b9173e711bfbaf198236b916447d85e16d722b916df789fb4d1f2d34b765c3803d987eb560030f32596562743c4338c7d076c867600c167c49a38dfb6b7ba9ace0d643e7f93491a72b53c00da8b8b51fd25ba9bf8889e3f59b10c69f0e13f0e1d3c89b1678afd29c4d4430ff0385f9bebb6fa58b0912ded11dd527618a4da290e8e95112ba4d21902856b3d62d033266d6b8d9726da2277e8e32ed344dad7670f9126686fd16350b142bca5afc4a40845fcb9d294bf36327fc4021332f87425a89170e6ee4530091aa61be99d797c0ff6b04ed12c52310105fbffc5c0d1fad8e2f585426e35a04b61570310c537f1f108758660eb4ee6de45ebdee6a0969dc3f57ed7fecd13cdb1b4628aa3b116d2b7c92b0aaea1e7215a0d889fde88cfaeed4373ebe964281c816794127af6954d76bd168abe08a6b1e0391e4fc41744963169a14f7b485253e7cf9773f62b60ec49bbd90cb95fee9b89846b31f1db826194a802ee8fc739b5ac56f9ead8f02c621ccadae0d9f0096c8a0a0f9c9fec4d9b4095f883d31f3ca775ced10c5118f28788fccc078069840265f937b1c1fb4eb44ead115ffaab273b4957836a99f3fb549ee287c3866be883e68e65508448a719cc2f768f70cdd01ede518efad95188276f469617faecbd6c6b55e2f3dea4a605676c276435fa74f4f02d4f6253492375bebe0bb450fa7424f3d56c678754440d99e262dcf626e3e20f70e293f3912fefd0b5388b271443f0eef6210ca4ece05fe64b8ccfdc195df2af35734ac587c846ecaf0306a51507929e444e0bbacdbbbc482f170fc16e3a0e391c6a16ea77e7eab38d0a37244e31e08e4fc4f2030147a32adc5513ac4b0a07de58cc7071d9ebe3a39dd07c2e2371ce7e63d4e83e178397c76d1f7fef8a4b96f3aa4bea4970487056b81e32c7b3958d8ba2cd44b3a645bd8df450ffba5ab71750b9c66bee4029c3ac4cf984ba4ad609c665fb88e59552c00096ac532f8261841159fb31dd15c55e51078b12eb9ea9a7033e076191bb585c332a735fa09937f3cf38ecaf609d9b30df5b890401a6bc48ac596e69c1497ce62c79aefece12307c4040d6821c47941680c21a486a8ae5598ed76fd12e210d5d38ed649e1f15e8f8393fca85639a3c8954889ee065dd8d07bc45660225e7c9f6dfe0ee246e7fd6154407d6fa35f3009a717cd428dd20e0540ec887644091bbb9b24c5dd830e9922e7227fac5997a1256096f7d6ea898361a6b7150800c523319ba958e12bced63a4d5a683ff30bf5a908e941996c1dfe661b6afa3a5627e721add315df30746653d3d7ab30b9b4f48ddd794f2edd352097cc77a3d7bf4bd11947b0ef1dd1a82cdb0d9448e8506edeb167695e4a3e8a233ab0362bfc31dca044333c6ca855ebacb14ec770454dcee0e2fe835e71530ec50320083c5f3ae3058ec54fce5f49b2a8093fe3c4b5b1fe36b156e1bebc1822b7eb22ca14691876ba3a68381cce80942e0b55980ff8e8f67428343ef3722b7f4270adb8d6ab1dee2b6fa6869901dea26bbec5aa6171039a1a4918af09bbab0689e4992f2adc65496b707ce45a2b4b23e06c5d483be97538c9efc5284837095caa0af5b2868d38e77f52af3ac6aecfc5e43759838c106e3ee9118395a8a796e5982b21eeeccb058f68cdeb30d843115e7b504b5412670a52bedeadb1d4d56103aa947c051d8b38f28a0e49518d7198390794dfb150714565474fb0e2a9929cf5495b7469f26a8fd7c8e1d5a0dce3f7807eec5bbc2a97842657de418b0d5eae9c46555877b1d623499220e2a486b9c997749d5d534d284e42f3edd6e4fc6abf2b68dae9203593281944aa6cd9e8f1e12ef0eb15cb89b47378da531198daed7b3cc8f9698ded7da86bac404e87ce3d6a2db8488089f5dff012fbdb52e815debee0e82c8cbada23c7c2369408f03ed9d25cbf690d860c82cb7723d556f4b20f309b8c7a84ceab9e54670b02246fda28397bb883f68df2cfdc54745cce9fc3134b98f811d73f7077f4b9d98b236047d965ac8955dce1c85275290e4a2da87c2dd1d41e89a7ad70957d615d21ec7b219920a94eef46f8cbbf15b6bc1dd095b801d1fa51130e89d93589d860e34d8cbf1fbb715e1461afda72c444363dac578d16344ad84575b04cfb64bf635aeff6a027637c53badd1635b19ddd91c1132bd5b12a40603d48b4aca061339f52c5b494338f00aebe703ed55c5f033c208551785eee80f4381224c97247a892355e102faad0b12a54c4039dc0cac1df1021298aa15e1274a5df78b7fe55ddbf7b098048c677b6b7d75c9d81f85857d74783f3af4d724210e60173a95eeca5cfec71fb45738c8d3ee1add31eff842d4a2cd9e528a3d768394adf16c5c744129960b6ef5b233ad4c6ed3ed0affa212ed61668ff819421feced407dfdf5d96389852b381408ab43edc8dba272a636ea04ef740f92370b710a87dcea1f64c6c207d1a6709728477a8b8efebc3c068a658f1911d9d79972dac6b060ce62dda7ae8b0699e1ca712f28da64e0a79f5d0c9c5f88b79acec243c1bc1dfe5cf8b6cb2dc22d65b31762fe55a2e4f36f9afebc7b3045204af80a0e8f9b2187ce70267d13de4a15f537b59586521876daf5cc09306b890cdddb607f68051ef5a5adcb91b8537d47a7416566c97aaacd9c4379c1e31360109ccbfa9d1ce8619ea28abfc27978087167a70773e9b6aee7b43a5356b0d1636ca03da4a85e2052882374304da17e8de5d36895dc9725e95402e9b8cd5f0f77714d68d04df9ab0cbef13392a5028be027fd5bfc3a3bb2da29af65dd231bac1727ef6c6c46de58d62dfa5100f2c8e0db911b455ad61dbece8ed656b03c8424f0c76c7d185d725587605d384c2eacc4995c9d090aa2f22e65d1268fa2b561d89f50251755716bf9fd0b40a66413acd85b763a1e319d78d6cfc46c4213afc0a005ad069a4b4f295d1bed481bc95c87660b8c34aaa3fa2bf9cae28fab1c722a21165b0ae354c7f88e4e0bc1ea97446d53d86fc1acdc912c64a9d3fd49d463c196c12b03ae27ac1d9ffd1949d5adbe28ccb9a3e6d3601779206654ac30cbb9aaac380232212ab24ff3f99cc04923151e992bb9e77ad1a24ebef8b82b116b1cfb9c2472071518a63faace628efa4c2d2c08f99dffee1f740adbf341b5f92d57c8cefe1fd54a6168fce24c41697e9bd3e370a71762e4267a75a6bc4539705ce712cdfb75f7e502f0fb8ccfc6f92e0358d881d63792777cb3b13610349fb0e845ffe6166ca415b2c8d99bda7b23279ed550d7609bf8dbdebd51cc6f162baf504652ec8a0889005a32296ab41aa756ddb5678c7f0ee0a65d9235e5c1529a7711b0dbf3faaf8e067535466d73fb4892a53ca25c5606adba430acda1a7582579a5563fd94cf3838e505a8d6b5c73abae5150131a9706e524d17f6be35f6b4fff7337a665f7757caad3627d47133d06fb19c86ec3dd5b8e7cbe67b870c56dfc47f94bce1665de95d3c57ddc14917c4141325a6b548381179c37594de9360ce9c615ce81cb03acaf4e38bf5d6dfb87d04c6c7d6e45ce06d87ae854c82a3b63de6702669d3f41ae7eea2cd8b2d14d0d7f4208a385f53d80cf45f6b2db81a9f2b7a4aed6f7400ecf0c74f586bacc7df09503beda1b43cb45b1bf9f73091cd581e5b69a2b317f3ae162a408bf54f17d9b07ed303a4a66b3526538c3a300444a0a0b9cdc0b2d54634b1b889e12d7ba427944b93945315465c19f0999a4a2b0f9ba7f9bcae64791b93e14e35256927db98ccc3e711b007c05925f6deb01466f86923bf3f2c90ad62b6e805b85f8b1b85910258f9374ae8a21373b20df7a8291d0610687622c9a9f9cd4517f0e8b513761f8f07a4610eef0ebe9f14b6b3061eb615d4762d348281e3d6bd4458b7ed818da578aba16edc82bb5f0f0e45163268cbf09cdaf93263c431297031d6206ac27b3a393d5cb545c9c8b80d7469d487ee717aa3c724fe0b40947c2a7b9a3c0ba77fbcd13effe1429a354c8b004f3e5a85314765ee223e0fb449b6a9282280e0bcaa67e474da4edee42d35674a484819a656117cdcb5fe6deb534702278bfb36dee69399ecd7c8d9658fafa0b513e6eeef1b5728c22e970e6494e7996c84ceeb2038eb17f864961bccfe3b1c455a8f34528ded1d66c64c07a38e088e2396650f252182b20539a3dc361a00630643d2dc3ebcfb1c01ed30ac6d262f20c096c7955ce0744951a0ea32087d36f971a0a53b7aa8433268f49b265518309520f6f22b1c3339e3f9d7c76a400bf7c7687ac330e78e60028cf4042852e9d3cad3ac0c202dccc153dcbbcb7e0268a17311fb28d243bb72afaa9910decaad94f59fc2e95955a2f0ddd60f877f1c3f23a7913a5d27f04dc5fa7402a247bc7954855e226b8b45327f4ca2ed0725fec8cf8830afb319040c3d664c6b16b521c770e1e4cbe66825c0e9470261266e64e6442a8158db821ecffb4e222b1da30bf661b942b5531cd58744ab9127045f0a25fcfd1971b2a3784fcf28cd4ac25fa5171ed48d3c934af5f18fb7796bf3873602fefeadfd50c14c526fab59c106dbba8e2485465eeaf228c30ff8041a6e0a8edc961e674d33980285e93c03eef2d446a5aa43705fc50d65dff694bd33219eab45920e7b204f251988cf1008adb136bd367cf49b66b0254d9d221a89d9397b81a146ea490a0aeca46287bad7a305e7147ab989690bc783416ae7c35eeda92096282757a0b8b4ea5cdb14d896a7124371be590268baa5422d87970d74644772c71ef13b43e834178684fcb02424de7d5ec4024daa36a914c919d957f50ef96c2037fb027f5f5cc93b753f699065261f2739452394bcebef7fa7ac0a94f68561bba81016115a4b780b57237b273b194077a6ac9722cbd2ceeb344a3da790050bfdd02cfae202bb49e9952be7a2805e116a1a953b4026bd6f7973d7cd3c4dabc6e3f7a408a5af75fbbc812dbde107d67a4419fcb7a9a97e03586d414f78bfda0483270b7027002205d396e00dba52dbe0f826410f7237edf7b058783e8a812eb505addb775c429df383556f5b6ac3d67ac754282b0a4146ebf73d57ea6dc89f76545156fc5755d957d72f6f7c81099151b4ce65f6ae68b68858fd1817437c4075e7beede0969384f4b354841c0f847dcc2bfb32e6a4d106e2a585b951a358b72ffd0c9f10a127432cbdc4406f5bf900d95f56418f80f0e09224384cd1eea33e95d3798dd8f97afabc7813269b8db6461708ba0162bbdf316339969f8d18dc617303f69181a4bb6fd32ba5a0dd03bf75c0d8f2ae6731eb1b4106d87263c8f0f4422960e425bc5bd570027fd6492f5a9ba60d1a56b0fc1ff5aea7f8d8eb2c36667718826562b8be03ae0ff3bb1bfc1428cf55e2c771538aa078c1baef08893dc442bc51c16d2e8576adeb6ee91e0aef9d66d86b3ba624a549a711ab30d019d6ea1c9abf59bcd74bb73693cc1c8e9e22d2ef2accdc4b539668448bb1966de0692b3dee17c454e2855093e6b31eaf010098ecdf482bcb18c73e61f96d35a1140698ec013df4c509e19bf5cc8ffddbf6bd85048f0bb865a9a696cc59f72c6111f7a245fed4ba3cc264ea9db3c107cd67da26259220e57ac240ae2ab3a7f5bac596a910161b115065ecee4adf5ed46dfff934c197556c31682983b923116a47671fc43eb08b74fcf6b94455d5fb179417c0d8966bd7d48939a6d03c3579d1b05c91a915ffe567fda5ae04bf3d9e548aaa6e0ba56b64e586de0542fe4d28a4cd8ddcca196d76369cb43b043e4b0b8584da98a5be6c53494e0b57c19f7c717f6843f664bfe06233bc1b4c8eaabd7e4f06f9d926cc7bf5ec55743de890f765b33d11f2a7073eeb8aa538ab5aa138260d12ba5f5d16b5db8f413bb8449b9fed0aa1dcd3da58ef186bc7e0374e42106fe117b8e3206c751891871537d0caff5395c4e00dcb75a3237b00d014b4f0ad19d353aeca8758d2995d02910a8a2998458a557bfbf3db5d2ac0a998d8a94907ef0e8cdd0b2d370fadb5ac76a2a7bb4131c12e49b87078b92761521af1981ad7c9296d9966d929dff7a90365b1d01325a2c7e57b4ed84235439a5d2c72307de7907195b1abc7ae94414b2f3d2aef2648d1e691be2ae6049affff235f711e1816bce3b3c0a4bd7e4d1e1be53f35f61a762aad16e3467bbd911f1afa00896fdbd5befd50b1d3fac4282fa22a348cd69db363b5f16954b5608f70aa9a4e0c669b865e0b6296157a42b4bd95e116c5465c639de47c22de144f22b96542e6dfd78e1def5d09fdc22c0da59eceb092617295ba1e1400039455ed46a101b3113e1bac1c3a054dfd3506fe1f5a5bdb2d00e28aaf1011a7e344e4abd4a32825cd15e75f6b78fe4edb0966858e14e87423ff9bd83e8071f39d883c5818912e55c1d5a18a080865f108e3437b38cd82821359e2f994b293697c6d6664b25b41220a73fcfccfce11e1f03b53792efa8ce956045d3c5dd55436e7bb8ef2eec3117ddf260f13d20054813709bee4222c35a214dca0d44134fc99c2b18812510f39cb4827b754388b51b53e39047ad1b9d52b3f5eb2f8f36b39e95bed988bc4982f3b8c1512633a5ad37ad48bc58d09eb6c799892c60362173d88e0f456f63a8a1e88c8d7963cdb737bfac376ce82f31cf8c93d70d95872f26a0ddb4975e5b0007da60365a4825eb72ac00011175be9169721fde1e6f46d67524d40742d1c2a37c5b82c0f1ea39b72091ced29124915a8f6b76b3a46f77795e2c61dc4246416a8b3034c27985b9fbfa2da1c2d778cd7752497fa8ff1df7184a4931491d04dd15dc7b9eb3d7c6728265ac35a52db929e8d545f0c475a68a9c6e1a4361a58c45689c1f4e97dcd5a855fb2c024401761775b305494b0ffa4c212093c0df30058d41821d35c9d5e6cb922d3614ff6bf194bb0cdd6e757d3f1a53b6b2754513f4595ee5475651bca94da2cdf50ee65aed6070c05afaed51f51bbe50d483cf621e032f0aba62f8fb32b935bfbfeac392e6f9cd7bb83f33b58847fc850287f88550b38e10c22aec0814ef7eb94057fedfd338e012e508e502277372f7b94d8124a71e157bb84f8a532a44d6f776c500f8993717393b8f8f5674e3fce688aa6735082080eefa02d244cfad6a1b9314d0771da9efe2ff9b8d70e057076f140c766b00f3dc41445b3addc7b6d1ed68dcac19beba45a4039b69e6ab6a6b7ca93f295924c089eff0231e1d442687e0a9a4b9f8f85eb984cf9e0dac8f153b4e7651de7426a1b19eb2b890074e5c59011193f3c47e0db885d222a788349fda98528c73ee7bd0d031fe91a9e82eb19445bfb6df7e865791cdb54156976cf8faa9206ce6fd75300f9eb3bdb95e2fd0a5a7308e54d4fe60bc5c0f81ef24a3b56536d9584b4b2ffe4811125c3ec388b6849cbafda060c7230d3749b1898c4a61c3a76d343a1f927119adbf2e45d31858f5d92f808279f04d840a997aaa4f051ec61a396e62251456439867b8962bec1c0688ba6791b719acda5bbcab5739df52284c60852c3d451a5c286faa301cde4d4e35ac200cec1b2b4dc44fe2cfb5b8db222ef86e9dce685af5d1abb05c0ee75b178e708b4ff69bd329066d21915d125c64263e1fc018a383520c3059e861c5a0772c2ff72c573ec2e542adf1c38c6761d09cb08b708c80bb19e9d9dde29d13b716099b405faa1a6585b9bef4e3045ab9f57936de3fda2edc6a3f442bc7bdf4699538ae4d7306028404448cf3069a5e4114d56d87cef85298b02baf5532bbde3ce9744a26c45ff8f7b239e3fd7b14b97289a92678b7e2e854508a5164a23fee01ba6c8f5c3fbbfb3f12993532649fbe7224b4bb890c77b48567be130d2bbc3c5bb790c058404b69347104b9ad2db8ef1f4b75d498cdcd538a1a33002d45dbbb4576786494e3e124bf51d75a6a852f986261374579ebc891da1671e69467651a68f7b07b8899d3b62d83e25cfd85cc877da68ee19d892f95c339499b8a01470652091522a039c4f3fbcca2e9de6eced3cb0c2a444d41a4ea97f06fd069c7b5d16a5cc428e92e0f5148cac061296cf0fde041054922f3012a47e23ba5859e76e5f44e0f8c9607ecb38a163083cce2ab0c6429d75bc0ec0b4d2f5931585f9a47e8ba7a1039a637d1595221687e3cb7d489e16f1d7ca06ec59bbeecd9f153637a5cbe1ab7d1f965b46f69a47abcedaddcf96ef331448e7094b6e195922885bbf4a2f8c79dc60a2c4736ccf75a337a18f64e5f40eb7d8dc8951588d4da664ab21a1eafffd642be3a5376f309c4820e4fc0e43c770b86cafda98e99b8d1eca42447b78da47ca73f482f24c408b890f23a9d8c0de5b17f183aaf869fa54c31579d1ab8cf3e45a2de1b2f857bee1f63fd94f64afbe2dc571861c0b93afe623d9b2233162c6f44b21984c9126516de13f2f0c53ce3d50907cdf64f14d621f2138fede6d28975044a9321f50bdc416a1582931d0f20c9898fc89ed000ea8147a203bb0001c2ba6f3d580aa198ae083cbaec4cdc9c0cbc1573e2bcd8c2e0b4f8ee770bcf11f29469e8162a58a071fd9e01215e4c617330436d19d4c7ec25de70561778f971eb6b94461363658da09bcea4527f33040dff5322f5e71a8e1bd06ddf5747f432c85230ead1574515964994c4693df27e506af16e2cd4266a8962cbf5075eaf682486983b939e744e47e89c1cb11c8c045647193ef8f6096094e78bce8b5a8a7d1fd9a2842c3ec5bf9c0b49102efa7bfa85c38b138fe7cb20eaa86ba6f3837921fe7180dd1d5a0bef398a31281cec3daf26f8ce55e23085a944fc8ae3907fed8724279d158007daccdf4a36639d73c90455d5c4297499699ca4d40088e7b4d723bd90cf34a7aac1462ab36901b5cc5a87eff8aad27858669fcdb8c9142efb789df8cc32f183c28d00b532eb4a4f34fc67ff418819126499cd0cb23390640749bdcc0cd79fa85e25c3403499a3f06aeef2923e893b9c1a857e28fa9bc5dbc7d8dd12446f364255c1b3c5eeec639eecaf1886506b3460f83b6cdcc66860bd9b2f609c1cfa5bd6c779414e19be3b9d521e11ec54ecde630e16ce5bc8eebd863a06dc91c7c214e03ab3ef706676913a50308d226e8652fe72cbc7e558eb3e823e4df7ef5dc291b0f15cf27d7f05c95fe1c22b9dfa2b902db0055200ae6eecc4f8ca59ec07fddbb7c473390026784ffd0cca8065b6c8fb71174c92a6a3937070bfc1186e5a1957ed4583ef0dbfd839b6281add8192e3c9625c70abff6dc43a4b6d16afbb91e94a9503ac6d9a616f5b04fdd77ec692d7907492cd2605fd7470e59127e4bb7d60f015bf59411adaa2d706ee53499c988dce3fe5536e6d005147e1e39c9ac12e8e7dd4f31bccc19c0c540cbaf16de140144d2c2355b7c017caf0f69977aa1ccf8161219765d6973b08ff6ec36dc286f972e764f6436ab32858145cbc37c6c9e225d9f6ae8ee5faa57574beee79edbf70b8067c7480fef5f3d1ae11d16fba959bf27baaf7d8d4469abefe6cf255af7f2ca21d81796152b088c979d74aac918960e2d558f19b28c6e2e7fef5d2c6687c68f107e90d6a94339e48c1cf5bbbd6652a1c3e69b27244cb69a6270ee317bb9e5e331abb57e2a023048988bf6de9eaa56c55a40bb81caca98b8a93d89298c8f149d56cf7289a9352b5c1983e265d3b0b905add5340573e2605b1d3283e15425eaa2c65a3be9fb7179ad3e2ad778e6de4a458170874a81a59658c9c0218bbfb45dd02a391438ce604594a16d1f6735e2927a6ae5920473b96037d812d3e4fc1bd6114e07ddf5a71da066fbca29e7146fd7d50cc99a86efa6434cee0c92350bf9fa2f4c2d22f6af5fa22a11602ed185101953e9ff71d5fd65a74008128acc8730152fdd6441c271bd6cea9a1921dfa6fc4ed548cf1991d286907093f482f375ac26c34c7b730959a890ed3591820fe5924e30ecb4bc5410d1235e26fff4354a8859114e86a4f522092c4c9540388ed30888dc21b1b6c79f379c56485bf05aea01d8e115559b3adf50c3d23b12d06b29fdeec3d915ef29646476a5631c27c4edcc5e4c06225453dadf3cedf05183c132579828a1d72e52fa32b30821e31ecd1f56942172c20095ddc6cc7235e45b8402791c2547d4de40fcadb84b1353fbe57c33d57db2bc17403609c3c5af7c9413b95f1dd35e522cd79a83cd1ff16416288efc158e95ef5d3e112574fa027c872967a19689a856c06cc04b6605f8001a7c968205c31d6ed2eb6137cc3a8f457048eec2dda919364b6067d72ddd6e765b6571256eb7f9b26d6e34be88e2b2484281363927913037a3806effd8693ed3783c31eb813be2020d6487ebffc569d1e2fecc6da08b64c68fb9a4e7ef06696141fe3012612344055363f7f010dabf513fa7120f5c3c75aeaff1192f169346e00f6f390cf10837561ff3f2095b1fb84aae25829be91256504dee1766928c2e6e3345265170fdd5d7bddd46b66fcd55d730e1f609f96c35280df0ccdae0773a0dc6fbe62cd6169f0794c133b4a6e16e447fa06eafa1ae67fa4d5eb111706f348ae5dba950f779f1477b9441c5810b0dc417f84d7a56a6d321041fd9ea04496f8b50b2f3f57aa89e7b49c1d81c408885b55d71ce64b4ce2652a5280e737e95bb3d4bb00bf7ca4a871893f250b3b6fa0e30d99e41a72dec6ea2362ade01dddf77f9cfa966d8d90b5cae3d7482089094297a944c0ae2b352a2897a40220b167d4fcb1fdd1e5538524fffc79538e84a49e98fbd18ce632850ebf03ab4d462818965d16aeaecdb857514095d2b156838de6520dc065a12cf774f8de100b452e0cc1fea8e85e542cfb55cfaeddc8040d6c5242ae9cfc5bfa6c262ae87a60e1f71f022e555eb0b63112347dd7f32f4d5abeafe6b35abe899e68a029c786200ec2284c38c89a5839dde42d933e226d7dc2849afaf7a93c283fb90c4e759003c167bb28cd02916463a1e8dcd8d4a4c3dc7d378bbce96886b9519ad88028ca39a2a48cf0eead4439d1f1878fab51eab0440fbd0bbbe24628adf8d965d32af0a68a1a3a223e7ce074e1b86e07fda3f65ebec0e8443e3810ff435efe8f4586ca814e814d3799614b0e22be9cc390f62f880e7498002c09523a0742ad1c41e9bf1e12843d7d4a25799ba24f0bcf95d70de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
