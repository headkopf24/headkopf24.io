<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d4621f33255f44c8702ed73893f8b1ff135d984ccaab68f08074caffb149bad46c669597ffc1aa09b80226b2e02c5be325016ae92431b9dfa0ad79f5c3125f8fb402d8fd42166bde008eda389aefe3e2e7913a01b5bf6bb5dc1ad1388227a6c2c4058dfdfdc0ea0e992b80364b3a5af4a9dc50746d2525076299599ca1035205cf40a555bc0e852dd11c0fda349e1ef12026a158900505c5acc75f7cae905539e651b58507aee15c1a934e29814117b3edc606f234184053f1bed4f43dbae8cf1c706525e6016941910792d86ad4947d50b4e4b945eaa9d8d6aba610df478aa23125cfb5d133dbaf1df92b275b3daa09374c4e8eaaf58f78b9497de6ab258f5d815ebd2033d045023526103e7ba00bda5529f078c6d5412aff396fda0db01a9eb7cf8ce62fda3122c819b9dd60d98d891ed31a2c9f6f4800d5053e805f7f451648c63869a20a458d9e5b97ea2ccf2ed377ac1cf1bf7cac3e18a272916cb8b852d1e19ac6684cc62db1a4d0ee9fd921bcb365441c4abfe288510a3f2154e02ca5c7d28263b2b74a592e8e1dec2d94caaa2e07578e66454409bd9ed7adb03631bb6aae9a1269f223d108d4d4cd3b08fc46cb47a1842bfa619a24a3898ac140eca78c4dbb1bc51b5eb78e018c1f602b25878559c49dbe33f99b29c6fd2d29c665b51451fc06f79e6dadd1f937e0658554f62e1b4fb6baea30397bd86bdab38fb72fc48b31904130aef80d7f816d13917b0e26ef1a7afe06e8db7ce3bd48b4d8541ec3c23c55e62bde1140f358128df52e536402cf2f58b6600b5fc4c3aaa8508853f0899fdc548497461709570a6735dead356d06f579499d85b93cdbacf4deced66430c741f372823a913c075b9b13163f4abd173028fc715dbe8663ec0851a1f17034aec429fddda9178a39a8ef22ae47131d268b2110e1e2ed58e15281a2ab011b706e4dca249103d9a855dc7c0eb88d5c18660d9c945ee26414797ea02f11e31f3cc9620844f03688b396276400040797659a833c0f79ed565c77844bc98fef7eb3142e459dfe6e63485df11b02ea743b27d35846d1acc34ab47ef14c6107abef5a398d1cd10c0bbe377da22342ab1af2ae4db1acc7b7916ca9584452ec178314295fce91deec6b9190a8d8e20fa043a04841545db2b60cf1dd34c0fff52ad9decce6b1c8424926322e2c03e68404a259823699a354ad3adbd5d271ef14e769520a23cce286a06c0c011260eddc638d31d12b77355c0d1c3ecd56918f01eaebf8283338a6aad8b752e02eedd3077577b2c536ad9149e25e3e96e1dfe9664b1ac80380b83694051a51713c131d02cdaf794f95f6c1601a5a8f59d1663eb0b5da87b6b9477a130c354277a308340c413ae8962383795a3bbbebd0bb9ede14ed5e15a0425d021f3267d856cce8f3f62ce92ebc7d50707ef98329fcbacde6973bae711fc36b71332c763d1ec16364afb8cc5031b5aba55116daf868ac1c87141edb14ef90f20c409dc42363ead15636b9555fb9eb0d8f825b06f11664e11a008526e8675240c04dbffc3dc3896a305f9d1e8b1188e4d6acac03164f998ee11392f4f8b530ea0747b2738d6496fbc801515382e956862e0b0531cb74dd217651bbe74d9736c9c78eebb8cb74cd474fa79d64384ccf34bbbe90f3645f81c3a015f20ae29db77b696a177246de21688c6da7d4b03dfbe26c69b9af1ba208068c676bdcfa04ceee144a5976528bafe6f1f1da8d5cfa1d89fcd40518604064854dc1b644fae357e47a3d79d371d6c33d4848342a86911f2b811e1eb1ffd31b8b162088f25bfe82a614e3114e86a39aceb0042a29e740d69a1a3e90b8d33dfa4d45ec845db33e77d06301417ff098052ecf67475598e286c492e1c528b683853078d616e3c864a4d5a785a3ec1e0665b0611967f94c844cb6ef17f7f8d2064e9a583ad9cbad12584cc55d2fb8b44f07b38f9c2c5defb0856427c52eef52a2d4078b9b7b83867230db61b694146e5256bcdefca15b087e528500cfdc7b2af4b1dd945d9341969b933479d1b16b204f7e11a3a91c8d2649a37c3ecdd80a2883c9fea3f0464ff4ad4f5f9b600ff491f3d6c02303520e2ed2ee9bda2e1907256329f6bc2833a077538b20ce622b2812045fdcc9ece046a72e3d559617e0e3ad779a89edf07b0dffacb05bf6f45ce1350d099f4d4bca1945b2d20a9b226ce421804bfd7992d957d4e31f6f2e07768f444d4ea5c9d353106e168af92e34be2e7c54cac1212b1d2ed9c5e72b21d42acc3cbabdcb666b560519c9e46434bbde7a6016de51f660c531608795978140b965aced1e7c2aabbe06539705cd24e8b72c6716ce92d432244079eac7ef66bb15568862b7c5d7c3634892f74d3e696f414b9f72abbf432337c621d050a24138a9fd50b878fd0caf6b7936460e91bd340291c0e0fe9bb119dabebc44a14119f6ede787a4f15366b964b793bab9f76dd9ef832b81b8711b5ea80efce208922ffdf300a005ddb1767bb265fe6660ca246b39128d0620bde6b86442b75327c5402b87bf75a45f2a59ca928a85f37af2ba5e0b6d760161c23b63e983789d06b647e2b95393b0a135f88c53fafd088993882ef943681268907c9a457423cf8fac8173d2aea6fa09bba6596462acf6608674e6f413e334e5c3910dbd1533938726641d82425a05556c718c7a8351414aad2831a1e860457357548e1a6d50f56fbf3c91d78da9896af68feed12e167928dbd3081c599600921af952bf1c946206f4e15d3e0c6b1a558b0f90db781e2ca415c541d3daa877e6ceaa56b4f2c827dea7ef725b42923f1ebbfa9c30242844c1dd920f8f1db8fc23b27fbdb64b6a2be91cb3fa5c87e7c7aac4f7a201ce454a756775ff4c3e2fb6a7d252da4e2ef306ed298ab8f13f6a7a1dab0412b94f2c790e098ef42d7ce794d7be8cf5c678e98c1664449cbd57ea7d2714c84711badd3beadc851cc882486ba820558e9b58a0aa998524cf0acdb2290b905aeba179bd19409aa385624da71b9aa12e3b9d107a374c8cf9ac5a6eaab3033a1c695d8f34c1cb294f107e5f701aa36ccdac11fce6e29e2e5a494679572b92c4784347c1d07d6bee6e0dc1b46f9e586244359c754e0e3a9c7000da55fca1720218afcc0ddbec4be120130d2b1a21b87ae9ac8c81b1e7445433e7a197779d232c9c7ac68090b0169438a5d570a7ccc3ce9d61711f3b4627400f8019a5a5b0dd06f4b5fd8bdc33b419d7c48dfc3a4a30758fbb918fa8c71912315ebdd4b7e7832435bccc5f610ebfd3147ab707e071309905eeeef3da3aec16316bccfde89a936c0cdc077557b1cfc624ee58883c9fb1f4ed6ae8e132662da469ecc9dd02211ac0bd1ff7c1cb0dd57adcb229844aed94735f74c66879a11ef171369b764318372c0e101c69052a168fff4bb88dfc435a84e9d42e8ccea2bb02cdb4882e26e5b710d3b50b85a0683a73a0d326b00c2275f349127ce575f77ab88dacc677bc325683bf2ee0989b83ee74ea10f648407d87440ad880dd249bae1987bb1aab472d16488064a555a068179fb946f97c71db6c593d41053652f23d300cc37d09713ba5c2e827cf90f819efefb6e016869a9f6a0bffdfd282a05553f50180ae7cb1663407c3708902387906a6a095aa4bc045aca1e95061ec212404f55140cedcafa0e18e2c04a4b88996151f7a7b226e6cb219f110914c72eb8c671c5abe2bc2f57e6957bb8b38cec0a33560db178dd088daa7781ebe941d9f5293daf8f8ad695efc324e6a3b7ac9690d3a53159d339eef13d0b9d16001988c99a02200d14de8be8ae39314c4f3d59916e71794585a41d815e475a728276c86b977d1e66ef150d1f2482279431c7beed7bf3332229e97064db3d2374be3e1853b10612e98decf6942ba72d8336f9c5d94c6f7c0860d235879a57c5a0d67e048e7197ccf90e06115728893fd304a59930c7254932f107821a0f19605aed23c60afbdd2500c942f1e9b8793910dc19893751c374005ed4325c6452994ce431f135b4fa84c326ff3e5b3295b2c342348d0b1420902280a8ae9f5f2ffdcdf5d6e02f5d4dea6c6bc32d75da3de7a2902728749fd55409e8686a3065ba62b01b80b16648b25abdd453f446741f05f8bda6d8a76bb6669674eb84f7abf1586bf4de48e02cdd74785041e8cb74825e04d41d2be6c622951ff98a78d2900ba2a0bb9004620f66b3711059eb12c74a24130e1336a72fcce18e56e16803f322da19ef28bb28a1ffdec37f02829c9a4d3e7d69f0c8f47c8f21ad1d24ebc2f428b80636745ce4e0b6704f07b8358559dfa77e0b4cf82e75d5de1f079292a0e6e8d4bf78d38afa46fc754e0fa550f59e33b3d223510cf60807845f7ee93612abe7a755325357e9d2041b37e49085aacf9e21ae4f55e18e7f1a3d8fe8a986145f0dd48991ee5894b003e777e447c34819a88a221cb914475d68a66464a78675b6f0754a227574ddb55a2fe5c0d1ec08960031966935686a37521d007c4c167c1737faa1d98c3bea2b07506e24bd8c4b3d2835129e6547e9b3a81e3a9109a0e5176bad577032f25dbb04d2d7e61a87dc365d6b0296e413f83215e8290b70df045ecbd73bad6596d543f2b603cd830029c7e19f318983ee1171f3c6abc4c8a2889141370bea8b55161e84652de14cf18004ab0e170491f7ba2c3ef1d64917d97b03559c53474348aabe6c8b143c2671aab712b314f4b1a5955e78f713d21db4146807e0d79e9ebae56033848fc8ded2ee10eb4cd34945d1f4e9c7d1b61f79a7df27a36dd2ae39be190c17bd0264b11506774f7b6bfe205cca507dfb25016220e46751a8a45bea750ab744e69b96fb17c490993d687de35f45757ce805b6f3e4bfc91a594c6462291fc286b774048ccfecbd0ec98105480d76480d13fee35ecf8b12aff36fb1499ab42a7920ec720bf2c155e178c698e4fd16ea1d8cd56782a5ef66c3e859a083c2cde2d52fda29d26a9e901ce814b0343cac48fbaafe5eefe17d06921dcd977f63730ea913ee0c7b4d0a767ffe09532bd942b1732bd9006f409dc2f690a5621d21d1523b80cab3ceda06e4cfff18f08bc2b88cb604c2b47b43ab3ab03627a621930ee82f65cf173ae3172b144a2aa2dae8602e0519aca1003ea819b8ed2a194e1e44ae9c7bc3bb07871b8144dcad9dc7679fcebcea5fd89612704d580deb200f5d1f23eb65de6a22c4858f3b106e704664a8192f7e518c0e14582cbbbe5f872a76a9dca559140448e38b9f35d6d12f649cecfdfde4ef9da8f2f7431ab5fd2bf026d46b662842f8c06addaaf9494621f5fd1dec97b5710da9ef796cfd0ae8f9173f601043bcb8991ad4dd91c68bd32edaadef11952a32730e9c964d98f5ad379d271ee35c875cdf8526e56bf8daa331d2f96f7bc07c8a5a3b2177cefed3f6dc4847b6db810ee9fbf404429f94f83e06fd4ba832a25a664d0d5279f1d3f0b2daecb2e70845fc1dcc654ceb6d3b4a2d939b357abae67de6a41880bbbf04b83eccf07dcaf69cb22b09ba0fb5667033506632f48eb3f6d4e8530d959908e12798628617f24e35e8408fbc3ebec02e936c17c373ffd30b40f165b6a00a9c116875e972abb037f18363371c420700ad791b59e3ae18bb59142a0800235e243567e9d02793cbd78c47f7d29436c195dd880f7eae3a390889123f34c82dc28d719cc811a2742cb049532df523661dbf0321de2c20606dc517e334c876858a4dd67611e23a8f835275e266f2630c9ba774ce4768d5bb0db2d2721486bae7219397332769c7ab5a71e97ea21b3b12a8ed0dd3ba4cf32ca9f95bfd46244554a44c8522f09d61a747b9f260974576a0904552b89493032f366ca44ab04b59aa1c71c62e0a936489642064c1dab49496d516897053952af72c8fc9bdf94b4d85f1f028483d831e2186f10a3e1dff2c4a4722d244d0a3df9c6e0e83a54b4f670655e127db96745636f8d563da0b770cbfcaac82bf022b75d4b436e1eaa90b0c87c3ea3c47b2192fb4271cc3f9e92f2bc55e6cf7473fe835f3e1a69925f4f732c9b2c69184964a0886cce20070067f44f0e0d2db3e3b972326d7ad76832d5721adfaadf6dcba8791a2798178612676f193e436ac6095d52b4e81db258a3866ef189db9d8a6a419225e8ffa8b8b3f3e6a5e75913886e8c094f8c290bb3e9b06655cb501fdf14857cd779c225bc0dcc6d59352d909d291a34bfb6ef98e3654431ebcf9acd80e538b22e36887101ccfe0d82e409ec23f227c0a759e63d896b13503bf8ae4018f1eafd7edda19cd9e1973582d4154d12c550207f73ca0a8ff5a8e89c899e7979d4be75a9bdb967ff5f1e6bc93c92774fc4fc0c460e87532e83defac83a1eee2f9597efc19a1f6306e878c020efe08f3308ed013aee1d468106fb2d2161ee812a8578529d44636bf62b65e6cf2b31785187bc114600b4661913dc838708ac77d3fa2c47bf28409aa944ea52c64a092c9741e0671a79424ce5741e1541e5f9f4330fb5e49fa620db1eae4315a7f8a16bddc0e7bd117396b08a8c69a1eba20b26a0af59a46f1551a9f95be975a5b4635bb5303d7bc5cfadc673b6a27935e6d4d461c4e35d506a66bdda63a386f2bdf0af19c57960213f3dc973556e16d7b92a135111e6d43603415ec42ab82232f8baff6d61f45a8ac5af55f0a73940a726b482c08c722d2883f1c497edf7d6d4d6b2ceed5966ca729487d6bf29e047139bd4f83a39a1d839b9126b6cbdcd0bb591c0bb4f9c5f4d56085b4429b41be87136d806b25daa5cbac2e29daa0be51f279b8e85aca30d0ea932463cc37870697c1d4051b9daf32518a945ba0553cee09f11f29569d51a798afc28cb19c5f00fb45f14dac600a5a42e7d3917131a21fb173e34e0741229c1bc16aab6ff303666f2e248b1e11f81d610e85bf631467eeab59a3a656d327e3bac03b321b93a420f7b1ef14e6f1f3ae03f23deb985c15fd055e513fdebf504c8430fe3e71f4c01b18b06172dcf91412d53e389e5d8c820776fb4be74261a1fbd831251bec84a1329db10c3829d8152bd33f315054fdb0355e3af223d3ec7ee55c902c6486812bce3370036deaeae821692f6cfba1679c3a286b152b1b5418b9d214c1c96fce9f229cbc821017b29a10bebf798de4e7bfa426453db9997de709e77107e3e899486db6a88437b9ea98b1f167373e3787f53076c3e9755496635f8ecb31120ef0cd59d7461c95f3f7051e862e96fb60a6f181671bfa0ac2c3847b03910743d13bb684efafab5f9bd0b637b313ea7a132322b44c3fe8152757d92de84c389d4b3b6a428bc9aebb39b61f11ebf93afb381696ffb2421c987371e0d98dc7d4ecc9307bbb7eb346a64a58d42d0e45d1ec6d1a6aa2afa8174fa611e9a2b821711c2031f4db1867df7bbba391a4f39d0f516b9678fc8d11420c9543d6fbddb37fbb438a11fefeb57648454c809fdb15d1b8a26fb5256271b8328dddc1439ffb955048ca3dd06c1ffc469ba4496321b3766873fe0fc69a6f931226979cd79fcc53cd3ce4d3b8d577961d48ea8007c0fce424042f1781c0b804a9a4c5ac020e261c41b78c3e9ea65f299604d8682e38acdd0bee8e1ebffc3348788fab24f7015ef6ab3f7f87f09cdc19e390887ee1ae893d6c9e07396003817bdff3363eb4d7572f3624838cbaa68cded80f579fa31cab8d94a530afa2a3eec75480734235050e583dead8ca2174530503d1c0073bb97ce8b0a24bb13052852547f145884e449544a120bb24df3edadd2026582b46422adb70e56df61ed18a064e4a78ce9692542705670254bca84ceedd6038232f313c29993ce3b8dab392a088206cde4cce4c93468f369cf311b662d6750514cc8e6d4f60a8119ba11bd1eebfd44a6470f7750258836973d3f844957c2e07b45ca131ddf2c0d587f275c9cb0ec9990161ff6a9c203dd671146fe53eb9bce30be58b216b2b9e28d9fb027b72605813d8d5f21e472264b19f8752046bb4b44ab9a9c2e42b02d4f04dd649f2816a46af31f5ef44fd9b4721dc649a2224851e85ce1df1ce78da3dd16f95078c89dc7d0ebccaefe1593cb0f5360bb11faca249340e403086bed65f719ba436dfdde383e712b99bea56c468c834075c44ebc1ed99c9ae6163da10d43aed2ffe0ba7abff3e0528e04d91e466401a68826919cd6ce9eeae3517cba7abb318096f4213682fec9ee0c023093e355f8c7f8de5490688caf352b3bdb5ceb28d5ec10a779e0d88252de8f0c70b11d958f798a8db931ff5ec346b21d223721437914a2ec49f87bd603a4686865214a6f6e151975ad13149f5b96c9d75004c40d2f4fe7105f35c2e43e0aca9f12eccedc9285d1b775cb46dead862513cf7c56367051b4b27e757109382a166c5a12873741860301e4838956240d87735c10e8cf4f9f2d87dc54db876168a4d1440a799feb1e1be0b1ccf8c0b6fd95a5f87d4814b7340af7b5162af54923a3f31b9371bf23c3402800797f8610ddfaa08b66c2c056f95c73e70c95297a1e9b1e82f19ee8dbe1c9e076d32288b1a30010d4552414ed0881e17aaad076fd614fdbc9ed8db45b3077d4b839826706105d1210147a8eeaaff4a2bbc5271c293ebbb830b759a46dba9a7515f9e641e438a841f1cdf758600fa19554566c0cba09368484d8f4997e4e5aacb6f887300871d317e71d2e6ea3ac9348920429205cd7c8a07a2d80a2e6f2283de7d724de174384a3771fe71cb54f8aa2ec1182393a0682635a98993885b616f336ec5535c22dac579fb30845400edfa4fc7f7704670112b311846df0d4cb9fa552d18834dc68607c2af029e400a9a59e87ef85331d081687477645c5b1320766cf8c1704ca45ee8da8fa2e0ef41dcd1c308a58a27c15d35ceecf0c67b283942ad180d177b579ab9161cd33863143a5acf729e34d59b1f945e6d36ea19954ca258b9054215fcb1459b7ee0d44d037c2072474cb9d2ebeae5a22ba88fa666f08ce39313956e54d6ed67e5e0c0a77bd5d3098609c2c8f9c3d43f89a154ae1f68ce02726275ec90dccc5393827351339a2f77216de2d14106985dcb4efb6dc8a8512876306f0443b47a12af4a9c2adf77e6346d8a5703246fdf61e546ff6f5e1a27a9d9126cd91d15bd6a79b2f53c0cb1cb3f42ddb25aad3ee0eb61d80e78274ea95490e56973963e932f86f5c7572a2c5f24cfcd838d693febb5fc6b3eaa8dd25bbba3e58fd6c45de41e41843c8107ecc351d555a0208c05d6a89c6d7becc60402ccd018698960c8aa639a16d4d11a7c35e4a510e39c64a9fd96c0964a65e0bc0f9bf4e45b1e0a6846d740ea8a7edd3224ac948ebb43571b98d1e18d3cc91c30ec71efae01d74750763f978c650bce496e8533cb021df3fdd3b05995917842a212248e3da28000c80db52dd00caa740fb3d02e183b068338fc2ea59b2118a9b1e0a61658fa07eadee2868382b8647604775089c41d60331cea1987a8dc921fd951dc0a51e3c949dc353bcfbf2cde69eadc81a5c48a8f5b261816788fd4761481e5b178882da70baf6e551612b5cf44496b13aec0293ae076bd80a2b0ad1d4fd7d19c068f3052c0352cdcf68f924be3dbb0a46a03f4bbefb71a6313b63127cc25e96520ad5f2ddd4df9c873c6478212071fde7b93eee90a836e538574d66303117585e5bc2bd57d60b5a5615d71d128adcc998a215aeedd99b1deae64f4a3012a6b8b9a5a1207c043b9d76c8e2318c471d213eb1f1f022b37ce9dd2ea20a936a21c6636cd5efe0aeb7146df1aaeb8a6f8fce5b7c6578bd60468cda725b4b2bb3c6128253ed52ea24d74ac3f0e2ed9aec5f392be78351d6f24a87c08777b2a83d2d3e1cc849be8780c004e9578f3fe9295d586eb0e5f0f972719430d3a534076afa6fb039aeca6b1d4cc2187bfe7be7fdba404af3117da929b1512b2273233b123e4405dad320ff2f71055ae985fe727dae4134997fcd251887acf12063779b0b6becf38d7bebe885d4904169fca8684823975594ae7d70a915ba9bf99b70dd14b6817ec43c9a8916ec9c11b6441c41b075bd2a27c87349aa84b29c92acc3f52f8232dafbf43b0b6e6068c509aa1dbff74c70a7ff9ddc356f25525d11785ac54c9dfc9e3628c62396518c5eca6fc9ceff389c0cecbe5481c32676653f1bc8befa6e7e65239375ce87425dde75e8e868b9086a715592ded726f5d1709c082b3bd4533d06fd59052e0088c30f01c6b49548157c0570fa7d59b60d2bac8efa8ec5044f5ba0bd5927f729736c003c75584202f5fa94125a30d08bb1d461b0e83db63e6873a8a7e56a2aeab8883277ae0ec9834c11f00052ea410c2ba02d45fe3f91f112c20ad8363d7f1452c49af652da72ab189724bafae3499c54528e6af5b8d7652a5ee65ae29510d66044aa651003f4a578151e7299857bf50dec335f20687fe9968d1dcea05dd1d21a080fc3642e74e924a2793481223c7c4898fbf26a82fb93c4e6487abead1a2f9914cbcd334d5579a177f2406a44baa2ec1a17b43e130b933654450092a09b0990b6eddc6fd6a5502a3107df7e4000b596845e7ee14bb0922656d4a58598acf8810018fb52545e540377a8e5cd5901e3e4fac041e0f6d53b659030588646bd381bf118a18ddbc4ca721c7141d09671d855d9af199d5b745e74d84ccc2b5a123659074bab8232f8f6b618931f8050c3249f42943fdc8b6eb3d81c0a9bd11547ea1e5f351368cc32a8cf2d443fe051923c5662fec838399be13f26f79c07c2337f1b4980433b2607626659d7e754642ff2642f39967a237b17346b03bc1f46d8178635f0304be0f0c31c28b4b269c09954e182fd978430a0a089c648fd675de93ee5b931e940524ae3b17fcf49d51f9e4d7ed0e007e22780e099ff1b95587f999da883acf2c9e6566cd1eb59839bed8883ece1fc796aa8f0257a34c6775f7fa3609cf3cebf424b21c6c316719067e31701872c6f568e4ede11a6b0097ba55704c410d05eff89fa30d86b3a7d53de091991c986e9e90e53df2d183d60d0a225abb7f98a7481342e73c2f8078cda13de489e22923f60ba02415b58a829993344593b00eeab4ebad58fd0d0394b8d043044240c13d53447e22fb8455dae304344db25f7bc2067e581938e47874efa655a0f64d97ff59f8d4efd9b50ddd3a0ea52bf5ea92571d8b588091f2a0f910335b035dc832d4498ba266de1831539bb988deffcc0595a523a6aee2359b93e47c5174fd3e36371a14592aa3e77c54f6df68e3d3e7772f176980fbb8852974c2006aaad6ecec66607d96251cf48b2175e940181041f84df800c92e8534cc2247050fd0af502abb2644711fccfa3711a02bf02c18f0cbf98077f62159b54ef23469d73b73de9d0167468e3a1e6101617a8f92a5d5982b009a8a1a080d41956819878366bf1791cb2333274ffea6eaa500d141bd7e28b77e31aed570c9f2a29990eabd6df3d3a97c7cc8fc4c662de39ba92c240acef27746d71858ce1e83441e0760eaca3bd3e2a42dca1addccc8058429da572665a7524f86254fb1c23cec6b1356c79d0bc27cf00b118767fcaeb4114ce5521eb084e70b991a1358e633655c9fe730dac0c1b1fabee849d0a2bbd552400e2fac67ec29d11b841f2580a368762dabc79d63a274207e0e88a8cbf83c6b8a38763dcb2d7e698fdc7c2c6e9a11f6627f7a6acc6c29822dd28dd83e863c7c060f127a1ea9870a8d420f1c1f6f8e749ab89893fe0217c363744d192a1c9b4f0e733c6e589975e688fc8fd74ea508c66d978d28764152d5fa5683baf12116ef384161158b57846afaf6cd07ac48d281f2ac498442ad83789ad9009b6bd5f7947ad9368521d6395174c864f77263aed336aabf87cb9313b9e1a908441177f5a2be1d016dde0ca396d5865f7b86f7dc72864bbf976e6b861ee74e25510e2da333b755acc5d4798383f439a7f0baeb4e9877e017033b667097890c5762fa2f9caabca2a61e14c45f8d6b9ddaac20236c138d1d5ad00478a72fbe5ee83af2084cb6b23a6d44f1bb60bf892e216b8d37d32a32dec33596b1a718a80b965e456dfb2767ca134ede9ea30d5dba5e9806812a652df2abd076f28976996bbdc9cc7251f9ccafb539a5ca281c4cef22aaa7a97f630e3f5175cfd992213ff452ae1c415e8d01d9c4f85a558f72d628214db23fa2e49038fa11bb83d7762f29372f7540172a36c5f9d6e24c1fd4d4e3c4d7f2102f3192eef820f8b64c09de3593b6dfb1631da429fe97231c862b2569cda0a2920a4ea27667beb11449e8097de12446fb9e6f762958fc5adbb324430080a9b63a65142729e9386323cfb73764650fbb60be06639c385f079ab605d48bc8586975348a113a4c7235da74e1550a23849690223153bd61c303941628584301a22da4b3fc09a12c9184ed7f94d4fff6f80c30fe1adff0737cb24fe42ff1d932d71df4d884cef7717dfa86aa169bf33d7ff29e23bb4e46d43d4f537ad4136cd33af85f119156242c40da70641acd3e19a0bd1b769cb4217e20db76fa506f36704117afa6ebfd213bca243feef6839e7902d3ad40d0995f50c0999319b215b082feecb1930605e9c69fecc4d7394c0e0704868ac4b6bbf37ef48d3abb72e24dabf1702fa89eab586771ca1dafb07005ce97f99488949f027935d4bec1446db51c0ed8331de88229860772dcc69f234f13777334d0d578d38cecbf000f4b2b4a8f7f4dd4837758ba6593f2bc032ab7636815a93ae8bfae77e1a3327a64b191904d35c9870b40b9dd0a6c24cf82eb8cc9178459679f782b34e149b6adf82adf6278bcb36462e14c16cc83c7b7c2ee1c6343bb1fb5fef41b9fd59b041b18bdc2ec7545921a23a55ff6a33fb9af8208a755c190f5a886c025c5e71689bcb544f91efaa82fc409d7fcf04459004e0df965066a1d04d36cbcc42fb54ae789d7bcc8d61b606a766681ffbc492f871bcaa86df2814113eb59340cca9723dd95ca8859b3d1b344eb082ef1ca79ee04168c97742a3680d0b2e027bf350eac317a06e4b9a5ccd5b7410e59fd601dcf9fcb059f9f29f3e0da5d1eedbb4492a837822c593291cc09d32bdbccba604bf7cd7c07a8278feac751392dc2d6c8d1018fb6d7a213890f0a9db2adabd5bead8e2835c6ff67452a4d72f28acf89bdd4aafbd5551f27245cd89a53d87285edbcd412ffb7faf3c8ccf3505fdedd61c524296de7487ba039ba1dc1cc9e8a988f235f34752342268ee8e16c370a359a98e4a0aa33ef95b80ddade15641d34930874bcf31da924bd8ad657a303c1eaa9324a7b50ec74b8bdc0ba140f9bd25e7d9cb1b318fd1137806ad23421a39eb539a2a58dcdf5717d2ea35a9742026c24b8fcb3fb0f7e3e65b225b1abe0d84181f1f3a7747e1f486119dff7d2c6491ab86e4d8120f17078d3ccb3508d58656b7516db8ff34e2dd052592fdc199d2728caf4ac8883e18cbbc7874636f646961cfbf5da4633c11b28e023ebbb35021e25a614d04d8081a790a2fe0a862868f8167476f38fd1754bfae917130b2bd648ac2e515801ec5ec121898bfe4220fe00e27f5d1c93d57c5bc153802e36a090a0a986acb114e227951433909581126bf0ebddd35bf6873741c6baaa963194a1acf4e97f50b61ad5cd82db053fa8259823e6cd033a1fb672a6cee89d15b198966ff8bd4507677b600c9ee2387ae13d6350c5547fa34f660884b392d4e1a12f36609f5cb49cb894d4a9edbb4ea2a3bca750dd33552933f8ae8ccff3513fc46350341bb74bf5b0c9eb1f2d8ba322b9a3814359c3bd31f5bb6d16e08b5fee1d6549c9566dabdc040f885b2e8087b8ced77cfac6d1af8c652156eaddf7e25c4a04dc7a5598040f58c1eca3206eea37192d697596edd7af73a04abb37072d81342e7127ee44ec511252373333267f376995465ef469e4fc97d9253b1020a01c0601828a3af6e083f2879cd8f964b2ef8c1d42167c68ece1460c73f1f853da9d513836c5b62cdae60cbe4ca390b71c706341259194f7c28b7823d6298446009c32391443709877e61e0d6134d48afb4c7e43da459adb0136ec5db75f39eeba4273f835fcf739c0457762bba8dd378353087b34fb354c95c494b315296a41b8fd079f306365377cf44f402fc8ff83a8c469973aa070cdda8d892ecea57027d11d31b5e461b9021405a8cab9a26f096367d54ca5cbbad411c5f268feb86028f55531f04a6c1d3ef3d1f7b47489a67e159c2b792eb4da5a1172cced1077b162a6ab3b6d83148ed10bac9a7251babd4d3a2a5763d357e93ba14bfacc480aa423a22db9d4f60e62a21f66d07cb6df1b2a633f9062fcd9bed3a758fd0045293320becf1d6897bfce07fbbc6145fb03593494071548d9c71ef9a7b1556878444ada9ecfeb93341951b6f72d9044191a9d7da22a9a46e504468142f8279ef7e95cdc0e8e44698ea4850c6488cde92d69ea59d902c8062e3b02e5ab3296e497cb91c9ecae2463b309d3b31ae0c5ca6ae391bad9dff78fec9b62723e419c2e2ba1ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
