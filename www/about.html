<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e08b8fb19db36dca7b7850f105af191b68046c2253f37721c66495010fcb20d5dcafdae34a21bd787ac51b33f1351daf728a4532334dd22298f18064aa32147c22710ec73ff055adbf41bba0af59f62396d236aa2e2b70fc55c777c9cfbabce26183c458985286b09136dac98656ee7cf0bcf55a9457a2a724908695d33e1e8ae492f86ffb140255848c161af182e3afc6913784b1d408d76d27e9c84d697d6959e641f6afbd1e34855e433055d35be556de22bd90d8c6515afe3aff85141e901e0125ef76871122d01d151fcb28a1a73902b9267d6d4b6e87e73333f6d9dcc0e475447da3bf25eea138705f52e93e9b836f3b65903e773b9532610e4710f5455d314f6119e2aab87d2473fbf189b749ca5c515f48de192e86be01f979f3b1a74c365b7d13f905187375997bf9a91ce208e8c75faa47f36be46e465f3ead285464a668c94d13c773818dd7c61cfd2651d755fcb600a1c2307007fcc14cd3e08c32af2a49861d1fe69ca4630060762a9340778f5010c8bbee06df1b4431b5a3f3ab44e191ef355640dcd5fac6254f84c5f8bd17d7ef0eb3500cadc4cd4f801508947be70cd18dbab2eeef7597cd33de9a6cfc25f0ec2c7170f069437eb8d0f626f0afcbe7326e70de4898a5b29639fee84a1311d2a0d8644f0e38a01cd68331b10c03b7bffaf475380910b8b51006cb17ebb7377cdf233694cb7c4ab9b84a81fb68ba4a1b82adb351f005b557f9945eaa1ce5ccc07955d8bb05389601a4c0256027fe59d14b87e3343cfe7d9915114ae27422b4dbfe876a103f829be9229b3f8bc774f92fa4e4b162a13832932caf8f081faeb0aa1fc03c54dc67458ec5ba0ec8b1f24337339e3c72224641dcd68cf833b51da86ff40768662aaa49c1c924f35099622a39193b55690df7dd98f85b0590e1ccd717874c9eb66270007fac96dfdc0be2682ebd48030fb36077076a58a698fc2d16424f38341cac3eebd555455c7a7e26843e29307e075cca80a797257ca9796c144797816709145d9f69782b886f95f1e4b0dd723afcb2d84f2e1f9015a53c2cb058f8ba93d793b00792bb9b6d4a608876905e9afdedc4f59c90acd6a47eb8013f9e812f343f82251a8bf3c90ceafbe02f2cccba49122ac01c093b0355078f28c5a3d7833bd3d9e33b12b11e9f0007e5c37f5ecc10052183236101802add1fb0dc67dca487384951c5f0f933f1e76faa10ea189a974abe7bf5f62304fd369672b541a5412223e15bc65e06ce401706a84e68b3be1281b6d815096599b778f7e7a7ad155a0a160326a34154353887891f90f59dd4af2cac809a206f83ea060cf1c89e46a4849414b153854320a8eb3d4a2d731bcd1ff678551ac530f991b48f5cc1adcb1105e92c701ae113bcec9ed9646daf63d5306a8a544d152728a7baff5ac21ecebf6348a632cf5fb192127556dc9a15167e119c2f93bc5e5f21c6751ff5b8b78a86233dfa8267ef3346eb533d36b8b483d140c2ad2bb8858573482aa27b90b4509581e5e5647f89997d83ea312015ee809ca0ce76d465ac506e531745bb5934fe7638c257f3b9d1c38285258ea545a3a8d29ae744d54e0a1ac7c93cd98c122fe93878db25c5c145b0cd3508d43e62b85c0dbc4d4223df28044e8da5a78a7f80d74983851891139c8cffad849900024fdef0a5740a5e06c1ff3feed4df74330812cf0766db5c46dff2d9363eb23af37183c8e0072502d21e25a7c5f9793f0685303938f430ea24ca956d8d3078170d553d07b06059af54f0a9c26a394a6274d68bf30c0b526fb8b065a55eea765f8a28b6417a46127fd5ceb42b9a6ae40e640ecc3783530270f7dac787a5343bc745120c7b74da1040fab29d191890daf84f85a40d7f1da30eb66ddb720b95f332df0d8a1714ff2baa6fdd213815014307686f5e536e9189fe0a70dd5636d512d038a7cb39b814952b445e3ff6583f9ef07c624035ffc9888028bd6aae0bd3c96fbe9ff21166b24b66b1fa00a1927b8c5552af5738f0bf8244095b0856be98def3d5d06b2339afc36aa0379c420a415295a42f7080e69b2c5b98f4735d2edf4044c3e2ba1f70ea85d370695e2f32e4e9e4e5f2033513a194e03242844da4b97020605fd6156f02d14743449dd470deade2817b9a98ef260affb0c6e623d74f935c0b76fe08398549d108ce08755918a9ab9a17feed6ed9774ed096486da96bf59d09ef5d1f7523a35d64510615db097a9c2d88d39a7e35e0feb4ff8a6f9c21ee52635fb359324c070a2d74f41b3642e277ee42ebbd6b10db491c1f81f5fef8766e21680604e2bb5f35a62b9a9436cba9970f23501a743dcba43190951282d2525597f635c91cb2a9e7e30a41ff0666dcfb0c611f297a59225e74494d970c00ff790f2c6e95180f42605998d788d844e24ce3d3275e04dbae6ab293e950366e4735e3359c543c7a42b994d4ab9dcfc9a8663959b84b5493bd8160c48bb8bcd723e6107c7bb4acf746a196b4cad2c137f138d3546d6711f77d29afdd43c4c8f597cad2f859e9488188b64069fb91d55ff6d69d76f5e11903f1e6d4344d29596bf5247e5d9c71c9535f9aa5d2aceee657eaca9b0ad12e4e9a908d94fa867e6166916ade07e7e003e71cfb396f81709312eec06dfde5cc84acbd9f7dff50d6060bb0336285e138efd8624d65d8d61ea550bc6856619f10faadb4562071c9ff8b8fb3bc978ce4d2321c280c298b6d179a56ef859f943908675d9050fc2d67bf6bbf8938a980f07fb698bc2e3663f58904cbc6ca6c71ea79fcdd1e159a5faaa9339b15f338a18a45f5f10da2028f2f148296c581cf8c3f06f30580f9043a79b74d9aad61312d612f6b6cb8011fc263161263a24040c0a5eb0159b673d513602aa983a01df70e121e2a1798fe8e2bfeeeb030c2a41550887c91357e826d49de7f6cd7286fb0b82320168511df6cea287b2fddd729fb3bb41fb3dd8f4527502be3f7ff7b7e3f8278bac55549521a3eae445a6e0c611f7a6b8f5e8c38335d1c92b570cd201b344bf001bfd4f1170bfb3de5590a82b13b6a2225fff5c039b84489cc8bda9150e3c16790ad719f59b19cd8e60802b4eb8d3526d5bb2490f82ea96b5123e4b93a28796af12ba590c7b21036db11609b7d432cbdc6b5f151b67109252d38a4843e2588e0122f919e14edba00cd25b4ce61e090e08314943c0c01549f2817c590dff19c2e20d73c29b0ce067759a2a6a19becaeea481aecbfb6808a4cded74f2434acddbc428a168bfa3c1016f29b45446b5d9b0f3f4a9ae8d6e44e7f777faac67b1778265a72bdb54b0773e20bcc127da97467bf39a759eb5e144bffe27d2d221b4ddded6de6d1d85ba45b2be1853816c7e81c74f440735afc090a1f5c6a739e2a1654657e28c076053b0f6b2cf84c923c5794c4fcaa66843ea0d99773995ed307a53d065edac86ea703b2b3fa4ade3385529ae1fd7a8a6828bf52cc3fb84777f03e4267b4d01681a8ca51449aeb0beb4ab49d5d087f50b9c25828bab48ed1303c33bed78fb1504b72e7352aeb2380233bed48d972601f144cd0c36d04b4a38869e68434c9da68854835ac77731e99cbe2ca1e2bd61c61de2197e779766e1906b2e0aaa32200ce906e6a4edefde4b09d2f269bf4efe2e961494d3e0bf6ea95769e759c9bc7f63d7d9ddb1853665f2a214203ae31d064f4eb8f41508d0d0dfb88a866a96ed5f06dd73a8d1e93bb653566e7bec6f3de3786de90e456260616f9e61f006775f2b7163869e81001ff9c629e24d73704207f64853073feb600a06200a3a1c54dd2aef2a466634ad974b550f2aa30c2f2bc9df1decbd79f63eb37acb4f72c17cfbeab232f7501a713b4378c54caa6b75018b85731880e0ff60c568730f41739338248132d6b631c65923a9c9a8939c5ad59ba0c17c8743508b1fa78760dd42babb961c3d787f5b3128b4e270e20997202723d8b3466639db9dae570266e0a9b548c9ed5659f20c40d401592b94ca7a43c05981df5b7823608533573114f1d4c3fea2ca7df9df5321f01f76d15c68e1e237e349cb4c0da33c1ca37a68c16874ec08fd524f45ba300a1b675026a27f9d9bd66126ba331ff4e466f79046750ef56bbd97c004ef08fb4932eaaed79f3024120910d091f6688dffd0f6c414680cf80de8f6f1654c6c9be30e809dc129fba79340ed6c423d50e144c24ecdba6a5082536f24a1a1a6a7162cbeb736b8f2f34fbcdf591e0aca7ae2b6a33907cf87faaf85016622bfbb4fc24cea6c4dfce2f1ae8e6423c282f4c87231c92c501b474d4094e1b0338ef752ee3a270feb95c4ed48d3830ee2844894a1f2142b85c9942e3442aabd43bf79150532024983bf4d265495c009834375fbbf351d367eb5fa6d64e24981db8b4979813ce14f6ab29d77f8055bd6025724501f2882484a4edde997a8cd1ccf660b6f5c78f3becd1270d2f70524966598af7bbcbb9189331947526d3d75ffd110f04ed342c1175a9e13ac0d78c4a3cfb3ee333395ebc0fd8c8d35dd97f3c21acb671f69c0d0abe4d472501796edc866db2747cf1fb74b90aea01f8b8197ad761090583f0fc001a0ed92d272f6714c9084c323fc4bd80f4063eedf5cb526a92337a4a2ad16b90887c407c49727d1553604db378eb27aa78a6a67777f264b4295cb4f01c6e3e623298e566b824b291138ff88bf7b93f15f7a5eb45cc902b67e387285b3faee438bcfd8dcbd0914bbe539965f54a08b5f8653338c0fdae6a82c29727c75acd2a1a6509a43d2eec756fa0baebaef61278d36bf96ff88a60eff422d44e10a4d7617d0caf5c6dc858b8a079de04b2733b004c67281a43f44b343a3871e2c1716cbe083404ee4acc221940b413b09f47982fb15c727b09f4d280c976a863c082741a5c81fbcb9bcf8ee969241c7f97fca08326d78487ea535488557f09a123d85fc8cb6c244ca1706f8c92a91de9264380c79d4c041f80b7c1beb23ed3829e95c83075c5d79306e59513faea05bb4c1c18e5172025360a9fc8f058174f68c69e86b84fdbe6e48a75582611dce7f0032d090046fc0385c3e01eaccc36dac5790528a6f1c373b7d99f5b987714c7c2bf15cfa421a89834e5f5318d4d98b52acc1528b23542227cfb2521be0d23e28f50d0b1e4c2c65afc9df700466278c941670eb16d14cc2ac6bf8e21aff245c0493d60fe161a70389f54a6f2c887f6c497a856f843c58cc27c5e343c2dbccc0309c47b0f5cb216be1f4bdda22b6a3b276b8fd15dc08adcda8dc2b4dc08c5bd770a815aa04e096df9823ecb43e1a1c6a502a734cbe26e6b7614d890b155dcfeae67a5ecec1ebbccc6b6e74aec066df247b324d569e2faac5afea918bdba899b16c9df5170f3846503e441b7402128e3c8f15a43902bbad24cd0e16b63afc159086e22797d860326169273aefe9a3d33a4c01382c270387a49e398af082daa3a76ca0c30ce21f003e0f60cff59649f2272d15192ca9a5cf54d3b2a0b78bc5d86e837c1a26dc825d36eda6e54bbfa757447b53f5dd76810b97e3506162f1813f74d96b6f3be3706768c0cae8f23dbe951415f69b0f6e47d9ab0a1e3a496144d0127de911d338ad6cf8028c3ac36283d19348279867b42d669a363b5af0fba3a5b848f9abc39b99b807ca28e233e17192cbfa93805c42137411b7095874af254774eab1d72e76b9cf41d480cc624e35ddff945a9d5b48d9755b19598e623f00813765368cdbd4ee437040816a1ad95d9be9b1e1f682a63ffcf62793f96228d879e0a20b57bd167fa7b50bb4c9b6e1bb3b74984690fa46a0f1633bfb04046c55f5165ce9c2667fc075b325dbace3d0a8e7b892471b5a37276b01f88fb88c0ca5eef651e5ed86fcbd51941a63bb57928fcfd0b989417ebad6747bd6ea61213cbff4a4a9b53f1eb7c38bea2662432150361dda1d798d77df8fa0dab03dfc6617cddcefc19caeaad41d7847a2dfe892280f2625ea1b7ac8ac54a9e5154385ddc23551d88dcc1dc67f272be860c378129162859474ea5176173158eb4fc957755c9d197eb7b0471e0077e7d43ff643f1757eedb6e732506e27423cdeb31e05dc8d6037642e7f58d02d3c2df55c26c7fa01c25003b9d04eda23d847ecb670a2a7a76e67050c55d5aefe8da5bcc737553da487854f88771c7aeb6f51ad328a6d51df3c06251fb937ccdecf2d47ae9e06ea2f496858481a36971df18f0dfb43ea663c08daaa5e782925279bb350af8af59d19beca90f66cc0b0185074d0d0a56768e80d6622c357b95f2948c02afee06b18ac10d58154d7cc71a01b5ecb54e59cbb36ca0a01c655bca9ca0c804635820924fa6ba4948b0febdd7cd763dadf46282ec4d2e979df95e11c15c158bd6954543b6fb9088ea84f751a328ab909b7cf04708425b48c4dcb05eca30a917f3cee2b6a156f0c9fe8bf5bd638be8f923a93c372228c2b2cde2d2dd12e35bf7a7f3425bf9fe0c983990eab2c6761d17acdceb94341b224a119090e4e376ac91b265c892491a3133fa9d2272db9f51a5a0a13c4bf69b706e561b2cf822453acdc4ee8f1614cad5275c4036a87301f38982f18680429da5d6a25951f6a3a11d1bc9584c6a801e7301ba1fefbc27384a535456b9bf6b07ed6d53c9176357d8bbfe0f64b9c61b00a6aabd9f113e2191a09abfc5824fdd43cd2805b5079b2c13ea404a02d788cabca376a8650a83047b8acb6d400f1fd8ca625d14c910306e40f65f5d163ee87a62a2e2d2a6eb215e18b4d09a3575fe9bffa3439287d6a160dded61bc6dd454d9fcb9c9ec017f33a963584f1dc3534d0c620b37fd7456c947a73e684bcc78a3c4db28b6267cc51e20a485fd0c8d1843e7095621e1d48e76d5310611298d3c6dae2cdb2fa803897c5198028819554f2014625b4da3c5f03a45e461c12a7380b11917ab22d74fd0944a98f772ed36416255e5e10d3213500aba1c605190b6fe30db0541f8d886188e97a0197775c321ca5915213d10e823d444935c67ef73cbdf897dfd33c5df8ffe3c149d6fd9a210f29ee286d51f16a25be7e7339dd198778e158e099ed47a7550ff9aa8ca04e0c9b80b33cc4157f1d05160dc915f821c7891c4ee3291078905d176bf844fc2c18338111897646a4011d37997d8cd4d0e8001d2b6f351c1d2be62d2c140c5f62b07c4ea6583fd06bfb21583967e47b77cd704bad06ccb9695fad8a072f4c55e1524a27dba9bdd26aa3ba00309cdebfb86c085188e8c3ae1cb98f980eaaadc1ccb90974ac38eb232cdf32fbd3147d3a28cddd86f96b02e5e7f1c0c14e8586c7afbc63d18aec5c1de0131dc7840a261fd87f602eb56cec108105de20241efbfe8bd82152667f43bd50782491b573b5a363d345aaf034e51f660e5763910c3417f7a25734084cd1089c71f0ffe04bfe1b015db635e6ac7d633c1e5b8fd1acc60bbd664c45537ad7e3243a7171b20f502d59a0b1cc32e61b87acf0450fa01e68d95c91bdea3ac694aeae8d69cb1465fcc3ca39ecfe6f07bcb19f7ac7362faef21aeaa2150ba4e575b340bd2571040747a859406018cd5e4231879e13e67190ecb8433725773013b7488662363fbb0caa9a3c64018aad1341d22f4322b73ae4bb3730a497cfbacc5330a524aa2f5bfbacef35645374c7a3e9082ecd188e0b11662a381396041d60d7e160165140c439ed5c0f39670dd5f32bf2438871870b0782b5c9475d038d7ce4b81c8a068f155131a7bb8f63179b90022fd280d99586b18cad0d3977220d2d819694a01c7dec991f84785cc5c468aee2e4180dac31862321dabaa108c29fd02aac91d024455f487987ec81cc00e342ee0e417b572b9a081c84eb836091db4858a256071c9baf4ad5d170d400a6ee48c23c2529930ca690890d02d30c0125d1c3c7eb527c1cea9da31de53787f01ea2d79903ec2721e7ab7039562b2dd6076c378d1f60b5e2a2f75c98d559d0807d78f9a242a1b9ab20f515febc1aecdbfef80a90f7e55aab753c3f9e325deca8da45a27c11545eccedb582ac4c7cd9daa9a6bce1fe7b2eb286183af0e37bd28fd6fb8ff448871d40e9891bfecc6d5e97572e6303b8217c10f15d1fa4eddf584b150a1e5d7ab3143e780d764a48f9fbf8a92ea664dc700ad00a4afd87d595079a4bd61e259bb165367fc87f30accea0c7af811245d94bd7d89c5b2aac802952602cd5be248833e9026baa7d590ce2290fefd37e3167b90da3d0a18b5ec0da348e2d2a8014e44ad6063fca0583c74cdeb6a9835e1fcb2c6d4372467585cd50be33829ffa3a52105b44e1fd39f1b51105af5c6c1174367fd626bc1c2b1c72f2e1ddcd947c069818fb9d6f901f881067f680a1a7db7455dd4f9152d7eb59e32ad687fcafa695c8952ec66981de37b3d4fae295ab81270f6ebcb345d39be9545f1e049007beb04f46170c9ca56607627df9043c2bb0bbb42b1f11d378c7005f59c44edaa4764808fc08b1c853b17c8d305d4bf2ca128cf2884ef39be327345928f90610451f90398d21e23fa14f66d2d508116b138e443c53408869f617dedf5b75999e06891d793dda77fadd45538b56793b38c12c02e8c9315368624ea0b4a828a1137905775e3627f6109e5754da6512b3f6ddfa400a5aff544276d077219118f3498cf9bf3048c4e9fc59f0ba09cecc9fb98142e3d613fca06764fc7d54de3e585c61b35dd5c0d8178a0b2453c65cb01eb45ca624008c48013791096112d0e16258069b1175bfc340f26bd7a55ee917e621657bc2e35249656dfc9b6f8ac55cff94fdccd1bab8dfca258649a0b0eb424d585a129a8f8b6cf14ffa3e33f649c99a2f865b65b4785293c3769ce8458f06881538b4b78452ba8d18fd3f49595f6c980d7b9d4bbfcd41eebb95d11f78711dc3c770ac8c8f9f7ac5c74814b772e3697bc77c5f5bb19a83a433239d7864fc6be6904083d1383b0df3dc08cc5763c1b48108c7fc44df80be5e776c1f153d86796379a54f21c8e0b5738ed620b42d4fbdfb08ebfbf1aaa7abd73e1ef2fe4d93522ac30f60d80337dd1b1ac9b871116cad8db6f84c029ad72915ceea92dc2f648817f66f81fbb8e988f3e966570e035bcf567f7c6bedacb859157180216e7aad5451b34072fc71c296f7deb31d7ffa0a423f5f9c2ae59d774f103b95f0376d6b41767ab5cf3f616bb129b959d550ab5d56804893cc2cc1ce2cbce47b99214f5e720841e217cfc0df8b7e26c50815a638390f8d42ce53103cdee5bbfdbb011025ec18d552c273bc848626d3ef67c8bf1e7194f67033df5d358fcb12ce5113b46d5832b134ea1565c3d5a542c482195a06a952c6a6bb75591efce0c549a7b1fe48ea9c17a527f99453a16f728ce8eea254dc9830c9eb88c41d238b728a2bceb33dc40405f4a851280d34f775b36f39d3838583d306a5492b87246d2cb42b679f8cfc28c1f100eaa60ee202421736f164cff2fe2bb51795c79776b20e6e93b5c91b25128742c57c841d59fcfe30488c7b448bc0d2b4851069d2ab973461c79fc4333e73cfc549ecaa98cd949746d8f9f3de9a3b84014b0287c5d1394b6c9f995872d51b8cccd2c64f2559ae3e6f0c81bacd66e6586ec9daa8a66922697d22dee27000ae91ef91a74502e4b9d03ea08741095cb9088b2015b2dbd9ec4e84a63a83bcb7de1b364bc2442b58969684c26637e3de419ec232866e7a6610e01545a58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
