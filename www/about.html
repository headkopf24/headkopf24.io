<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e6ca3cda1c0537f0e98ac41b283439823edfe21c1a70314252c3cf5b4106cb7b5f1f47ad38b3b62d6983fdf25f6319c6ff166c42bde211d1f8d9f8578adb4ebc8f187d3f7773e5dd818da665997aa2a6cd3076dd93f7056588119d5763ae9eeecee2093b0197e57de73b3ed0bc0526b3d0931ceca0bf143c663e753a5a3d650a0593183fdf828ffe4aed1ba24e9140235bf1dae267c75e723cba01f419784c7876b4539d77705f5df897fc92b661ab660cfde83b3e93b171fdf375e22d4f3404e5cf30128d8633c8ecd49d74470ec136ee5ba0ac6fca6d6d5330442e93547adf1dfc4c33b49e9820359ee9e3aca6524d00863d923877522a0e53924fc17a976e5093f176635fb76b589e5e97a319872d85fb6286bd33a0205275bdec529156793735b04ed857280344331b03f81ae4935af87b55af52b3e9557d5cfce6d5e82bf0105d81561234317f5e2fae164117dcc3cc9d3116bee2ef0b3b05a3c817a60b07766241b785a541115ec692443b7bf77256ff31fa212a0d79a9e514542bd495644a82a95a39a48a299c3a6396318a1ed57a694daa22e39cec5065f96fd8d956510544a8852637760db5b6d5311dc84654bf8022743dbb79a9bd0df72b0ffad09e4d9be9f5a30b5d25aae322191d1859b010ced9bd32d00f8bcac14b9b82ba631b622ddb3fc29784211e1d38addb7cadbec220b9edd45487576dc071a6b0bcdcb2f5f7430196b39dec1e22e62ccab1b154ec84c7668c513f28bd848dd654dc13be61f407a2d7ba626201b2bd85451f61f9363c48b0fb7c5a3fcde7875a8d826d6eae3d7b4ffb0c836560316d53982d19a0874f5962e1037db452dd2d20a1e0e3b59d3aeaf9f9121601cc13b96ce0fd2f49105f5f84c39203ac3ad27e860ed341fc09d3ff2333dc8d6dea009aa7e3ba1f5224b5b2546e823318279d3db29ad05c4bbc2bd18c5776a2ad9a00e3877ecabc8884d956dde927dbaa0b6fece5d65f7002d9154a644c967da0569ce178e4249a4dec29d72d9e7a8e33c5f6e76cde6e278d586076b3ec264804253d99d1bfdd3da7f5b3c2f35363a4240adde58c7f10839ba3f2b6ad98990e849677b752effb79eadb1fd28ba1dd576f5ac656f4f6eb37bb650553d74c68076c9807406f41feabc50a1956961c348ff071ac714c04bcdccb44d388f81b145f68fd9edd650c25b7d911f8a6bd4e28045bab3238add99ca16a152f746f272981cf0cec5868dae2c5d6ee7d662cc2c26f92a65c8141ede178251e20d29cd4eaeca4f8f26ac5be92e036f5a75210761c41e9ca93136b4ed0f16c0a254a04734da0efc13e2b0ae2da8d6de2743643dd6e75ae737d166cc5d30143e17b94b11babf18839f6f263fbdd4e6140de0ad30cbbd873ddbfdddb014829a81c28e1376a6f4165896bd5499506ad625832a62be19f3b26bd04874fceeda9e45ad86e85902f7934a0b11d775d1aad5d668a5b3dfaae9ff5a8ca4888c96c9517145d6c9e0c29dc3e4d936cc1c4d62920057e27e9afdb0ea51e16af19241f5bc9b32e1af0e6ad675c8497af775001537734291fe96b18fb498742b8d139fc0492e5c0b80d54a27c75fc948e3f14b4be81e11fc04be9d6ea7d5b0adb890330c11bf94c6416c92cbd5cdeb75674994e5b839054de181e8a1d03aec760b0bc101784fa2d98454ede3199e287656fc39e649d59446c999bcd1ee0763de22431d3ccce0e90fccb6cfda00ba0b7907ac2b617f3ea0c07c9f25c77e5b6606944af59fd9d72b6b4649f2a7c6182a874736f22de8c4f7dab1e51dcd2d67dc2affde81ac84dd175bca613c0a99cd2592fe192d4b954f6bfd84cb0f26baea8eec3ff31e740ad39614e5238ca1c58228a48642ef2bf30ce533f5d229fc91ff82197c0c81ed838d6fe683bac3bc0d40bffb66e1a396fd321e7febb631958f1dcd3961323b3cec48e6c88078e58dcdd85f32843a44cb7740202c38ec449965728a978db40071f7e90f903a2ce9850dd79a8d4ff5abb79b600c1301d33864e46013e11825a37f4ad6519539485036eafe5eca7b3a5274b6d385944e35c427fcdf81efd3f43487f81a66f5a4cda9a2f490216487894abe92697b5ad387c682666a3b980361a7de10a18126691b2a861b816eaf721cfec7cf786070757092a136ffa1f0d61a196f255b7372e6a479ab4303619e593963b05f07bca4f8830b71724746143ae9a83c0dd0330a4baa515cb60a7eca5490da3e10c0b5477a133ef3d97f13e814a553bc2ea4c485c16f1ccc0fd9ff75137db73ceb845b9a5ca3ffaac763b37a42adf5ed553bd81e88a85cc069cbcf540fa54b4cdca0ff61cc4318c41ce3105eec653c08cbc03ff8229df3dc033e4741af5c8a59d719cb7e5e88a788062c609a71602c484fca76ca6ecfac5b82884233df66f8ab3c069f674bf5a4e18df858a711772674c017840b7163fd46051f19ec571b6dca8e98eb2ba49e7775c60c298f82aadb90a670508d6672a2fd1f9cca2864c03d40bce5dcab62443e14b2d9e13702b39552bf1b286a52f54f96aea86f66d2e5c1786d119b237e161b9332a988c28c553d5da7203002f2e0177debe07c2db475020737cf247742a55d57e400764d448ce98368e8c56cf0081ed88371adfdeb11fd05c0495a888f8fb5b12763bf43a1677106da6ebcd3062f96cc2d0a1a24826f0856169aaccef7d1db00b2af5772cc2b010b5d991f341b375d8f0239500c7bc4c63680cbee5c296d6fe172efc73be6e960e01ce814407bfb26b8272f3a38c7b3d0caa2375c64b754d9cde2948cb0a1be410f02a3deee1b04c673ae9ff616c1333c747f9d67f16e434350e80e793828768fda87b7e9d32fb5a4325b6fe5c083d5dbfdc39656414b7a4a43c752386966bf385f77db990a2810107562bb74672b127ca674e531a5e2f85436af9d5131e556eef1cd3c247f8bfb634f1bae8761149d3599801d1b1dab3d2dd2b24a37e63d3fa69531c51e924c5ed6425c8c9bf827f52b2f2db07a73b37ea28a64e9c937b9ff08fc0e1ccc701a7ef9577d0d83b607e5a3f1879cb29c812218b4b59706c8a32f0295f013aed39442efee4f7d1e7921e1ba308658519fe3bf53ecc2ee41ff1e83a5c2159cacca27314abba31861cf5a3331a3c0232920786a2e35c2749e1554bfc7ede00aa237fb1b002ddfa5a73573744c53dbdc4645d9febae60f61dd85ae1a130bb5a4afba07fbf0cd811d3b5b4d3660fa631cf72ff6da6754b0b96e8289e572ff6397edefb55e2618da1929ef1cdf15332b0548e4ee861133f853a63c9bd77c2a16d62edbedaac8511cda383690f3298a34854736e6fd4d41d65feb9dbcc89ed084a27f1ca56c733f08c4d932e327972b7869e3438ee2431abe9616359df5cacd52ee3293e931e014fd4316bf2da53d737bb069a6ec1d6fc89923708bd82b3543a8d8f9ed935083d7493537cdd1e9af61389b9b204ef98a0f278a9a248b7a96c4efe0848c6dd22d516531b4bb4418963cb5ab243bb60b82b63362b169411c5cab77eaa6b67b00827aada413aa32b70a4fa238ca4c66870d4bac86c099e196add4f1d61a639c13dff7fbb31f0c42d8c0d346382bdc142931c05cf9dcfa78705d2e8f9f835a19c3b7002213bf076af163f58a414c1541e6f17525c6f5537bfdd4a236ff8529058fc541dd8c2808fc5a02b477f1fec92c919fb34a81179840af4708563e44186fe94ffb2fc56ac52355825a1a98a111bc36b756d94cfd8d9a6c26064af2616a252552557d735b28fa7665800c58e172feb0ded85b930c8266bfe7f43effbd80095afd23ff2145716dfcd2b63a574eb96fc870c45cc86c9cd9be58dacc11fc916b0f47879e7aa23ab81ae4f49a76624526c0aaa02608b21de61488bf6a6527acc8ea305a8b3584c4bf3b3b89a7fc95cde91614943e06c3e0220e95ec31032089c8dbbdf077e26cfa18be5dfa588d6040f9433cb454df773d29ee543d9e81b22b066d616012ca523bf48e8c207c3392d596ffd5ad64d12b27db551320648eb9fcd7cbe185eb7077057a4146d1cb53f76b65c55aa6b7d51c26c280da25160c940c9b25ecb13ddd7ae8846518051ab0238059c6627b79c5cc2b94a4f1fe409814c61722b0644a16279ae3baa9ef26a93b2a399112cd806f53fd95ee17d46af3cdaa693d9fa2ffc2f7b795e889f709e5a6dcb6049614e08db0246e5a748d13203d0fd45e9ac1c0e07b132fec51699fdff2855df62dea51517dc4d4cf03eeeb55f6ef2701fcaa1360749a9a4d3545912f237546d0a058df4ada1841e8ca33689bad3ed592f234e3b0eea56075905dd0446f676aa8f4533f83d0ad7e05a0ead231b4bb69d274a82810a3bea69807ceda8a12f2aa70ed3f5e60ff77f637f750e223aef8d7fbaea782e313a8a81d3344bc397a05264d60a52ff20731eb7b09747ddf1c4e27e9187af2cb94b695f3964594535d434c17e020e510457de034562af34a88835e2bb15902b863102e2fe68e87624b32f857a56e94640e3994408f29d661b5b8424a7dfd586365595dda750e11a99f8a4efc2f59ca41fb0966f5f9adcdac8eca8c42bd1abb81f94fc3ac4d58cc8d2fc53a5dd43c8cdd5c4cdfff9b5130a5e89ca3136d06198f31b4ce3471da57da111b3adedc91c3b32535b0e89dc63ccaa5cbbdde7f13d7c9a5a870c7b3a1294e14ff880185927a63cde7a8ba11802cce0cde8e17ecbe0656fdccca42408b7cdac95b43bc4e241c26cd3065c5234b777122024f374c86636a2ac8350ac7ab009e52cfe444dcd7e4e7bc24aed0b74d78464ff1ff43d6891a2a56a6176059c442080a3f8cc171e53ff28d5f8cff3cf6474137e09ba7c6245c56a5c7c5f6e2bde695d34ac7ea8e9cfb9a8455f35fb2e193051d2b4ded23cce2bbf4132cc9d255e6ede94fa94b1c37102f9d628ae2e517f88202b329fbc554dea0eb2235781347a6776d00bc85e0ef95988cef6e207d614b39c87c3f5cc2a872fb9c7cd8b7bc787a0d92d8126237266ab87a0ccaf18ab854a4cde2a93920cc17baa47de86faea116ef2bc4712eb1115e22ecc67ee8140a2a4244fcaccbe851d1e80d52c99b0ff979a7b395ccf21a0bd1aa21e120afdb1ea55a7f4c5dafcdc77065f2631f94145417f165c2580e7cda241412c70efa09dcdc6e5f6098f7cb2d5315bb85e8e636e591bc4e40e620b00d8e327e471be751151a1fd492f436617c73ca2e671c5f9edd81057644c793edba079b2e6c08304530489d4a1433a2c54829f92c68f57e6903dfe2b85dbe4637ee52633baa1af7628b645fc7a5b5b57adb49cf81bda134389c762eb98a053b9bda19d8a07f901bc5204da45dcfc48f4fb5217f60fbfb5f9c7cb252ca6a0cdd7489e4aa94e000e6e5a63eac973e627ba1f2998bb2cf0c7e9b9a5ba2d5f1347239b681e860c5c13d398453aeb2a2273a30a372a996e31f389c2dfcff9e1499a627948e576d8e4ff651dd9975f1ef035ea1d0c0d3adf9ac9c8024a460f33fe2ffbd1e1a54be18325f1c0ab01cc015a9ee2a27d17dbe8713487bfa3cc02e40f8e6bfb59103e1a465f3d325ae20faaa405f7949e14a64064bdb0b21309efd9508554da5fd034666e84c6ecf61249c9ab8512b68245d377d8ce3cbee4ad03724ef4258c0943ef4ee4987f033e6dc0fd045f095377c6be4afdb62c7d08d966bcc23d5c241f39bc965fa6236cb8e219f68b43b08b8e84e5b8937ef890bdde0dc73b7cf8f752d4c67029cab62f87941b8779d1d3f6dc5ea8e904a706da2c4adb21f47879304f8ab7668645aa2c98478d65a06b28fd9d049a8099bf03467c3693756ac65a8a2963d515df92b2fb5c540d8ac5b16d90f1a8623ea113ca8cc95ea518b4a51189b5ceccdaea9533a5d46965234085ee4a3ca044d808f48d40de738e6cecda2e81c67e31070aeacaafa55e1a194d237d3319fd7a9d46165a2d09eaecebcbe393fe834a93458d6b8fab161e6489c4cd4b2744d77eea957872a3b481366fa0dc5a8618b2713d3672978f1b3b96a24593fa9766d6731633d618e9c8839c635ada6324952c085a573806fc07ed4322e0715d0d7828fb16343c36fc9a31fe20240d2f9bf1874b5cfffefd0a6af0c01dbc3e0f9141ff0a9da516c43437e2336222868f76112b497031d11785de27fd10f54b2ff1bfa220d5e96d58af172b301dfb5bfd01d5b17d28ee4f6ddf5dd086c07873792b370e2b4bf3d6f965fc2e6760b74eb7783d29284df4b3ab5fe9b9d535f7b6462cf1fe1a5ca0b3ad1853e82408b0cda0d62052e7345e93e6bd4eb7f7e6e8e4b0d4521f9e26325ddc8fbb5fb3d514d49834aa81a4ccfa2730cbc74702df0f5d7d96a44e760149d7cc81c12b07a308df990a38b365ffb5bb7ea4add0e9bf92f570663688ed4b95766a8c29fa851b410582074f5a6047b09d60981be2056bb29a5d49181632ba00dc0f5339ee92fd2cc4bd8653b07f077f9f627533b7300d2604aac2b2922bd2fa5fe321789b83b825a62a5fc07a5eaa9cffab0c474572a3ed0be815655b6e95648b56d2c1bf78352775456ba272bd517181f39588d0ac4ce9b615c41edd30e4566ccad30907afda52678f22f8c708d397ebd628b943d9070539508cfa229bb4dca4601d9295577ec058427fccbd114f2e4ddf71c8034d690f45651abcdfe5b3520eb70fd4ac455c561ca71b57c8144ada67cc6c00d959b5527736061cd3be1187877ed4fb7508194cdc1e5fd23632ddd5c4aba8cfd95fa2bbe17885bcb380602589f36de802a011908f8b3d6b356f456f57c822a45bc7d9e5a25d4eebc6a2b6841b23c08f4b95e464f6794b7f6b1bab0884530680a80b0985b0275e1a58158b10ee54c91dac050d6a580a74730ec7e0be341d5dc0b4c78d1cc36833c26db63ce969e3b108084b81ce20f85cd2c3aa79dbd59160c0a30cea642f99f38b98aa4351585ce0506a0d2a6c504c34fa5cc20be671d9bfe91206eb5bf73c1a14ae8f1c17d721ea7078c47ba91b94c3b23584e890f0a72c74ae2cd08d801f53c46e4c5048ac61ff0c16e24c08a6f87498d8bb99d4698f4182786cd73840a4bf20e6083b62f461d56a7af7d7752469da72403062080556d3c89af0a6b411e758e398569e790b43181f722ffea030edc02c324eb37ce155cf7e161bf1cb32bd91cda7288a89862317c621e14f14b9b7c4567f68cb4d5be939383cfb413cbad5c5a6b7854496c8a511e58d652f4ff39ffffef85353ff55dd061907defac6dfbafab523d48b31a74b4948fea2ae1a995629e3ca00945aa09f5c09e0821dd4ab26c3154611f2aa7e0ce86ce691d9956d51edfd211daf2ece463ddc2039c7df2ad2ce06ade5f0fbe4d04f996a33816e7a55b37aa039e0e078d9aa550fe23336efdbbb19ff6e0bacb1acc9332af4744d8b2d866182c686083789e0e83e404d8b16e590ede7683fd61dc17977988e16473b932681ccef27040260711d38c1b7fd591e65398f52bf36e47582b01ae34334801d1e4935b58e87b4dd8612599082d1dad7ee2d3c7a51d29c37894b22084a5a915458530d016b9cc455edb564b384c161ac8133994fceea8d763369ed61458e3cca31c66520fd5d41583b5f1d63f5fa5faa9928659a05377e03fea07586241075407cacd9dcabc21b408507858335dff27cb1a9fee7989ecea5a811d3507489278719bd626cb3bb2aaaa8797ec16366ff774cfe4132ef4496aba161f430de40f52198d080a1dcfc64ec4b7dc6f6098094e790b5bd08c4e6faf22ab4b15e87ca5fe24a61fd2683a9ce68eaaff4bba993d7df92e52d8916337956b3f3b8e737e9f857fd47eafea88ae0e3424769d5f22c9996eca0b56c98c1917d0213a3efc96c723bfbb2e5af6cb960fb1d6993873d1c2a10bac7501233f90e6c15dac1e9b5635744a5c48d4834fc008cb86e7579ad1ee4cdcdb44971ead7455943b3f1e8393aff8249b38f8db5e9012b7ef4ca7f9e1254c64d6d2aaeefc61eae9970637d484e8be7b18c3eaed540b77ada8f9aa4d688bace18e539aef9bd890e82d2fe2e835537379a0c8f3a8d8f8a431c607f15187d45ae78d325dabd06f7a069bee0027e316a497c07569110fd312456fe0c6051cf4f953b6d19bebf359cb4403abdbad48ec00e78954c3e92ffcb9cb438acd502ab59b87c0583a4a65f14947c43273d8fdcac379ac4e1ba8d56635f3b837ff4633fa624e177b384f536f6c2630337d7e451c755cade5b16942c649e4a3a85423c7d0bd8e363b0328d560368aea7e74b3e28b29fc492687f71a026de6098e6618afe15039cc4c93c6dd8e6bf22f2d0c337647679a02b58b246af5771f138ca2765e740fe0f9f7336dcb0fbbb149a505828cb84aa3196e5475e4e0dc1bb71bcd752072be6060c23d73931d01a58263266a6aa8e0a46a4ecf643e7f0b01f37e6b0bc245721b7482f35fc7133d2efa8c1484a0682ec98b910e153d7e2444864181468438d533c714c160f0c1cd0768bf91b5ac287841214bf74c6b6cb18f8354bcfc3c1e24da1f0211b6a0f800d05ae5ebdfd82ffae9194dbfe3a3c72c36d2692c8aa808eebfe49df38e45d3a0fb5872a97087068d0c0eee3bab878f77566285d1f62d0f185ecc332c4a104b24e3e6db6f7e8ed4ef0082248a118beba79b8819adda419680a4f1e573e331796411599182f901f05a8df90646a01264b165e07c178b58d998904f722b2304a4e34f19707bdc119159200d4d47539f3891f484003d95f85cac9c431eeb48b833f7a71cdbc7a1d7fcc778c9faaba2e32c76581626f49c1a953ba13b5efc13a9af95a0f9d8dfe6ef8c444864c996b76afb9430b6480e5c0096d08fcfd91ef94e96f403e3d29798214fd6fd86693b108f0d7deb722d0d5f73fcd2d077b5bba433de4f78fcd2f4972774be0646129519669d8c4f12","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
