<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bdd9a60800001fa1a053f59915130e49de523749f2363cb9bc7730714d47248114d0d5082e307f2d3632c5cb35d6b70122efa6c5878cc55a179925457dbf19d934cffc4c887446dbfdf5f9afe1a0c710284d720a7214f42022fd1801565d39591362bd1af2362c069949821b1ef79e4ca684b369c26e0eb29bf6f1a54f56fe4c8130fc1d876e898befca58eaec8763fedde9047a9d5254650ce6a9a8706e288488a58288b6dbf3cc7e1306656a073d6f76f7d70137c4fffc44e90d5963b85b1839f20b0745c120b18dc82263d92ab7da45000089fc21ad83de04c9b8687fe641eebc1b8ffe2362782c6563c9cb2e64b588630be9475bee947536e69c1c5d6a168a02336bd2ff9e69b9f8a21b56f70f5fe09405afc19675ba951933b3379265d951c0519677e4cda46511a254e6f878de7faff9ab0e9ad00d43c96bffc8c742415347f0d698513a65ebfd2bf5d55fb0f4705ddaf3f93926e4a690df86fa4aefa3047c679d91576a095450c1e28b1f35b9358d5ba23593acc5721a7038f298800a0c439993f5708c2a3fd1e477253605566bf093baf7aed89673aaa54a8265e74899e5a3c1a98b829eb6fae64aa3ab3c09ef83cbb8822b6996bf80a6bc594c3f596e7a0496c1c7c6532fa9bc1a79e0bc6ce67f6fcaeef5e6a70cc2d160aee9bd3a8c052738cb36f07cd4a0b32a67df459d3223688d25e3be1e691267c53a298d8e1a919c8a9538e2e4eb3e7967bbe69150ec015d1bc99dafc9b4c0d6c3da8f726e284c702a6a53619ae7442d1dad410dee5b44c49d8101727c2a7f16cfbf1bf749f047132cca26db31700aa2006691eff90a4d1aca5a3baf0b6c603b9c3aa88712ec0956a75708635116c5e54e885b714ee338fec29401199456e9c877e2e39899340813fdd88ef2f49b0c46c9bb0602b17eca9751f094ec51cfdb3203d70bfef9ccdb3efa85193755072c9f4f5ccedabd1fc9db768037bcb7630e428fd1eb82dbe28935e0839bcd9be1d2822eec41ca0bd9037826bb83858b106af9af33ba4a3c0d0f50f4def0cd9ee58a3848cb0a275b3cbaa07e6c5bf732233d8ae333fe20edfd8af8e76daaad9780d3684dd7bbc63f1048b5d2c17ce4a5ab43d0346932105f72b010c2fdfa04e919fc77116671fa06565e26b386ba4b8bd2563bb6d456c960035d0ba31d910db016fe4d00931ba5272c660dfe84d4f6c5d3d268719965d95eb5e8b1e604cd2dede94806d58fcdbd66c3a96ce3501648efdfc800713365aba15260ac1955670c65458d3068cb7021227eb953a4dfb396728c54eb8fef0a7d2a435e3a63b6da0de7b3407094f7887142cdccf4b75b951ebd87d645083a9e407ea1b6e3f6690a2c259f29ec080e329471bff6ee258ae04a29011821afaeac593862bf2ba8996a0c53a03f3fa32366fbad5e8a6ee105ad80056e5658b904dc1168f7ad36b47a135d12eccce24b1b99e21cd906b3876c64ee5329f7955f46af2f5d09a1cbac663e01d12e903eda33aebd7f1bafce34f9a29de65333e520a6e3c0cf85480f9d13ccebef6e847adf6dfa732986ebd1d93ed7979707709cfc8d86ea1fa1fdfb3aa2a5b0f3d3ec75a9750e86634632ac00b437152490da951785a3cec2fc4191f8df9022fc3f7cffd03cfa20c0624700b617774d740c547e8fe102c4fdffe5f5475e753123729534f4d6fca7482340012fd8b418f4394898c62e716e5cdf22548e3904a2eb79e96761ec365069805538ab3666d9f5f58cd9426a701a07e82ab818e530224cdf43b1ac4739026f062f507442b3405239971d8d497d3a8b53a08ebf8a6c2f394bb426c65cc449f0002180e86a7c30137b359cfc2ab486dd28c0e0010735061974e289f7c1014257afd6af3b45b450b59ffa56de0c92d77216948c6d5ec04f67d9d9e55dda90ba5157de366a0ae4c9995c79605fb7d1af95842c80238e446868ddd68d2cd8027572693a46af85d525e3265d1421b921b00d8705afbfc0307a52465d36ed015d54087386c9dec2a37c2997ceb60c9815c511d3a21af2515ff1d2f2180826169c5f932529e985812d1a547623ffcb0999b01202cab5c55bbdb00f7a91595902fcc01a866481ca14db3fbbbb3ba87ed88da22c8b0be3157f0225c6ec67417d15463f78860c5de06234877d03b70a2843226453f4fdfff89e0c90a3bf612ba48707f4fada92c1c4f0e008a38896e86ca463f5c4504a7101c6a8fe0e7c01f50713f188444b8a1f4261d2f0b5b88b8efa17e211619cd3fb95afd963318b2da06d231db36a9fe2de9ec397fb7f1c2a8977b7241d504c5256e39cb2f1b86a95815daaacf2736d2c7b98d48b087fe3a9f0841715c2fcc37ab71a7e5ef72a59f3ff9b05083c9e079c22de9f0a5e31adb0313ade8b5db4ff23daf3e417e483d8f6cfdb447c5656779747a58824b8d08198b2ae91fb0337164097641898586a85e54dac6d1f053bb2360d4298e020b9e8cdfd71a45f8acda2fee964bc43a9ab99bc6a30d2567d717fbbf68bd2bb83bc8bf9100e04da9131db8f738396664537c4c254cc44354324cf3842cc2bf1dc1a0e83c3f0d164ae3c386e7e9083ec7db51b32693537d48e29a59966b8a60e8dccbd324ad232c04a8da5b26b2e2af9965ff8d5175c3f36c2369667bc1639b2651864f0350232a16162f17bcd1c120cfdd6d73fef6eb527f0bc599eb7b48c9a272ec048554ea034dfebf9e4d3c4594965dabb36afe4c31a78214b4c59ec6fbd55eb6375220216b423375dc2f3040b05b4bb61715a501155d021b2fd816d4dcd7a77b2b2323fe6efb8030a44889cb43405cd2f79a2c7f41ee9f7ba9d226e14a9b8a6f7cbcfd1dd3eca6828958b1091c1e3dd6ba400f5e5771c76276437015a91d8019b27452ecb235817ade312d07ed86f9b40ab0c96a2c971d00f40400f2042fd884847a12d7113d712da93ba84c8044d6398aac64995299a11e7e5febf0015ff5ab3749759642177b60bd94ae382f78a0e16bfc7aee000e171402cdef2c454e1365131afbd1ca5dfb96262354a4eb0f6879e88d8844335c303db64139bc52c060e2dca2bb22f0d536ca6bc158edf670bc8531e5538c8e259732b7a06274ce9473394ae504cecb30969b706151acaa7e9d51f6d63b9334f1f59c2bf032517d19db5697e81d75a9bb5ab65afd949083874bb5019141f1f7cd0a75fe3fff1f7f13ad6dbf7fdf78b21f100f47dd67453912c788622c4f826529caa14c8e7a3a4f8b7cfd65a8f4f37d42304ca805729ef03ecd5f993ad1075fca03adce7413951fe5c76f3bac4ecd3071f6ed2fd4ccc1493eb401036236704356840e7741ec251d0141e0544a6d1f127d3f2c88350f95a87f5e82b444af45bec236f96a9c34922f0ab394a017ed3a00388f64556104a8ebaf7bb2f56e614f17f23817a075794d6ae32a035e72569f6393a11277074479aafd469b5ad0bae632ae107745a91ff170950d987ba13f00aacd036a0bb475d2d079454fffe4de22a965dcb98821b712ff182a0e164355e0ed1d8a993ce7f2fe1aaa511ee31c6b2e67640da653c3ad5c5f95b6d2f519fccadf617c5bb113b2ca47bd35363c59cc21ce5736ca73e26ae79b97e06e17c9afc5d575d2927a77accb8322ced890ef9ce9f77cf9fa8c30e8d22965aeebd93962c2eeb4573dd76dd1a1115c8ec3f776122cc2e6a1255bbcf48aef896a6b4061370c39b97144dcf7865169a1094c7d472984b9ff31c0435e8feaa8cf803442082dc2ce5dc02f88618cad1face92740b1728d4f3513b0231b5852f0db0347be7895d1f58f86572103a809322ee88a55dcb1a0f91f2b8bddfd30a7736cff6f16f38d46fe03f9a16ab6fc42b652de6797d5b41f4b84789e7999d9e4454738412c2c2d0b6a708a1e251439717749946a63c99f64b56161fba064b3a86676e0c4b0fb5a8771f51ce903e39bd12a485c1719bdd629335d3ad5aa55591dbafed47e75f3ba2fedbd5e3dd3756d1665acf5c3a82feda6a737a4abf2c91d6ce89ecc7361626e5c7b5a5d64a46fef276bb455446f015d8f816d1231c5b77b56d00d963f60b8c9e9550c6414bc1226a49394ee83cd013fc1bf66c8f8bd2a2a620c50760b258e92c3b7a8966059b0893432cd7633131b113e0af8faa6db47609ee33583a64de7f1deeb56737145fcf46d3f6f479f9abb14385b46bb544d3c75773896fe0eb1fa1c0f644da0cdcbc845321e7e9f49ee3e0762177b43e2c129a894b60c60a5d2e11cf810f6ef59090ced27f8ba4536368a96ae34f666de981f56647820a26ecbd65f3fb460712e868ca0b60854d9972db6dd106132f219179d70d01d574d04869b02256831bd87c0b3a85ea531b98c5c6248d18a78624fc3a53bdb685b57c2bb91f5dc61ef1dbd7d4d2f1a3032b695608d4634e691f73df09e94d266a04f13cfcf20df3b1af3d4b2d7f6c22315486f24fced0144f3fe0dd528fc25a92b39baf5338e9f9d93176ed787c456e1b8f07060238a650136dced74f361b27ba97e251d402aba2153e29642648722fd6e836b94a47aceca66fd18909f99e146195d3abb2504e0d2449182b96f161f188fb649f699e1bf127e7c3a71b54f0936aa253de85fd0d9394f2c8c480e620d49b0b91184bd177e1caaf7097b557dc56da870178473a74b7e464bb6525340071400ee65e7dd20e27c06693bf558eb8cedc5bbe7068f5b97329f5fca07c6f3b65185c013e45c12c30e705f6dc4a1610c450e689935b748cbfd21d2ba2ef8727873af70a7bc8283cc7085415372bb31117f98775ea742435a6df491ab934c306c1973b8fc34ccae92e2c9675680cb6c19120e2aba418ad997220111de0ed5729ee3a25a84a9f2b90adf52bbb263b26a0e9a870a91354e76fa9bca708de26eb329e8b78ef0602324659ca3ec60004fc955444cf4a04e378748d697e3bbd4fd9011f8c8abb93672d4560d2fc790b7529ce268db6a3aed009dbe707e9cf1a3bd97de021b724714652d4ad122cd7555ea1c7646d7e2626727bdbf8b5123b09dde10213ade0680af1a1e65e8b914674d51557c7ac883d362dba1f03641a1d76c93d200bd5b06ed45fa9fcc214ef58a4d626d7ca6d7e8e6963cb416debcab2b5377d32821bcea377e48419de25addd2e3157a644d3d8d742a593c742c27de6a375356c3d1b1d11fd4c91679f64048e8a6dd1e8f36ed212d6ca3e19145d4dfabfd458b9be516b8c84a216eb56d7f7ffad23ab00a34881bc670f97a110b94c5a7fe53429e5e0d2bd70444bb3777a526eb5a8ba0d593bf5facabc12b4892608547e64e5f038e3abc37f7925d91d3a0150b124b15afbd592f56d9ac22b59519b7e52e419d946c204855d0386c793446e3408461f81359dad2538f8648a2f21d927366d3c9ab7043099e2a9ce4e82bed41befe901266a246a9d0174bc24c0a625c8b54ceb605b728308858ff923d952ab3da0c8cf0e2b0416acbc89c0af329a0353ff5717c50505bd9e0cfdd557a372c098ed6fc78ad79e2a4d38c43cec76d59a4f68c6d745d0a687ec8bff6ace3aedf3d54b49ce74ca6e9af3a090524a6a9126eaef05d3ebf5ff7104e7c0f61f7aeff39a16884aad17255b30781763c74dc22d0d0eeafab3194a09773a0650d5fb45c80659f2087df034e42b6bdf242cb228503542e92bceddbe684b8c1e153abac0a1532b7794dbfeee36a29e7e244d45b325305bb447b39ebf9defc0170a7241bff509a9455fe5b85000f769adfe9315fc78ebcc35babd58ee204544ecd2191e000b6ae734448b8616de5637660bceb1e9a9df681ca882ee0910560a54d108c7a23fcb6a05213acb17a40e8aa565d260f10e787816e3b2ff66dbd340063ce3211c9938efc0fbeb41179aad9865502de8dd888fe19e27c22bc7bb270375bd475a47ec61e629700ecb4bb3abfa070097887652d4b57b58c86d85929e1b034400161eaa714097f285da45a812dfa28a43f47133087bd9f95a28fb56f478e098b93ccac7cbd335da02828c68307b59f9d9d9ab9d2ad4aa95df4a888c734dc84683b53c8d0c63f7207b1d17ff5ef646ed268ab7ec80efa0f590d9bde589dd14ab0a27ec090381bf7f3aab7af6cd1632a19ad1608e315a85abb5e84f5d10e2c5042a28404898bfe444fc5c96bd9450640926e3614e3dca6f9c6d882e74e4e6edaf2263df10e375d2e9a4d8a6e41006798c5a3f970b13eda2485b8e68dfc5ff9985ace21dd58f368b09e4cf2403cf8c5182a693dd7d89efcae984b476c334ddf1d99e43ba854c3458b8c7a3d3cfbb46d9502a3210a93033f625f7511253383704da2a67db772e3bb72e46eabecc9efa15207dbaeed919198e478c5d25ab2dcfb6caaca9d95da1d2c76c1076565cdb961b18e7de8932efce25dbbf198695c85490f1886b9fe65b9a45f514e78f2a6b437c4b32167cb43cc902575886a841ba55ca12280cd66cf0edc1df4390a9569b556a7e9a387c6c25fb3ade4c98cbc2905be40b614719215d1938e2b36dcafacf73d1b4fa1fac2c353737e211f67450a377592414c0b535c848914796abe7eda338b3e701782a2e5d4d4e0dc651cc22fac2794c07189b1064bc44e44552a1d19d12c23778cc9e4dab70e98c88a3207b4997b7947cfcfc54969c8ba9b3f89e327339598b14b0e1f197c0a26018772c239e69d01942aa4890a9b36bcffd101f7e490e3e17b3886491eb20c0040e0bec6e022135a5566386975ee5edd8c928638500b0e67c479b7effacfc5a5b37d7f4974ddcd02f208a34f87d664a90d0bae268ae2674b5ef4282fd7ce33947ead6f3035f3c9a99cea37268280d1c404fa4e8aaa9dc0e082acacccfa789bef8fead3b48595740b90a0048f86f8b8cfe277f9ec9d310ffea448c56e4179b373b525b5506066d4c5e0cc219087d5ba3124111d02e854edf2604df1782b41abdfb090771bf23f98384d724ffac3b7936b6ae2edf8fddd8916ef0b5f6d542304888d5c3bcbd03724da741285fdef8f42bb7dd9bfe9f5235e6f5ee492fc5c44206ed347f44e55954db1be76fb287214d089b02aa03662fa7b95631f2ea6afa4447776b973d46618cf870a3b92f5fa6319439409c8ad2fe8c0fa9e1014a3bb30fb22b59dfc279ab540e466cf784966cfb90655a7d5e812096983229e05a1b9ee800469fe929657fe99dd9c193a213184b2fbd3c87a117b919dc9befce954e2955ea446b74d56d9380a692fa58aaa16da1110601b78cc6cd83cef5d28c7d7fc978a3f734eb29b6f6b453b492978b88f122c4f7a6ab55246925109adb1e0712fdfc4a2be8e2688f58fcdf517448f287cf05785f2c1c7400b0042dc23909ac5296978b976b0bc14530a9c0816531121e1e726685bba608ae14570ab995095c4f8ac8d9d5cef99099aa0a94d3bcf5a1ae80eea2c486d3439258e4af0383101a59c41059ce094eedf38d03c463e5df99f1ff9a8dbee306408fdadfb733b06798ce4b093aafb2a51cc3dde9a805db8a1fd3c02be779dea3a86e52543cd82175dbb4fe74e10760fdb79ce292c8fdf92ad8974330bab24b2cf1e53b6466deff8a7e0b3e8e97dd618ed32a7fd6f18d729f01beb5daa0e3cb7f6cd592576ccbdac03d3e01772117cec3bd5abc35e47c5f5dfdee19ed40c53c86b708303974fb7ccc32406b14b39403aad878c33ae9b52fe943afdcc831f754fdb34c45307a77987c1e64c5fd7f5683404486a6b3ff86b1a39811872667c4ce41de7283c8b0b209093d6f1cf64b0c30b2cc468e5783c281a1350d45c93bd68870e5a844d876323e49b0c281030eb222ad30aa6f44e069140442f9443936803b91fba7e7ef4294251a3f691eaeabd9764109429588515a652fd6fe3665111038c4f29446dd3cdfb1419345e850a4c76c639b1ba5663428e01a77cfdd2193e5c6b20530a694564b56b7f26642d5e9e964798b60b3b3ea9874acd05bbcab1b69e92dfb82a0a058d800f3d707c3c3be70711ac7c4d163cb9f39261aece07c0ceef0d8a60127c550c4f49cc9706de1a1f7c68c372eea00f355df68bed03577c8d55aa4da92f3f2b49f1166ef86b772dd5fbbbe78e387f171d30fe921393587ecd85a2b9e492b4a179d6544577cfba9a78765a5e1a5d06003d1b78063c955e70c2e4eaa12dd398ea101631ca90fff04c3d95e84b15e9101b163496347a325762f10c4b3e8d44044a10ff5b214af4dac859e691114a1e1dd171a5ed0980b26257c5324ab283dddf2583327f41e63b1a00cfe7c476c7f33234285088999c0a3302a1b9ee6335f56125a5e95c90c5368feafa1b8a57846049562ad8966a387a4c9933e16b10341a8f102a362e93e420293c7676aa7a90f880021bd5cf5f42534907fe3ebb3559caed3483459d0437a33368c9c2dc1372fd88fc337003df18fd132ba25e59ce829e16e13de1c0984f4942cd589ac6b7cd306ddec4e9a15138818fa4d063051f74c4508c96a42d908d50620c486ae656870ac763027289895ab0b68f441b9d4704359def385b7ecdc69e0e65a2e87d4808f5e6b24a9d3d6b184a26910f16311d3ac3adcec2e6097125a739dde0c1c42cfc8f0fc00c032c567fcf6ac784a3725520d1a71307822ad34bcc82e6f75ac2f49fd7b931a08a0459d271b38ba5897ecd78384e64524aec676bd3bdf771d50595dbc19af563c0c3f022d46939201ffd26b516d1aa841073b294889e9751083e16a05393049f8568fe54fda39d77c4bdf0a519aba396bb459fb82635ceafdc5a8ea187a3db2d4f7bca54f049aaa7badfe9e7faa5ada7e89c6b294c994061162eb689624e9352a6f838ed26e76edb1d06e5e4b4f8ee784fac1bdbf518aaa1e89cfd6e52dc37d32515f3b228ecb173a66046a1af2435034a7e526124a72bc62b1be7e8097a1c224315a2e235eb028fb2c89b6bfd9258a388dee0a1bfdd7962a683c86c0d87c5d4cec55e1450e832153c81f9bda24546d740ad3e88a18bf534c4e506374a22b775fcd9acd52b18d309416fd8510e1564e0de0d7a4590d79e9f9fc9e03b7de6feb710d0e770ddc4de703fd53afa1de48aa0f17047a1b89db1bf29a843484960a84a042eaaba89ef268f9f5510064fcd9b561e48f137e3fb70526213f68c04b47e307bdb519575c5b2786049bf4773c1540315ef20d972b6ff26533262a529d0d2e0c16623f8e1a97ac7a7109e9b301ee93e637407a2fb41e7e02664494886708656c78aa4ae48b827482903014a347513f68909a73ed02c1fc030e617bdf0bfb75b32fafad9fb217877dcdf71414ee10db4415132abb1d7e759990bfb0344cb8e3190203908882b8c20466abe967ba84b9d99e1afd7c562ebc6cf72825a7a174cf87f9c7ac7549a0819171352b40697d4495af5880efa68f3215d4560f675606019b6e067a6e46709324826de7668258be5889b5912b292cceb23d103c116e9cb11d57affc9015f9b90eb640ca47dfe5f4989737113c9903d7c168ca0638ea9cd29ed5e92040162443a64d0113c182d596d4e7b8c4c22f7d549a772f0206f0ccbadcd381a1bf81d3d1ab97bebbe9d5bc3d19078abd611be60d8628ed530a3062a07ff7a7ee9eb3d881e357d258c4947c2b2f4db19d55391798c3d134470703a4bf65d4c5030ca73a6bdb3578d575a692e3b84755a5755d0beb329836b2639a008f99e308b217bbbf4c487589f306fd576e6f98d222fe2d7012e4560ed9f0e8be5f6c3d15e20fc8cfa47e38bfa8e1e6d32a8b3fedb00b6ec2543f3ed6039bf975645fe8d96a3e84205bf704e5e4fd37d818046c1f83961fc4175b460dcaceeee2f06c41529ed6001e0744c4a0a310fda59b2049865e7a17898a805e5a7326b31524c1fdd1b5d1d745527f75e6a0859d2a1840d88875d7d89305a9a042941ec8ae4ca0e4d7308d7739968e12d10e581859e5f3117e64fcf58cdb45740335f54e98b42f5a6f7c9d50d9dc0c2f48d8549dd9277598570baecc50ec17cc2d989557f39ac8afe2a7fa8c3e0e90fa0eb0326097853f6167a997794cef0e541607b53234885881639f276334ee08954068166e8b8916a5c219d66f34925159ed20575740a8a71ee7ddad64cdfddb797be3c6fb8bdf54cd788cd8617c16f1dfc905bb5328a1de64e52906713d135751eaf4b42af48899f98619f649b0c0919555bcef5c8c535048a2966b8c455e98f5834908921c5896f8b54119c70defa0dcddc2442ccc8f80cf0717395fcd237ab9f26b9502db1fef9fa8ec8ff9de59e262b05f9c1ca6384047ab0c219e2360c4f174236df62c6a026022ca8aaecb296fad7d90ca026a16d61eae6a7966d2260dc744d0739d8342796835f46589fb94abd007da13516dc47872c3182e48db773f0e241b9aa11eb3a3a9c4b842bdd00a9354236d36821993c5fdc6b14310d7bd749aed65d2f58362788606b76c8533411a486b20f25c51f2712505a01e0e78c3c6730480357e01df4ae8440167557460b08656e4a23cef6ec90a58ef6f4fefebf68cc9e2b433dc70008b9b7ae375ca5a164901774e1ec248291d1171b05bc3edafd08c469fa9c38538b5626a1c489aab3d0de73310ba4b2729cfc2753b0bd0107eabd3eaf3172fa9ba5185b301739e485f73d81b8a88aa0ab2524fb38f41196fb078b5c3c4226b62cd63e78a7b0b2291aa28f315bb17e0df3adcd55d1e4d0d368b77dc360c33b269d4f9b30b2a37f8e7428301fa115c2ec76886e7339efc15c3ee953491ba310c70400c59545047ec2e2d7aed199c7900dca795de020c89bce4f22801635dd7665ab97b77edb129bd05fee43bd777ec11cbc97dbcdb9ce406f0d36e0a8b038f76a10868d9161139eb063e313e265001000ae3457c01ccd785633d5053a4a8512fc6915d30109ce4b7d10d9bdd6dac14ffe84136eff86029cb35627dfdd583972ec2f593ec16a7d414468778f8e38d62d8bef593534e7f569cc729aab74d605ac247eb77603b0e264d375e37d659052fa88e706b845d1be9914ec435696554253764b70bf409d92d6725f368f26f0d7c4af81d1477549c3c06976deeecfcf7fb2584f2a385c8e6c42ea92200da7b239dad1128e3498c3175b471cef785821a6f805b0bcff01a7702ccd8250338d2245ca7b234c45a415c7b2fb08478be64a78aa81b55f69828953e8888389a1a3f6e5c3cf6711f218c73c9fa5c685585b3a080b739e1f4e7203d362835f09d2e19f1b4d9fa757b6880a87fdf30321ded1d60dd3f6deddc99fee77290550840b994d8b729822783e8fbcd1c2f5685a31c724966ccb35302a958fa360e46168134a026d4449a0f58f99af4b7b81661da142979d9c980c1f72647fb11178699b57515be87882d8d1e78ef026e17bbc9f467c371a4be1340a92302956dc8967e40278e9fcf86f2fe954047ba72c8f68e6210dd8ce04409c168e2eff454cf42338326be2dbbca09ab8e665f77d1b1c7598ba58cf3fa9ef259257c04f4d2088ad6adba2dea4f27ad00c909d6cfba490a21db4e90cc1a3fdf6c425bea5ba4a69f68ae7fa8dbcce0610fbf99e0e579c44e6d90147a9ffdb4263dffcf434c129058c9c16fdef83d2deacceb00798b883727559fbaccd7428dac08feacdc0c03a6b933d39327c78f590c5d579de865f4bf1763c3f584287674bbaa8627d5d58f25e0e60b19fbf9633d9e511170b18c2e9d5f0153c7d443114517e7f9c11790106853212d2496ac43c73e9d17f79ce1104c9a851d5df8810dee43d36319fd55c5384c7eac95ec4d30933bdf59b9688c78ee2ad63c99c637bccaaf6fb6536982da0f4e4c30dc55775dafcaec3c2a491c21e84e3ccad8c681a4263912b7e575b311514f4d457b5eadfc41f68b155f22e284847e1fa4bbd021eec8c7774d93cf40a3845bfac550c3268130dbabcf19f1802528594afbfa6cc499905a8d4ac4fa853dea5947cae1707b044fd52c8e37c1d9e10194f009e06eb323b06aa6585d35401c478f95788ac52757c491e2cc5ea60353e6aaeadc4b70de919cc3589309e40fe4c39ed969e31502f4d43dca4deb2e2de9d65852b364798f372169a615914d4a5eb74f49d4e98f983a8b4da3b0a1d31fc55b472760910baa426a70531b7226d1cec76294b499ca97a8bb1238dbeaec36395e0aa01f61231f7f54c1f2d343b8149a5d47f9eca24d76acfada4bb5cbad0882993d1af3f3081ba60f6ab0308c0d254ab2abf747f29b23739e6e81163ec856797af215b6c51b6bae622e8a703a254f03cf99cc6c9a7a537dbd215f4aeccd0b6d426afa8ded09a50fe7b6f97c6da8c69ec477ad3463ea17c1047d4fe16461655a21f959fbbac0c5b082c92ce43a98a044f352cb720b2786760c6ef6b1639dad3085034023e7c8cf7e0fc59665fdc1858ad661711ab06b192079ea4b903bf9a6ea2b775e2a65dc32cf3191fb9aa4588562eb715067a2f72ed630cdfa57589333e3762879a232132cf2605b64014629a804b313ec4a1ecd494fea88c7010e8e8fcd251511b86bd7986c4d9a26b0ddd25608b4c73a4823a890443c569840b8f53841c21e9fc82f320b9950362e0e31eee0e89e37233d5724e2f1d13d94a878ee26ffe405e8300af922bf29c70f7ec0cf05de9b3a6ed21ad332ba71f8a73c1de8b00d4dc76a1723e5f5848d74d08cd4bbda9235e4f24e147a4673160e952e45f82d4fe2100e136d9d33b817db25b2f8207fa61ca8289ba7ff8f299d23c99c62bdcac258da676f84e6f27a9a995086ad0a8288b3bcc81b45d5777764d40c8ee1b3f6ed73219b9fc44235c2baa81468bbc4ca6e2492406d1af63c0419458d13e75b1264cb57eb9f84b49832469ae366dcd00deb2d8824d11cf94990c2bc15999439ae9eabecc281dcf3625ef3a2761bbf20af553bda4cfcfe1b81b6843e2791f164cef7c3fd1bc94d5f3d39e6727a6f3e5fb4dada82dc95243fb6924d6d8a3cbd9509e0984411b2a1b9b9034dcb8f914a5a3138b6e691a3dc75d0326a8d2a6f9bf50a97bfc6ebc83a9b4edb98e9c2e70b23f968c12c837b1e81e75f0340b1eb0c69c3af9764692125793560c2e2184fe02f36f2a68c964b9fc93bc9fdac6cc9ab8fba4200d6f90ef2e58fef0d0e6515ff3decf823439e8b782a44d4df1ed4599ed67b273da55e4250143b00c84744cefb55d94116ab4e1a12f0a418fe791d153694e20864702df370a3fbef7d9b94720d8b132ac6abd4ed247def198ef7941292b6518adef464e60fa748adf9717500a02cf3709992eee192e9c86c0f0a4a14142e3e765b3fff8c0ec146d451212e86ec93b01b3ba8cde6596a0ad8f6930108aee02a1263d843dec9a22605f174a7850e7d1634c30f19e9e10aba45d5140fd2e7e1e1d09ac0d1c04ca52f36cc770e6404e426a3224b8be64f23e1eab6c3008fb3b12e7277f986a8e982a2a34721183793aa34548c670f7add17155fba817849bfcc49d03a86c314224aec77ad76b73d7e970b0bda0669dd546104763928441c3c958b59b4c42fafc14cade774e8ad6beb16e2a7e0df8cd6e867b63b89543ca4bfad410147415b1fdde4d848cd7d63c35fc92e672efa0428b0b96b1cfa7f1b3695b3e4fce3ff3eff531614dcbc957eb6519406ea2e516e923b215951066728814d5fa856d824e9ea4eb4e994d7aea4effa4f7233070d99d21fe7dda958377911778371cb6f259b421ee572ac91f41044cac6f7a5afdaffafe74d4dc05cf8d4dd76bcfc5e49237b471727a041fc746e6be48aed815f6989cc752cf15e5c991cbf03305019ae570ed312a8fd8c0738253f7764701344674f85609f6026c94b8a1d736c7785cd6f4c3f3e3ab880efeb6ef1ac48d6cad631ad61496aa3e9c528cae705335ea37b927de36158ea38f2981e1273b6ced540785f491618cb708702d75b5984150fe198efca22948ab74d7feb6dc6731e06833f5b8c46c7fdd5c65c2ed62109df81c20de16bbbc16bf1d94ed23a6a1c76048079f6c6874e2fa652ddc308a7b65f0d65c32e2406793b3035dbca80d0200cb38f1bbe5106a9868843476e2068eae2c80a5ba8af9e566d43074b35e18d07c830f7084e578af0d0de9d0e0b3c73df95d8b01c8778bb682ede00bf5a60fbe9a49cc92798b45692dc50f8f01fdc41b8a65798f71483e56ae30d3e590159718419697f755318269b56bb30c63bf709a0495319c7a3ad8b202dffb674ee7db576d444e9e1187cbe8d453b3ac056708b926ed96f585028fbfd52ba58d150e6a917a502722e67415eb5ad7f9a6d7eec9da1398170111be62d1c5ad3e6402d5706d2ffa01e6101528787e43bf542751e0b1f12d0a8c15b2f61417b3ddcdbb4705ae1c2a66212581a83d2cd0db506502d6cc079cd6d9186cab44bf934ae3710a762a1b5ad55e6f26971f150a355dafecc5c5364391cafb20cddc03a9010d76ead55d61327080d219e4b44f32cc39309c58470fa4a06cc1197e3b1515297cd59ad074b4d7a83a28675c9ef80b86ec3cc274c016c4ec8927b47d13489971dee5e5e8b875e1dd40156ae7bf40025a3a410b003e2784362fca9bb5e00afcab962a10560e89e50d9bfee2a2b4e5c09a962ff72b5049bb2853cf71ec1868fb0fd93090a33a2dc834e71b56341a0dd0b44169544f82a807183022eb31b7def8e6310b8c01ee170c3840c595383f9b60c094ef4226c756a0bef1cad3ab9b93a52c7d7b0642258918210be61deba3189b97dacfe5346c9938b3f27cf9c6e90ddf9ccfbcffd8d0b494c821ebb693c133562cf83274f322c5ee1fada7e6d2614684c02ef224972c4af408b511b4fb60fc23b7a39668ecdc85fd64a5582c6da155f2c74ae7cf2a36cd46f6bff9b918b98b5ebd4ac54fdb0357a210816fd2606a463d545a10a7fa670bb3ee5a7021afd0a61099a284baf443d4304f698e5ef4c709ba87a14180ccce832b65096eecc4e3c1bc6d1b21da7c3e8665b6ff7e98ed9369a97fececbb6bd61cffd829fb2e830e1a8204bdf46e6c8a83bd6bf5df516f203c8d03731a33ee54d54497f3e941513ac3e00cc7f15d2cfee3098628a6e6ee93c5ad31e5de920e13f59ead4a719854559920b3011b4877763f253c983a1e96e634ebe8928ae9b8ae9bb115c53b55c1cf5109825fe1d46b5a9f7931af052fa8e314f115f78f152478fc7d476be47ac480ce5595d07bdf3c129aba9ed247ced1edb96b46b0a311cef0cb4dcf9ad5d7a034ab13edd52dd78c59f1598e3f3df384c493aacba6c0c88005b369d12784ebdf1b5aff515620c4c2d2b7d977efb66ad1b8d70a71a7478debb40b44deb39945810bbb1dd10db16535a2b4d8a72c7d651066710c9c980c8d9b80360553b859e8054cc1d1385665a1068b028a405e0d76da9397bd8391224a26cd28a96e3ffa7e5456c0446000800fdfd9ff77e091fbe38bfc5476ab26bdb504034b7323d2b383633ef9beec37edf017a5434227e74ef606e0c2cb134aa77eacd1788b12e2a2aa3e0e02d7cb9e085eafb9b8ac02794c760e5e6a969abd98657e468460cb682cbb72d7ad858c4c30dc9739f2157261403ccebb07d60726fa54e444acc5b029fcb8f5143680e1123087e51b35c0f786ffc1f2ab8d5a0c11fece53a7c259c8815526db922e137b7f1caecc7798049cf75db88fd5fff3547e3a15da0025d5062f59c5c1d7c3fc67ceb835338f5fa87b612735c35782d973b76bc451d7dcc157c178bc237dc333080888bfba0574438a34fa4052d49f785131ebc16ac69bf12a5dbba4caae5198067a659daf85935b295489a513d93c98c1cd83b82bff3f9e3b2afb9fd9f504e6e5766edef1b88c92343dccc17ff6e016d0ddd17b70577e7f8a273f373feab68425a03b9cc47521c36ef1f8c6eb5e36b2f66e766ce23fe555b78b003848ec19f5e932c0a1ea236f12476c543300bc7db27fe3f6513088db5ae6e603455f903a206a2a41e89a10c6b2ccde313d58cbfcc2357b6647d5e780750c60aca4e9f631562e9306700e56d315c5278536b487f8522d07a3adc3926a44f2418d153844bb0e337ab6fd781746cb2535993b914f8c37f74ec234440027b3eafb004270bdd0894a64b1adac13b1907e9f272bca4a6ec04e02ffe3b68f3bcf9139832395eee963cf7c4729d2bb0c31ab7e041a5f2bff7815bee525e3f6f6e9b35592adc4bdd86423010e21764e681b49a6023a8c281e1c5818aeb41cb57e4a6f9b4d215a5dbcc5cecd1831a4812bc26992afebad928d8289b1ff2902991e682a9ab3044020f411e3f6e74299286d507b82e573a06a183c7d3660d5b0a9806d69c0856a1fa060d3cdfb954401c30da33960fbc82f5c8e9b88cd5302541bfead6c0f702494486d85d220c958978968ae546601ff5fd576973e9372b370338a665216cc0d5e2ce859fccd001fae62ab9b7afd72ab1bcc38f25706fb66a304e2eb763770d9a3f34e453ca148a3015dc5af5f2a46642036cbe40ce928a9f0e1971962ee7bf4282e584070605d16ce7721aaf442918777bbc29ed6b319362cd928a294e974c14ba013250372eae28c2d349ea12e2f26a8511b14b21dea31db13f252a08fbe8212569d7a89adfe6f007e2eefda36bba751e812b9265bf3492b3ba75af91498555a970e6e96344276db443d610c684aa3284ffc6305a828092162909b106109992b6859bc71509730b171c94059bb4419362e26e7fd8a8e29542298e62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
