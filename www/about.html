<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b30b7973b2071e84944579109552e536056d1ffa68dd8679876e5999c395cdfb33d2ec8f63cd6673fea784db18a85d592ac7ba33e8e2f69a584124d4679e5128e68e6158d95c771183e965cef36719b237cd77ab84e17ed8a6a84641ffcb5ca8ced276cf679f3d65ff027ed63fdc9ad834916fc600a00b13cd3151d890a78282bb77056e23fa81bd1fde2d7edf78bdeb245b2dbdc0a43e491985053cb2d15ac2c650cb8ad796f2f4a854f86ae840498727a93276c7531b597d267fd6b6810be58b9be92ad33d49bd8317059f239652a4e332407d8e9b262fcf481e9879cbf3f03a322a5a0a999079a8799fd4af3cb184a3f3ad414ecb610fea9698c6c08385e7e4b4e1ad13632fc482f981d99d6ed866ab0e9d2905ee94dd134009c90998f1ecba227a753dedd5f6aa0ed37e6868baa8725ec8c951ace94c578f7c0c6cae1a31cb69ee5ca26bdc97ce0d47ce140c5883e8354166d792b449aac717ea3a761e4f9a190880d2cac97d4b8f3c618cd72dd5a78b40083ad4072a43b25befb4172475beb010ed1f496b7ae62e7f52c7c5363e702323e3defdc6c65e8243598a72231e216f3b6abe261f1935dc664603398b5c3ef346043eb87c66d83395d85d69b16dd39f1da420aee2e9c7d331920e8be073a4f5c6d7270e1cf4b344a5f4cf90a4ef2341fa91f3b7b281d992177e69a5ea8a1d168353080265bb7b6998bdca13d6df882c83f9d3ce718a695a8cfaf9d6a9105ea7730adbe982fb1449db01aeff2074fd184f594c98b6b47893c5437eadcc7184ccee8f86005a170ce24999e47c0f63a3bc4dce95e200d9960866a93fac6cd8e5e94aa3640d15b1b46405f2e0d39191b86ea88fd0bb97c3ad121df3f19733ebf1bd5a63986449b5df4dd2e47e0854cf991d228fc6bf3621de5cdc7a55de4d43ef6857c79e78b9f61a2ba8bd702b20437ff6d0bcbbc764f7db6b43ac338e25768284f5ec1215813d6bab97962b000c2d28324b3ba563d7fbfe87007432ede145f03d515f8d5a4ec73bf8e93753177037ce1a98d1acb61f88c06be4cb325fe7c3b2b4a50da7402f17db5bd9c2e9749ff0a6dea117153b668573f7360215910c06f829c7d9d34afbdc6549d08bdd95cc9386fa4c107cf7222593a51a89668beffd0d9da695cb391d897958368a6c00d966b4d8d4369e41a16ce9b929958185eeeeb383a649a4a27898e9b53d5a541ece157ca9ba2f8b1e3f33b28e36b7d0df75dbbcccb48c9719cc68c38e8eb77e8d1444e535f94c446b760c21d361996d4cce5e68d87f2a2a2a9f9e1a546f06548d7aff941146801a31d5c675a3e51f67319151cc96851baf7bcf3a0c70e7a134332308a9451d3107e537806d0dbb5c08e16080719e4b25d643b69199baae3e336f066d2e2451fe05d5424506fae68415230801cc7d5f9408bfa03952c89b0cf78d3a01a2fdf109e494bfa7d44b8c23ddc512d469516c84f67c6e1339483906d14df39e999ea4a31c385ea85e43ced6b413fdea4e11da9498a3fce8a0d9bc0aebb54870b163ade45dac23d69dd9ca62d1eb4857f49fae673c2559d6aea272d838d7886681e90da4dc6ed185c9fef17391901ec9c72b97273df0578339ac94e6702fa877426a5add583d09624bf8a76e198e647ef396526669edd49fe264a82bc933ac80ce00a13c72a9a1cf5367ce9613b1f39975851588fc94024866da4cf382288a096b3388ef6e7a6d76b5bdeb23f23ff882ebf8a2e6509cc40868e37bf8cf8598d2dbcdb7e290f215bbf717c4dbd94b0d72dbf9926f70705589301e240452bc58cee11491962265226c9a21b6ffdbe93809d43813b231f084a8a68ed1dbde3e8c0256d0b35f2a5b8803dc41c26705102ba524ad9eddaeeff3a0c99799275104cc5cf95e7088ea2367b4dfe9abe634566c996e9b3095ecd4eb76d83570522d16a0eb2a687c9dfacb0ac14921d3520be11e5f9d4f5d1998ba98407c08c3da47c6dea35c436ee3a0615466e9538b83e76de4c4da519e9a957a9ba55095c5d61a9063e527d14fa30ba0dbcbd7bf4f2401d9e43e70e41c8b99e03d79a360ed530116ff6b6c057752e67a0fa8d7c0e8ad32c029d8736f5978dadb5a5fd6411e2ad4e867e6125a65b2409afc49ac96ae4eac7b6d8640d1ceffe0d8390e470568cd657795cfd10ae504a7473eabab9119b9bdeda26537c1abc4d69b601745647d670a303b9de1c5709facb4c2e0a032e958c6146cb5f72fbfc34f8a89a3fcea494e30ee7224c591fd4538fc87c13f90b2e7b5688a21f33f4711b9d73e47431a4b81b427cb08e9870885551433d1d93b8985a7ffa3e7e3cf756daa312fb5850067bd087e755c86e1b4da27bef92298985c8134ae559751f68458f2c8eade786fae90d80691143628cb1d6e040084c8a9ed17eba4a3731083a48af10af5005ca00fa7017a8fd0354fc64f328359cdfcc29f4de2f16d8c0356e165ffa2399a56c0d2103e990912f1e1c62498e6065b8473bbd8395725389306f7184249f86d1309a9e97767052a762bcd2cba626db58390815694cc0008484b2342a2be03470b2c220c334aab5b3858d388f508c632cd1b69c42fa2b8966365939528217f9d2d60ce776e6c30d856995b6975049ef4bd8774ffb1bc3443bbe7413cbc57bda922c991fce21d435dd013fb4e00f2dc235d43454227e987ca88413f9fcc7ca6f461c0c6e8a896dcd008f528368e1bc61cf9e3a59283c853fff6402525afd34c26b36d628c0b1d449ce79519b009edfbf111427441d0777006e699792263a69f5c68be5501ad928a1946196419e504e95327f6494b17bda094ce40606ab06e29b305335e62c512ffad3228449a50dd8abfd9e25836453d70ea82234d5c0065be918f3af0aa1165f2bb54bdc98921681b210fbdeb5a51bc0443538b3485f0c04ba648b1e932b49af0ac4ba8932de60b6b1f5a35617ad0c122ef96348af4f94544001f570cb6f6415a9bf36c5911d7ae91a3e072a99915853d0b369b6e24a3259e299b665bd0f246facec2f1171d811ffa4a3253356a2bb2a6dbacc59aba807200f5f6835c4e69c0521d8aff710d0a7cd9680b56bd2b5043da018aff3ad18cccd6a3f5d750a6ea94609f491335660732a538de29fb9d223e4feb4a5fdc3d1124c840f1a8c1a78a50c0a51bec0c63947a4c6286f7dc6eee2d3b2c22e82fe1b7b92ffe47317289ed19b9c920232f341976558afc4e241785c862726f6a115e4a4cc3f92e2fa1dfbc2612467d03d65ab1b083dc75bc2f77387b3a900de422c657defe021a021f686dc9320e96f5b8da821d81795f7526e2a7a44a8dd3a22ead30daa4d13d57c8d6b168828ae74abeefb7c761f86d3e776713d03ee744bc1ac85b116e28baa6700d7dcc0766200007ed5d4c1cc49a8ab0bf1d090a05b566010b02e51d58d766794771e736916ada38be64e7c76116d9497f5c27e17b9d3efe0e4078249a4d24bfd40fd23c50d254390fea95e2227466b9ee0a37a25af103a1f65aea7a91e4c25885424f390e9b79753a06abc5af1207896d47323d31f1a335322bd438239395433231572b2abae1d9158a008a86ff4cd7136bbd7b068a7d409591af48757c065abbd4126b152cb87fb864e8b5aa080990a34bc281d064fec6ac9e21aaf379bba831b784f6d4e24e33660aa87bedc0e30eaea4fe3ce78e0fdb4ac7a5d6eb170f9400c2afce9b38b16579e65e5dd66212b075b17110ca14749d545d71029763e9fba8bcfbf0b9d1fcf7743df25757dfd861e402876fc75cc232da105234dd7f63152f7c555d395c6dc70f5aca3d0f5a4881a4d74045b0541e953c3efac866baf355eeb31ebf5f1799f0b58251a0f96a1af7a14641da84270f73bd72e351051f1ca99b3cd5b5cd46be20a887bcd367cd8227a833e7b60379f5fb762b48367af72d11e313d88b1160ff04cdca0d4aac7c1922fbec4b61c285d2e84b23720c141078045593da7b39f303e65241148273c7e7a9cf6c96c5342060bb2e244acfd3315d96e12b40b5a4d7c14fb0122a60e97a8980f006a8ba0ac59d7180868210e1f9f0c90f7d5c18aec6a5ebd82b614aa711a0086ad6aa74ee55abe35d90075141e56b0e6b4a861e473bf80b187724fb46a2d11bbee9d3127ffae9da5163fa33fb046abd68dc824f446def5a7461228667902c127d664f885339c372e1131eececdc3902f052e8817ec7ffd1b485c8e58cb529fcde546b2814d39b18f61e6eb6b384b5e4fd743b11e4153ff00927927e64a5bab6640c49ddcaca01b12f918bd55577702f078f3544cc683ad4c9c1bfdc0b3535f9d1d18c4ed1bea5b748d244c075b438b1a23ed9e7e76609e3f85e760bff38dc30bdcece89458e0a55e1b0556032522f786e26b4de2ff2c63e8552a13f46e58d3178c93ad0d7d1582f7015d6ab4972ecf9458319f4e60dae8639d2ec11a85d54ab64c0c86902f5fd659cb909583b5561548bacf2c793c1256b2c46900d009b929b3aefdc068072f7a41a4936cf58628c8d85f5a0d204472ed9cbb9312c9e570e3b7417c6c5923278ad3d04f57fce077da72f39c5d5d941e35312bfdb0997d4ed093875942fa5201fba314d37df1dda2e0c7ca20d884dd6655d79a1c65d274a342f2ef478e3f943ecabf45c4cdacf673c847ea240798b3aa2898a23094bff956a1296c92f1361c145fdd8d7a6ac1b1fe6618a1d7e34c48ddf186b35c0d1c00f55d87334494ccf4997d5fe3063df8205f6480fddc4d1a7114a10ad0ca07381a7a39094fb1166237aca06a3de7a1ade6694eb523a457202628f01528ee0bea7ec0d0050c6ee42d920cef6dafae290e76ceb814ad795425bb96b24006db38cc75a96ab681ba836388b360dfe997fda35359a0da12e4b197d6f38860a2c1e6e1720d63df466f957ef95d7bdb485ecf6ebd4271f56a85947c9188e16a9db3293180453e783b51e92341f625018966c235e2170f680889271e65f2ddcfe651ed38c8bdd0b2069b9954b80dcc11b050ce31d549d8d5d89375b2d229d4e92cac4959ab80973e704aa6dcd9b3b315c804f94bd6d57588e2c0f5229c3594c5e49ed60159fcf3d6669f126e08ea253ff2c269fd36199355a56d8c4325af1e7acaef5eed80b434330e38ce0f0666218b0dd7fc4f4688e975ffd0b50c3fa504a419fe633a70b6c36abd038d6fe646434ef9996bf760873c6010bffa1162a05e0f902b95e11ab35b80e430da8a16b9b2a68abdfc643b1fbed4bf294c437343b2f696338e7e9264ce0158b75fe88a9ab94db07504481eca9bda7a0595b097000b328355a2df696a07b881722d51807e1522ecb5b5e1b185bb37d94d4ab7ebfe4a6a60a203e256fedc03ed46548f703130dff08051d98da24a76222bc564b0bfee577ea7c8f02a939f6dfbe42bb78376b2b3b45a9d7626747cb649a2232d2f75683b45c05ac897f4e61f3e840285185c27a436be33091a1db9834e4edfdee11267d4418cd7f7e65184c6606bbadd18644cfb8783bb555724ceef1295ac23b1bc9a51a93d92945902179140a72bd1a7f4005457da181ce0c415e363ba439de6ff9ffb56218e3d49edb0028278cfc4c177182d61fb9f53505996c67db0c2e1c1d8bed731e9c68a1d24103ed6e51e41b2f008ca6330bf3549c236f638d2baec689d39cb27187e5192d6a729ce3e0f1dd57a8c8d6fe325a078e51fc8d475cc1a244c5a9ed1b5d0fc864b9621fa67549c60ea8b616767cf287e5e54330ae25a6a7daa016144584798e1c32d1e57f5ff861b8a1ea1fedb9c9c8464dc71ab589bde227876ce2ad6d53b4e8cd322b2c9e20c401928b6e0f3d7d85a98cb5abb3641029ea686fb6554c3d7ce0418425b3cbe6fb888038d222480c19b7a373fdc47b2f1ce35d0f22a029e83fd421c23915844c2b9169849be77009e7b4eb08bf622b4c552136b3ae44200ef430ab556993ce153e07689862e8eb68825c75adc45a90dee3d4c0138dee3f008836df5d77506d0d4a2802547a9db356b6755195774b985255ec265a93dfe18bdb20223c2c9fbe913bfa53470096c897f86f7596cf76be94753cf39c3b5dbe51944ee4f5e02110034d78f4ef2db50e22be0c7542e0972887577be191658f1c7bdf3a08e67a6c81a7897b6ab95485d7967bf0f7d20ef3edc01e326cc15a5f064953f276472aff83dae92d04d265b01fe8f360f15b6d733785a2cc8e426d900718424f4592b08da79abaf499b0b52b40175cf4c3689f6ab9f8a180601157956736cf3b6d2f38b9c8639e950d43d82d24a622fbafac4c5ebf7d16bb4d7192a41d15a44c35516f6d487d9976f13d854289618e2245f6e46709af63ef387bbdf5583a51775aa213de5cfa6509009f96b0441bc7954576d2b7322f002ba453ac7611c36e9e7e9130f8df10bfb22b332602d922b1fc5de5a5be6b05cd9002c3152c7f0adfb5eaba7c823d8a9c97bcca53107104cb1d85e46eb9aa10800f0c1b478ec177da9ed52ac88964a7698a2d3b4e0951d02150e7c322fbc2f8569543c4e6597ba7741259236fb6862a9bba46216c272ade5b8af7104d72d3699df1a31055680befefc62387624ab5fd8253966653e83569625cb0ffc89747d903de7836d014973099a3c80277e7c82a23f423877cdc111a41b26873e5dffbd4cd0c44bad4a85727d34f57d04b9283da9117843f2459b23c55956ba3ffc6fb7758937e30e7fb1e93d838ef9e3af8cffe150c7e5545c56952579c180d5f1f9be46f96b583d7b1fceb21993a719988fa819bdd911253d6ee16befd7a4a5ecf705ca1641e636b9fea529408260e0062344011c2b058440efec8379ae145d7ebcc2f00ee87a05963bc738090dd2e3038140a3b1570e634b8fc3c074605e29c52a049874c202031488c03402b517b448b9440135050169c132864862a5be22687d66e6e7a6c6e1cbc0ec549d146fb3f0413626567bb3ac17e5c0b9326f013c7a68fb4c347e5fbfd1cfc42be88e53950afb3ee1b89dd211fe3665d7423d60c214f9ed6dd1f23580b0c27701d5afbaa11051939c8b7ba1e22bacd3bdf903ce2efedd0cd6836f42b660680599b5945dacf3c9c6fd09796e2307e9049c85cf2e3ca671ab929fd056c9d74ebbb2930d302c5e66688916cb0b63c56dd3bfd59e07b910176d28bdc387c790661d92e1516a122e391d2f9ec05ca2cbc1cc59bf3d8102d42c3834aab906151e2d9787b0e80f8e8817a891a3d2098b63e816e5adedbba37bca3885a8959b8065d91425adf2d1a75b28f57e1ea76663ef4f454ed9fb17db4f05558c5e71b8cf699d54fff0baf1ec8a454d83b51d6f1dbe1b684a055cd93ec3ea8593aaf59f9b14166c81ebe2865672190a8c6d5ced65b1c17f7c631b1c76dae879de0c6894268c08a8b2d42ebfd010e964e1e760d36af4e42586cfc90679ba6c352b6143d591c68d35b3666841fce9825aa4417f571c2bb87df5948fa3c7b2c669f886dc76d76ed8289cc27af84e3f1eef9c22b01be5bed04356bdc3556a111fee5153d2694ec747d7d2c397765cf6706acc9621f70845dc66103dfe4b06f9a0d1fc8550d14ee51660ebb2c1585f09776b482358660f20f04315cc167effea81d189b515d12f0f6d755ffa7b126cd5df1a212dbb485b4f5cb95881ae52997b6111336ce825dd7ce103ae565b44a72eea8b1d70c1ad148eb26f628a854de9590c639cdbaf3c00ed9d96173a12115bfff04590fe5861430a2cf4063af451e30231c083a8e95728038ac635ff0ced5f1f77ea3e5e9962536bda39b819a9a8109a417257532594f803ab31c9f2b42e5830cb8a6f8812dbf1a791609d2f78a3e7e2c92bf82ed49cc04ad4c83126af144bee38441df754a1e8e49a0f39d4039beff625ea89aa63b88eb53a8f0c8441e9e12b3861f5deec05ba92c8583300bd56bbb09890a8548ec736267ea0d8319f302c171fde38926475255f0ed916f59be4058bf12aa368772998fb8177812154a658e512567f157c32128210dfebb31ca4a1efc3827b638efc467fcc300ced0bcb16c4eb03469aa72f59a4f5948220408d4630962e612bc020bd1a6e8a6544f6f12670d05922fa419bfa5d4e2a5f625688453027274355fc07053a6ba9482097b3283e3489ab7c5485f8facf52faabe96935663bf5ed9036ad86995f4bbd515def7b510c0d8c3cedbe8522db1e9ce5ad3ca6ef3be35779aeadb6ee7c67e93063f72bd633cf669bcdaef105ec42a4b1505483d1195c207031d65e97ba93966069118201959bf29f65c661e47e9893beb3dbd2fabdb70529d5c90250f4ab1fefb70e7b2422a606d57b8cbbb606d26334585f956f8237a18b9faacf63ff57e191b6f334e831153fc8e07ad8a64097b9bd6e88193118dd649bf19cd6a5f34eceb2148c8ac90ddd2af5a8b2c9d295ed39eabf041b51e1e4f8351ee94beae93660533141c0956e96965c55a4a941421413db2e2c7886f131803df15cdca332cd8865d918f0dc3b7b55a24707c132d1eaab3f1b39de577cabba088151ccb77390d57e1a76dcac3845365237c593cc1fd122290d8115bf12c90d16ee1b9c67ff46f1dd25c010adafd230f422ab4dc95324d93f9a129fc8b66ee19eb3f8e508a3e437da835caa15705df4ee951f1cb5ec9f63d890f856bfa3b2acf8a8701c672e6f0e5c038a919196f843bd057984599174e9d5d6337aff0c2533c22c4ea7ec5e83ac771570dd6063b368446b4e00e931bca945df52f6974e7e585bcd45f4996ff9d221a10fd8424b4a46027338e8117cfbeaae5ef7d36925a9d639ac8a0ddd96dc7cdf7b7c9a5834aae9488f5c5bef1fb85de0be70276ececfb1edfbc0e45cbe784c685c9b213afcaf67c0aa9b0103f0f6f5406c89d12ea2005599efe17b8012271e4a87e05e141063545d4e0352a9c9aaecdfffa58444a92d8125ad3b53e883bfceaff6e0f66f7af4db6404bbb4d0c19b3b60cd62e095509fdf2804d5d7034d9dcc792bc5b86efa59e861adecbd084686b80947b5ca26f28ebec21c47245a738b35787ab9191e469e3f865e16181b1b48e1fb856bf50c03588069a2e5425c354bd3a9b40c32f9097c80cc95fb6e8ed2057e103d4a23c1c0e18d1a1694584b967dad428ed2521c13813c3df8adf2332130b2414a70704f417d0862389f5785c3b7d2c375f279033970aa7fa97a2f5483ae3ff481bd7b79d7b2b883ef8ecc861db210655ed759980c35234b9819f17be3ac65914191c8a2995031a08352a624a6338d16b61b79381ec663b5e5b2e1753d3bdd49e861ddfe342194576e52b59f379cdb5965827a9eed5e5cd4d7152831ec58eec2a92e1587a3941462a4985d10ae04cc857cb7cf7562ded83cc24fa1c93eceafbc21a52d3eb767274d8fb1fc98c99f7d5972b7aae505eedf590611a1d36845bb030dc0fc5af59b70610c7c43b25425a1923688ca18366f58888b3cfa9e993b4e431bc48f1209015c6037ab316668922faa675b1079b4697aec82b120b0ce908f4bf9c449ef24bf203d2df4ed3538010c62400ac0e2cdb7d31b1e34c6f4e628785ece6f48e706f29a2229fab9293023ede4a3a38c586759fee00dc1d5b56c301dc9f5ec48c3eb1e26749614b4c6af49b16e11548b1b6287232d2c5706b7a1772c0911dd896edd3d3beb547f0f7746be32c6bdcfa01f2cebe74dd8c8e701b0fc8057c6f0da6d0b3d8432394ccb30a35b05da7e27dd44e5746c6bdc5989b6963ce87df3887567a0f453a6a16d1e32e93dbc33f6658ddecff87a6494d0212dc94cd52316087e055261a5b37943f9f644536b652f9d1a5e707771e4d6e865a07eded28ca7f87da47c184ed58f773c5c5bcdeedc6412880c0361fc8eee20c113d080b21c5553088f34cecf11b3311bee821f45b65c45f3e55d09c19e3d18ac21dc145b2bc20b8f470d6db021f9adb64cf139c07fcb0d60ab2775c064bdeb03a102d362120aae74df2d9ca6b0ed28b08a66acb2991562b8bc0cc5990a4264a3c2370972c4b76d978067a1326936c3087a03244f324b718f57a046d5d4235980184382e2c38efa9a19b4fd4dc10689d52d0e5d41ec54cf452f209c1b940497864854fccbe8207a36934ea5628c6bb19d0732bafc3a256150092df5ff287844922401e0232e49159f517f188143decb18dfef91e53ff3afc8c548b6f6d8701989ea1eea7a1e171dfff5ae2c9bbe2c43ce5269a2f5e54748ba3ba37ce79c4dcd400e63f91ca5cb4061d8340ba4213c6240712aff1dd65d444fa2241a4475a8f92b4232330d99d9d9c11bf9a84ce006f4b7d37703105ead00d44b1b49200b79ea1b7243f2ecaaa44894f61c023d9da5ff750f0720d56fc948f38e879aeda26b43468d8eebc346de40e5091d7022c92f1dea792c1ab15a3471919b58f9ff552c35f084a295c01bc62972e7ccff228432e753ac9ab3e7143b774b7c713ed68a112a4ddfcbc9be38314cc116ca391d690336ce993c5171d017343c2a4f8ebaee5766d0490d0a5516c126c677b63ced467a607c99abe19e21d17890792f2bf734ef8adb832b606c3909b4cd737440be965ffe397965c83998fcfe3c699d02f2ea676eb9abdee9454d1b131146a10931bca84b23aaac408a112da533c7500d88f2aebcb67ecf2b1af4ac7111e38732e3f707dd68ba2c5a600316bd50c3516297193294f6ae7bf30259fd10ef9e289a4d4cbc2fd19b5c7f6978e3b3243d0b79a020fd8f4fd3ae1e4204cfeee84ff1e0e719a4b5675b2f578852c236fda6c0923f528397c21a96fad921cdf42238212d8b099b7c009935860abccd9a3f48d0992339501b04372e36158a35a2bd09c71e1b3b91266f0d335bf4e5f0f62609940b51e8000dfdbad1f96df086810e1eb8fdb27a908f7703aa32b23d6f14e3b60ac3d240578982dd3fbda263d118dc355e7ebaa0875f94ae2bbad42801b3b32f911c96d8b1ec54939d356d78fd1707d1779085fffe43aab9ac1c5c10d7d64187dae7413eb269caa4d603c569d29467c9fe7d03e1bf3d2217e116743e40aa6935972facc6abd935483b1ead1d19fa9b044b3dad372833c0561298de6fbe99292de168805bd04ec314acdab26d76dfda2b79ab5da3c90ae14bde75aae07549a8e09fcce77d9c939f017c4020194bef91a8c7758f2ad9a53265eced5b7e4c00cef2d49504f9fc1bce8f0bec8d1c4a61b0173b788a8eedb885d2c1afd004346e8db7b084de827cb247a7b9a98f9e2792bc87bb56cbab221fe2e496ea6075c2249f03d15a7f8eaf6c9ea3063d73bfd9a7bf0bbabe96ff1ea2df1480396b98afa073d192b05d74cc7645289d3bfcf27b9f067dfb479b31e713f1d11b11d8174de955faa5df7f9b3c29d14900af0aef3f7f6bbab31814f47d85553c903f9eb72fc948dbe81a8e34561ec0c66e251caf8783dd8146d30c257dfacdbb1965f75dc44a1fa7e7ea3646816b68da4df92683521d72ca769fc47d5c1ac2c3c7aad7550bd1bcd64f8bf444b62fd1044ac9d3c32534706168d925b0abfeb320d043990d039bf0fb903dde93fc2453f1ab5a9fe6b376388fadd76a5df6d64771bee236d5cc7eece699359852605ba7a8026733252d0fcc0fad2880f49a7a8a6055cb9f64395de656e0e7070352c017ea44084a6aaebb427a176c382cf8bedca82977b44c401d7a8302f0f54580775f2bc4ddbaaee416b87f1005b64634387336955e56d40695d39a4113b87018ae75dda15eb8a170d9a3458dcc48761273cda4c7008077ce5edef86035d96d6a40234621d1910a0b1abd9fb9d196696e8c147248a1ddc3ed8e0ec11ae002e9daf18c71579b32bdbe2af7f56734d808495fb4976e4fc582c228f2cbd74ee2f3d4312c87057fbed3bcad757728f180fd05cb15de6a9dbb28b46b91b766790d5fc24b965a0b1e9b688435dc046e0c0d89094bf5869f3db52ce8fad52c472e75d63abc9d627db464068ec540a329e95fc34e2874a67fbedf6ddcb79cedaebe46cb8a26ee2594cb85a72e978ed133fc9d15b5c200d30aa681e7bf629952cc47e812e8392538651ae71d35b9194e81aec088800fc5cf63ff460713943ea8e8187b891bdc30849c2d26e184d0322b52787800bcba5a06f8cb08e18902c827c97d517b501af9ab345fb834c275c1159d267fbc9291c6e106ca703e11001325105ec1657572c12094fb85d0ae055615713b0ea2b47ff538a309b0327169426bd75bd744c95fee42f9fea7e4ea3ef94219bcc4022f18e4565886af06b2df4ca170ca88dcfdbf6d92169d4979ca44ca69f488f833b5306833ca9caf7c95bf7b289015cedae478e82136e780cce816005554e4ac63caf1afa846490fa0dcc4381356ab976c00c3cc2b654c7fb4687c2d8d439c035bd3ec67c3a56a3449537d429b293bebdb7b918904c52af3db93aa2d0a1a83f6f7d1f72787108b3dbcaefd41c49b56ddcd706ec74cbcb2c98cf36b3a4d76e76221faacfac0b82be929430e7b21867a6d89d82c9f840d96aee0e9d9152f50da56325f2fbbf1511b0b2b1420b352c4ebb51008ad33698eb3dbc3ded3917c1ef9a57e0e1da792518beb54e1d2463cbcd40fe4f0af90ee3f2abcec9b98f0b2cb185c7d41c3cf04b20960a5f2eced7ea161a07cbb4ade2a1c45389698e416a6d207dd8731803c93a060922e0f3c2f86e9a45983e19593a5fc3799d657011b94baeef20903dec25151a9681e7c06d8a756ef4549aa3beed48b20348d11d16ac596273b9f766ea04889805c7619d3e2eacdc21852ea806730b89a8fca45df110448ae23c0a9f29b8e4ce8ff2addfbfa8706be29c913fa229c0c4005ca89e58706d82328ca95103883d43a84bd5703a74244e8c30a1984b77224a85b062520e10b1d3c8f59f3c29e2b5e208c08a248b8b4e2d2cb340f191dd5212aa204da911522492f837555f58eaa4f15965432c2a44fabfe24804f58b6e7702d13424c96052752b2bbc5499f5383551f678aa1e10b8842c7dd028a55e1b7fec0f3ed42622bbd4ca9ed2667373564379bdbbdcaea48981a8c8a3f6dc54d047d8bb8b68f9c6727bf545de729eb2aba337d6372248402e071d50256ee36d92c599a8895b92c04d2328a6fb28ff8407de72c09d2b21b4016238f39949427af348df952e332a890833b8f112d277797c838b9730148b54982c0288578b2c5f4fa24feed8fbb4ec87a057383271970a6c0265c78dde2608b3ea94d0293afb285ec812aae831da96cefd925b653251eb254407a3814984e66cbc0309613ed18535c3ddc8ec0cbfbedb1e94a0a5e7050d4ca0f3e4a64d523adb46b70822e4b36c94c7aef1d30737c3e511a88cb07b239df14eb5a761dd8791dc1c81cfe1757c741a4c499332194e6ccd15a9753ec5647dd32806ae62bd55130f1f53bcb3a2fa156e5690a9f604f9afb38d9664d861dd7a6af2d2f604f03078cc7509d15fcbd59d66f843dea26f92689c454fd0887298c4f52c0cc24d6df27896fa32aa568ef096a7ff789f1d6eee95da7365500a1bc2ae982ce417bf0b86a88899edca18994c2700c5ac09e6e8e3cbe05d13aed7ba70691122497d1d246fe98186e3093b42260e0660eed2ab6870e70542020442d94644563256bf38a19947a3021cdf59ac267e3422dec6fb625364172f0d0a408734b0ff41d2bdea0879dfefe022587b630e7f4e881cb6ac63f6c472e876e3331cb18f67e8d97e13319db6ff3cdbcf32be16251a7d0346d0dc3708c7c45c3b1956e45442a611dca8ef150b3fa7ccc4e3d3d825337248ab04fe3ebd28809ca968d747642c380af586c2a0c22d35b7d5ecd697b5e09b58dcf9bd90fd5bb03d0a0e3ab6e924f742bab439f01d6da8cc7e04ad7b124c74329515e5a58c78f47490805adf220d4366cffe27b523132e7896d7c2fc36312745220a03ec81e4d71d993b7da52332adc1ffff0af111137ba973a73eb409edd100418f1a0fd19d2289f728d4727256c58f1721d9527152380a8947b95f7de4f39d26722ef71135e7b2679a1725877aa8a654703bf7eb4a3ad45cf3c6fc233c0ddce766c27c014d9c9b1e01b4a7c7e39e92bd512b41335903634d6b81a4d4a8c8b18c69861974471975de7d2cce9c712843818031b91066a7a05f5c4fe2e4143fe89c37f11bb89145925849e5fb440b13780afb74fb42a362c28f52f16105d783f3be898819afad09f5121c0c11bcaccb325e58baed810cb6b4370ece896c15e901389e542ee8de3cb6db28df9b2f97a2d236864b2f737e9cd6a661887b476c3e273ea0c7f7e7d3ba1789c7cdfc611d90c9b7dd0f30d5e325b93a06782f642c6121114981a72300dbcb9672449287a737475d00ee4b3fd7d83b4ca07df701c14a777f4562dd396885cf4f7cc54bb09ac55e53480d9cc6ee4ece79b97aa373099e96561e937722c548fb74f28ea3a7a69f8053703422853cc9c8fc5650d928f31c87b4187cf68eb889d8c28c441de2a2bc0fa2216f59afd52585a4023e9c0a8729d53b8ec3a7c145a0490373a4bdbde9941ea21125d7a534a1f38e5cd2513f89d1465a0f7fe50e104ea8ea719ded76756886f6846259597bc04c74c87fd320c201fef6907e3a69891d68fc43531f315a83141b5dbed5e4a3854590ff4bd5de017a9b1f940ba6d5724d6c687b968ea6f604e07d63fd92b310d03386abcd59205dc1a4951b0078421580184d9358b3f738b89c98344db6b7c07c049686dec4392994e739a481b4e2cd5b421eadbcfc80069cce4aa70a0a8f17c41177bb4a5b719bf26248f6008474eb9ffbcbf4dd36445558acffc3a780752a5c6752a29b9a9306d963380250d6d769b6718c459cd524a7f78b71e6736dbc6aaf33548de6055062a96e92d172cabb0b91846b04308daaf6f4ed4add3ff9a7aaab36f726f50bd0ade402d6dc4381da2d9cacc01b4af25c371ae31a1666d75e3a0bcd24559fc941599d7645603fb63e02fb6065aba7abef0ca6f4dbd8df013fcf5e78e520","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
