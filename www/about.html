<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f5a837079b2ca82f5ac698ee414ac658ce0eae18f20bd240dce279cd466877f7c59444a21c946b1bb8eb08330a9b2f4ba6fbbe54ac4f7fcd285b0d12388ba12b54b04eb026ccab878ae775940551b7036d21ab0b18cefce8e001ff6ff298561ed0c6d54b95ce484bbc578dc5e7bee1bb2331eefdea2d71433d7a7add31f76fce6f978a4ba61f6639076f35a32bfb52197047ab70e967dbc4cd3d436f66111601a59d0ea3071c5c7179a9b2e63d6dab0c4d7acbfb6fe58d21cc2ba1b93daf9a10a46cc6d16b2bd9f1ff868bdeb26a08ceb7949b935021256a244d47982ee5751d14d79061ffc56e2e630f401a757f72f454cd99768cc00f7e9ffaa5e40df8c3292a461319a891eee17024b86952066a02d2e72353ac635946b756858e8795751c734d674a4c4a422884a581abf5fa3fbc2f20e2a181988c05360a66c88680983a9b85979b2b484facd6bfe621f49e48dcc292bbeeddcfe83a20b4e4fd576d9c8d490578f0e10dcca219cdcfec745e8b1818b51b64c50cae86b3016ca7f22d5545a1ba8d7c5c3c444a0e85c171a12e1d73effa708a4c5b69b0191dc341c55fedcc9d0ad312da56a9a268e84d825c3d6e7a351b2733cdd8dbb57e10ab4b32ceb4ca8a945628bc15ec7f378752a56ab6f239c78d206fb57727e4952d425ef553ca61560a6d83a595d774d7cd54f8ee74dbdb2738c681a7ac6acc5dd7961478ba8880290e2af8b92d7b0e65be54b4da7f570a6a9f6b328a1cdb2f22609c264616c052c6431ca81617aa5726f5f3e04611166a6e92bf99bbcae3011667bdcc6bc6590963aeb6295bd39ac36cae493004a23c9f61d86affb5afdee6d835069213050b66ccfb63ac2c63916a8daf6d4a532dcac0cfa9dfbf3b82b353d342a2a3b0d8ac2f27ef316910341b4ebb88347961c5cb6d48e523a3b7ee68472f4d9e5fb953269439ff584ffcf422380daabb15df359dc184284dd7b17835c0c02578589ba47677e96da3ba195e3ce7ff5519bdf7113713f4de0e2b43098add80403a8cd9de105d8eff94150bc4ede73abec320f029782a367c4118421332e7acfd1408652b4ab2bd9d8c428a30dccace371b4f7d3b5bd5b564349d29af29ec9f1d144327bf62a976a6452919a50c0ff4fec7a75160c5ec4e0f7056ea653ad9da54a63ec3af636070d341de8bd898691dad6c6be5893d1f0bed977fbfce899949f43452ca435b50991a700c63b1dfc0384468da1cb8877bc3e794ce57191dbba6ecbe746f44ce19d0054e04ad7d36c1438ccebfb33e4aaa9bf3f6cc7eb51c339d76d1c3bcc5235e865f1a41cb78066a9a377fcdce4dc5283e18101b6497783bfebd786a0d9c249d3189d3020b8cc52a92e5bb4b58c70d7c7b81a8ab74bd739ce2c696e6cf32cadd463f9bb383cce1f5b14a948440aa03df2acc5b023236d17fafe65daaca0898197050b9765960eb3e6b881dc3a049b0362a84c6f0df7678719a1ca47cc2c2f94dd37baa9d10099c1447cb0b83879c919d71b8022a2a818861db478d341b7a4db1bd8a833c522ad2c8f6a7d56ee9c725b13a322ec9e78d9d1fddf33998871755634c0262ee96ea344e0151c6233dda9474773419939b3fb56ab0b83acf88adc19ceb9fb05305f9285a38a3b4001aa9f9f882181b90d480442506f4d473c3bc96b634355510490c4d64bbc04fbc7fbab58c18c6b7def0898aa65a436b6b243f8805989c8aa47a41f78081d1f4316b10dc14c1ebe50759dccc5477c372e61f26da1dc0ac870ad99f54aeedf32aca57179f3d751c52c3ba3d92000dd25ef16ba0d28eea97321eebc854479b69ccfdeb42418a009e9567fe448dac55348ced1006f93eed487ee2e9cad99ef32ad0cd518e25fffbde7129a02db263ae03cc243becaa845b856e26c446d64d9faed1d83c328866a1f1ed8d8cbaa84b09ad92f8d3ddaa165ec81c69cb272026ee4a96805a7780d6ad9462619e5250aaa22693a09c12b8e1539b9f7aa7fc6e2e5e420fc443712c0b76645c8a8c56e541dca22ae98f81d49ba3e308eba2cc643259c8e4e625fb438df39e580b8919a0f36092be5cd3e7e8c6e04466a255d01e9468a5af2370b60f1ccd285536c1b3153e9d71bbcf702c503c9e07c409034960c0288f9099ad3a6d9e41f1c9bbd8a312ceca0ac89ee9be2931cdeb8fd12ef30212e3c629ef9c35ae3ac460d706f31cf6726fe08c5cbf7e3e49be4efb891210c131675737c51dad7c479a39790649e649baae4c7ae69d1f8e9284e52cd4160c70da00e658a2ed89c94568d792ea8388f602420b07ff3bad4730c62d4987c546764b1af43a77382bc6e300f02050cfdfe73df64c378cb428da99d13dee5049247b853a50ef7c47a43f7b0201729fc50ed2ad011a0bfe09ba0c22bf2d745373d5585ee4caef65c9814cb9488d0c462681016a742d971c97f2e2f8469013d6792f7ca01edfaf51d6065940ae76134fd0b57b554280f75a26446738176505256de4e4e3d9de4d9649726c2469eeea3aac107efb555396ec56775bc55fb35bc6cb310b0710e9787b483bffb978d5b18b674500ad0b0a00ddce39e77ab6714efebe908285783f2b7e0c6d10133a0418272bcda7a34b7396fdd12c0f4ccbd38536e599104ee8c6d4ee85a10a1c8b6f5ec4bae1de232a5a8d1e15a677e4c2a26311ea22e94e5509249319b745182ee796ecc457600897311cd6e2c60e682be2a6b19ddd8c6b3ceacff8011d9da64b36130e422e18ec25481325eba1cdb96902952fab744cd8691996aa2bf30668823c134ba1e961b8e0ab88824866787d6cbe406b06d1a867bc22165d6b7f786547076c70015f3d1d71a1c617e417f21bcb364ce40234bb761e17cade20caa29cd82db8125185224a4641b7f1d246b9f6b9cb8b1e8b0eda5a143f1db967b8fb2424494bd052c5dc4559000434cb29a20137a80f9ee8cf30f6a2fb47fdc974a916dcdb8bf743cb179d50b32da5e920f928fb0f5b01dbbdc3536591845c46d07f469743f2c735d4460fe2c73b7018f98460909698b837c7ec4f3142c579a872431275d1034cc7a2af89f28f1eaf4269aef3565ac694777cfe0d703bc9234c9c06cfcdca29703c7563672ecd756d4e615b96ce656834fc003ccdc661adb255aa51677d019ae16ec05dbe3cb708fd60510e8229696c5b5c3f71a4b1e491d69454b9a4f989f394eeeac76e80e923b71357fbdce00a2ac2a94272444b04d446b146b7e1f73a2bb145bba1211c88c8ad8194b8f2fa48edcf50181644a256d952d62d6e4d5dabe024d28484af8c539db6aa0c8690c7b232b4239b893b7bf54804153e6742bcd57fac20a9921887cdd96c0a49e41bd902fb7ac1b6cd2cae386ad051afed541efd63131e43470e73c227d88de91b7c8ffc636687f1107d3ebcba4bbff76a1b60ee17d9d4b646d0ab23461527eba2b922334bcd035c0bb23dfe18b18dc4c62b40742aeb2f4223ef0a6c86f758b5b8b3a7b7c4771464a2c9e7b4126fba8e8d7ac29af5d8576dad01af73153cb07713eadf7596e99030c9ce6cb4454b8d62d6c4c6fba58916772b3db9d6ebaf9ef1441b1cdcbea85c3e636ecbfcabbe370d79b1d01252451ef36fe9b6e6136648bb3584845d3a02209ffed66dc4b2c5aa3366b86060e6a7993bb5d54aa04768877846e92d08ebdf29d4a4f8c991cfb92c9968a41f8824c0c585d6170643cacbd8af456ddd6377105616ea6151cb8b11ee79641f4e13abdb91b7b1da92f2df4aa866da97e9ec70be746e82b2623ce9aba8e122b35ebc7d652c509fee157944347d01ada4ea52347e758913c601430cdacb0880fb44bb4e2226328d5af8fb7d7dc805846e8487b738e602f82733be7a666931982bf206bc811022343033888003e20164f336858a61b00d001a3549de171d817590159ac3ed3ec45c7ea9471794ab83f9763dda72cce6893922354d258c0791f6880ad7d56d0ecfcd681973d7a2209512425acb230c75dbf0c17ad1ad8758115c32c00a12a91d7b0936834b7d0a9eb5e63d755e9de4a6a784a4a89eed396e1cb2b7b9c2b4c7eeccdbc4036d0dc5d78c6d0a6ce8723e9b3a2e611ed7416319be67c9d7588ace17c74ab8ddc0c8fac3ea73fdd3d631744c4007fa349dbe4c7f9f2b53992a5a4e49b360192b19ebb54b70b7291a00e919e96aba9eb46214061b31fc16007edcc19fedf6c8a92964682b1d5a201a11e9a9d321ae393491c558cee8ab21aa8dea588725763d10fd4ae69c507a40519e4494da8e425e4e352a787aadb9f5dbbf0406bea780363c83e55d9c6e5151c003e21620efff5746de78fa8ef5a5b189c342c4974106f96243c20adbe8adbb408d7dc147332a94a1f0b7284434c4943721bcc6fd8a404a0bbc59dfa12475bfaf230eadf70477eb016c7eaa4bb60773f1e528fc7793774ca41b4e57347a6a0e5a921b019d1bd328044a8fa2bc7f7818d20fb0e2d09d77ba0057177e8e9694518ba2ad5df78e7248e343c135a43c2dce6abab5545af760002ea9ec17586de125fc877dd11f10e22eed95006845ac9884c421dbf585ac2c76bc6a68cf7fc08fe9f723f3182aa6158cbd9e63c175662ba07e4423f4b6f67a30a2b242764efeb0f35b89e99d27764464c8cb2937eb8cdf5af3363a0260079cf01b53fa035a6af4f2a1a7dc811c139b26d8c450e2be62d720c787760bdf266cc003d30dff19afc38ee9af835be9d3d885c0f88eb3eaef6ae4a074fa977688f8bb7b2053733438a0b09108f27ed11c53ad86d5e00f032308a3dc66464cbfce8840acdc0ff1a2274b5099e699e33cb59272568297ed1475bcba1cee74192b27b5e4500e92343bbffe4431a070a6ce4f9f24d015aba52953cb9d25828b2e025aba1515433bdd3d9302f8bfd3247b3cfbc6d83ebf7531574b603e3f14401728bd6c530dfe2db1a01c20145000f543205a9b9ea1e5f7b2dfeeffe16ae86ef4a50a1ce8facaa68a239240a91d614a8f38c4d389c93c35d4351b8a977ef7328d6a7bf901f44c1365cfd482a51bb23605fe99a7702e00c7f2185157f57d1914b1c6b88d57d16642fbcb7f225d050637e6685e49dcb03b24dceca227e983c068c14af6ffb4385547a296309a0d53d046c61819fc38478df1ba0414e3f99df70a553abe202639fbf6b338319a303119d4a1f21504ed589e0409921fa45d2863ffcf77728c94b69d0b2bad5105ec5cf78cf53d58043fa5cea05e1cd31ed013f70cfc470f6f8f09bb9afee78d97bcdc6a5e4c3f497ec305e41e0485c19843be626e66d50bb0c76500e5f0f686e83d0d1d3df6547227c646bda542aa1e1ed03b753bb0c9f7ea40d5892f706b9662b7b31033b0b7629286eacb44afd7c8ba4e5fea9c06fc34f8caf2b333e9cd03418138294d880013ae9091e6caedf8263fb11821c3b1ba898c382b8eb74d804ef880b4b9d82917eae41d6abe0d3c01e94e5efb0ac8efcdf4872d8bcb429d2061f78e56388505411c1cc3038ad187ab3d176acbd7f35adec69e7f11055f37803816288aa4ad96796fd32f71199cf6cbe05ff5999b1757282f3884a227a5f83923fa845e8187a6c4cd8a860077c41e9d4e0d82fda3dbaf1d13f4292b3c2cb65c01892aecfcf61614d82b84b3900b6577bc6d95eb029bf42f72dc9b051353b3dfcec689ad93f124ce6025cca565077a7da749d2baa3f66770ac96de887004a0d4b08124c87d70b1b4163130dcf172908c17e5d342ef0784238fdaf7e7d757d9eed2323b24163f379a5bd7f24f5a6522ebce4e755dae35c5b4ab86bef0fd62f5dc740947b32d931b54aa8c600f96886b09cc61af97777c86a461dcb6bb9e5afb6301bc5d2b984b212283c1d3579718bfa84fc75d47006f5efba21d8f8c5a03a7be81369798bd356bc2a9647936ad3d2e48072fabef587e22952c82d55d22f357a1b8d03e478a70423ac7530dfb743e96438e8d3a5f62061e8e750802c91e82cffcd00b5af8dd22f37f135f6f3ce9da269cfdd622a22ed37cca7b4dca21d0ce97003eb65cb70357670219503712e0804d2a6b6cadd0a9c8d04d3c27857036d0c937a76e81e02120ea20503c25d390ce8d20b5519d6c42b95e80fd7599c338f91c86439cb20d47c3cff1df980b85307e2ac09fba81eef7240f97dace536a2e8b8604f4b2895e624443e25ef9294213b0fe7093b364a14498ce692ee387e972c430753b362e9548e2fed7ba91e387cd4d568a646ba058ea5a1f38d5669c9967a5e4f3066d6675ac2e08f53f15dfe86e084825724afea18e838b878e9a0f239370ddc3314702e8982702a54dc3165c0d4b3672b3fcb22b54e91d679792aced207176e08df0ae85fc4b5abb7500f44992e8ddb8fae560fa86c3671055183d897845fa9e006c85dff1b32cb585034935b44f7fd3e535329f8c2ef9137199395ba06da04f0fef7f70136a2739a1c8c7bcf07cfc8268cf905f3c3f8a3467e1db6bfb2eed50e6858418ae8bdb8247bf22bee03241a37c3c05dd35bcb6b964b96ff0f7d89a2015dde7fb35f70b60f72cd7b03c269316d4bd78e9c0a2b29cfda044b2635c29be07eef0172f03ecb606805e67f2b2fc9684c629fae45be5e6eb927dbdae1558438c4b12567127b3ece75f7b7262882d0fd14032a2baa58d8d134d3d3962a69c76065d7fd7ee4bd672e04c64a6fd9da9f3622aeff66d91438f2829364baed32d53696e3a5f618d5b39d92c711db386391745b300f63e94c643cea168906287293c23a4aafcbde4c68d90197354c579b0723fcaf653a04882b1bb62c55c45b5be167f6d461f3651b285d4dd89b03703b4b0633b80303bb3a9b03093fe08ce413a0a0d7085d736ad0db59909fa35e138dd74b489fc147019443e874fda7b50d5c5b3968e1aa24131ed63c4467bc23cb5bf2d584042084ae8e5d0e00543e33d7672b4ab06febfa26aa2e707d9a314b6ff607e18eaf2c88980118d6a4f73bc25a3bbb4c46abb63b3a2539fa87a8cb9cef26c93e7776b646a43eb93ff1a525a9abe47c03584beba355824e339e13c3c30c5a96c2d23b8124081d040f7303f3affcc8ae84df51e35c3441cf9cb90e668dc164bca6b068598ed6e8715d45f1e71d3717757d43c6e53b9c96e0d3ad093c1c232b2fab1d00af96a85efe4a6402a874796e826a961e421c8e6f50f68519d5551dd0a154095cb6f7b130e56d3c4a64be079774509ac23c73b0a3b5c926c23b40821080fb9e88a463ed35734620fb94c68ba4a8c2750ef162522b127951ecd146393b5b9d1aec41ee3b4c00addd7a8b1232596572f4e425ee69add82b977ae302c61846d61e682cf2e5e5791b82c7f1a2e8bff9d7b440287ba2f8df6ea2aa490225791395bb482785446e1d4cdcb033f7df37037b206019ea5bf0d6b86333d3decdfde6605f2371570025d7a7001803ff69132f620e5ee460c638a5a63b62090d48d632e2eca74517355e2ea5fb1e51bdb0a89d67a9084c3e6364a3229076e5f13671c6f164e5fa96088ed16e4435aa6d61e1dce433d65cd42008987c7b1545824c71d4e6fa0270fdaba981ed88e5125e314adfa1073a8a1c8ca5434a3acaf2f5d6735cbd0a9877ca65a67d95b58ef433ca36c544e91205234bad57c07319c798f6aca13a9f22abf5020fbb9453f433e944bfcbe3db35e31fd64a3faa2b6c7b4eb79d9cf407f1de600790216c35086adec3ed4edd23f5a5a7f38ed6a264b911ab71c99fcdd32e53ec8e9112ea752867d4eff15599c952f1500363f5e52a0d0ceabfe6c393611fe8b1b353cf608f2ddf5fa2a40477c55359b1b7f1191890a67ac4a56a975e06440f4a9cea755c4d1185b3cc7973d7fe05923be60facfda163fe37cf610eaada1f8f23ba0759cc1991a369aedb340608fcdb13ab6ca3cf932b8ceba5a48e1b6588a4ea7d6bf902bac0a107cdfa61fd40d6fb06a54b67fc4ca27e40daf4f4ee9b605a16af754b87b99010cfa925eddf7cbd581ba93daa0f3485f7167270267c45d985268b900740d6c7cd076e7b8d3e5a5e5bae30603c9b1e887b561923990c2ee1a544e52c5c109e024c13cf7ef7561c5afa4778fd8ddd9343ff0bbd2f000c241d3ea97ca5532bb260fa607d89749e1539f9b076d3d65630dbd3b1d177cc343116262af751ba0e00c9049b98f496072b91cd07429d5b7a0dd5bb465725e90f677aaf36f9232c0924ca94bfdce6f9aa002beeb9d561c3e79b07fbee695c3160971cf4948a5fd1f0a0d12c4fbb10b5fdd6e91b02c61971a055f6255ecab6375fcab2447f17a858a893590f1e5c44d8add5e0c548266839554bd9f387e91c16812f8f1fa6badcedf59a1247f2ec9d628720d16cb90c5bae1cf43a38a7aa6580be90a0fcdacc20ffd12bdcf55434c943666a4ba50880e0bf8dae4345944891bb2fdb4dda186da414a053330dc6a4513ec41017e2238b04ba8bcb61dc5a4a1437f7919b5603557032ec7201472fde5a3ec753a98753967de4ae16ba1d27f3d595ada80499b643c6a847d1a4dc147a9acd4a633fda1469a00f0e611bf2546b512fc06a5c1a4d162971e57709a17333ba2012689030e156f0ae82f1f852c4b0900fddbc1aaa5625d508ee47fd622466dabc4f38d75a34890fa4baf895a92bb1ae9823d2f44d83fdbbcad30be59a79983227b3b8285bc775265267a3d20b1fc6deb993faf964d7a4342c3d50e149e653b9285d69cf4a68f2b642e8bcd56394541675a38aecac5307a32f6e86c634655cdc0a0e8a9e18efbddeab86d14d8ce73eea7252a280ac10e5d3a2dc394d03af0aee2cebdd0d976014e3f2a8bee1a6037ce1e6630fed4a71b843a4bfc4f84e650a9fb46198e7d0fbac5855ccf1bbbfe4a94b284c6d7ddd1a30fa9c20433ef3c5d60cac09c46a81a715eb324e261af8f765d16fd6d105a9f888b937199ec38dc95d45d1773c81035000fa8cff16c7c3d9a0fc351c88c7db82f03c52c669d2080f2d92ea3985fd956771836e3a11dce2af496b360d5b57bd359f67d57cc8119e4bd46d4d70984d41b47c3459048f6ec7d2088b408e631a21109a069c5d7ff8aec82a1506429472e003c27c452960bb37e33e8eaacb663b3d6fd49772ffe9c0fc566317880a9e7ee4eb988d4b3ab8e10f69f5192dbb97ed5fbbcc2e89d2a1444e96eb26d5459f608fd0f2fb2158b146d67e6075f291b5356b0cc873bed3b067c8400e984c337ace21312d05768602a7be9a7ae4e4a88f9347f787a0b1b209d60d59ed8f723557fc77efde46cbd9f1dbddb46766418ee0fb1f1aded219c94398047a5fc8f06ccbf1ea65dc9cefe980268c67a24f2010c21a4fbefbfc17fe169c9a777ce82784279a6d26629149fabc5198c3c13ab7f83c71f3438a5c30f08adc6c292fa868de0bf1f7b0d76064c4557d002bb95664b3d00d96b4dd10755c3f66163c1b89176a165bdb63fb6a56cc33b253b6e332543062976b7355155b219a520a4b314053988f9984500acc99b2885ab7625b2238b0a10466582b14c8a3b72e114c44e85290a007e3394ddb63dc652354491350062236d01593da90857a6b62ff5ce64fbccfe51d0d91dd65996e35e3491d9955376a11ddc642d19b023f77de53db07077c2388fbeb07efa8dfe5f9c84d65aa48b3a84e74c1d3b0da1fbd0f91922b49fd4e122ccad0eaa9d3da26faace935dad49dda7314d383b529c4c9d74d5fedc36ec9d38616919560eb96f1edfe503f44774414f9742a8ffa4880ee265d3a3a4fef5ec9dc435bbefe9169d9ba1db545c08a9b87e75b1a2a40bd1ea44a218bb157174edd3d3ef5c087802db2ac6ceef2f6d2b7d0b023a082b93273ec6636d0ea0184add6686b601886c6bbd92964ba6482ccf0c3852ef0327e86345177d8244402613576489be5ff28d1492b14575942f722294f73a69a25db29935d014b04c780c76da39b6a7d8c94fc030853bcffd4a30565f3dc46a5eb6b4c8649564382be11de994a42129d8c4688d3f502b9900f80f92a63eddcf91c953d78218d455f55fa03dc753de80e04e99be45cf7d06225f666f62d15d46276bbe59c2a4cc065a2b4e0705ff4fe1de13f0351be7da8285daa146882005239d313588821e98bc75d6fe87222959c77d4279cc3175ebec8b5f4fff08370ac0e585211081b494a60c21f1ad6e1a98d202ba201470084082f3935267cfc5879f5a8ca4432c929ed5789cf0a03aa156625f5d35b493efb8c62093adb78eecbcdef3217d72ef54df640be7248e9353ae75695bdcbe968f0e573dc9b30d8ff2974a5f00dd2b3ec1a054d25d49476c5ee29c302c6f1e259d242f39ed60db36474913d1d886ead4a83f392a5d6da620bf0845606ab5257bb086cffa4108afb87656860669ec8d3d44dc1547827a5c178c72eed00fe92e3901d90c1ec50973226c61b039fabfec556417c2a23ff0c5223547d91114456d8090665483878af0cda5b1b4557bc39c5461fa79b0f29c4a352097f4c6f6680f2a32c2cbaefd0e9b49668c0380b603db8d352b0818b80c80b7bde941c4a2846584eb7a6d605cf4b835c6e2eabcab227cae76783a6654ade0ece5efd4ef64aa52075aef8ba8db8a6dd7b05979dfacc47a9a88601275b187854188b7e722d11e1ee69d643ca2cf587f6014ccf24ebba2f24089334156163999a58d6e49ed8a4e76de8b4f7c8022b60a421fbcd032ab39e92bf8d3e33a0a25a30f25c5fbf36f2f6a61130bcf3ae786c0fc4d1d1dc0235c4520a6bf63e1c4e2cdc90ce20925f47afeac69480765081f813cc36ece535f4aea16dcda232867b5013b7763a7ef5684e0f84abd259b520ec459032fa79fe3eaf12fd8e8b0e2d7e3be56ffe5266b4ebda9987b1cd834ba430bb7ac9658dce438780c361e4392425fc0865fec12eef5cdf3f440efeda2ad8155ea17ce3065bb9c9852e26170060aac9bedfe632835e7f2d7f1584c32eabffa1bd1a960d7ab104ed835a3682ada5b83bf92628dd1a29bc00acaf5207f7599469c7e0f1057f636d8a46f31906d33b65d609df1e878f542c852c828ed779d5ba6f1c4472475f37782617a5e1b29cadfca6d8654572ca0a90cdf4af5f24ccea06ba69a262e90a1a95e729084058f4e8857902eede634a36f8c6f6dfd7afa1bb72ed5730ab9d62ff66ff2833b49af7943a5b7a13fe99f48d7d3d22cb96612457a67003495e9e55ea674fe52ea5d1a444b27720fd21aa549e32af35de333180cc58291734cd5ffb500af34ea2a3676a31d03102defe704000d9ca14feff8acce3424771d4585bec7d90ad2aaffbd053785f2c53a2d8c03c1ca959795cb6de806bb0f58ec6ae709ac24e15d394b59f27a68b4c9366cbd32fb8aa9ae803aa1dc85d1e7474848cbefd1be562fdd03074111e5fc13ebb34fb2bea7ddece865202ec76d4086fe77e218236c002f042379c1974461ba09d475914c279a000bb03419983cc179eff29607e2214908dbc24e634f36288ea2cd1b810fed454829013a32b386f40270006a849c986ccf456ac083e12b2a4c1e2c2735acfbf30f809b4c3bf4f450eddf19490f10aacee2116c7798d14d21444534f369bc137c66180a7bf7fa305a413c3fa9434183f3ba5f20deb6a696c0ae810f438fb8e3d02bf40386567d57e66234dfdd6a7a5b620674c6f93b358953f7f2e75a6879b3f521c2cc1b1a70576649fe11d2d26fd0ffc0240e6f9f86974c4b3257b2ae189ef8b20dbfb85f9df53b0f73e546c90bf7f6dc21514a4759c4ab89ef3a665898d4f33159f569497cdb6d1c1e2b50c2189629a4b6b76b5701104af3868324ce36d9bcdf8711bdb95b4dd72ac96b736c2f7c746877103d56f967057c3dd24e261fa191abaf225a624d3cf57e8867a9782f78c61afb25a80c9d11c8cdad9c116f0fa2d2ed95057e0c008090b1560a727aa2d01e9d069067acd0c82a820fcfdcd11ffb2f5fc4d172ef7de1e3158d1c6ad0ab2c7fbffe3dd88c2d6132a5c6d2265acb202bb18f861d7754b2d17b35476d1ac7be2be8182fb459cbd37135c861a4c1054bd8faba7c68c4e115e2b4f4e923d09201ee3f74666b35a6774832b5d8a9bf7d75dcd9eb43383953fa2867544d17805cacf722c1d3d2972f9f01b86a3c264e5ba5f9573cc0d341ca3b473eddcecd679f4994b910b80a48501558e726bba9efd354e8c5dc82f71ffd35e30bb7976e1ef12294b064e0d7e04438b3ac55535007633392cb8d5a60790fd68030d8a166f6456fbce8b58f9c7b4fbd92664ccdebf0266831bda8f0cccd84c19fd6c77b012413379a942b9b2d606ce49ddf4e7e2a0548c7ccc8916ac3412b0f0ad3f54a6cebc8e0ee8579b11625022850b99bb74bbec76ba0825c6bd3d38f2cfeb71cdb12dc57c33cf0bad1e8927fc006cd5a83a09bb4016b5adda9d284022b5e0bc1bf763703d5f2675fec7a8c76dae13f7d89f1fd6bdfc00d27705336875d4443259f17051c1f2d87c6c6a18c4478fdca2cf6c8585a1ca50ef7d9edf1e31be31b983a1712fa368dd0edb9f2cfc6522aed696bbb9188863aced1a361e62b1e71a138885b6ca51784b33bb251b08c1e093bf57013d4d0b4b8facd9c8a72f6a2ace0f003517976af2fb25aa686d675e33135b666f404cd9e7ecdce207df1555ad3b56ff71415dea842eab4c4970e693f6b0ee20baca4951682e5ece143c7ee8313442bf6c37f20284b5f7da017e6c15b16c9ebfbf81125d9b1d78078f483349614d96bfebf139e7abd5a552183f4f1625c619013fc1735a0731531623894b8d8058c6b8a38f6452418eb0c85d11c6f660f9fb9f949466997be5d14ecb026239715332b396813fbaf259450bd304b4f5f6807e05bf5d0cb8de8754f1900b54661ac26c7a303c0efac4f508c31ccf7563dd028cd3accd610a6cdfd5822235509672cf5aa9b95ac14dc4e753a06a11a7ea7ae28fb684c63f2b423b997c089438289b521778a272cc572b4002ebd9a8f31f412d15a27e2af42f0fc3601adb1a13419c6519278b71ecf1ce9f969e4448508b988363ddfd7e7a77b5c0343cb1b597e34cf919af4db2589c8499d30e306ec76d87bdc629ee0a8a1137d2dea678c274bce6a6000d87c016c4940e125930e775cef16c8542d2859ffed496ae8b9a6679b5feff3fd8a62332d81c7e059f2f3c1c88ff3ec484b13be57df0fa28bf55614725cd1781d46e5a0c86096481064f28a4e3e13bbd49c670ab818a323599446884806898d04d52612216412e2791f0ed85f74e487c90e0618b5f5eb8ac630817818ef0e1c356a6961a91cbe280b175b0616b03c6b8f27496522660740b6b516fac31961ee43a640ff3f230b54183be00cdbb676f2adf7e99562f8fea6ac4fce97511d8db5263949af5206c31dcf09d9b35dcf2cc2ef6d87df1ed7619ef8a3daa1195b6f9006abf81c301e081b06fbf6778f2ea7a4092859e63aef5a04d5ac42f96bc414da31477787d6015e1bd1d7765fed29cb585a6e63e25bbbd89a3e7bc7faa678f7cc4d53f96dbe8152ab71c7c6829cd0868cd3cebb0239daeed57358b5783508c3bad3c30b718448589bae17d484db35f207890c782d2585fc071375eebc6bc0b3e259c3564c135c682ffc7012f7fa841d75af019f0162d09a80670e60dfe6a109d8c5110e19f3388941e7fabebf6b0591312b94f4a08056d0b78504f7a829adf80f8299fc5ec94806c3bf5d76028aed565720748c4de0fc6f71ef149fc9fcab6661db9475403125ff771240649a3f2c4c2d53e67fee3ae1610f77be8dc7158817f59730e30aa1fcccce327cf4b907eeac7fa2bf4ff3e21f9afc2aff3d997fcadb76a84d14f7a8fa80678a32d6eeea05cefe7b29a30ebe7486b0149bb293d4c912691cfc8773a234bbd0c53eceb70d3350336cfdffdaaadef86e5dd9cd75373d239af8b9f4a2a81088f4ac5cf23404d2019acac3c11909a9f8f0b9112182c9161c7cf876e86ec5e276ed4bd996da29f53d8c8d608cf18681db652a5a1aa7fd77c70b91f288cdeb84d12d48a1a41b113159d4cc0a141a39d75833fce4aa10ef60d02a81e5ce55ba4f9619c3584103f926a565b92d1f81edaf13f1b85812e4f6ecfbf708af4ffedcb2d9a7ead6c5c7ecdc868a362b12973203e04fe7fcba136557d5f5c5d0fbf898d4b9b17245f68224ef478a19e5e9341f5de298f22b175f3910efb046ce3284a2f73865cda63a6191cbc06346e4a64e01c785a5c317df2ffa19cf304b08cb94984e1dfe11501daf56c89692b1c7f5a9a28cbaf5f1ab850c336626771735de39c387aeac51acff24f046ed929fed82f63b0a03291c9d71c66b003fce93e74d554e85b5e24a1e7b5d49f0d9460dcebf34965e721a8a30478a16825a6316d3a3428c02df1de374544162e1c0a571e59dd9871ed3c7d21251c6c46fd6caf19cb9364e62cd3eeb8fca2b0a4ff74b8773cf46be25317fb5a233e9ea85be9578d5919b9e17287831f6c48db39b2702632d04dbc9a95dab16ee2791f3376508d3ed2a52f3415e6970bc18e30f3e850ecef74456d442ea337e1b2474ed1e6028429996d78d75e3468ba946a9a21e8fe056358004b1c4073fcc1559f979d491e8fa6c4e5c37d170b590317462aea7c55a1b4b149edfb183ed5107e03a97e61de59888c47bf3357ed03718ea6bf737f56fbf7d198d43a4be69f513cff58269f639eab2bc2d67dbf5369af86b89d41f015393cf5b95347b9ee7a730a64e673a2f02d1d4ab5e789c82453a195862e90cc70337717ac447208ed4968730a1059871d89b78748b17d14a6be43adfbc68ff804359cef9902f40cb5f2754e9e8b30da87524af012f093b3f1f94edcb661df0eaf92559aabb3e10c3ddc998b67d41a04c2bc9f1c5c0791f58c4d05b8c22f3e2ddb66a9ffc4083f31bdcf1b9580cb7056ec1a9d44f10e11aa4ce7b97005a7b82a4e175eb3e2a94419e3cff84c3f2edaedabfb9008658007be29902c2c5e37cc135a66eafb765d4077c48a51eef121bf3c9337b235b8580d1e39deee7ab7536e387190d94246ff7a9de290f08095be84e526bd55d0fdd7ca056c6b60016b46fca1f8c015783aa8fc4f3d37b270d3316167126475e138bc8b7eb95c87ecb66405c0ece362c9ef6e66717e3d51882b0201ca6e4790507e9e57659a777eee0dbc618ebe823b7cdbb727ab187d1e16b4ad6ce6314614b2dde1a383ed3930107b2860a7ef22119354ee40ab7128718b9320517a65dffffa3f59198b48b2751c93478e9fd9114467803a02bf2740dab4d2db6e62b95018df52f27a354a9910f6178f1d9767050d0c6980015cd4f12a7cdb3d8f06ac600a6d273cce9501e7a6c9ee7730a432bde27cdd0e2b13760b5e74d673378d86e652afa245be45dd8de136bb7870311667f71274ec5e7cf273a825ea9ea21b1753b30ce42cb3b069550349f179377ae4da7ffa2199dc5aa63305e375e97cac70b3a01e5a48258697f5469fe702909163017bda40e452296442c48c4505d75301fab05a826c5febd9c17c4ca20133748599dbaa52c7387e42c974fbb38bf7229f61dd1f3127b6600ab248855690b53d8fdcabbea6ecec7a5975332a7f2ff3846794f140a679d626a67dd14fb5b5ebdc0649a96bb2e44c4179577d1cecde799fa30008d34e3bea98c475c5b204c73cd1b239aae8fd40b4016d17f0aa486f55abda9a98f6fa83c97878c29bfbe2dbe9832d5c707a7675f20016738d2e9c63b0b2cf69db57dc87253b24c17f97893a247fceae0d6e941d10632698b53fc84e6410f2715113c37a6a4754dba0ebdd2a7fa70e47139d73647fa1a6dfd7ad0e0178a9919259b9879b984661f4636b13670637742de36e81904e1e755b47d6f613db1b7985dee8e5ba155a93ec424a7442f4100022b985a5d88875eda889798caa3e0470787243ad1d9bab049b39a8351f4cdb27a6a1beb98fc5a388d9527d86218e6c78a4cc83261a9d19d880bc15c9281f77f6c16e20a5d7f2258417351153efd8f4f3ab9ad845218f2338ba7366f51cbacf126942101e0ee5e96a54ed3bb58f84d4100053a936e1b6d081cb3b07a1593929b4477775906cf6b33a8d41054a30dc5540d09136d87e70fe78d1a17cbc9dc66550367449555b5f3ee93f5dea0aadc4ca5f567da29a44fc0c2b65b847e2af6c3f5e5422c5112d4f863620794b65e7cb52cae21f99f8da75f40bdabb27039df033c28b501c06d560b71e4308dcd525f871e1571c91a2a5f2ece61f16652124d346a0964acde6462f066dd1f75f035e20a593dbccfc656b0d6b9eeea813967df9e45b698df76754d319789d2d89ba0adefdd3fcc223ee485d9523da3c9f08d0e9febd016de8af9d6e8a31832a17661244ed9b185035824d3d61f9c37d3d4925db9c7312f6eb976f15eb072812e66b9c424e784e946f6da156c192d283f78dc220c434f98dc0a88aa60c2b0a0e5729a8c54d935d434008c3d27c7dd61cf8c59dc4d56764d2f718303d04a4166a3f0e3fdde89fa0d2d76c146cd081133a029365bcf60c06df2ae1f27e5b1274b62df44675f0635a2ea93e3763c1b6d4c73f96ed6e2a3054b1b829828cc9acb4ee84e44d02c15b3028061b51a3d82b221eafc3cfae838353816bb1c89be7b2fedc2d502b10e7510aeae9a3c3738b4ab74ced42550bc582583804b9fb14d7babc7c22f36e5600fe28411754ebf09b3be5dfd605f5ecd22f43d3990083203b294b37e2c017f1aed65bf557b253dfd84f94900d1d58e856f222d11dd1cda742fd8bfe2d554ee31f78edcfe46295a0bc1f06b46a38b773dbc2ae26bb8fe566527ba79069f3a92f4fb8e9cd77b483c0fffa152e4a0e9ef67a9ed953bdb305c3fa003f7f57bd0ffd0bcaf83efd146f0d48a538e40f031a74cd95e672989b2803620d55c3a7d11239c696efd4d8fe096f659074627390e8f3cb2540e0a455e0ab7aa5faabaaccdf26d0ec800191cf28460601eaab5da05d88ae8893101cc9120e6a8cd8fbf1282808824fad50a55215b6120d8337d5137aee23101dbd7af84977cc08b2cd9a50702f63483ef3af10df8c0d861b280ef281731f48bfcaae0740b192d3d48fb7fd41f166109d6362c29875d4d299221036ac76e2a705be75ca8e15612690e96d20b6b190865be5b44e66970dcc34f373283409cecee15d8de4f168f06c1508d66d9bb2bc4d5e8a0b9111e94343d12145d87525467f1f9b17a01e2bf097eb86955476614563152f6b21c1dd20b02dd94a6b93c660077224d076c212764318ed77729578887d969be507b2a3be8bb5f09669f31c6254802d45ea5dec8866f2959eb2682bc5ba39dc5494c08f446810f8928b9c6710e0aa218d852f63d58207343f6ef03dafd96ae5ff8db834285ef1894df36ede316fa48d46ade38ac74d1b2072a5e0a8254662de91f2d05a5fa87ed8f8442db4cee3c1be151c1febfd6bd43cedf8ca11767494dedba3f29e107cdab67e04ea12c138c0997fc8b81eb4bc89fa6be2e0b64e8ce0d2a7a9c93a4506a8b62ae8bc47872d39e88ed44d8bcb7f4e2275f0fcf0c5e1f8a7f6bb63b4885fca09b3c5465865ba73def941075fc1b5bda936b72c6d845e71d732057efa02bc0e40306b9aeec77f8eda9ee5d58475bdf406837c9844224988e95330477bcd97ff5d7ad118de00cfd3264fc8d881701c75a27fe050fe383fc1a6db6992e73bb6ea5091a662b7068eae88da84ec72e0b8f5463769266aa27d7790115253d3fd3102f219e962c7a299a9431adc09b7c08b636754a3975248003e051dcfe9141caca4203368277af0d7fc5467d2f4e4b6090ce5ab59b7406e5a8393d0bb6ef8a218af6d005d5422a79f26093539f3e195de6892a54b866c971b8d01c3e821c205b6ce0e99feeb3fc4e7efba8f0147d6e68e10af399ca171a5ffe23a10996c911e4e5671a88f42b597ae2910245c52bab8302a9cb19d43e7eed32225660858fb065a755cd2b1008e2d01b2a8f059f793ed3e6d85cdcd95fe9aec5a273772e9911f33418e02d459c186213386c09a766b5f438922b4cfe95b50c83bb737d46ff5fd9a9014565541faacb2b2b36f002570b75977ebdeee6b72541c9a00ae1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
