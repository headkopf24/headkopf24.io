<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"736702a4a0ec270d117576d965cb25c89cf06fb5f7f03de910ac82e09c6995833005d818639f0a814b6181035436771b38d3d49c1cab22d12ea73874fbdfd2699f9499deffced1ea8415f58ddee5bfbf5296523e94642fa3de38db1498697ab368784c97e6b6552606fdd0354ceeb7213086dce5fe4c79383f847806bb90c59d50a889f193cf95dac0b65765f68e4b3adee5112452d179fd050ecdad08da406c82ae13499b83a3f894b0d274ce13624756809cf9242b07d634bdf8649d5f0322d3846a052bb9d149bb6efd2d9cce2ff5c630586d4fcab1e171c28b638d7323dbca5c3cebbc7056622a2f947f67f31344a7c2a275dd4b7b0fc68a018f5f1b896dc791a86b1a202f7b62de4b8cd93fc0c55bbed97f893b017d142a2dbac124bb8c6e8d62fa6df62cb012d78700e4f27300a621e6016b3c0fc91fe9fb9a406db86b21e5a22c0895ea194197db86f4d28aaace8e49fc666177db9b296bfcabd6af867b70a1ef76c1f96e22ad3a339be28d0ac14fe98126a4e3d96fc3b26cf271d88c7391328c2f273bbacd79915cb6705280631cef64274e58dba655643de869356cd1bc8ac6f8766a481ba5ac5a61cbaac561a9978d578a6e0ce8f0373bfede4aa76408a7a29c007251db762071242621afe3e18f23abafbf19836919a2da198aa1cec3c4e7af1cceb154f3c9abac62a5e6356b209689abf45fdd1543bb5de74a096c73f259a1bc8aef1c16837d381b8af59833bcaacbd8ee4a7b341c50641c5542b5502c1dc04c838984ac44538ee8aa1bd6b1b21ee025202fa20a6ae689c356e0d47a4679a067d7b13a0ba563ada896b4fb0a4254124ec58ad95ef7a06a2b7315914d937970333dd017646d402f0518f31878b0d20fa901c32397868b64d72ffb9f19f45b159472c7e19770f9283a9c663a5cd6ba9434cbc7ddb9c28e42df470e53f12728a5bca815004739c749618c3e98090f29c648fde5b4a74c41a40dda3075b31259fb52807ae25d6ef3fc547aad9f037615645fe930c58234c078e13bbd06e0fec738408b874feb9cb75ab84b80d916181563ac911a0460533e73e19acf5b7b04d90ce589bc4cd9ac917082c620043972612e3e8bdad6a5d2b8160ee7fc9107c25d51a4e971f27f8e6c12a844917976f37275f48233a142d86faf871b2be6ddbdd5af158a1b8b29c8bbca2fc824561be7f5baf066ceefdb594aefa61be0d08a6ae4cde895b69b10381042feea4102ae0a9f31c800e60e793642a390b2db9b4fd7c76a04eabae8e60312789a6b7cd643e8e265efdfdae1836a34d7fcdf1798170630cccd2100e6562c41964876ee56923214546beac46afdec480e6be5e0a03d835f4d3120e876222d2f07dd6d1c9b3f0bab7043e9a3ebe562e36224c2604c950b1a2d58b0cb2e32e8d0d758d983ae711e422de99e8680e3e84c6970b2c501ccf7679c72db3352f01a3776f7e8b6c2ea465f2dd15f0fa513a5aea987626d587ec2212f9b68d7152d4dc9085141d27cee4e571975ddafe990d5620cae019569f906b78c88df1b9e3bb567cf1eb2ff50901d8dac8de76ad0cf1d56ee958f60f8b211e5cee435b54ad10c3d451483aaeb23d9e2c037d61af853051912b82f7fda076d88a35b71d96b52f19e7861944f4cde9334dfba1148e61f5a7f95bda9e85260a3f8cf6338faf68869ddec2c2a261a3bdb875553809a6f5e8bf704ceb2072b154d126afb6b9fbed78aaa7ca299dade5aee32fd983337bac12e05f78674066d0a71f89a67d1ccaab020bbdce2abb6bce3e366f8b03a53a2f0823681edbbd74273622b596ea017c95eb2ba7223308e686f0d145e18c0fefc86fce0d173db3cc9db38393727e7d156dbb061cbb8a4dd97692f1d12b463b5b01a75c9bc0b9365d9dc808a9000f36a83438b7085692e6add215bf63ec9203878d5f9380999a6b20c622623dc5cd90bd0cd4954932cdd9cff97d8119a710206658f27e62fd6c41b0cac9aa1133dbc63ff481aeb78b879e3824d02ac96ca66ccb0550940ed1e679905e433d1c4b512ad1aaa12e35e8f32e2c122597cc4b6fd1db2f42e79fefc9c44bd40db22a39520f1eeeb5dfdae5f503d05a4338ad30f6b4482a1bf6f1196d79c151c3cd863972f95c6e9873efd1cf57928f765e43e58a0a8cabd26ac2ca130d50be5022af6c775db8745a24b357451469ff897a8f1faf6fb402d7ac672f7829e87c5694228be5862ef53008fa979f11fd47e28b3baf628637735d26803c5d1e627ac1bd29014357fe60c048dc7e828dbd7ca0dc2fee23532de359c12d82eecc89bb4fbf443f3c1d274180f1b1f0b75aa1cfc9d5750fc8908f546089dbcac040ec13190780d43a38748b7792e209f8558586b1f845ae0318af9caf9cb9637fc0271ded43b214caca847c81c651e0cda48b63e7d23c790d7b0d562cff1fea23b363463561e1c41aa8508bfa81f47d3579dc6c8b9a4cc6dae7a5def1d76a20b6bf21f08c670c9103b154f37b7bccbba8b8a6c4f005269c2119c3a417c0bb03a0a7ad25bddc8ce4caaf9b2b936e55ac4f778e5a2983d1f19fa4544dc8b89c9bd84fef5135ed2db55ac9e7d852b8e47e1b95608d547f6ad0d7d2d025b3454cb95075982b59feabde7a522be75e55001a77298281769e21eef76faccc1538b80a78e75cb3050e5e9fe879d1cad6a1e35071a852d328a7d14ac162d37d78df34aa03ff9f64291c0170556ad72ab4fb741081b1ea1bde41bfb98ed99fc61fdac8439c434bacc4af15c3dc036948bee8e569a6deae1d115540011e7d87a35c383de24bcb1678cace66dc2b276cca8057d2decae91146ae425dee7365b9760d143fa57364b835b1011bfa1e8bb56d3aef834e19e98771ee7268f9eb9ffbdd209338c400da0c9becc0e9c0fd232ff6842fb5144814582eb689cb85a77617313b09e83f99c89bb9b9674c3611205402c5dc5d709f42a111d6c3d995079d94178bb0dd92bdee6bf08cf58252cd80d8a0795725c293f7961bb47fc282445328ad3ee8c39c8bf8a1acb556da07995e1d600c024a2d3917e4e3c5fa811c92344eca7091d3a15f3e9715a31891e8e90b7f3b58ecc783ac117b73c057f626b725bdeb058ea64f1ea41da07e9a7d5769cdd64a9ff8c429b241c34948918f9dff532044a2bf40f3df0930d4a9d9ff9d7bdcc842240a296230d2b00340938f81b786bd13f21ce1ab45459184cf97f245d4906be5bb5c99233e28e3be753bfbfbf331b6d19f9e7a608ee81e164b8ad54b2179823b4b8692cc7ee608f10b1f5b6f1cef3bb5152143d2939a029c3bda2c383a68fbcb6159d750facfe21df943007ddfeda50c564c9e647a30193881cb0765c372783c7f973f31ac4320e3a267d15f878eb456bbf4a53cbb7b7ee6bfcff9a3a235e4aceb7a0a15fd6110f866ab1dfd4fbf9089c58f0c3ffa53cd617cb817354caa78a324da503c43b4a0fd93f2f9097eabce42a2a0bbaa937e918e408f44e45f2e7390cdc1eb848aaee4fc03ea90813e3d0de64b6e9b9c1f5cede3390cb9449d4990b161b31b26119537b152cc604666797a00d8116e2179569c924565e729d3906e42a55fb2e3be9a2b666e6525e873fd8326cc26b51b9908397cc94ff623e9fe4f7f80fcd1a1678affe1854819b38bca095864309ff61e60fa8a669afbc894805559a1b13892051f0e49097f502fc65d8a6ef4d4e002d86ae1e8d3250c5c9e10c2449e80f7ceca5cd45cea0c6c57e9116e0fd7f29223567bf6726ea23171f578784ed00335e22adc075ef2776d54adea81591f262977b9a86827d7f750be61ed8bd55ecaf73ff2d3dbf7abc58b667ef68d5645eb626daa2a8f2ab2e3c66dcf5f3d0c8ef1e09cd63f13dce3bf395eaa7e98768455beee753d41c5c2285529fdbc63fcde08296fa6aef7d7721cb244cf6a2274731ea45a35053b6a4d711827d76ed9e74869ab3de2acaca4131a79c42c53bf3dd5331e2947fbbcfef6ddfa237b13e717ee0c80cb47135e112545c95dea4cc4e6236088c0e1ce8d198cdd30e842916e780d28d070b6fa38b396a58797f52ba7de8288cbd9837330ab7a22cb9e3388a9f69224b2f77afe9540b96383a3821107f73a2408883117db8271d26d2b68aa5b581a8eeec94feca3af1ffc50a0975f637330911e3dbd7f6d3cbe9379362dcf6ee27d7e0d657697c3ed67cc22ed5327924634a89a96bd689cbf72a5978d1bf1cc3dd68ccc0e15ef6f998e8714823faf4bb055654f10fed24f991a4bfb00f73e0877f050834dc2db7b9ee4b6f4df918a987d452d176ea10b7456cdc01308deed68f017aa714fff2410e4915179e4860949e7a96d3754d7a65f662935a3fc3d087e3a995c354feb6a6d826947983213ed93642ea42a74e6375695148a0c811f84be4524a2541cb9a414ea339f35b82d37e93164e02450653349fbe573f47ef87c8d0574b06c0d1910a41bd0ae75500daaf06354388fc56ee84e84e37d74120e7e23fa850dd6a119e5b72a1721c1675820373772f7e339bd74d812af8f1bf7557ba7ac0534738b8f0051e40a6d4bc6d6f6e63cd30302d985b2ee6ee2073ab832f4526a509f8b5a86425de890d6ae477f07f83fe8567502eabf2bbeb49916743791c7b62aa6e6637c2448269ac95a60138cad1177d6002ff12fb057be7dd5bfe389d42efc220e460c03c005de366e27b0c0a935356d77644fe9018ba8ed49e6440da6966fa30eccc192ffb3f3d37005138295bce08e13b5c2a49950788c33fb50d996a034b92c1259d85fbed00d466bb9bcdfeea65c13cc4a5a351d2cdb884f383fc6b231f2848a4633b3462b49ec9ee378d43922a101d4cca7f29cab872c24682afaa1bee805cd8399497c61f1e5f7509f401aacfbc9f01d721df38d6010bfcb2e408431a1eac3ce6957a38a986941c28d91dc757e9b2bc65f1ae598f0ffba49112ee6420cb83b350892cac9ea7ed6457e3370aa7a7625e20ca324a9be7037efb0fdb3621a9c31450d2265b60168f7cf91c3dc53fc56ecec15d29978db343d4a92b69a640b29be6eec5c1b510938ffd2b593df48bc58579758d0248e719696fd610c5dad6052a2e49a3d4eb7b9e94d2ab52641f07989da5b9789e88698551bb7fb35e7e924b0b29f7a4b58825b4ccf5c030c07e17c5c0e3a82363915122edd4c040671815783283d81f104231c315645127408a6bff37a2f52066f2f1bfc772eee0fc51663496ccaf09d586b027cd50ad3b8ccfa48df193e871ad7a2e02b9bdd68596e243a4ae04b40e94735ce3b27b032a6f875ee931986149fc705ab09eed1545de8498e4fdee6049fdf3c26e1c980abd871520420b5d90df7d92e6145a5608f5820380e164e07c69a1658f843df02fbd5e079f591ddebcdc5e5409b5daf6117b1d33eea16b81a3b2c4be67d574b1318dd922ba5984e6a8009745becf250d2468620d23112cbdedf0549df329408723a7867158b3f6cc4d2d365f40d9dc3e4617563755d957789c67eff2faf0b006789fc87cac25dcc0bc1b8fbda967deb23b333b09a52f6bab92fd9c811f90573449ea16453c44e711e035b0006eed247549ed36dfa299d4640119d15a4b8adc0186d2d58d749122ec8d527bf8dd089ddf77097b062ba85a4834b84c610152f4bdf2f9df85765191adead37c2fb0f1ca8547c717a750520219ad5783b70f389958b00f239304065bf259171e8845e5912c6b2736c6f3a45bf6e6123ef3aea828ea8be6195a60b7bacb443adba63734ae2bec60cee2ef405e6ddd12fe47b9afa66de330969ad7b97e9c0b95359e839c33f4668e1f26897a791c671d770229c454891a9b1072a78ed7993efbbff95e0d5fca7592d0c1417fd3cfc0cd7cbbee8ff029c664328450ba175548e45ca24ac5b47cb45a80041f53f6f6829fd200c0947cf18b002d0758a7605bcf61437797a2e8f5e97e6358274b1315ce4964cd7081dcfa617810d99e82258672d292db23e860ef53df26eb3054fcb83e7fada200fdcd1f01d672bbcb4e128ccfebf68edd1cca279ab3a7d547e02d1dd6a5e36dec8d86a39033d36358a93da2827ee914da652e7270809bd1017e461b72e21d7bb499cb423b5ba8c533bdda51546a1fdf340628af458e2153ef3189b7f33697f5a882af2fcc6606d7db9ac89389339eb44c7a1fa4d8ca1512dc7d3e832181b25fcec17de5061cbd47fd5348cae5df25f21407461970bb0b21af531a9de0a2d29b84d65fd2965370f2270177c2b9496b186cc2224b4ceb557fdb69cf0d47868ab3280377d6bcc358892d6aea8d076b3ef469bd96d9384768421fab23c3ae8f4d392cce55a2bf25528220a3c78561ac687c2013821b5195f52c59264ca2369eec7e448839b23c2337228b684386c4967efcf55dbb655eacbba257f47323d93d1966708d1073fcbb62c7abb47b2167cc06d0c3dda6e5765de86a5536b32d073ebce9d31eba1f80055c73018693463de24b3cc1ebc61e1396aa93abac920620c8a22c3e6a8db6d4f20acd7f1d4d9e29006fcf17fd9021ecd76bd3dc3af50658cdddb3f564fde73073f9b0fce5548eedcd81aa6994a0ba89c30f16e8b931e7facafb4b51a2da32af6afa3139e8335fba514cc8d8e49395282a6d46b555ffd8e30ffa52d413530adf750e6c9ee7b6e3483c0349a69da5367c98852cc8a75074ab92ad8b772c2ff98179f5f16c5fafb7899060f95c05d25b0711c16d564e98a19183400242e9b2531bdeda6fb832a671dfca265e0c1f693cbcefd6de0277eb4dd6d1e25ef4a6092940f079b7c687d4bc33a8f1d55002fb79bbc25e58612e86387a18e4efab5755817a6a4f88b254f1540d405afad595dc9b368d83da4cacea9da66417c3412059cf041c730ca26d2a5b716d25db9346e85a46fef6ac0e5576614582d40f0de7825bb2a3792a8c89efc9487a0e5e6bef0919c16d4045619f0ec54ebb01deee04de6a71d206af2d5f8da8fbf2ff9e67d182f9a39daf4ccefdaf8c399b4f3af0c322f3ca4bd3a1801a7bb6333284558a21bbc78b8d59d25d1b9a11b0900da101a2dc2d026aaef500c20f5ee1b6edf80bab827ffbacddfa918d7e5538e10aefde44a1087c20a28433b5c7cd48307fe539fc75331b224ac4411aa56f72c2cbdefb9b861e3046f620de235d97d7e5c384a8e44c8978907999d0a0894d1ce349d086e9e6c1d1cdfcce1db04b8d2cdd1c805c657035e3e150e497babf1efbba70885dae24aa5413ee4ea75077a29c253aebe9b869a16e31ab9a53c5efad9f5172b3277af7f66e055dc835a6b103f89ac3fee2ed22fd9e4b8ed83f36d23a8013ca2dc284470ab74e78690951349bd2a506ccd7c690aa667e62976e8c99cb5a04a34e71136d0f6ff9b2306237785136860095374ba40bf55d2b7b218f50da96fd5160d9ffb3f377a79d328a3b3d41703c353b2dcc48518ea1f88b4e30a6cddb2c563d44d71d3eb58bf254db55774eb33d60c5bdab43607147d1c4dfc4a962d63b50470fc5278e5e37493b5318af9dbe5c2aae10614265ae7e71e9ecb7555a42c691727120c73e4ac65017762d367d6d600911238a49112e9eab94f334937605b5089f1b9b6a676e733f9dd7ec927d5104ef4d449be39d9d15c803ac461fa0e2bb9658c62543c064b7d35053eb0fa88879b33d5aef22f87aae825e3a3b5dbfce49b765a3aa77c25214afdc871d9d7236729f6b10bd66f9970336fab157eb863f68324f1013c788c71b193c9e96bcfbffab2eee99419735113c31925ca4fe55d3a7aab3b9a55eb907a7df8fbe0668b9d2a4fbecbe031bd0be00ae67f34ea10e89f76bfe0e4f1db267a1293decc3c4b654cd4bad79f2cde4f5d386967644d466732c7cd97e1ec0d9f5cb6a44e9a30caa2741068fe1b1c9f83f7429f30fb88ae3ae2dbba8bacf91eaa6385ae7a8a8ceeb612c24dc72b9d14df6ac0112369ccba798d9f8ee0a0f44050885b2b9e7c46996d30fa332e8f0bbcf0d45c52f4ff1525ae92034a724ff9ef0c7027dee1862f6b8ce6fce00dc4d6b1c4d2b3e5db215264bf19908dad6a6772bba457e00664d09a80ccab6ab77feee8bd1615b4c1aabe5446713426979d5b3746d5309f2ce59a8be986620248bbe9f7f11798af63947f7f050ac148b6e48158e257973024d86802fe556b236a0c3bb96f7d1bd8f5ea5919f653f86b4740e23ff2b7885adc6e682ce94a4a0bc845afb62dd102255eb7f3ee1a1ec1916333efa308b7bed78800160378d38b7d35b790921dee982f060c2d729bba4aaccd7f7d1b091712c86b6de377d864fd15b423149d4c2e108b4c11f031a95d4652895120e6b9e38d793652cad4c1e21f76af4e33f8180fd42fa7d5f284bf0346212c66473515a189dc49205d9680da78b0cd35afe36dadd2d5f3615a20c6f4f071bcd24fc9c3e7b738ec0e372bc9a61caae6d65e3c4d76eab3a74a4c2e683e732333be0cd93c0905f16b7879641639a4a9f72b5fc4ce58af4e0a8ec3acee91117b88e0283469b7f4c203debb9dff5749126d28f3cc2d6a6ec6ada3abfa2fc98b381ad902519b0f8239e011a72e902d55ad9dd595b518dae1f0bb41b164fbfabab57d55dbd102b6ccee0155ae4c9276ccc0309336567ebc93d23241bb0160378808cdbf1e32a0e43630fbf9b1190dc0f22d220cf9a4bd631f37ffc28132659a447d174293af15fa7b0c0ee55b555459338e71093f4b4af1874ed9a649b1691acca6fcb9547d3eb61dabb1a97ec8b524f9a2bd1bb2ba6deca1dfb786ee1e60e309adf4a92014f653442c2d8391d14aeea5ac96a912c674337ce05375dfc68c9b7867ede6cecfc1ae742743edba5fb17e7d1075a750a4dbdb823c36c7827bbf344c560f63bb44535eb2317a3ee7e1797f6f82aa009a3f84f147bf1b3da59776b355230d2ab4dc12cb6f877e01e1d71489faba01589988cc9c53810acd53a194ea8f0d043feccc0effb8548916e6d6acf38c37b5e102ec8708de48911d33efd72794f1771135a27182a6e398042dda0b6eff1160b1c7e34d72ea39213d9840f5aac3e8451f9b46efc65d509758631719095bf7e1244ef43637d8fa248f37813d9febdaa19e01f89affe52d4f26c91102f5ee300d7a26e18dbfa512201dbd7a3f8d42b372181f9aec2eec614c86af4c2c0bcc660ef8b3159a3cb38d254adb654177b52421fcb551107731302acb9a2db75818c4641b7e77f079c29fc89c7649f23ef804703f0447bcab6ac5100b57a2e58c3321c5c489d17180a637a1be3025cc044564b4b546fd2c7f5f7a576d1fa8a21a4b1f3956768a219e53c80a8bb9efc06084dee1b9714df855cc417d4a1d6a851d6063750874ce9e600af9422b4a25f772bb8767aa29320273e3283451c7de9f11d036c68ba2a74ce2f8aabef7120d76dfa2d04ae56f8d94d560a40226ee5ac1f8736a1731621fba2f58551a71c3d3a253dae3e508ade8ff97e3e02a21c4f0cdaf7abfa2303a68f95b70d482a1fe324da0453a692353d83571c2bce49c49b139bc1548499881a9f95b262f0292687cd503ca007113b26884b8b9cfce84b243887863ba2f14919646a8825b04ef611437d24cad26c7303c27c52c4ed8f8a26e9b68886cf428b90a5c98056c8f97ed0014f57078de1a698622de98a7b6e6a652af67a8a5e018fc3223f54d171e0d029e4ecdfad7b4e4942a436a7a5f14d9362b450c81438cd1c1bff7d64a11ce3b99203a0ee6f402b3c17b4d7f7ca9fce991c0ad128b98db4a8359c71d54871444300060db92c0485f147597489d2ce0f43abdff31f580c5e39a8c8874cb4302a36f47330e754bd34c566649234d4382df140aff1ca3f009822882c826ddafe79df5c7649b375b34c81814a9b2b6b595342896cd36e1c3cce1884d7baf42a595dc1330355919d009f766864f4b61ee917a5690cc6aa419b0e7191cbb38f3d011b6d91147a398856d5590c4a0a6e242ea042541028530e18e76e0847adb437ebf6600997ec906959add86d5e3d92e7f9366d30de10cc6c5f7509a75c47d622b0554ffb26d958d0b525069d1a170600b843a4e19f8a9d0d199172c7839958946b450f8c780dfd8fb0782963784a8f91cb3b96295b087a6a2180d85fa4f5648774ee545822c072aeded65068ec766d8a70dbb6163c01ce64a752d2d749469c4e1c364662a5919cb31b7ece88f3de7e10224f46e4597c781eff465bec96bd367cfd048d43b94b87ee7419a51d15e096a1dfb06f54e9ebdc6a8f9e3ccce17c4d2a30c716926e478e96b5e753ba53bf709a752d0ade8b5976ff138d662dd9f44ef8190668b83626f14a1fc485c2d8a0ca23a46c5fb1f978be8d6863fbe4d1df7b983621c88b1ab31658bc7b9c77cc2e61e2e58be03ac45eb6137c8686f8f46213d58e9952e091ec4df29a558d97c3bc5e11595f75652905710e23084005d88a2e3233354240d19d0e56bdd744aadce4a26635a81d5d389ca9b7e9ea2307941d43a63654aa07a5d6d9910f3efeba0194ffaef6a0e53939cb2c0e3d2110b61b66f695b3ef5d22f8c52a565df820192f7be932108de99eed0c77559d0ac09121fa5fc2e6693e8b6c5eda4c9b7e4b2b8a594977eca78773ad993a3afa54a3785a15b6cf84cca9331bad34f7e1e43bfebccca6af123650652cd6569f4ddb83687562390a84f82577bc713d741f675f44d36525d86e0bb861ec565f8970245e8168fa075ed43f72964128eb96784ad1165f4273880d79d470d12f57be0ed52fe9dcbf3376ea0779e44a598a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
