<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f48a6918352845316d519e5e0160a71aeef1b7de61ed185be383cc860edadb8aee0968b5db72287e1dfd07ef69e97df5fdb60df6ea472db6ec800e6510777456c9a22c33ef891f42f854499088208e9c9d910e65d4c3c69ba348e4359bd01fb6f07dd83f47a6000b1f2e4df80add585c91607867f465fd87bd51210fe5f9bbeb371f954f03418377183278121ddcb8c2346b40482200c8a08a15392fb11618517cd710255536a06c00b21e51d8042de4c763dd38fd5d210c35299d3a533746dc20960dd16faa3e1eafe0709c3a1fdfc00845c68f0b947f9170c7fa1becc4bef7dab43fb015c6fcc154fa5a0f352012ad133bb18677cc7985d228722336b7b39afee95411de94d19b966358e563b7387753a085909fa944572211f52e8a471040b2a2bf7f2a3bd0494ec9775ef430ce49bd0b0a32885823f660ab9f18d7d3ad48538d7f23c217121e8b10e6e941a7cee3612890d0749dc17cab295c1a8d9d40c1357c24f84eb8ee5b082354d99e449b52b0322be991c68c0d9ec1a6d27b945547baf69ad455035395a84962d014580c6ddd5f5db8ab10c2d61ac8de7f14336173740d4842ac33f57274342a0e28ab5a5b4e6e7ee9b0aef068bae53a4bcce5c6b570e5fc58c871955066b4303a15676e00385d938a9f404ce9c88c6e21f4d541003b6b8faaba60f9768575830eb0fbcdb79f10f2d0f33320a9795a43163d82c411f861c4cad49dfd1e1604de74b93a01990ad90ffe7d3b2c60d066bda27b9ca1562af8b89655010cead272bcdaef2cc9f7f8c84b96e2415bdc11bd46a5c661dd914153704b82ab4202b9653b6b975e02a1411c499f11dab491c262031dfaba95ef86fbfa6802adc90bae2289bb42b924860f5f7303522390b77ca896e3f09b5453512d0702524facdb9c4ed96031fcb8eda94389624c1f89491c5b661dc809898f531ad979bd5302751b356494e44486d591c97677bea04ffe25cf865f50ddac05d4382e961e21e78dce0ff136821ecd2e6c576697d6c1c07c7ef2bdcf39df32e7cc0bd5e4b836e4ffe6d3236effef7b2383bc9788dc766c1115a2220aa60a13e97e8b1081b4e2d4bd7b967cff8c54c70bdeac24f9b09098a18af5f3e763b1df2aebc9f89b981ab196d738727704ec2fa344a4f323052c622c01cd266588a3a2b88a1fca335a5b35aa5625474908ec61c60a67a93463e09e1e3497067c49a65f2c0e47a4e9ab3454124eccc2caa16428472b4b2c40e88b34a5cfd5a3a7cd5a145f6435dd30a690d0f39f559aa43c0f2e63a7f7f4f3fa931e6971cd99cf5f03b1368a3950cf930e68c586c473ceff665f49f0a926c67b144d7c75b1d278aeb162e55c0690dac484a0ae254be8f8deadfcecdf649c4d4babc1a3b35c8420d0df3dd6e571d30076dbdb928675f06b655138b74a17da33dd0e46a498ed5eb6b4a5759d166ab25c732104a2e1882680f76d425a9b9b0695d54fc69e4598779bb24164ed388cb9d4f191cccc6aa679cbb858a513bf753df5b812da245ed1462b8f52046258b4417932e5868d555ae07f9df5d89b10c7f801e6dd45a37d03f59178541c345af63319099a9fcc7e87978f232ab99293c2f0dce99a565067b950bec63b8917952e17d1593d49cc8f7dfa03c52d994affd8291feab8e2df59916765e041931b688cbf1940ba63ac6e06dc15ab01d64aa8fed04cd332c588948ebf64a6be3ee7a0ce86b520b05aa9489c0f64275ce8756e3e6838e44d1c0d360cde864dafb08ff5e815549a7bdc06b3da44cc1c684b7bbabca1fc1523688811f6e50f22951f73c926287fc5c08f248eef58e3fcbf6bfd95286e4d2efea7cf092f61f9f8d0d94c053f584ce7afb34d49b55111efe814d2f1761ccd85afcf1e8eaea8a2d4a2f42b16a353ecb53cb66c5ce200e9355094989460135fee4e3a1a0ec75c25cd775a129a56850cea36794cfeba0bbbc4f7bba52dfe11ccdde1858c41fe03ca221212fe93a7966fff5d95a9357f5fd0547d85178882f362013efd7bcfab268195a8ff2a96aa21ffca541c3e747c94953b6cbf19478a0f3404341ddbcbc9b1242bbebb27c88b4a56f4a21a0776ae3bf9a3ebc0e11d3f8270ebdec745701f31bcf1646523ea0152800321d550aeacea1eb7e7e75d9e8968de39e678d0f6cdac94090b285f6eb8ce0e859ae79abb73070c7966c1140bd91f79dca0509b7ecbc5399480bc5a35945293bb33969afe5c85b85575e7d5d657c167860dab2493886a7ba61b1f3d71114268afad771a2833ab408c1663c7b001c5afc8741728fb262c59f70571eaa9a42a482d06498df6e948d227856eb1019b316a8a1963e8d4f23e83b6d3d3549dff0e70417af440a369ddaa0944d24b18501ed56cdc95c1f398eafa5a59e3ae31ec57b280df17d992ce2868f9f3acc6ad628b9b7fd9f75b70baa833087700bfb7c9d505f728621cc2cf63cae9499ea824cfdd5cedf8dc92f2dbd3b84d5b8a5424607eb2843ff1e6210d7d53d22bef600d946523aaab5e99e0b76d9171ba09df272ca98f681307d55229bceeaba8e01564c79d5be53dbaab586b5eea180a009d3cc2d13a01d274c4d857d599a0766514c79772048144c7c58262cbe022b2fce7fa8e79f89d9ceab46bf3c388fb7591812826de49fb0ea6ce8b50eab74c093ab41c11ea6c4bf6ec713c4fa2d351bf77c10485a7b75ce5dc57446fdb35ce372ee6187cb9829db0db3e8e224bb2b4ff89e0db712aa93d0895fa53ab8aad6805a2c06c6859c26464de00d67662ad0ee3d8358551bd34ef74effd8317aaa2d317930ebef0d0eae2a4d817217d418b813d64e57e8ad64043bf1ce2aa1ccaa380c877aaac00b1565e91e866defa8c8db0c1feef2bea96c3fdde76db01489ab49d0e60b31eb2dd343b5c52416ce0d49bf1b46653ec74d142337b26f257921f566d598888ab23e53fea6ee9aa4f696ee4e94d202d259c028f62645a7d54fa1eeb6218c0f29d51d37122fe2142340cdb8ae5e406451bc6785581f413397e4120284b94ecd7001207f988b07782b4f2f12d70461f0e54d5c6d5d3fdc80d685e23567804990c192aad9b9ca9573700d645259d845955c9e8838f592211389f2c8c7c0192f0a835eb9dda6465b5ac7bce875c1bf121dc59b30abd6be7aa1ef277c593c7eef9f819876c22fd748616000d065e22dd9d8a033e49d9af7833622034d6c35f88981135fbc1335e7d1d4c59d05beada5d2559691c592f672443b7dbaee975315f071009e57bfa1059ec782deaf5ce726f736903fe3853dc7cff93565675016ce351c5cdfe660dc8858b20c82b3959b7b32cc0b407bd8a3c90ad0f7ce2823f585cc81a952b6987e394fc8e82b9b08326a388abad51e13a29f894168e790efde3a76d06491f9067f760b17d18308b1e6a7c77ab142d3cafd2fd1f3b120fa77469d6dcdaa363fee3b53f54e20ba8dd7df55126a71ae67f2634512ab82742147de1570106b8d0b88f860d6b99d00811dafe3f7eaeb74459d8fa2ba1ddf76781130e9fa5b35ca6112c9a1ddeb08498162a7c04206b546d7c5a6d46dc988a246bfff3a34de79328496186d8252b3040e60d20339a2281e352d018ae4533b3d6c4d6a3e1b876a3e00327209f928a9efc29be2705a714ab9c76a689dbc3f92ed5e15c190e7bd278c0218c108eb96a065e25cbbb6bccdf884395945393c3567c272a83838ce926ee1a902ace1744a0ed22b63599441c72448b07aa170e48b6a6cfbfcacaa32c9341e62b8148878a9976990aeba7052426634a596107b57ed20b5c7c836ec0000bdbe6e1c7715307b1df026918318b6f425f476e997fc756b7ad2c3bf3f86c284fdad7f87100a0a931860af191d6077bb9e925bfd4219c34fb826d754d5d88695b6a3d1d42fd8e2c56364f8e2bbc31368e91ff94fc0332fef4cef191c768586a45dabbd09d9e6d29458dc6d2178d7462038af173f08fd8a279ad4267e00049c95898720205fcdb81d14b7ec8e1eb3a95008eda37cc0b15d10b44d8a2048d9103745c7e62ff9316793564c1bcc110fe533b0c513af5d2eb99d778549ddd63e3d0a777f118a7f801e46652608f96935a683edccbd345a359fdc79f2b83f4275b6241db26d2b55816a9e2ef830c198c44e2c4290fa30b52010295d76e788c8f83ed10bd18d22a9d12c8d8b7c53d6e9f95a538ab47bfeb38be9d045a6694a4970fe0fa0574b1effc236ca3d92e005f7c63e10fdf1f7351e06c529f477ad8799f820b2a05df453a08e3036168243aee6eb0639ec9d45cfc1a0e06ea43cc87a5f89bc7d692ee9a12ccb26419ec005c15c4348a169fccb06a8d8c1c7986b78bd87ecde72db71a9abde7d4449e19b8a54b7cf9992fccd10bdc4ebbde2fc462352a88bf59a8874a59894fa8e6e305ce881e9b23dfe3cb57840bde75b5267d7c9e6a0e3b1a0cc7a56349055ab17b6d8cb2a31997ec1c1435c20b94dd2973b7d9338a6a14464be76789d23742c57bf5a9ec2216ef0fdaaa81c85f82ca6e7d3ba3aff48f84c8db7b4f2f70de2ccc696dd10c96e460cd8fc69f66b44e56baae1b69eec5c568c1f69fdd01c435207e41b7b8eb9c879e28399df2e3b402e7b514021f4e899fa68f04ccb18c708ee1e93d4e48749857b36111d62bd00fe255c16bd1929d0e9a9bd253a9f2491be08a781cb9f98ca47f0caa0750cd4413188c3e829fcc584802ebc2d0d5023cd84d05dde0cbcb4c3449a55872e8eb9daa95a036173c8207272cec7a9a41fe2093a2ff470dff3aab5cddb3719d0ab14cdf6897ee7f48778dc4f6f437c64d2379b29bd747876e72fe20d8d0d68af0f50947578408f54eed9d7d931b7d239aef87b4ba92e398b1974f768120a3ab90bbe4454f350f1b79a5a97c504c803de642926fae3c05e92793ea20cae564b74d450a4e5cceac22e9a33f08abec5aaebc7bb6b9b7d82e5799664f8eee77bf80617dcc6e4b2f52267b677bffaaaa207dc91d059622793af4345e7e5ec4be828913e15ad78102e22735701b5b62ccfb2bf7ee88fd0ed3308cc8b35c5cf60e2bed9aa4c38b8b157ab158739ed4135f5e0389f24ef8dbd952701ec1371a859f55a395960862589d23fa8a1b0f930236f30ae00a7143e4cad550706e5ddd223d77c01da32ff788792037ea250926648df525f82c40455570a161e26b4822ec05d63cbaa5b511306e7c500d982e4be864cf451cc438d7c398937356fe4a2b5f7288692c11241b2a48a07b875a20e0820f171b5a5e3f103fd18010f45b998b0c8d1675d3078c831f2d7db557f4981eefde0b6d5b02f104bac19fa94c5eeeb1cdaddd6b63e3b4207bec04f9adfb71edb9fa45cba410f7b1a215784e103ab6140bf182e042b9f81637781dd2d0947420d615ccd0f436bc1a9ca6b9cbf5dea2e5a9df51e828b0ef66304addd85e412c9945de340450795d7f938021f36cee319ad8d852fff7e976f90a75fb7caa9bd613441dffd94cc5471572554328679e22f71ff6b17153cdb095d27a534731da88f1a512f8f14c2258104b880cec4af196bc104eb49198edeb0c488bf63a62cea7913b821a2ba460b84dd030b2459111c23806f33a582cb7fb88b54e43eaaba56e28f51684b2a2d76d7ecf4d77e1926d08355ea0497e99bfed83b6520b420e8a6d97cdc3d58a05dbf460a635128c953cb7893e72d3def48f2dcd7fe68d312ea7fdd6470d9082f4cc13f89122a4a8131c1262766935fabf7d17f1d436ccfa92da29d3dd2726634f5f6e41c1456f569da533409b6f864fc58776a2fbbeed5bea1c5597848869dd9c166ed451ef438efbe0b11d0031da8ff8614d7465ab03b372c81b45f59b6f9c1f3d5a8392538cc36d94d934f79e259bc51b6efca60c925b096cadcdb935b5d6daa80ec9c7fc982721813ef5c7cb25954ba515e1a6224ed7293845cd8025b836cf0cbb84761725766b80398326e5382d29cc876f652db805c868f1582b7e271158d994dd8e687c898a912ded621bb4ed0f34b36565875f2f0e69eb1f7ac14402180966b0b3a1238105233c9d59c0fc1faedc8730e7f785fb8f46a697efdcde6db2299b63b40c88b793e58fe158e6f5c8427209faf19f51d616c083d8cc9423d531ca7a315064b5d56715753830edc1ad6b24121190ad5704f5032df8c3bfa2a0c68261387039b14050ccbac49d0bf72d4cb9aa5ad1f160547e3cfd259424ffa172b05afeaf844eb8ec419f7326f8a4fab9cda108de43f6dd2781d4fb0cd457bc1b312e878102b9ae66461a8a1807299adf48105b78587b0d1fc3dcce97ad8cee5092c4a325c40a423cff38f19d0a0692a2f104997c6f6bd860b8e85c5eb72810fce6f3a80268591dd3a2a9f4e90ac28e316e1c641fb397e796670fa15c00223546c887185da4f677c7bfa227853b34adf9147915bbc2160fb0676fb369ede6d7e547fd6d698042d5fdb3bd408b8cb5e8bec402bf6fc2cfba8095d8c50b1e11cb21a4c525eed46df4b80c8bdedc5b4bd071b2705f2a7846f007eba1d33e0b7163b816161804e7ea502b8c5490293074d9884ad5f8ff1419a7ae42cebc3c74aafcd77ec671c999b18c0c88e1aff33a4e37a0100a52e11a29748bfca8fccaa5081ada1ec0b1ec31c02ebdf0a740fd1187b97d36cf5f241d63049e1cf3d9cb1759b8613ae0cf4a63d5f65e354b55208787e9712a6bb9f4ba0a9e158c3e1f226964b67aaf536b7f9fd5f7d1e88517664bf8a39d781ff11f9f6b5ab7a944e76fdbb5a73c3884f2c4cd2969217334de9bf892764625447bde8090026402d1a729e50d18783d7dcb6023c0464324d0a85b47b0092af161ad140c52667c517fe7fe0847e6809175403e841d7d962e06bdcff17aff30d2454fa834c16c59b86f4b04284dd9da7b61a79ba3cf424d26e3d8576e5bd024943b04047ce10cb4d019f9c26ae4aa34b03e54bd8eec1e347fe59d77c50d887e58bb0f9a14eec8e88391a85eecd1772da82c16a30f6c45e0ff09c0fcf2ebefd6082707b204eb0c10a6125f995cbc53be459e7558a43a95517fac3f729882cf1d400f559ce0945b577834fe01976bce8e2a10e62e143ee98bc30f864803484d8d9e0a419484b35373995cfdef7598a2bc9b3c6809036005d9e0174b0ab7c49c38fbcd0cc1efe975e26acdbca03a6676300f7a2e51e90fe01fb3f393ba100c5aeb9c7459eef2e24c0b4a3aaf88b9cefad3df9d9527c63873b926c28d5d27cd694e3f92d342ed87f15b22e39709b09459c56cf60fddc9b37cf5c0c51d59adb0f9bc2e60d41205367f2c6668317cf56499cae648d9382e347fefa1042e8fcdbf6c0b1f1e53d1f95de25b270c46939962036ea48a4e54922b6d96badc08580099866cddc0ae48c050a6ab584a484c9a8b8e5c097a0d65835c87dd4c5dd9f8f1c3562a8d8638e8277e48d049e3d719242ca6d5e304d82f7c8c22a5fde13b8d3199aa58cd083bd8a0c1a5c51d7906f1e37f49f0daa2d30e16e7f1f9483d75980e364bbcc6233081dd05d57ecd37c05e91f7f66eef026252f5670efae922d1d4916724d336379ca4fdbaf69ad0fa22e3b0c2855e8cc2e4e13502a0b5e6dfb5a5b9e5220b97efe70e4ff42a2650740c79bff5fcd818e6835e8b0a1764a256c24749a9e0cc4ce6cc1c82621148d5f2c7204813d651d81b2551ad3c635c72a1636f7a97957f881b7747c71e9af3fb11abc9ada42a837ca88cbbbf46cc0df86e9a553784892e2bac687c3e7325aea7abd30d024e4a7f82d695cfa2220d1e2455b4497eb8de2c7d63e947c39ba114a07b0e081d4e8d6f7c7ea4523392c8a5ffd76e315d802113e791af403642b6b94fc81dd4abfe5b0cc1c7783eaa3bfc8a184382d8afecdf4db96eaafde0e9e8f98a5482d4b86438312356c415c320e69265e847303a39c3fd303b6bdba5d31da13da162bf20a194c8f78a536a75fb0e280d2cb9c866278219c537fc89e062e7cebcad50164be21197735b907d565bc9cf6e7e4a714dc13fb3164c3e8d0e7870dcb067a8e0c7ea1d3932d8cf1bc9053675fcfd5780e3fc651da61ec78487fe7d0fbb9c79e286905795196e526ef11a6900d8dfdfa6be5c59c33993157453e23e98a990e2cd82cb6efc5e38185f48d7fd135b6ac052ed29500ce51ad9564d5de7273315c6277531a4771e853a20a9282e7a418a886f1ba50297bbd172934606834de9f04755e703c2660ade12f0d487a7e8803b168ea8ba63e4e4fd3b2bd7931b7f6f7548d17ff9da92b31f0c304e7f2954de273095bdf8d28957412d3c978d082343253ff00450f1ebb398bd06c2218b72f39a5b0410ae0ac7520be77892c7494d15e6095d3ddcd14a1abd89b0739d9c5cccc37460133d7c436067c10327e5136895436c99175a3a1b95990197bff531f2224e9a0d677e1cbb24d62fde436aff7e0715c3cfcfeb7c4c843ae452c85dade242d2b8cbecc82fb3b1e8774927d25732dfc8ada3f80f345106d09353318de1d1bd0c221d67c16c46809e82e5298a749407debdc158d042758f30d01bbb18e460ed0971bf28c5af359435c2ce6c4bbe734d891e1d4d24bf13c9518865d9bdb411fb8b91a5a06ad029fab450b35f917568742a2787c91eb3d22273c15fe366fc03cf72eec5c25d875a1ab72de78db868c4bb8442126169e175642c40b18592c66101d54e8eb0b36967de7e60a48d3615b4f7f49385d94ea736d4fceb56c87cc69656a27576dab41d33f19123423fc29f74062457e138221fa896ea37b1945cd304d35e15aa5c09dca3cafdd2aa0e0f885b1c9adb6c670dc689e85e923bc23d3403043b549529022cc88ba2d3e8731843a1a529234e2e0cdab61080861386e78f64988d2f7ac544476fcb09aca9599c876d8341cb4cc09cd89d0632963faace438d115722126a35b4bdd235820471301ec1a8751af716771274ad38248605067b316527e1e47300590d1a48345937f5ae0456bcb1ee051f13aa1db062166dfca54bbfd4383bab4b5aec279a0b856b72c3e7cd0fcc508f08ef42ccbef5a2c2ece111e934b5a20a52dbcdbd546de979583007ae3ca28d3a52066eb88f9b769877d0ced22c6e2bb9b06734295b8cf69c5c01a942fe480a3f7ec5d9e5607486f9c77ca56c008109b437acf7d367b4eb7bec5585a6cffcf60b1b0595e4f7dd2f635ed9bf31e3e80f6aa4ead91e78e0cf8943af4e02e020509142135ef3f948d21ed41f7d9d3cb2793498b8e3b9d7b6c22a1fd5ef7dd717fbeb5d7ed389e82738b638bc23a099d508a247bc5900c6ee3ad7bcaedc4d5939534f6da1201f0392a515fa63c0bb313b21674776d8d79882077038afcdd5b265050a38a4cfe9ae4962576141d82ff4791c0eaa79bc034d1729220b46d4ef67b24921147a4f7ac4cbcdf0ae5c327e50a59cf02402db64735ec5074a45b9b7fbedba7da5ef333d6d0a4e870146b9cbabed9f5635a7bdab3605c603204025ca1183e210205c2b67a2348c9b9adf00e899b39c336db317e17dd6fbfc9926c884cae2cd6aa694652933d5ec9724ce19ca98c769a36871001648dcf582c6e8452fa360b2a57c54dba6bc4985be354e3f913a12169b9288a58bc86b9e69e26224c56adab70e02f7abfd055d499434b516dcc82dc61a79a04c3293a01d6eab3375e4f91f7c0f432c36dddf2b8d85614fbbf81be4f46fd8c5d3c67ebc68156d9881093a7e9f8b4801c266eb594cbccf0859af733034bc9dcf9b95a1355b5f081114c2baa77ca68a1e29c6bf7210217f90b7de276e89c0252048cb37c708ba8452181b454a8f3f94c41eeb701cd47186c23efc4dcb4bfc343eac08152a254c10b1618291f87bda6f9e13771a75b2ae2d56c275e56aa6db1eb11a65f82ec705ef036daac1c1e1b0d8532699e88beb1810990d019ec43b66c7949df65be1aaefae7b35b5b7ad6360f481d34aa8e6ca03ca92e240767f33bdc4f04d329da72cbddf00962a7c5a1c836838a9dcd30299783a8b89fbacd081cf12b0d8d572144cd4fe22e9898586048e26dceceb41e76ad1c103d94aa801c606c5c4e376735bd3c087ec42831ff63626f527e7a955389ea6de74228cd6f7c54d5c778999ed44e96cca8194003f575b9454336a2318209de847e351d1bb36528aea103025d29baaa60b41202c0530f8633bd2955ff83cb9ffb5c763c838f8a1e122713cbdd1950ede4708173a3e6f272d1eee02d00f31c78689dad141f3056412418e65fb6e71e7f3e7df904ca9c42b2a2ca9d6ee8f3413850d4ee7e6fb56d5fb9190569e7dd5d68427ed4d8b1263ab69a15471564c68717915ebc40fccc7d005b2344a963ceb974c33e0e37c7353653006d8455629ddca75486477487b57c04222199adf9a704d9b8daad910ce8e940dba5b8df43d61fe7e52454be45af25854650221dc6c4a068fff5802b9c03b9dc1e9ed7cc803ef0d1ef1f9487da4d0637dca5a1ceeb259d02bea37bbf58b53636cbf0485fcf5ceefa27f305f17127de60b93a5028e8049f24196c4362a2b9261832ce201b7e0596358ec7adef3ee6d61c5b6c7bf8008c95307706ba424a6a68917db97be0b9640f38ffc2672bfdbf9826c3d1a53cae91e7546fdc04e6d6f867d9bf0191fa038ad6ed86f4dafbd023ac64dbf928b8f41808f92ad019ffede7a315fc5b1a5e8ff07efe20ec890903da8c9aa75332bcda025c62884ce6d370b26d77c54a41a042f2049785989f25408b8c672b521462238e949573305cbfb5eb429cb66032bf6376f2bf0655f260831e80df65045bc123381c4fd8234a53037300d5c771df93890c07626a79e5a5756ab219fcd4df9760a5b482bb8eee3d76141f1db6ff950dc635f4ef7ee2c964ee45842e6e232e8c6ae64587a25c16299fba0e265b0f329b585a367cee5de94c7ec8044a43ba21f3c40f7f04b2423bfcdd1ce62be8d9d03338d3834ec1211bd72064a95b518177c63f8585b97a966afd8e599023d1d963b44344a344d4a122d1c1714b68f7ebeb1c4216ae38c92aac1139086b8efbacd16c97ec6c0ef354c6e6821a85b6f7fbd6de1dd9d159548926213bf15a266af75aaea5a00bd30d2a39d8962dd8d20e0410eca80a4adb1c3d2de1d793316e811c3e367e33a4ba79c2b3e94996429dfa5898c8258d857e2485f21a19664ebc0deb774d49cb2dc80a060e426d758bcfef517d27a0d5b69412d0d218da8904afa5541fa59cd7e3ed15cd8d2581e031216e28d93eda9a6b836f7d0790d9ab75514fa3b59338b2f23fe5861e348a159741840c77832ece4fceb6934cca01a716cf57a262641ecbcca28780bef0d09c209a283929b15fd598ac10ea2317cdb6ddd452695d715f9b73e32b1bab7070c0eb9177fbba7398dd2a1cefb3cfa2f1929ec88cabbf2c6c90bcbed30f355f81a303d9bbff433e0271f9ced1d183b0831a7550ceafbe45c42f95a76730a38a4f154589facd88610e97b93e52a2bdcb2830cea3eb882e3912734582bd0e0a823504f16549d9b1e0009631f06fabecf2adb1ac768235b79b24e1d06516beda7c468973981028150548373a9b4b11a0e978497c785c613ebcc044914e2d03999ebd5a3d513e8a426623557f6e7178613b433984bae5f59cdc3bb6ed49003b796351d4f724f5725390533b90e7ab3d6503ce486a478c6946afd525dba556e4d82a660eea7229f3b6bcbe30639eb11552b6fa77f480bcdd32542f5ce7044149effda0d0265869fb06f9c81cfcc568e7ad9aa836e26199d4d72e868474ccaa28f0bd3f58078806d4174bf3efe36a5a5fbaabd497aabe3e69f5e22f6ecf0fe929f63adb5ab7052c8b6640d9501b86124c63b02d20111c1324027fad4a42b7c7e9728c6df65bfba506a34b794c2a9313800caeba56e0edccae03d9bb8250ec16fca57a5c6c41887fba536d034f497d87b7df61855905798c1b37e05212f245b46322783760f816ca92f26239126d602b2a87a684e80136b5418e973b9d5cb1c87c43d5c1e2d20123029a3f4ba96394d69cfa1b2b580aad2bc3431cbc52bb095c83d06d54bddcbfaa54f38fb0c16a88e4623146378b714edbd0b3518e64c3e97bde630cd1954d7c9d7d79c4e337f2b50454991d15fc78b4e6ce619ebf9e63f0b7f44c847cfbd38ac6fed881c1102b06e5432af33492e1066c6030356a53bc6138444c8373d972e4e0005901a1d3bf93b42f445488f1bcc323600c76b3ae19298f39f1372bda70e2619f5a3d5fdfe15c5cf1c2d540d2a1d94b7585221b7e978bfe3e0570c231b17a4bd69d6f23a8f37a00b194c6ec71d82fccb2c78d4ecffbc7eaa555ba966e7da41e38b49e9a265f8943a877ed80f5a91cb86c56a5d3d560e0086e1efa927b48ba215740fcd10e5c91286918f9c969649dc269b464ab31e1114ba49c03363a44112e9045c01f4c3105e716637e236f68141a8b2b499870bfde6269a3cd23983a7dc84fb1327c59f0b627de0c7a6713afb0d2a4dea40605911acd8dafcee89eb4b2429b44dd3117beab7971d6a83f6f93406c525b1292126578f57fd0f823adf23d68c4697370ecf554cc0a0513e40c64712f66297d10208691088d5219242409eb9d7e478c55b83a9b16826a38afcdd3049987d0d317f2f33713d9bf8b0706abdc40867cae20541075b236e94062db2b760cfe1d4bb992871169b5a0634bc7725849a1d82b21abe0108853212f7e7a399d3755b7706ecfad8e6f4c512eb2eb1a88498fed4d3f139316d083ac3710395fa21a742daa146c35a3189535b0fecee8b1854b8e34c9d8422d1c8653bdb82330b0a3d43ae889785a137eba27a0953858f0568d89a75426a341d50771252adbb9fa6af0199b5cf2328005704a1109d31cea901f82a825fdd453b63ecd4d9182b5b3a7cc8af094aec1db7d9860ef6a57561d75cc63b1a8bc6cbb9b6234d58609635e44b483cfd275408dfc03ed35b88fb6c579e0da3d8b400a03039009197852e7210c080333b7556cecea6c60dfa18054f19a2bbf9cfd33cf66bc88db8b3e2d7a93f04bb6d366df4b871e37c17036d847074f59731196ea3eac7a4c1244656cee2fd7b55de91df984e59c4427cf5f227307dbbd62d188a821cbb8fb63b33c9bb9409648fcb06620410bc060214ce72adf976a75dabd4cc9615f6bf329ab405a5d683fa96a28dcbb6463c57f809ddf1b785bc51e1eb7468b8b16404d9287b6eb830f01d4fd5f82d93379fd589a8975d4ba6ceda008ed12a7e6f21afd1927347661409542c172cdab4f1337147939f4154f8e73f4799b7eb2be446f9dc65f21993b660aaaf4363d52aa861f8406cea05e7c01fcc83f4590725251f41aeb6a39fa685b239df69afc1852424d74ad006daf5852e1a0f39535335bee9d7f875ed138c84a884cab8bd5721ff25d54738bcaba70e5ed707f6980db1f0d8ba61d25a720e9a4041a3b7e64ea295c9d8eceda1496b38029a4aea877a652936d213a89016c949747b3bb1fdf10ba7eb630f22cc3ee7290940c081f461f523de5904cfe3752fd52e11d1feaec09cd5ce54650a2d835160de0fd610652b993ce606e7d77a42b803f19c9beb4d33226933788c4bde334fd9d7234a268848dfb62a4ab7a4298afa8eb343229518a6deb5be9446adeff6192477865d738b789b3222fe524957df3faca38ecc8d9a17e0ec8834ec5371c9250285090a600277130653fa7ed937d66bbde9d0423db55e1d1fe6116d2f345738453fd0c70b656e2b32e9c49455a9937e7d8e6b55cabf99ff2428f36724c7dcfb6cf67ab4e1d7f1c081c6ca45e2f9645ba72ef06146aaa5cf8ba3e6af66367171e435c695405f7795201a352ffc25e9fee0f8ef1c0b658cc33eef7dc1009909657181081077e974bbb7fbdf50415a2e0cd5cef0b3a40464a854e95cce2da5a03095400b652d36d9471fbff9d2bfda4d885af69a6c580dbbb8296cbfa607a5b04f8f464d3db33cda412af31283bfd3b08c858c4b2d8b26d78a27994ba9bb2c9620f6fad700a418e4c6d8f1770e794fcdb46362b6221f83c76856b8101db6e58da38fd1f58e3e09aeaafbd8eea2d3c9a8b7700749df88a332f99f095b3d5314b46fb0a50f51ceaeb7ec098d6bd39f1d25ee75b2b4927a6f119aad72ebf897401a2d6938e560e7c113cbb61d3a0f972a5c45c82dffe125c9ec744b09ecdcc0cbae261ba3613199a00e52d6dee55f5753739bcf8582f6caa6846e4453697ac34da99116b7ec1170e48aec59a0ea7a70a8617a7b6148ecbdf8489963ad19158a9e82d2a1774717b09ca7e5e12c8039395301de432fa607212d1815e6cbbc68b9ffb30c723a94b9873c6fe22671843e0c7652e9b240dcf94f85ab82dca69d1aaebab9c1b1c834fc46166eaa35f5b8fd833da624b4a1dfe38ba08d01aba90f3ac5278743753e87c9b18f000a84e5aca49805ff2e3634440252e94c4830f9ed63654a073dd21d928eb41c390e7a7c98f08d35f153e7c3b7ad2d973ff139ad76fde17ca2702b6a47163db2d531571cb6c5f8cf5f95835219ce4296e4a0117ddb8229df34eae1505f3088ff9468ab38e8481db0b57ac33014f04f28272f71a723ad459a8397a4920c309a87cd7478fb399a25529b37ee89b869e292cc8278189053afffbdac906aebfc83f4958adafa004b7b9c383828e5798fe9e1af14f07cf61ae29fcacad19ce2f78a5aaeabb67460b844574999f194d27ee050668688be6f270e95abc8302f18a18001db723df6e9c63d143fc016730a298a73a9ec2121889991a7bec6815947636b89f76577ce18a8bdc20fff7dcd73dce7100094519c47543c3303f56a21cfe4cd5859dd60de5a7b5e2dd8bdeaf0214e82a99658ed58c511cea681b2422f71c16485783b0e20e21da5843ad9023e2bce76488cbeced5bc279ba7dc883e1117ddee6881fcba1ff9099417437564e1fec57d0e6d88ba9b3ea21260662a14b4c92e2a17dbf4b58a3ef60bfff16f372933ca8054e0a417342ecf228e989a83747b8593dc6addafd3655ec901b0c0e51c7df118205f5cc67e53a1a647a1a0251866136724f51b99e410654c2778551d0c0c427b1fa7aa04597d0adbb5e02af3e180ecd0f62c9e490cf863d4c1c72f9e4abb4ce54b634b3097bf44761e93b8c1dbdbad086229f89d3e42183230d7d3a9481447269fba7b5cb3667490e5976beb5c690f0aaaf1de01f08f6304263c392f4de85c8115a5913d1896f1d65af3a36138655ef43fb80eb8dc7349169299e24bf0ce1ffe46ebd0aa8bcfe64fc2c227f80d4287423159fa820aedd135cb318822ab35cb43eac2c40e50737e82ee2cd640e98190478138f651b4540e49c9f2c3922f9fa3ec68e08b4024475bab1605ef18ed032f3c39ee23af8501a61fbddc54914adff2c517ffcaf8f3cc1ceed153fbc058db665e0c60ec4ac40353d58986a473a0ebcc363c191884b7a3773e30702a9807d312ad1a0e2b9415456021081a6698145ea0346cf0815b889fc294939c643e9bd0ec7c3069018eb9cf618e2f7d86c762158e9f576085f9976877582514eb6c81216734a755ba54e9b77812ca4bd744cf1b0a866e24f31d6277fff490d0d766dbfecb9d0831ce7c87a76ddd9a2a4f798a299ac01d860210c753cc6fcc58db625e5da9353dce3abb7d8ae97728a2337bb2d5272caec12e18ab608c67f0b2c1756643cdd6b9e5b4429fe40f1d0dfb1aa42b4b9fc6fec6d7eebc831d230d5d66e84b332d2465c8fd3b6cb9422db1e5b9a63f2f0a8c53be8ca47e20fb33b18e9b3249e7f885d440b5ab6410af02eadc08fc4da71f9296d557bb1b4093b851dbc45105d0d560574ffea346435472eeeaf893f9b735e56229e7e41a2f765cda704f1763a6704cea2b88b170adb35659a6a64c1ef8f4835df501cf591f89eb37c8a1ecfb4646bf3c76deb4f84d0045ca4695a32fd734d5d8163ae4b2ad37578939894ec9f7cc066c68c876ef74066381b5381aa886c151fc95cd27b7bcdc803ef04fe4dea7866f46f7b2b937bda086839fc5d1bda11b0cbe33516e53265cad62cc7d2cb42ec41b00d2fdb6c19c7a17e6292b5884551b8be8fb4211fe5c9540102325ad67d827789629b1efa492af832b8011edfac6b0807fe2e939943e834e9e551c63aaa2b4368051693e5b89b98af097c9f0e102f87d42559717cd95cc19edba409d336d3dd1da576db6be9b962b5a76dcfd7c2568b3f115697ce3804b713d43df22d81c7a1e089dd952f8d8972eb89545f24829192af2515352f94d10aea7381b6ddd6fd1c0c59078bafd8f75afea787126a5b12f537e0f080ef6877dd7308286a51dbcd27a91c3f8127c3b233f5b868c02956e51526529d6aad42fd251633fdb985f5b6d3dc1c3a4cf2f65db4bd4359e66dbeb8f4f227f6dcb6180d2bc10e0653d97433b78eb4aa83ecb0725eaa52745a628cdb98e3366745cac89075712fb0ab9c7bc8eed2798c86dcab66dbf483184d872b31658127c80a14b6c1cc9102f6f3a462f8d6118618a4be44b95540d22cb0651662f9e7757c2cd19631c589c79beae4707e2007e79fd3275a3d9ab1f1cbf4385177270ed428d178f410152315d796ee7010ebb1c9b123b4d6dd348952a4221165d416f0dbb82d0ace1a257d4e8d28622af6000e3fc0149831af91c589272f1a25eef5378e544219ad5a20c07322a1d062f1faaab0e5073d3081f632eaf67711538b1c02a0d40a605771589f2ae7e442f7152cc68c25bf86fce5e693e91bf27210230e0135f042b772472afdeeaa8011644e01b6c7766d0f798f8ab74608055b2a721beebe0946589a4b88323134a7e461c3787c5a8594fc290ba62bf902e74ef88e75b4e8bfef51b71a0cd96db9bf954cf4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
