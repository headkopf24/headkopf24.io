<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad6555bfc5d6268af1b65a2559fde973d0828c0569e8c1d5a58e56bdbd65fd3621316e811839f5f39c7c2763edcd5e660d5fa380e1845715b5582c0059eba64eb91cfe63c1b4130f1a09f2baea3055b849a6ab3a6fca0c0f05a488add526eabd6dcd5a53d32a78cf56b59af2c8008521308111fbd4f9df21b50b4c3fc1282b7ccbd1f45aed66db8094cbb7a2440c28bd425bf763cd3b9fbb4ff1f2532e821cfa03040fe5af9ba1801b08e78930fc42217d5bf0c50fe3b6aa11007d227e47733381ad995c042d86f7dfdd0d1bbb6b59912cff377df24cf0a6c0bfcf03cd0f6c2e93dd2e100d866084c7ced34f07aeb6e3d421ed149b6a0221f9bedbe7cd0c5be171f439bb28c391abee4a8763ee7d930caa7b4c9388b4337f2387fb530aae0b5e854eef963df93a7cc653b155eb3e5669afc53e5fa4319d71920677a2cf95432b863f04fccb3d0695709ebed4408391870fef0e7d4566f419ab214d5313611b484d139509f486133edf84e4ec2121555ce21264c31e04e0cfd8898fe950fc523505b47af2e0c7cfe1028ab67610cdbe52a2b9a27bf2121f7ee9859c9367ab7d53f82fe8ea5d4369d7b79c76081bd8bb7dace7bf075e1bc11fb5ca977aa8a6c7f9074ddb40942b14017d893ba75615c1e448d49a03c8ab25a00f5cb5ff78f668651a20841762a3cbea0a8de69960e4c2d1ae24f1cee5881677c7cc613d92efa3d2e92c2019a47e31570dd1aef53bb50847781ebd0d59cd6a1455f87910838efca17edc1404c0d617f9e16ed7caca7937c5fe61b856fa7f1ba8cb2b69ee335f35b847516d01d584afead9b5de3b108e31c557e11fdd156dca72706fdd3887ae44dd037b18e960537f8ca6b78249cf08e51a2f3e48340ef9707e140d783d7d515e115c468146ec575979a913f1fd0ba79784765b33b9cde1eaba105befddcc759c8baa0381df72e43cbba0bbea1fd7e7eb75714c8d0a85a85802a1e12349c6644d15a4b6408a3a86a70a0e7fb7cf033c25700847dbe431d8fbce08b07037864b394a51023ad18865f36748a02b331aa493e8a685b4d3d5c00b7ff12108f5ad732144ba9cbd7f7fc526de3ed60100a25f1ec96067b0455a050447d56ee606bf4404117b435b0a035427d58d8fcb00b2415d9cfb9158356bfa474a6ee75d41374fe71c683e0990973944634f7bad2caa2af8b8e7672b67619d4268e8ec76497d19a7a6d77029cb4c1d5b89abe4d97ef2811c5241a5276bbf08ee119b6bb250261b4459439c3609f990cc2d31fafc640d57edd73c8e58c61ea42d43b86addbb1927f3a4a0e4e4d2966d9b0200cd09eb219ffeef36498c9ee66774d7cc232940668e316d27d45bcec775c015b4edb8839b4baadd2598eed99c682991d3c5fe1c4c1f74ac1cd7d0fa49b30b62713a3ae755d6906764d3af6cee8a44f5d555a9c3bc017a5076437d29ca73758960dbf4c70641005936c5b15792581921fdee59880dbfbdff6f4bfdf2e7bd2a6d554d27924175d8ade48cc6a551d0bad594e153391e72e11e20300ec06ca00fb25bbdfb57bc05393a8f95b62216e2b4d4faa02bdaf796d368c44e1bc8c69b651407e25e169be7ada94469b3e1941b6744e732d74a59d0811d2246b9e7a8579ff30f188239de57bec87a42649e82e93f04d2451aea779a651269f49a40cf80988fe4b724d28a1be3ac9c1dd77be069dac89b35cc506246bb572e89e4d18df3ae85812d1d36a71ca6c30b1db4ffd940b7e0e1d13d33a9fef3f040c7fb9080a8f2ebfe191413b32f1b45aa1dd37621f1c6aaeacdb55d620f2faa5f904c054c80e09798ecc4a1be40d918096da8bd5e4956481ef02a0a98bf05ae3d3f239a69b6c11b58c3094a1d4e2b8159d307068a0a9b10d3da485ceb5f1dd2f5d3f620240c3312631f8fca30ef07cacefa9835a4b3e46c4c4a9ad518a75c8a160a42f603dee7f2d92ab3ddcad0280f4bf7a675d133d5c14aae8f4342a42e04e95550f1ccabf9a6e2dc15d6a02776cabec99664cf26160a46db5ca745f5017fc8016b3f6dd2e879c758bff642efffb534d6b129dcf886100ca71f07ed2c385a116fdab852309e309f0d4818f14b46a6569242a206cdf0d31723644ece1b7ec6cc8169e444293042e80fedadf2d79f05aad7756104b4d20807c782a5aa3b32155a7920e183d3f1ac11f1e2ca6f6f80eda49a42ef12e009bf397c580f1f092c8c7fdee37fb3330e01e9aefa60d3c7eebdf6ad246b2b0cecb54bccd9d7f83b4c8ce060b430727bda41da241e01afc32d453938bc38298b4714af9af76ceda690d9d28574872a7c2d5716f41cab1cfd6f874dc8c69734e81d5a5d81ad7a699e31a06b44ea0162d09558c3b1b13ce004614fdae7f603a3aeb1efa6922042c5fabd2c245738be961195c8de2fb3c41eaad674bf635b92104f40a4c33ed9f376ff47e9bfcaa190345706d378a2b50b374227030c1d703b4fecde43abc1fb18a038b262feb96570f288e6bfb118d62086883e77d56fbe56361efac8998c212828732cfe45a9b441d6874f6892233eb9729e39818aac006e83300a714a1cb4b7ccd20b1f81686a3f8367a4197ad3380760137f2fe3b5805060c3f516df2ef6e7e16f3f2cd5473fe66bf81df6892b516848695434cd20b3ce356b5dd8016dcf52012d46c4ee0ad19397e9db69194977f269b997b94cb2909611bdbf02a209e8aeba3248a63aaddc5e6a328fc6b887c6ab3be9cee550a22644588b64736a12880d34878f2b2fa4a3a19f2d4f7a93c8280091129cfef09ee5e886f379cf9f25cf2daadf1718df012efb01618c21e23a2818bc4e9624ad50c90294885340d14f630eae324f885b974ad8905f239fefad63b1b3a1bc34005cedb4e0ed63928bec9eece8b78a350c60423b8a9e8d70b39ce1742d3a6c6a36908955d2292207fc1bb49a01f9753afd97b11f4b1673e40a14bae22d613301738d1e52dfbc0809c16dc1347a2eb9a29bfcdbe6b4902d5ee5cf9632e957b6e5083308b493409588f16ba3da8aa0e69b45fa737d8a0d46b7c4d911b0391ddf56cfd9751abda3fd781298dc5e03b831bcdb47f076fbffd9b96e74af6394ce1df94b3c6b5d43b2d8b31fe8b9c3d7650c4d26f2964297c48ba0ba37ecfcda13afa1fe4b076d0aba8e1d702ca77b58c91c10550c1f90c8f8dfee43e1ec0050d57cd10ff1ce0cb97cb801323faa61752a837b7c785bd861941824f8097163d82e161aa9d4039d390fa974ad13023ac06cee63f5d9207313e8b089dcbd72912f248b6973bffabf382a9c48f77aa49b594d9730d5df5d7c4be9424002d43c63de5f5c29b98421fa4f2198c6d852ccfe92b46fbf5c729db24860e88e174a3395b6ebc2d585302e1c885b8080e71b39c8bd2ba2e6b6a7329f3f94a1836b90b0c57d0dd4ea1eae650e49df6d864ce324537d805ac9948988af26a31eb10724c4cdeaefe2c4cf6dca4fabfb7c0a4361b0a43559a467cfd43f43c41c75587feb7ca64fed8ebffa66c77d62849c5f38b7a31a33c8bd81358945f0c9c8e26d37e59be4046c2a24607548c93f2f3d6ead3b5fb0db4d5f5d0db13308f76c773aa91ed872c64e6dc2a7fb46ba334be30ca1efaa00ecfb4dfbbc63b001de63baf3ad9edcb1d13dec1148dca1879a8d3fa575d01427acab291dc3c4273438e2c3f9da6b97e80f4c2e44c7e3723000a382ca368fc3da5e5968f4dbb0362e4fb0a2cfe849045af67b874289b06d293d052f2cc9fcc4a27402c004f45ca62dedc7439cef5549acec19fde7f2b7a512808adb0198a795597ee1c5ee988fd2d83b0aaab64bb943d05cacabb024ddac2b83abb59ddd9bfd0278e1f1ba817b85144c13f39403c76441a52a51312df84e289338ae4779355c70a9f311749b467c5c6aec2f90983e86080a8623ebda0d713a7e903f4c786aa2df2a39c21be2d7b213aa21f3a893a05e842cd541eb35f7da3c81ff4178733ff946fc22680bf6355eec02074314f300fa49e5eae626e3438be3ad1af6f58550cc657abda597a8813456102dd8ca2dba703b2f25ea3a72e405babde9388118b9a899aad24f19c0be968787516d6f8f0078272c69b7dd63dedb27fecd7b74c07ab800c1823ea04cdeb1a7e57576e6406414adeac86cea65f314ead8ba6e8d456dc7e90556ed69b8e03cd7132c19b9dd67445c12d63aef803e5922a9127108df03d31c42f8f687ecddb9493c00a42377318ff41e44f143c93c3cffdb03c039464c083138829e5b38952153d175f78f9007210c88c7249e73739a11b24099a33089c627b8a8e8f7fb587a8073d4b61130a014f06a00f152686552f34223ac40c6a67b4770863ad5a76d1709ba82475df1b5b987cc078ce253acc6e8a05765faa3344ab92a15a2dbcda7f774aa1624f60e082e22af89dc3ad4df32b87deb107402f85829c09512b83374a5a6185c9a7e0fa902e1d81e5257d0389f00ca92e170cfe4534e8e2fe83c8c44fcc59289c5aae1f57de43fb4f70f02bd059a70d6129898d0a23fe511837b6d7482c4478a2775469e792cc145fbca21e2d8acd3b979aea102a981da0a6eeae4adb1d89f4edf87c359663fd7fbfd53bf46d037d06ae435bca285001d84ba3389b83d7cfbbc449f9b0bc89b6cfdf868d3ff01a168f07824ffd1fc831de86b4df5b0d0bbefe68daa342fe332fed34d2cc23cb89cd80835c58223b076d7f8b2e4b9c7f7c75abccb26e190fa0a9991f5be0fcf8a55d2b3285895d0886b1a45ea6baa66a333b3673246390ecc763c1f3cc4f50105a28932f486ace02dce342756c5a25654220219744fb1a55a4860670beec69f28e487e826d9f396189925fb788c3816866126a428bd1755ddc4b0960845f9648693ee452b089c3deec049e9d471397ac89986f182688c260f843e621477fd39b8ed1d363fd3886c1de2e595aff91672dc8cb5ae87870a6d7900f030349e0342d420cb333d29628999fe97ef8643f8ad1317f53fbae11b98599e304ca41c29995fea605e6a5ca861dae0ad55c71f3a7774c17d53600f0fe26f05d6e0ad46c9d6fe85f17bc0a3d8a6331724971464dac97a4f7334be8acf69a9a92a35532e959c32122430a76c7976a8cbf946f913dd0103420b042b4d7f238a443e0084456a0e74463eeb3a35fd22f4d880e457c514375b9c8044a4d328c00f1f83c1e7e944fdab1768d42ce7ea7c6f851e240e8298a80280e8ca2eda8da033c29f6cfc84615b64378546bc36390296148c1142bc1aa7e18465c0e8f74b36bc6a31620913dab80233ee8fd4405dda43bc9a17b51830671fb8a2d24129ed8b83cf6702c102683617818bb466bd3347035b7138d16bf5050c8508c2223fecd52d9eccd074888dccbc99fa2f249e2f1516dc574ddf1641683ef971494b7bd3dcd887529cff83b714477aefa21e7fa8481a9138e8463adde45f132f0fd5d8337eda3278b55d1f99894eefe1f0febe0b9566b78494c82b7597b4efaaafce57a4bc9040974e4f0f84247732348f0186d364a868cb6cd9ceaf4bd8f42c261d2350114bed78b5e1159133bb7e156a82d751a72c08a5b064f363b1b9c7c8dd33f0448a53005b48726f62da4d5448ddeeff7e9959d8c44006b819f274fb1011535a141da3362a8e18fcb1c8e02e41228b162425c7c1b0753928a57b3fffdb6185d22cfde88ba2dfa7ab06a496dd0b6ef0890114675b5c7a9bb20f66e26fa7479de1019a21fa386545cfcb0017714ba40e63c8a0a4f1d4e059a2fd5a3d8f4dd6b9f1549467e1a19f06b9d53bd24a219e36eaec4e932486ca4cf516e8ed52c014ec29b83654ea95b72482d5c01ba9b2aac9292b761ec81de435c0bcf1dfd82d6c507f09a6f4969e0bbdec7ed64cd22545d2d58a80092e7e03f25a7a4ec13efb363a8c7ff4b1515b07771dab26ebb7f80bf4cf0dbda4166e92fc661cfca7116a287c253c2c20b89df027858ff78ce5cbb828777ec61d33a11350f18029da99afc42ea6b7188b1f48a37dc3f2ad9df54981d2aed0f0b5152cecc5122ea9ce2672a1bcd3b9e24d9f50dac409c51e76de44a29504654932006bff5de67e495c26a5b1b8c6f8ffebc24508d2c31625689523f3c2b5e1092c67d41e51f5c236c7f213c6d1695e4992e5212d5a0d483585818bbea07b32149a4fa56b8944bce02407233648a3d92604e439ef1af32879507f0ce916fa6fc30b572a2235f11a3c27d708f5f81d5c2be665b5c28b1307af158b43e3ab41beb863605e496c4f8d7d08e552d75572dd406f05e63d7d7abd37887f456d56946c16b530482c13c62b63608e4baa2f382482fc3238efb79285410765e003f8ad9980f56c0c6921282d8cba6425cbec076337988a67af24b60155afce4bb94effd06c84d77ebfd5ebfe10fceb4a089f27d9651bfafe1914218a4a09b57ea410927ba6822b623d0d3bcaddc49f4249a78ccf030acdd5c16183f53aee9e57bb14f6dc87e9d51ee68d2a69ac1098dfd96b9c40fb09429a2130bd61192e13df2d0d5a37a1746097dad0d99658d3af91f9c20eeb1c6763a9d43d171393aa1b8615cd8bd745f68a6a1a8f0d88bd1ac0459d956af66f9ad4a4712f4cb1c8e896f554946cb0f914c16c552fdca85115817658e1a1e354d393cdd91d28f72c29eb1dd0d62a8f4158e9547cf6659069a2bf0d195fae30746dfb8190ce0be52f8f127bd6643c3d0165bbe2b9334f95561f8a0b552da0a2c0611098aa7b8eea201a21d84f0553709db472b31ffec5726c32e7a7829d1bf79bcc185be2ae136eb61d7ae25bd2a33292567f10d6515614fa32aae0eed7ff8978cc64eb1695314a087ba0dce9330660b3e2102d748eb9b9b30019837c332d93a9b6c67800a1a8a5760f14c0952554bfe5cbd4731dae4a419acefb63561ac350c4057cec347bc30140f06bd36dc7de2132f5c7389ed6ff6b92071800b685d4cff0423a7f14763c4c86d4d5b50ffee62a528766667c9d7167f46285de58f4ba71da608d57be73d407c8a5ed5011cfa7659f583ccb872ca4757f5b330c6dff181da5f2a109344595f2d61243a5d5d015d7fc99a7bba2123d2ce6ea5ac6d0683db85e7c415ae657cccc6650817ad42d08b6b6d2caeab757a1b041949589749b27b7aa9cda39938a3808ce4a1b92bfb010057e593b7ff658f32aceed679b84ee2898e5c5bd1e16330d7433e82cf3575d15781dffd4adeb51e4321b95bd4f0781bd6145b8bc783e02fb7cc06b7bd33276b54acf0f8d6d89d4760d67837058076e36fd0eb109722a817215fc6a1d90ca80548cb578e78aaa0882104803f3c1b8a29c73fc67bffaea78ce556fa8895352bb565072a0d56aa4c40ead43dba8e872530ab462cdc18650ec4db39b5df1901ad24c5166d8d010928c0775252f29cfa1062c0cd5aba223b47fd5577024189233d5f804737aed8a5f27ca35f73b7822627f7caede99dad5ab97e1506467989c82fc5c120ee90af22585f18cdfee69e419bd3c50cfded8615855e63c4dde66760d53208c36f42f5907ddfb91a3de18fe6ff64369849a2ed7cf28cb40e58a38fc1f4b5789a1b76998021c476c4b37445e34cf8a3116d229db9d03e560f9f267ba3704040dda42ba375cfd9558ef01d4f29b9e018b6d64bd89a6348169cf3044ecb43a0c7f24f39c49f1db94ad4d3ea782dc0dce892d8419b22349caeeb5d16c0fd939bf16d19a7a61126358ce7afbfbcb1d16eac9a78050368513f8621ccb57d3aeaf38c0e0ff818e08aac3e66b203ce9edf2da115d70fd0ae004d362c228ca91cba0778e84eb6a6506819d8bf8f6267b7e22da634b239d8002f7f6bd4a978b87fba55324b387db6c107cba1f251c44bc99af551f7c122847a23fc35f8cb134c8d51192c4c0f0a62ec66b8548032da91f7fdb80987f65c00dc28bb6e34f51519cbd6c604928061d918faa0c59d4648af49b37fc9202a504e077210521229c421e720b158859df9d56fd9054421e017e56c43ca43a8ca22bef1a60cee1447db18f8e661463dd44c19563d035fb8d5084347b66932a183613466266a80c684d29362b3ebd9b22c7165cfa97d555cc5839d27fd978c3b865b424693a9a026596e464b13637f3b85d6888455e5435be9f98a72b7b562ce1ba7a5e3688e0aec22baeea4d93b3be338708bbaf9955d6ef1f95908b9bdc4de87c5491a4c6823a7b6c666d10a9dcb0b004282b84b62733f6c02d6ed2a82eca7657ae4cb81b7e7184f9f41510ddd3f9a92d600727cdf6b22bb90803cbd17c8124793037304bc2ab4f36ab8e32857f80a115c8f8de46d80a54b85ecdf9292183213f5f2ccecfaed8d84a8541c0255abb80a0b33b245ace636fb4f32c631110186d6c62ec19e8516999a363045e4904545b9c85d703682644ecb3aa00de7d5d94f614e21ce1bb6fa1144758aeed2b5d3142b4251f4d133bb98ac155c80c9fe09a4848b3e4cc8a28c368d6e8f65969cbce3349eca1bcda4fadbde076accc1c10cd954f7ae9c66dfb7262376edcf1bb25a1e3b44c93ff4213c5315e507e7b2db5f645511a8a53169473b50f62afc9e285c26cbe9dcc087a7358d83e74187ae2ae916b5cd9958c74fe1b5290aa941881bb0e683ef9acd2130a2486a53459671fe46b7f942a61e74f4487de05a6829f00b1e68715d68935e18ad817f68a880a5e3c7abe69966d90207245635088c695c8a67ee7348a3a5a34608878a238a1aff56626be0843a7f4442fc082c55873d928e45b47512a58675ebb7a01fc0ad086a5483eb0e6c031cf911cf53fd44e5381da30d5d4b3bf5e121b9bf6faddbe5da8f4057ea90722fe0cf6c99fed16481b797bada0198f3ceeb5d0debb54db4b5e2dc540e0998ec9948720f788d4c4e79dc46e539d23ba4a4617bc746c48dcf95ec5ccc90e6135635e5d9d3867e80405f26e16017d602509e727e14c5f8ede5e51abcf4f55f5c036aafdabe41002bec3686319b6e0aff1a34bee6312dc97a55992a1fd6192be55ecfc9665a94cd23844f15d685e605bf651be5470f38bb979c6e9b9d0a19fdc1587a7e09bcc2c87d030966322aa9207e9308c5eaf69","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
