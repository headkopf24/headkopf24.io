<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b89801358ca423ae0999e951f8a57adb4da7ef0710f0a6f0f7c6f30ebefe2188fb6137bfa297a4f3ffcd2a6da1fb159343458cb1dbd32754286fcead18d3b454a574d845f5f542fbaf38a7737da1ee04d5d220d4708e5f7ec9690b76cc6c75b83065edff451be4cf655b69d3285bd9e8e5f804868733e8f3e806e5a6555683f243ef1473498093cc91704c509373ae3a72995a2653af3c8df4310af96831c9f507198c61412e76c838f62d0d19954793277be3a5045502ffe5b824e2019e1e72fb5f2a0e3bf1cb00e7bacb5909e28c1f5fd9fa1c90eb65f62d22a1f800cc35e3314a4ccac070af6143b5511d47d2b74b531a8e17014f0e6e5a6291dd7c91f913b6640008db461dd1ec71a02bcfbf90fa019fbb43528cafced9593878cc6c8851180caa569b501ba05da41e43572fef986e54471d87a5a69e8b39797a516fd859b79efa88dae36f4bf3db9f9a7117f5d82a6822d1cce5154722a8499c3642bc0b375f749faeb5af2ab8ce90d0a37b526652edabbdacb20a6fb87c8d87cd05c31c50cb54e9a13f2b4df597f79e14f0acf4dcfc9a5e13a52188ae3a38a22351d04b690598e55c197bd9574b04c6fdd13cd891d049ca7d49a1691dd198d7c68caa9da54321f22f54fe1f296c024f48c58461c0f0c666b7cd52346ae5df561b23bde4d93429ce680e064962506cf54a1b6dd337324c76d5fae2695654926dfc135829f843f4ae8a23aec8f6bf18f3f3e57dcc6fd544bf488532bc7959de89e00daa8f6c7a841328ce38138ab663f0d2c97601131351e784643f47756d6df5de1760c59e581a1b2357c97d204351e5e537fc600c59721eb8c4f2c78a1227ce3abcf1b43327a8ddf0eb1d3c54e047163b08d694045c6fbe5bf0246059ac333f0e1f309d740f6fa69757be2193541dfb31268ab59aa6960ec7c818d013e02a2052ff828e7251b020ce520d5faa10ba51acc744742c1f07ef291b89abe58db3ab545a62c14279a346e6f5cbc778b1cf1cb502329461ba772739b2ad38c5e53f7e391ca6ac7c7473fdb2a4870c1e8f9b8655e6c15f76f4fa5de9e7a9a42efb3d87a64260871b6bec6582b90667fc2cd38353482a015a832c506467d518f8496b788e3a343c26267a34a93e09bbf93177f4fa21fb7d1e7e22ce1e682538f2b7523759d36830280adaa9c2053ae86ce58327850593ff3a5d34ff97be79cbc925e77cd6a42a28ec6d91a822cee895750e7a846069bc4d8dd294ceb0d0fad6174da50c12c0b5977b9ae79249dfe74f3c440640030e9e7f16f329e6cab426e41cc320eba503d29f6e97cbe39729a4347174744dc73a1667f6f56ba2470cb8869789509a2e6a273693974d094cc7ab02c046680ac6531347cbbbbc5a1e8627f1a1ea03a6945631239b0eccb49d7d194a7bf17d93faf92e6837e1b45db1e40a808ea10d930dcee59a0a5b251bc74a2ea2cb0d5007b143339811aa6e95ee7152e2e7a869cbc485cc2d103a0df35538a9a5e4fc86fdb4363fc8759969194eaf0b976f05ef7c88368e231b4ac8b5cdda92eefd92b2889f93e3cafb9e00642bc26c42fbd714dedcdcaf7588a824ad5045361ea91e98aa13d9571ba529fa33994b7b18c0f7e8aa4e2f39cbca659a040febc7a1a456ecf247bcc8e59f278ec9b7a38465337172b8f8b3001eb309aa3521eb3bc4b6c66ca93eadc1c04b1a5c750d8041228750609a35a29ebe56aa8bacd86310414ce2bc1c72c5b9937f57a35190a5f236a5e1353f6c9cd24ee7f2a73547f579bf1164ac2d7403f07709b9e475e3e7c9907be4d22f1265c5bf123706c3971d4574b065dc7150b647405cd3984e09079ab14b3926689dd9cb950197f988e467be577d94a8aede8a9c2d8ea9da5ce963070cac6c4b76c1cd857539b8a5a45b406c16a5a1e5308081e924dc50fd9fe22c541b21b37528f95b27981598e0cc8d8d401014a13af9629a653bdd3adcddff5ecb1c6f8847a2e2de9ef0e5b41b9acfd4ae8765d2fd4877b6ff084d58b450b0ab9bba92b3e9f5119ef07cfcdf67def94ca3dd6ccce2dcfe1a8a7de1996908134827097bc05f2f7e6d31afea6efc4990be99a6ce704131490c352c2867ba12d66be38fcf3818cf4e87c8cf52ca9f9ec5cfd0b6b88160003d1642b28fe6a2b27a614c11d9c78f8297f52126bff023a2f74491908b9178bb4607d5195af72c7838e9649a7a5917d9b667c7d9888dd1998553a96c38ca07b1a4417f71184a324bd71644639d60828ec2183e098c4c7d71da1487bc5056bb852dab63735cf15af8d9f5ab51e2c88ee8477a01440f315c8f4a57a54e45636f55d0c2e94b17becd6f4fef5a0a1f203bb667217fbce7a59d94bc0166e503ea7f04fac16fdc906094bcb20f01d98437c0236661bf1b1e859b71efdae7fcc32befdbee41b5312ad7579b6136a4a0ee9bca10a3392051405943df6ea624c68261b9870e08b72f1bf9adfbea5d38e710c9166e39877d1ce252d8afd94c135303f3ff650adfd77576bc414dc6d44b030f61187c236d0a90016401faf6bdd0300321fba316ec9453497b52c8461d5bf8620ac314e02a2a59491be4a62251cc8451bd5d49a51b05abcca6d06cb2a8cd15e62329784cc4a8dbf16f1a67cdcb1cb3f74ac8ebe85ab74d058b34ad4322353edfd5b06e49a76fb73fb2c44c6a40d8ad25c592cbc2ba2a3254dce61afe2497fdceec88ff35bef0f58fc45ca0b397e19e98c31e3f61e8f28ae709df9108e82a7d1af586e75b9f2fa27ff1a81a16db3ebb249edec4afd5808f773d3adeb93bf63972b27fda3beacd246ddf0477c875b45bbaf699015c79b65b17f87a973747124bf8ac52f2c8ddefb9483094fe5dce834477437712e345449c07eae82c43a0f222d78bce79eeb54d90456430a587030326d412c75fb86a121f1fd705c21582f2bab0efe6232c2cfc417bdae48333bbe12811eeb38c7b6f476cb95233e7931bb9a72dbd5c5c52b5d17e0e1a9ff0653ba4c7b5d680371d1efba7d23265b97142986ea3e9467b0d158fef175f1f7579877d20c01f005634f4d9133481b461e6ed0440824a13727b7d57de0033527a69c260f5fc6fc41f8d7fee32aed422c267ab318cec95eddc0ba081ba424bd3d1636c6dd3ffdea460a4b1ae4fdbce835e8e3903794d214257ddc29364774fbef751a32d8dbeb7434d1162ec54c9c45a42e180a3ba41162c8eb8366036d2f47068dec876ad45ff3fca951333bf24c87dd75985f74968688d70cbad975dc87699bccc06e1631d0b2d08194cd16983f3ecc989ab98979e2d48856dfed40ec6fd3f242f7251bc8e20e33fd554e7f2f078c6426feffc1a5f16e2d9512d49906eb0a85e2647ff63a1c3116be20d8ba778ebaf8403104f1e273c6be500beb8c6e6cbd1b7bf7a895ea53ca13f264c2d9536e5bc33ef9e520daf97d26fd91d87ebe469a5d38e65d3e659542d2557fa8142f1a9b7ff56a6dbd1e0483296efe0347194039e223984bd7f7d532a186071146d8e437ef5e8ccce3a1153df7b8acbef9071604b7178890078a19f7e859961faa40ae3cb0e2538099161785558bdc7f0006005affe5b6629d8ab9a342bd74d2682bc4d862965044c1f944bf16c2bac146ca6c043deffc1adc9d00825fd9100e1aaa449e90b71a17ff2f99b96677da0a2a6ff2ebeffae1c5cdcfa1919b343fad948108a470510d61d077ae721cfe07211f61f35490f9cc17472c33d73ad36dffbb9fb649f61fe32a952e3e2f936b85b45822adec8bc7244fcf321827586cb2cbe708d99fca82e753f8f4588b689279ede1128ce68287cbbd915ac7e4a21bd0965e2c5abcefad76922e3946d437d9028f8e26a0284b95f3db429760e67982106aa998fd44bbe29f28789fd00af398d31e3c3a1af3c3b54e75cec111728791a435ddf0ed58c780238120902b5526294d238bdaf53f6dc93267e44bcca88babfcc1e184ab4105aeeb94c71617debff97efdba27933694cb70e03b4e58b3af1a5b8dff854de05d83f6b6d502cacd60c6b6bbd56b5a884bbdb3dff47449143637dc901c814c930454a28af00a660edaba292ad312fa2fd2539bcfdd30584f472f10573b3d16d3a612c4a98b62e3da97d4c159915e975dcf8f98c6367de18bc03a8b6705a1dd649e74958e61fd5770dfc747edc7b7b7d60b3b1c91d0b4a5a69291b51cc204990db6b127111cb0fd3700008546c68e46ed0cf72f57d4bee08acfe8566ebac6e035f3b23faff028b20f7d804983f5cd6561a7e4e2f69a94ac28b79155d59637a363d293a52537717d418cc435934637b933909aed717bf86a130d0856edf13c6dab078e6497892b8a696f2f35a3886f2ba0e356add1b016a671532090bd0940c42880d96a8bca10105da1e066a8e073a73504a56bf51eea2c5796a927ed00d413f9f0630b2f51ff21964a45809d24536b5d3e0b09ff8164da0384a0c10aca9f1d4de1fec37d123f9ae4686ac6c534b0e2ba12151207d05542be60eac0d7df0546c50695d2339162b879a61b3bd1342b3a9c7455785359dc9508fe37c07a0819bbc92853df1f0bdff3a53d1dd9c3aadc9b777f62e546f94212a034a7cd66c6fc40de6d21c95394cc459adf883e8fc4dcf1a93cd298bcd82ea4fc26a5da442b1e0938243e94d04d843add52a7f2853f7ccdb3d424d7e0bd5261d1389131fa304056df11d24b519d2add42253a1f640a7429fd8984af286eddb95f2f965b91488e3f985a05529df424b6cfe9014b5372d2f86ff49b39f7101218a0f065f7e379ef2ee7d2bda7c5a0857027ede083bd79183e081035e1159fa4843faa720699ae7857f8379709831635ca6c116f4a72fbc24cc86a37c24be4ff73b6062f1e4058943cf419c0eff219263a2708d5c205c0a7f88f32a308261e6d3dc84548ad23d017417aa31e552b875254222cff6dae6db56c9c80154897d4bb79b4c231db5af77f6d83cd2f45cfb90f1e1d02d1f6ecf91e5415a6807c37cda348eb5ac2881464f1a9d20d363d290fc6320d8bba9b22db2acdc47147fe07909d04a16a16eeb994ddfa844c01cf7de13c0767e14ebdb0622a5c95196c81157cc2d5e0e47a929914ffd6b6d1adc80a60c4491bc359bc14b2b2b7faffd14ec3de43b5f802d9714ceb25120c05ffeb9fbf79463087abaf5789093db7874e4898a41a91e90b53ce0b81047115dbfb57006552bc7f453d8bc7f0c600b860e9d37221aafdcbb4e2da133efe6f0bf020b34ff9ca56db558249419ff4e29ee37c440278b24baeda277bd17d79600b30179b54344aa83590ff12d4d5a9996ad2cd8950ce4be910849cb021bd2cf1ee2de73469f5d020663a17bcc3436a004910a89bb5af6d8136ca797517a1cb53af8f9ea5610f3433955fa0590cce9c9c3e87d133f3dd1bf749fa826ca73a52cadefdf833bfa772ba46664513f4af4a9aca4dbb2e2e8d3dc41f1c62baded599a1ec45a3dff841981416abdd2b3c3dc49783acec314c33a51d6d116d66b6a12dd47e7bb1767183309d6c099ce80ca42ce58fba005380c983c53c996dd7367c1d2a82e2e0d3b81f299267edc18309f0b8c7c87923ca9adaa0f84143460bb0b9860315d025552144729281d931c9f58a95c43b3a1c00ef8f638334240499c2b90ba8f100fb41812a80cc4a4d5d1f7c84bdd3e1822cd186183cbac414afe7c68f1388b7e9f39f34596b6b0a568c286d06bdd37a2a5eac56f592b9a25b57fb09c452abdfcdc923746537a931e72375924663415c509c3f2c8b0903f3d5a23e88fbc36ec0335bb6bc5d9aaf150f401ac635b64974b8bcd5df6aac26e55f8ca3fe5edb9e2d4520d535c8851387d39233bf219e1ada8bc35bebf7df6f6bd3939e10703c08b1ec47c4b51e87082357d3caed2966e1b34ae07f7924d191eabb18cc2bb2028f3ce2117c01e88955ee3d6ef04d8b8f3db08ae4302f21fe2436bb82af278697d037df4563c0109dd1d9ae7806ffb01cc7e61c3cf78084ac87d9e0a8cfae08753c6db546456fa9b58663c89ad6721ee843d1288b6c3d89043339c517c8bb8998532b664f1ac91cd047864330a2a5cde85b39f60bcf3b7144313684080bb8184cf479658f38f52d46f57930870498c3af1045354d8da7cb6ec242a33421be77200472959600d361bd94e7a74a487785c256c0cc1c42d695c34c670b2f6af5035c9ed9868b31969d2773c7866b5b8b59181548d43d091f7a0cc5628c36ae2b0703130a5126584a78154e579857fbc7117c0aca099c3a6647d5c4ac53fa07a901d52402c3075225606e1dc80f1c947a7d41c04e0348b610609973060d9a76362cb82a77bf196fa7bb2794672d90524ac96f12299e0100be2ba5e2d8d03fe67991add9ec156d0412b77c69c2b65a32ffbe0675d8e0989e9b8f956da7a95c095a585741cb88fe5f3c2a13b4d744e539db45fabd515705941ef3b02d4a806921e0f8289c39fd87bede024cddd6fcd0c644dd9bdc7821ddc3eee8c95b721fe49230e7794561052f924cc7957fb962420856f49f2b2b1ffaee3761f74a3d62f08ba3e11749246c222570e415b76b4253035d7c6fa00afbcde88673715477b48139eec2ead204806e91412b729be22d90d21e05e986a60693c98b0bc76b9bf12bd52802619ecff98e0742f2786e071b3474d1c6a6eb02b4dd3c1614b6b9e7b79f87e19fd69b624b1795bc1e1552c7e9b27f77ec7d60a23c274e8c5efbfaac5e3132fb03f622338f44feaa17ac06a22fd362d164289308eb7de5a6c3fd1702b0f0d493532995aa76af04f71f8f5aad7f7d4c696662917a20c112a4ba6372a70cbcb69e69243bb6260381d36e71b9b6f2f5ec0df559a15103c30e4177141e85aea20de4577c61223aee69c81950967d4f86c03d04474df180bc59e602ce163074788c585797f245f3b62a07994bc003b9452539243e249fc05e16b72029e6553f4783d041528f5a2f919f6de11e5bb84cbacbd0cbb452055eb312280e50f707fea87f9bf2362aa2a296c82186f304ca07356f9baca0f5ea61059e8f5adcd272eeb3e2e27f3d50f430f57274f159293f44e7fb5389e96d4d537a2233805cd59dd1c73348c48b3d369d251c8b1b09f2ad1710e28d9a9e554fde7ec3a482e130ca32000ffa1460a355eb22ba5f1406d1896a74ac9607ba40f04bf4966685d40fc9fde866a4ae043e0d4ffe69962280f59e6bf94f221f5b815422871e7cbf787c22bdb4e9f5a1f421007867c910f0cb07bbde220df5b7d6900742baeb3b0491316001b42dc05f64008bd5c5c439fff90457ecc574ebfeefad47b84672f7e368283668cca809fde425fb6837b8159a24dae7b886c6fc9d7f7faa857ca84cbc0791a982000f7150ea3bbc9f92059bb386b2b1de12cebee876a7d0aeba759f37644d0113546db149ac84ce2b739b26394decc8ef38a36fe221296fe98c4894545079a0468fe977aa742daa10ed7c01a17389260baf8928e1f97a240493a65afd9d690d94ea51dfda0f953b628970a8effc1b963918283ead4ad5fc4039a3d00bd449c0de61229538d3d5ebec5251031e4b9ac2db6988a02a921e0c3f5d0cfa839cbbf0c0a10badc988cbe8c61e48836a95dd047d8213b81eeccbe0d7216c35e9a1d6da2dfd3fd3081146820fa5c941f2bc6828bca251a085e94ea7224a1e7d14901fd27eb79080c28b42b2b9fbf2ddfd88f46fc496ccad7814515b8db105bbafdb5964f6d3cd22a490fa3538bb8f8f9ed85437c541ff14b1bd6f363a9fd4e96a8de37d4cb2d4a96cc6c3ace1dac8c6afe1de0b79270ca097d563140733b49381830202495b96741b1c7328e13413e2f7256e869c7f38c086416211263566e78e361eb1f588f5450de7e0f724448af049aa47b77e2d9284ed43d1b45abf18f497c7cb3e25ce02ab0132907589388ea3179d1d92168d7f54bfe81815a005dc9c5ba3a586b61afa753f99b867234889b2e63c20f2cd99ddb7a7058420dda5f962b79d9d6c7def8de55808c3bcfe9e435e8b91f2e465b24e5c4cc741989c69cf5368738d861abd2e08dbc1fbadd0cdc63af6eab36376121372bd7e31dabbad09e75ff632b1e718182b78925d1c9f62807d7e6fed241a312cbeb9c55a2bf615bebf0d665add19ba4ed1b6f3790c0d5ad36d287649098b2a69b1f558da709eacdb2c91d1cbc73e91785f0cb57f7d241c75a7f45bc944247fbaba5203131714a94b0474520522d3289c803f41efc177af182c16bfd345fc62275f1ebd5420a31f96e1d198ead02f25f751af48e79ad0ba432c789346d699cafc55f00ee161c56d5a3c379d1b60ba81c85818ccec56b55a252bb9341e8ac83052e9fc25b13afb8bbce4d8ad791b6e13a17d07ab7a8877942d8b5bda400b9f6bae835c638578c095251cd0263da71cb457d3d8acda98eb6b56dca564e1c820fb0d4b28c84bbd9395c47368e7a3fdf2033bc141466caad97540825e93c7c272d007094ad166653385d73529b8fb4e09c3c2d526165683f46d9090a4c4b8ac1ca29631da8821ea48eaf7953e1ea6bad86cb68eaa1de340f9d6c927a77b5abd4a6183934693fdddffb7ca618a2e3253570dcd6162e9ce127889d25a2106f091be1789bc4979e226d432376537ef0e914e0c95e2e685bc2015638807d1c4f43088fe39fe6da66280f37d44d29e4e0cdddda85c6fd4a92d28b3af72a8c5d2a23e30c7d9b8eaaf9f1be6fe9cfca2feea1f89305e537c8889dbef8bb5715e77aeb83ddf13a317d3ff067f920bae1c3d6764d74054b7825aa77fe0620737aa5d0c3d8763c8d0d9c2062dc379e2ffe21d9a827ab34512de658260e5cea5c21d608f15356a78bec55f7ecc5d6bfebb3427c5169b8a657071914d886eba4214da97196d5b31c22a7550dd76ddced539c6700732cd357d0267d9caa3318533952a72507eebf6b2e9637a0955952db74bb5387d019f9aad78db356dfa2c9e4f9c5a1521d2561fb92e5845588ff8c84b5024c44aab0ef2dfbb89c527dfbadf4e15ee7922fc0caa7e4ef673018678176fea5d7dc3558ba746e03207c96d3e28bf71084c6db9d23cf757485681996778c74c76f2110bb108c037c30dd986704711c5871712007ed372d6efe2fb72dcca375a106572332b62ffd5e96a573ec2fa992dc0abc42bec6dbfaac755486d09867fcf2de925a7467ebe67d1cc0e265a20930cb8633302e2af0b1084ef6a2af676a7cf20e68f692ba44ccd377c3e852d77d5ad2fe0411ca3723d7c9d2e30d548a6e1bbd20cf8972a5b4cfc1419a7ba884979399c3dbb667a314876dfafc25890e8d67b6d1a734a589a9eca056be445250181ddb05381336caedbff8f247471852404804aca559d4a0fdf575230651e69fbc39cfc2293ce42860d56abf92333ff08492362a71e189956d83956d1cffa3c67073b6bcd78b71d391ab4da2a6d99c45c38c6d4936e4f400a39ac37aa28599421554ee2add46017845275a6f07007b79c3e90bf9ad395decc0d3d795e101a8abdd32f18a473841c44e81f14afe46a2835381bf0549923ecee03317b15b651a2a14470b41eba7f14fb5d74a96b2d6c2f467a6aa9c7665a0ffef37a117ba4f8560a80a79952ee35449a89520e5999b4d08fe366d78fc88bfc94a055791f3849b5b70ac52817fa3013df829e8b162f091e8af69d9dbb9ab5c88a1ca4b5f9fb43b5c1aaa47dbeee3af28bd1784893030fe3f886e346f441c2eedc22bc1b27a83933e132323aca8c8f3d173e914cedb8926f3934642e7d3c5d83168dff9f9877e3f4953127ba66e7838464944763758b7fd57ca409cf5c0ea85247ae66a09e657f7c9c0a939ebc691f653b9412aaf6e30dee7532ece4ac8da610aacccaa3a29e9eb310b83b5261caa91ae7aacb3d117341c0b0bf64a5c6bc5b1048964db9cd7bc429eb353f8e833f472fc79091724b9381426c6cbce8c8b70546f8d62565716c44a75361341f1bc049d0e61cdcff992a2541feba5869b338dd44fba51a06d9111c2c737861bf6dbb6c6795dd6220ffe89c8e0b8e2f8530cc15c6bf28e775cc0c1cb009beb323fc52a459cfd39651db1503ea49d079a4a32dd2d19b14ac1f9272105feb251a841eb6ebce961747f019b718e446808fea96fd815fc0547bcd287e705975f6d376d223ab929feaa94737bbf7bc7e1a86d07fb7a579c815bca8cfeeaeef82224547dc47e1149a8c27231ccdef2094bd31c4d825890af78172e5761773ffc6ba928cc8189461113540d6217287558a04e5eb4da0b409138db647f989bbde50729de7792ac04b36c748dc42a1a6d7ee427b0f3ef01505a454ad7c2c08bf422bca52d3cab7520a51a4b2db19980ceba77a68220fe74e89893a66a7d04fd834416edfe632d4e641426af60c3a2723d8f1486ef275ebfbfb5638bad0a3ac556d126cfba3e4c84aba3f330c40a11c00e3b8a28a0699bc7eef2b0a5e726d2b296355babf9a8c203ab54612351a8a66ad431c083a2fd2229e77d3328a181c3f3e745e624d141b3d65c41a347b816964850f2ae221ae6a1da16c41a69ac6ac635bf09a4481e6f76eefdb771ac248c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
