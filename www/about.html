<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe0e60f385c37e138ae118378a68e9a4014f4859ca64b82219f1a3e3c60e706a29451ebb4ff2a21e4ff7d89b4f30563e5b95d649756a4377f41bd1d53bd6cfe2d017adef0dae475839a6640bb26819818be881bd6be60ef35577056cbc1da9fb89c97588f9f31528f0b5a66b9ac782eae6a6ef20f111b12ab121fb3268daa499d05237b70600db69e6d1d76fa25e4cfe3622d216330dd8c42d02317a159c1e3671e6ad5252ceed555831a8341efad91eaf9602034777cebe788e7c90a2ee93ae285fbc4b6b3ddace7dd9cf0013799bb41c2233b1e75c4776d841ffb469e5f7ea9757f52a9587edf97041590a4bea205a4d78ca4ea53bff901b0a4f24cafd0f55e551d85501d329624d84992b4fe153ebafa4516b4abc391cc83db729f483e93388e6ae98280f71ed7b43ba91124c53a408453b32238b87e24aaf04a3a47949010bdca5e9c88cf6a86ae5d71485c0a3567718b8680bec9b7e5dd5c2fb3c1eea7963914faefc3d6d492124bbb9056abffa68ac1fb71328c46caa7b04ffcb09450368cbff3c965ee2e1a54116880b73a9490dca3b3f735f298aa3f61ddf704b78e371ccaccc72a4c24ca007028e967b2d9e3268b33041a07d37316eef550c947b5e590df48d134b92f97faec16aa65c8a4045781115eec4d017318784a78dbcf6ea9e79f488fc2506c21292c9bc51a46070bd49bbabe50c92e5d10e474a47ace48872b385ef8611cbaabeafad5188166a49f84d1541e0ebff131875d8bded6a468fa0510d42f64cc50f03a79f602633bf6b61d473758549870f123f3841b827a37b0dfdfef2f767a8f7c41b2e8e1de80528385a4f8bbc5b6f56a589e0b8873618040be3bc508b550f02cd8450308da9fd25d21785b0a1011f5c87f58ad2f7ff93f130f1fbbc0b326a238a8b47652afe84a71d41569a040c5279ec6460bad9d88ed7112124875146336d1b5c4aa6e4b928cdae139817fc3b83d3f9ed0f7cd0ffb7db91ff66d2b7b7302e7cfaad4f13731c440c7c4349c11db96f4d2c45851237cad1160b8c12e4b26abc8a6934f2b5cffd1aaebd668b445ffeaea5562039dabe246abe00b4b3deb205574cf8aced46da5560ef8097a104e5eb8ecc1337e139ffb4551202aa4e44741ad75aff20346508faeb8fa2b8b3ef56a38c16ec90e9b1e90f94188efd500e6235518201e4b22dd83cd189d969068e6ce44df489aabce54c37a4a696e416616da5d96203e7d7faa4b54c1707cd1e933aff450e5217fcc11ab11eab5914f03bb471513002a79b666faf89b4b90bec3119dcd0f8ab908b704ad8cd26da0f47715331d12e1e2e86d397574044d9049cdb5c59d04e0a78db5d8796765f902c43c9ef784b9df90f5ea51ba409c13bc1ccf54bf00cd5a9c1156b6f245b69a0556b484204d3c24e40cb00f748ce59f715f7ba907c8f3a328754a73f5e34c41fa163780acb39eef38947fd351aeb1f62df3edf0839020ccb27caa09b37ed7a0588a745e4a9f37bc4a59e46ca80e2617873f76f024241242c01ff81c85172788d8c762eaa10858018e885bcb414dd41e2a1981831b3fc65a8f0f3910b279383b1ed57864d7259234fbf25d238a67af9f48f08640c8cf154a423c433bffc041382b831d224cdfe402424fc8208c53832cc30c5e8ebe67feb046fe83678aed76b0862185cdbc2e22c714856187bb77ebaa0e2d6fade42b0251a59ff558e7da6772c2fe83d6877eccf65219771ff6ad06bc2aed54a9a8050055e23be3f1d260be29e6503f965dd93afd0869de09752a1ce457559bb0657b7f4d8baa43480b6c96572cc4521c1833bdcec55fb46416831ddd453834fc965ce1f078234b0a4b0798c0933d2999fe44b0e7607577683cf63ec116a313c8426d1437a2af77c47871e6c182bcbdd5dba40d316c4ba1958a4412d93b75fe5cd90e8a4f356f8252a621dd32258ab20a641a6433f04745a4508ce04dd1cbb00ec98be4ce10ce4745e240665c416ad3343e4ca5fc605eba2ea3831ef0aa1eb40c3c194b94182e306e3fa3b509df9002aa2525982f8638adc795db261c61202ab6b705e09b2ef171905592fe2233c0ada2a445a3230e7e8fd167213f23f47791396e86558313e4d06f925433ec86d4aed024b6edd7de6916a50bd6d7d8e7ce1b1271b8e5b98e2c718e315b419eb32aaacb6a01af0cdf634407bcf9842ae9f52bd45224c5395f8f3a7f3ef7c3df8e117d50861f76c1bdec806a8a17b68918fdcb085a72c7f1b303119569809508942f3aaa5ada8791ecbcafbceb9ad68f55613033b49af26d384a43910d927388562e949de33d0fad6e9f2a35ce6747301689f6d246a203b105f330c68fab93804ad35a606ad63e5b41e4f1770425b5413912131f923a0e309c11f5dd9db9f282248444b2031a6f5a3f599f6a5e0ce4d958da3313ddce43221cebebd4c655348b8830554b38c39e6e34774fe9cdbc6cdac95e51545e1d2ed4127565f5f014e0f757df49037678306be2b2f8c239a0ac15f62730f19e609e37686d9c1557cd37974bcd73b07cc12ba6298052f8df572a2982588177cfad76d844ee53bb5f4b127c6ce2593f76a77902f43452b0ff52c7870caeb0f90132da606d64ec9b8fbb669f6d44bec0907f59262364889429cdfb892adbb3ebb26b6b205bf417ba409ad3b34fdfd8d1f112e919eafdcfd7e96c9e3af0d527155a5064b225ded384ac586228176f24e73d641dc8a3a843a12e13c0aaf88360a2fd12112b208cb8748e76f22aa74ed0790aa2fbe8dfb0a667951fedb861cd6859ce7dc1713ebad8bc45764e01c614cd33b1ee73b5258b9a2919b6010e8b210c4a30df46f78e2af4470a3a2ee9745c0a3dc5d355c92180714eacae6c2a1af5f6dd2e987175fa86f62ff2d956def22d84ce8b3472e4714752f2b811980021e98db36a36e2abb5ab510bc6822d6737fa668eb20f07d008b17aaf579fc5685c1546270b15463a813dd7325693eee5aa0341c5c4bb44f13e1909ad4be8f72ca423be2f62e2cefc9f1106529b55fc73d86273d75bc42de4a709ff53464096a7de917bd321f902773e9302f2e9172af51ceb06b9f51d0a4f16101222b0052373ef22a136bd6f06e9c1823245295215d9c9c1f6092870868b5bcdd264450788ea0f85fb08202e4707fb3731963e09e778d2612bb01d4062b988162d31d758dbaaa1099632aada6e4de4af1b4f349c77625c3c94f04be7b673e8b73fbf8bfe27e861ed8eae8f3bdc644f096fd55458d028ebaac38e1bfe63a69a8e149f41e695ebf2896cafb81b404f652a0b0f249aec462d98a2a2ea200ca6720400cc16d02ef92b3f24bd1f5fa150eee6180f052936044f48ea8bce1e811cb8939e99cbf362fe02f90bc67cf8b97d2e640dffd952a576476aa869071bdea09b24ad95396a2395803ba1a257e385b672bf4fdbac119639bb71345d27d4ac1eea2048ad72001fe851e914dc0211ef570034a0028e87f10eb073b1e474b9468e91cd18cf2d3b1e0f0080a2ba73e0390cef3cd3e14485accbec682687a2131d4beb609d1a291e098e069d17761257968af2c5b694f0d99c03f5f4396ae5932ef7ada10e5909d59a684597160038c8316346b244524769b4e70b926129ac88c65e10a36daf1e1096f09effa674817d73383778061f30c44aef5a85f11397cbec78acd97b639f3c2f4e5d9a651fe5a406a05e3c7b9a3bddafc9f0267510c1271fbc4256e15e3096c0475a4f3ad3ddd2fef4def502708ab17939ab835c04c40fa274ed71abfccb0d5d9faa6eec342252bfc755dd1ce58986371bb1ed966b642e597e56b0f3b724d1ac70ad1df06533141312b7414f6a4f8eeca31350327ee37be1fc2cab5d49624b18fa6299a3836ace510174280a41901f3c049e7673f4d1d5ee3ed523e82ca1a041dc002c24b3d847dbdc34784ad0c40b5d7eccb8843dbe2073aa2e286ca99228806ad39817a3e07e766c81f8d9dbda5d46a44dd56e943213e60b40fe120d27590239535c9bdc4959b7a78a0c6e09e35db8687284d18db40cb9263b76060d5d418fa1f4712ec5770abbe8cd8117ec74b93457fdfa97c1abbd5f4c4092b0d22255d4e2f37328d2e62a280e8ea7b96e00feebb606bd917a976c033bbd830f468dd210c8b4237a1b9effd162bb1d7944eaf3c207d4d9edf017b6d07b3580147c8c9b7fddaafbef97a62bc4ef9229364e36403ef35e79371e14624420c11f48f291474913f42bb6a8b7bc3d50f52745f12a68dfc01733b909009c3771296e30f332164275fff21ba55c9c1b493235145d53862e5f155f1c855b4f7648b9833dade25058b1813099b20a62ba76d25d406f3b13432a5c9d6a5fae52cfe3ae31a173983fa2c2aae71d715873fda2631ae52703a0a768c6b4af3037b0356ef3d63771e21198f10284fd4cfcd7ff056d9b33bd9c7852d359c713a5c81e6e1784972afad7203ca439de88d46231565130250091247a1aa02aaa345425b2ae8ebe208609ad928dfe3c908db7dbe20325c573c1176704e15cbec4251c232c31334956c0941fd05a36375fc8a295597f57384db4a1a417b20444d2a4be85c8f2b910e64e58d1947e70fc8438e8041249eba20df9fdff2b03fab965fa586f73c148ffd4c316b19678ac83a82502d4994aba6a6c29f73997db59e86197900954d1c36e4357bc06ea1066d1ef3165b74c1c3d5847fe01f04e8ef9eca28fd2f111f25ce660e9b16b7602d2cb998f1221420410af2ee2fa4f266dff12b85df46ade89bd8e2bc270043e6478c6e53368bae0860c7aa2c513570fbf9cd9bf63bf08cfd09720c9cdf68ca9b4b874edfde38378c437c09d274f2b55ca2d1cd723e4fb6e92e3efe6f44fa2f6ff553e71703be6acf9f3ac4d22694a57a359c0dde38bd55d99ff7da25b72df48ae56a2f56e1dc8b7d3bb447cf6de574948ac5a03282b01400e0a472d1a02112b0fc6b2216d4158ff7fc48c2d713ac09979478a8ef0be8c4cfba5a428265750e530bc578ff4f51f76ea418d7dbbd2a803e8fe3742feeb8689717562be2c139d7cb318aa3704ff899253eb0d5474dafe9fbcd85ad8f7cee30b8bdf224ea46eff2e8915536fa0f81f990400e4453c66e055617db7cb33964d3a16d9c5e88d83a081adc8a110015a4237804c00b2abf60082d2efc744e2c4d74234ebbbc5a6f11e90bddd8e921cd0bf28b9ef76e23df13d7737a5db31406bf4d94bdd2e48180e16664b550431d10c12cd8a2333f2344d2b6aeadcfd1d2cc0555646f079b4949bf0547cc61a52d00b491591c4190f7e8133b19fbeefed4041b09abf8d9f7f61340291617af5da5f7641c377fa4819d0490e18aa10a9826f698b7cbeb3ae1733e042fe9a3d03fca74b3947ffc871a3a091df7121db4941c4304f61a9bfffc6be34de098e2d8ad3d2c5f07b993777c12d59cba27e87b5b03b6d9e3c6c6d9a89d1ef41a663533a3baa7cb639ffc661bec36ff0bc84faa64bf13c56d36410cebfc04883e782b40fe6e250f7fd06dd404f95acad34f89464460348a0d446e8a19634da12b88a933168e02f554bc74c70dc8fd998d6ace0fdb9a0647d082742b57789bb447e075ad4de9d877717495b1180bb128ba86a4bf13493abed18f783c1ba4f5d8dc5d06e5de6338e07c0a2da432e6df3867b1af732795ccd44678619a185e9b7cd01266cf8f190aa95688248a0e561ad662f58858b217361f000f8744f362fcc083b1da67433409f78db73fa8d3648c00b2105fc690b43a0c236ab144d3b6f0c3cda77c878b43cc06c34549d418c2f18e7341a8e0424323055ea78860f7229d88003b0f4b589ada6544f5fab55696a4cb544eb239928092e807fbdda8f62207b42e1e77652fd3e56d16b89d9f17be05fc9b39c61c35ce4624792e1f0db5b2659de7b6dce3a48c0a1abc0bfe0c77fbb42f2788bee38c2280feb96dcee68f5bfd2c27f8e4babb4b83c93183abce1fecdcf67477918a92a12c57c3bd871d237665427499e3bfdd65450d707d2d13a1ffc237f88c21458fc2951d486623cbc5e8465fe07e5abb60f82bb7084177cb46a02860d03ead0087bacd336f7b510d453b61c8745bbf2112c1a0296d6884164da06b978c84966a876ef5c06768051969dcca09baa865af8afa2f65a32b75c181836c4aaf1b17ddba3ff34fedb3d71b89b3954e152bd02687f4cd0557de578a0d6feaa8d695d91b216d599b6b8613144dfdffa3d8f0e6edf8734ba9805c9cfca9e7ceb284a2965c61b8a18f0743ecaa843873e9f21690a064bfa5c9fdd78f52553ebb0c3fcb61063b7a1be4b3675597245f93d9739753d9d9007f18413c0574b1b50e41a032a5ab2890c42b18741efeffd213f9be429a44df5efc7b7a5d1a35f0102df6c8ba6bca1cb60cdc531ea94545b70a7431a9d6f5abb80eea06a7ad2a81907675fa9302485422e3bcd08b1b63fcb711c9bfdb64eb6db0ec69ea6291c03121746ee6d246590b1e7af68314a9ef17b7b8befa131b5ba8bb1036c5f111d64521353581c321c1db3ea5e43ec6e51b2d1e29f7ea8bd30480ba500ddef1f380da46e1d6cb7a5b3feb39b93a4e59367c8e299426b033b2e61e0493b1b9a5c0508c342df673592e307cfcd30840b722729ac8a8087ce2757ff0ef33eae5cb1398d90d0b8fed16a66f4e968bdfea669803b8e35e8f8a3c473818a1ac627e21897e0c128bf2d94a437439b1846493d3e4212f70a487150dd02637e605491b8bd811c2b01d52143ac547fb20e523fae4d6a810b3c177bcefe476007783594bd1105d8e3eb71fefcb2fb7e91f0f936ce4c039794b11b7829c74239819157896cd17ea2be2e506d810d706dd654a4f1d57284798077f6ad65aee1e2f153582e76619f21eb1b06e2d0352dd8167e979c5c7fd6cc4d476d898ed460b83251ead80a49fdf792a2d8dcd85c3c94ab1a0957afb14d900ce0170ed8626343f251ca6574fca1fb1b1918054f46f5e83590496c24d1e87c877bf1493a6bad7394f39364b0a32d297c7aac0d0d13138b96e727d7ac513dc51629dcc904699f0caf563ae280b81638c34a4946fe30d18a14061e7aeb6ea32aca136124916937a86ad96c3ab64f4ff1f86f7aca9930a727e09cd98bc6fa2bf3357b5b922eab10c373e0bef397f485e22d1a6e5a8688585b07f870ce9403f4fa0bc7a6e9f2f1699201c7778902d43029a971f6aabd6d452d0fbea96ab63a11803bcb5d3943f558ad85bcc4d6ccd6f363071d0e8778a4783f71a738bece108368ccdf30ac93384b0e189ce39e68fb6585f6eb9c887737872592c4cb7c8d906de2ae32d535785bc080fc9932c30489af3071eed55edb62d6d4b0e979cf857f213f826a600659cc80db59f7033143c4974f221840a2a81375c661a7284b4b0078c0bc69bbdf90a0100ed3eef3671286c0799290a2190f2707a6853810393f376df81107dfbb93fe0c24f020a91d41286bfa6b2be1b13748c4fa22937e6d723be94a06ba8316794a9325fb3e2342478c0a5c558780c578f38c7dd55b02a3d7b027a9649e43c3a5356a47d5c69fb95424d52ef7a4ee79f3b209cb309abb0e90d90f9ff5a111e11cffe67a34e9b976a8d795e6e2a1caf10a468c6d47c22ac4957ba92e327b2ad5daf586d462a146321bc183a8d9252150824f7b68f1ec03c1fd88ebf1b89af588a7d22bfb35f6bc5ba2ac816d702c516fdff14da983a40e244b0b44ab65568f73733e05a015fefb07182ac5f7638c90d1d6264b79da97fe5d40ebadc967737667027a48e6384cd01df7bb9d10b60bedcac6e331969074035b0df4fe106e1beb950ace210575ed8079c977057ed7a98b96de339da67c5e6d460e675537d5698fc19f2419a655d784bf64b08f4fbaf6556dc180d4fff1a0f6dc1a66ee54270051e222ff8e39ede844ae47d68a1eff918bb1272274a3c3ca6a1a4d9dcfd6c0732494caad4935b863b07a94d9dea5efd9c1c0e2f20269a31d072db487eb005e250b1fb3e7af82423ab1fda3e0a604dc74691490669b0d3673b2735f4706f67b5a438e30fecea1a9337469304a1b8cb754ff62dbbc07d4996b748dde189b75765174f6414c01ee03cfaaf29b889fd1a952cde1947353baae029534f8d5232bd991b755a111c0e08bf902f34ccd548d3a98725893cc63a81b799a06fe88b2d09926e2e4eb80bd45115e1ee9b724fe27e47f285e1eb6d73fd95828058ab588ae062e27868a93d1a6ee08c6ea13f3f4ef2d6bf66672e72f04f3d24aba1391f7bebd68869faa9dca9e70ce6f6c520cb87dff966d90ddb78b8e78c269e651811caf5ff8369e61808f185ff598d55241295c513f66892f7c26aa5b5a3c84b96a66c0c5ee20c3bf8230ce303c6eb85d32481e05fc59d3367b5ba19c58abb8e48c7a730d1311a69b68d823bbb0588cd883ce9341e75ee547ee6e74c840d9f7f143eb5011e956def06ec2a20f383ceace109afe6aafb43af1290596069f43d3771a4a08f1286846ca9674e69c3c04c5a5b3d32eb908579f80c87ce60b6bd650526b03e4b0eb7e18589a5865aa24cb855a63101ba74187a911e026403817eabfad14ba99f1d496d0454c592f74716cb886395ceea5d94ae2ea845b322daf16f11e8a5b7762eb6329c6e215b35c028f4b3ce34d2e71fe8f3e4299bfdcfffa909b41ef11b53238303663bf38c656682b6118921f0df9e8cc432a9216eb4eb5baccc55b8ed52e8728c71489a84af158c140c247f674d04b954948e5a302b72ccc05de0bdf405943c32b55103096024bef55306b1317d75d64fb96660b82afba693cc82c2055c7d70e61106eca2038e82460490de513f2a313cd7d598cd53de097cdd0a0c200c9916f0c8c4080e67cbb4402c4105867a4d1cfecf0da014b82ffd86d36925043d8664e3f91f3cc6a59c07e5c3504a07396056cfef2c95ee8caf8fd2a9f596cdd5a6888e8cb0e21cac4d107834394e0c74a998a27148fc4c2841c345d42cf4f6514fb7049db5394ce193488eef7a919aa4442acf79900c6637c12699d17f21a943f6e1238de3f2fa002ab97d4051fa287979df8f085e3d83b08f79fd01c6190ba6cfdc8b9c6cb015272f61199fe367cb2f19ebedd863f366975477b8d179ec48584988f76b5401fca0bd298d85db5343467506ac960812111a92c60a14f65141162f34d3a80e46a72f0e7cdda0d6a70102e5c8a34a8be3df90d8d5454fc477e5872ec833b9387c9962ab05423bc73ade31e3ad6947064651bc92d2a428813677ca730ef841b741a83f204fb3c35bce541ec517729cd514d7d424aadf503699bd17bc005b52e91a47f98a006f620b8ee85740289fbbc681cf092f6122645c5ba6a354f7be16502c9d6db96a086c060fa0d9d108ccafdd3b19898846ad7a1195fcc59ec8bc6b1bc89b0d87a6fb6aebee2b17fc15393eebacfc13b271810a7876926bb9bab5fb2cdb48d8c26d8a5edc11a8ac390833680f385425c4f8a682206ab4eaf44813b0644f0ccf378f121765d65f2f44f2f419fec5971eb88f5280e675c34f1d4c4470695bf1818107be6477c08ae4543e261c6fd281c76a18a93589db077dc4a2a80493979736cb4ae79173d8d2a709e7a29a07ee993c8b68c6d00999b64f2882fcd90ec8102664b05a9b72a778e555d5bd7017be3b6f0f07bd9d5899a6165712863dfa9119a75c419a1809d1b86c7d4e47c38623810ed7644df9af3741b9d6fb089feb7c68d044193c9833e529b5b358cb0cab43be340494b0a5044d93426796d4c4249939a31c1807777fa57b1b7129d824d0720f9573266bb67e7b24894054d2a1420f110f41707d8926b23d2713e20021b7dafb8af1cef62290541ae9a0fe8a2c7eeab75d5536f800d632075170404df1ad10b9ff5e14f2d9361b0398acf061f9ab9da8f890b7d891594c97fe3314f71e03b5006cc5897f60ed4076366f1cc048ae456dbfe7788c9a4340f68411b5ab94dead638b2579fa514140f3c0cb6a76b796858ecab0907dc2e831a36dd57b1af012e0a3bfbafd4dfceefb9a97bc783d20628a0f9cc61552fd42dc8d3adf4d8b7603eac6184f93e776fd273979bee69d346602067e09f5c5e6156cbb89054d2c4bc594f446c46d2199ed1ea4deb4dc0601063fa68cb0bde6c8434a9e49eb3a756962d1adc9aa8fda648753b8865afd25106b844cc5966c12e8b17f4c52d113b881f7609966641860a4c26732aa5f1f6906e4ce5d7d55608c8205b4b8d220830e1e50328562b86a5227e9a924187419fa4243ce841dd22118900e72a55d22e963cb415e353db043d8f2c7dc3a05d3aea2cf130cdf9df95bd1e70aef6003c200a0b71a795924b982023286836ab46178a83dfab505db15e472deba70a18b12fb209c5891a589a715ed8d23ca90f3c22b3e3c8902a638817e5296d6159cb7b3d3c3e7a46946d7bd5b79895d1678fdc1db451db4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
