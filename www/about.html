<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"392cc66571ec6e2e8c709e4d26e54656854e09c033c4e02e6ce20e165962ffcef8382c6393f2cd36a38c4e22a49cfc3b390f6c30453e8760e3dde9fbe56026b9f7e73480bac7b403764051dd225bba27a65a538a2dffb5f0890aa9b955efcf29b4025821eb703a3d9a6e14b7817e5d040e17589d6f67d92cb7b639b49efcd0738e1d8b8d0ac5f8db71440d84b8016e8f1a90c442b7d06512319d1db779e01e9dbe9b362149df5deaa59a1569d1d789140e9111d70f5e4837d8efe5c67f0b91650813d2e9211c30219c9e903ac0c413602ebe5850171ed57d33a3b0e3ca562ab364ab14936a2648812368655357cf7d6490f52ee163765e6a4fb5dabb53836cd4d1c7a4b0b363cb8fd3c08e02d8f91cd354bc67de8ff14e67f6e8b95cf41a577676e2637e317a6b6943b42531af4243c48dd8c594dbd0d79eb5b454bbd8b9cdaf950782097d2ce2b175aa514e420d4756e17a1c31dbea2c521cba59d7f1f0d44c6f80790e3d60f8f3bd229432c3c499e980e106767de78ca4fe088b5f4b0c58a413d700ab6ea550827546a4993592eabc6b0dfbefdf12035dcbdd3a2b0aec6cf5551061e6df03e9d93479918dc5eaaa807c4c5363a6c39438886fb78755e1627c452b9658efb396fe0c702236890b0c24def18a4e347ba3d4ad650132c831edcefe39f961af4b2c3b29baa64d8c061046620ddda614c17a06c5044281cb64a1652491de9e7af0d209b2af2dcba809111ba2b1fc339caeb336cbac5275403c5a77dcfc615b239a4e019733ee50918e07989d80cabcc8ec81f3d69fb6e42b055e26308c20040c83e797ee07931efeabfd23ee4ea49ba0e02c1ee1f4f146437fa0a3c8b0b624d095b7b291a1d082445c6565d680147aa093c030bacc8e0e76989cb7abe44cbfeb8c1fdac9f9694e639145f6e5df9b413a44b17d5ac814d3679549ac6a053e30de5ff61fd6507b470c95ba3bf15055798153c39319eb491a9b9a8fb8ce14475c58f0fe45042b1227bdf3332dbae4af7ed8284ecd90b17a7a05cc749ac543a338eab1d48fd35f107e399c11477932a1f0ca96dc1bdaca3fb78c230eab062f7db01daeec6509fd239f84fae2dc15cbf4e538879127b61c40f32c504772f472508b493427b4879f2a70f044db65dbb4fb70430ecd500446bd06e186b48bada8ddf20dc500a55f1e8baed00116cec2f55084e374ba72ecc0f115fe5e28279ab7b9233f268dff7b9577d9e2c5265fe093606a1a60b453572d2b3a359e3be13773c0d96ed705b2f39f176c797ae98d47dfcfd098be7a46f344217e068023209bf6a4d08f830cb160208a3df34d73f74566760599f18f9239de8fdff35f8bbe701347c2900c1e9dc48305e38c6f9c5b476985daf7560681ddbaf8fcfa58b1ef6258d953cc6b7c30b76cb854a3967c8a2aa596b1173aeed9f52fdd95ffcf48e51208ee6cb48ca8bfff31a3c68ed7d192d37e1eb37d8a809ffa16e515c14dad6cd23dc289e3affe1b3bdacda1dcd03d967a37945c63f7f0c7f9c9aa9c26197f279074ddab4b422fbc968bf31c7cc891fc80ba24e5e835f6f809623f7cc71a869f959f810da722bc2f2f09b8aeab9446b91e629b3b10826e87b85844d9f0af4c0ee88118186864f520dd14b6fa7d334c4294371e7700bf42dd6010f9d1c929061af4c44aaed49f28c57317d8fd8e5154f6b7aa9c2102c9d7326c914a08acc210b2b3cf7f8c8d1f25c73822749e93341ef0e5557f95f05c1b3445a6d219a1f7350eaf4129113630259e2737d6b3f08f3478305855319425083d4104685b4904318f2e7049cd125e72e505893229eef83baaa8bda2c11cc98c73ad1de6b36f3c4a0a2c8ff5509a46fd12abbae86e538a8a12afff2a700cd16e76c3e2d71e67bec467b23f093eb40b86dae1749f07abb8f3b6738254f672a6a351698f5366417041d28b582878173a2c05f0cb3cdcab49cdadae22d98ba4c7a55e2d55c9b1c0e51525e0af23580959da0a0b246c635df60c26df6d09e148cc344333e5376aa87a07aa5b97096ecdb20847e72a0ddf2b05c22b78dbf2e3c60cec40e418694cf9c0569488334aa43aa31bdc711a50f8b5fb4dcb49a82966cda8e21b079c12405d00f031267fade633cef9b33cf2e16d1a53bae34220f0f5c24583ab5d1f4129491523db5c242521d20e3cfbc63e29d89ab410dd13914be505e9a2978dbeb2c6364396a9c7e3c8b4527ff09444ead987bf0969cb5aa8cbb3578f9cbf793eac1b238cc4e7542ec8a9025e765e34fad49dd6e792e22f4454fb95f950da5ca48cd1442d49b1e3a6a42a91c83609414dc31c568745ee10ca9aa9201e35fff617d12b9ff92c4b0781d08f9b140b9e2665805587a1bcb2088236ea1cac0d3daa2ccdd5c380ba121d5a48bc975d507b791af3de07bbce8bb7e5ae72b18ef51fc98abab1a8251c35d6daa75ed58f9c6c323478a9b909cacdf5799190446346bb9bf342c4661780ff0f149f619bc8694efba01ad84fb57b88032d84883acc57790b75cbc5a0910e67f8859c9d15a05e45e8a45de30000f0b1b8e75902ffa5e0ce8bc74acdd83253f756cf121ca67fdb21db290a70ff4384086f098fb9c6f50ce1756be13ab3816763db2986385b03772c9435d6c7f75b807226449b1ca0affd827313f95569a8f4f3e8003dc452cfca3584e68ab0b7e59dcea39d596f31646381277bfcee7a15673bf38942bcea32c8f31ed7e89a8d33cedb2eced06ccb905921ac92761507d84bd050a48dd22336440a486899f19214e1944f77475d9fef01fccc2674159043333565997fc34b5671dd33e38d95cc5475fb084f5aa3b01aa265973b3a88d31850840bebea7fb675fa4aff52e9992e927b0bddc60b98472a65683f80edfb03580da13b5012cdb7ec72506a0a4e90a29c41f77d96a63130936b37db7c54f7d54ab6dba367b81f938e212e3163126e06e18d57e88fc43e8a586b1db57fc331df12f51b4f8462b4eca94b4cfa99987cc98922ca8d88cc1c1e6a98238c8eef76fd27522547ecb3041defee383f11852ccc4b9857c52ae5608eea07ef6faeb3ca6edd9f1df36804444abbd2b84824900db14b94653c8ba7b0b35f13b174005113719d0e9b3ea7c80a2c2bbf1154b549af8c8d7e872a27231f3163b4ef2742bfdad5d68293896e3ca2e340f952992e7f9d5d8a2fddba6128479e908fd6e268bbd499125749e5284aaaa5635b037cfc294a21bad69d7308f2ec31310dc5aaf672d5b70181475f30bfaacad79566cf3e5f787ebef2f18a2f51e618df5f0ebedc70b5a09efb8dff1cde9b50e0f020c7456416697a89154248cf6144d3b1c664b7cafaa860c3b604fd0c2f42d2b2aae92b60abcd4e148ec4126a81faf63f045be74a23df172e7c0f59d4df9de89f777cf8fe1b35300d7dcfe318a3e924f3b057765765bab1247073018cecca7f1229b24bcec84eed47a6c744536f7943219dd49fbc3529d0a46535e11d14de330ef208e9cd24a9cdc273f237a182e5750f79d7e05e53b6aa4ff8c93a90d407445456990316eca7631ffe493f42dda4955043ded51e22f5462ca460d935f2b108d74f05964af3d938d796ff050fcc89e39b3c33dabebcc47197226c743cb6325909af502be40d6c99c47c926e693b9a3b92adf49de1a70ee9db3d7e74a75c38a3faf5c6ecf2c087f4d41b3d46ebc6e5367ef2fc90a97214f3fbdd8d4a4c50c9156fb74ab8b149a800e8462090531d5d5bf6d7f0e05a6b0e8f6e5b3b9d17d1fe9cdd30fed5b2679b5b642942a7444bed9ee0b0e5187396e53a8b14f40891bd87bf47c89dedc23f81e06d0364f739be870836d602276c8dabd934dd3b66a7d2a0071dac4db13f24c92b4f775bf446f429aa66c1284d4f4ecd8bf374603805f5d494b18157e60bab4321f7538caa13c7fe8f9b4b9d4826394ceca88c3430f6f8df61fd9a183d217a492db7f61d28048aaf26b6b1e7e70a7a1afe239388fd12593300d35340c311f62089baddc7d7cd3f19a17f488027361abd0752cc96a7e8855981a3488d894d6c2aa6cab001e98e68855690c79c57fac95545a73cdab636c837bc83b07d8a639877f08888120ff5218c57884c34848ce990ff380f9b62709e91ef4e341a83e6cfbfc48a441e498dc6fea033050b4c91196d0252cbd3a7f438b4722cb5c6441cbc10c8bd233491588856b6a50ff88f149e41aa630fda76a9d89b254d463778177e2ac444d383fdc751c9eefeb26e0527b17719864520a3936503dc92faf53a55401b4f195d4e79faede2b55886e1f2b38af069b11bc14cfb01e1b9b959f20b5f8982a3498612d4ca9a34ba99f2416c73a2ecd68cbda9c4f01f73a8ec964046628e988a65ed4b0c4112eec249081885ab4e87ba54739933ea7907b08a36943f3d750550702747edcb94fff656bd893e4b0c852265eb48544a3b0db1d0f308d8af55499df0df6bbfc55edc062ea14a86f33bc13460ad88a109b854a957445ae6b745cb128f6959548452468504e1476cdf9342704e4f2bac2e63b33317f466ccd605c8d564c39d5a2db0b582ce2520402d3a7e89b7c9ea258470e16b9f44bc52e035697f7e5c6d0dd46a8964fbc8c82687a6496caeb1ee0eb09ac6a36784adc2c377e8a5e0bc9eccfcec3bebc635ecec38b436ea400b80804957e5f5bd2c604eb0111f457d9ecd12cc35ab1bac646d309806477a75a9f0b08a939a5b5297f6c4d26d088cdee689c4f49110f02e1ec002e63cfc58b5d09d4ea4e23c517cb83aef598cf56377c317c21a417a11a8ea553eca15e147113cdd509c287a48114ae45427af964ba72c9ba27cebf5d16f6ec0f564c4562b81952b43aebf8926eda5a6e915366da3ea9d43cd597b60fd4ba38752471a936ff53caef7924ec00c4439fb91b298cc08531892703853d1fb3b8181713cc40f2dcd1d0875f5d0e4f87a16a896b1cae0ad0cdc0374211cea98b110bad4a1bfcd33cc0163547ad7b081bee35761a6e262ac3f29d482c12be41a38c99861787df610332134381553a60898619e7892dd8f8120c25130c700e9ef42aaba54b8acd9ed1133c8ede76d50eae9450182d9e49d7dc9540b5870e989738c69873ae0f461d3832ee4dd4aeaf6c8fdd989be3b1e3e7ccad5e940c0337b4ad6f1ec93e2e75d769f90d5c421635b7db217809b52093994e904009add6ef575d0f7d200cff9d926550769c03aaf55259de1ff0efb20eb3e3706bd0e7d227d30c6240f94f5d93d32b07ce79fa93b080e84891c0eda5c20980a5110440321c9e79beb7c451bb2a08b307c34ad65a0258b81de69f01e2e8259e1fd3d0a06fb244d43af450c4724218233c86fcd8406c18e150017a029b782b9511d283c9018c9e8b84f988d0ebf5fb484be503ed23dee3b6abf192170aded207afaf2aa91e7e69088680d15282625c3517ea3219ebfbf7a89f3cfc17cad378ddddc4faaa79841abde28af198fb647973d45666296b1e1d4d5969a5586caa08ed2c34043e48a610e7372efeba40afee302562113b44a9e215465ecfdbe539911b0314ab9d53aa9c397a1a78f944f2434ba9fb8b1f8a9a24e0c078f6487ad77574d4a14aa1ad5464cbceb66fc74562771cc382840b1a343f377ec0fa28921208118fba53c26a6616eb8cccb701016753e264ad38dd3fd2f4a5831243d1f9cadb27fd5f59e14d6ad98fbf70021bcdfb92b20738228353a51f40b6a79599d274be97c6b72054197699b6f0d0c0d4bdfe28760c85d96d39a5495756732c694b7a8d3d9ef68524b515a1f907df4f819c01bfa1c23f54d0ab607e889c830137ffdbc622068def8a6f6b6f9fef81388b9a7bb8f2b2453ebf46e27c38107968b66983697ac946685b87d6d00d246cc156229ebe6849f68af4209eef39743832ac1a97e1ecf87dfd13adacd966e16bfcac87c9c7eff9c5bac724778f40f0810936dcec3bd99990e911297e25e5dea1228750c5bbee1b102d5df716749c4ac9864917a083afdd5bff9cb7426b800b1ab9ca47e5ac6dc5842e82fd08865023c3648bedc6e4928d04c275f6b55dced6a37d87481dad48f941313ef34151f9f79b9c90e7fc9a902d95d1fb83d2c81db5d4e01e85ea3a8f6dfd2b7df916cef331f4624e33185ee258b2651eaeebf941ba062a9581a766e0332230670354ef6cbbf0443db6148f5f59d235db53f8203b0683e92095622869d4909823703a91057d3ed8af5e8ba37c7d7f1202312d8b30954d537c63117d631cb11b9ca1a46df7702d14e5b593f2e22831722aa839319c52959ede52df4433ce2c2441f17204f5fe1a376659b452e6c6f92178a24e042767265705dc9df65b2d04937d80a358f8009ce8e7cdc39225757d875c130a034930ae00c9f917ba1df19b12a9d41aa4e2a75bdf66bbdc7304545f8c04c3b3e72753a3544099a174a9251b5120b5478a6c668d3770237ca7cfd9c07563e5c8b102081d3d1ce2afe9fa567b05ac7dfa347ed5b88a86bbcf5939b872027d9645eadd5b80b911a22591acfbecd37f95478cd816f36eea83ba460dc34f3a68251ff184cf7d9994384fa3635867cec11a3461835c5aed7e845531382b8c3aa95e1a2b65ea441a76c131a8793579a771983b32bf5c0d9244226107a07b6c78c2f7d8150df4eb8f4fc712b94962c4dfb4e5383eec8d971fdd76dd83cb6ec461b7fa940e5931d39a4a7b7b0dc5f069631cd579554c6387e3437ca89c6e3c6cab30c06cbbd87ad31a2d4a7a9da8f6b877701f5aa01b34989c8cd942223eff3a91ec2c8d510230711500f0316ef2f563c0641f12b6d0ca5f242da25a4a29a9cffc7ea007eb8b5893b20edd443ff4690b5e978d6296c33183b380e6e5e4327631f83efdff3838c261259d2f3c585bb25e8a4de569525145adfedad8cfe6ae989fafbb68f9f23e9ccbf3a41ae008fbbc6fc12b54ff050db1c9af4c1c216e6f14d54b3953a40bbdd620ff3dded2b6d22f00e6718384b8f2879c964d05ef14149cb5e6127e09289c44c58a9957dcb7748f0c1f878a3eaf25f0ac7c8695cdb7002d45e280d1651d0f57f577c182410809b9c8644709b6876ed118259c6082147fb965425b9ae56dad7c8b54bb3557e17035b5cea610994270258a8497b2c9c7ff3a09f569fcb8239865ce831b7f141fa77137dbfeba3976ec59df16d003815c8730f0f08c777bba188b2917e10c5b800c4703b888b7bec5c238e7e412eadbfeb14044b7be610ad2ef3ceb3f9fed67ffee16edf542dd8d4aa29109de55fce9a3fe7f4e8332ca332cce789d54c1fd3561e56b0f749cba05fdbdc9505f629d323068d263d8f239ba92a7d6153ac26ca7232466cbbc06ae895a1cf8b4b1a038f06df3cf5a442ede325be1723907be27cdde2ad81563702ac0887a795aac119d64387b1df91ada0ffc2ddfbdc90f6cd14233605a77f35d80fc39f41f558a2844f66f9ddd683495284023287fa14108bd35770d56fdc1f5400bea14ac752e47243754c13146b3e5a9eaa84eeb5581c48c0957a6459048e2d95a8a589514924aa6ce1ce4260b3b487c256f44140b54055cc55c545b750b600a808793bc4c2628467a3d82a832e86938aa9529089bc2f055f70edc8ac973153b31e45160079e1fa634642ad1de6af49ed304d34bf11c6203450b89ecbe95f2fc875dd4daee739de415fa94af0577a9108439870b42f33eaf9787ef6a38a960ebe7ee4c89e5650f1d43c28ae6ebdf503f9104c06f3f633561ea2397a5e34f8f8269ca4f79cf9110696ffdc9083c066a1935dab10ba7e1ad3c901ea16b576533589f24f44ec7ab287f09c1109f8ed4cf5578a2425f8fe545fead41dac340a6349b990884a5b77c7b096205e8e45e1e2657a0f55e1f28e6702f3bfb1c07063fc8318d170c0fb53d4d310277090d8ad9ec35418caeb1dfd9190ec09a3148288afcfb885c370390d4eae677aa95f1242de6945d1a3e25eb037719d164f8879ff17d992958cde8f741bcf46b6934ba56e250d2b5ef5a236ebaba7ffef0661eb364a947722d2d64ab5a68cbbeb68f53e727466a6e4335fe76c74076b03ffd4a34625e5693ce5605455536ad71225bb8374b21e2a1f4cac496bb9d1c464f54f1120292a937171e05208850a76dfaf54ad39d5e70266d752f46fc43edf89dd2d257ad6d2a3ee72c600caf2e596f1d29f57542c620702da4826e0dac93c274ee6cb2b6f8e314baf408d765cecb46faaae49770d1b479573003af58fb9aac04ed15b2e773e3a02dfe1e6760f54672dc69560cad1ac4f5dde86800c8171e7894b3e738acf7d60e4926f1f76b9df7ac7ed8065770a2ee0b4e3b218da78565dbfe36b6796917f9a6179523ecfcdce86ff74579fc2fd8dabd850d4193551dcedceed3b21c8901f23032c6fc805c7c9ecef570760d16aaa0f29ca0e09443709f9b82f737bcd7593a977f3e3eba34d3ab9721aea277af62cdabc78995469103996a5aaeed14f223b7eb8f88c26aab10ce5fa8fbd2e4176cae334bef15010f6c4873d5231fd92ae035ea58b675ec179e2c35f83819916f2b97119c737872a40fe1d159f8c83e1a10ef06cc7be1827d99e4917ce80334c43b8400e688d0b5c51bbaa46b56db5e7124538c5bd45dfc82da114d202f1fa6a45a6c6d406a2e864232d0f9e56fe5f4d3d993ab691e20f978375ce5d06d8b6a149f155e757f865bc89a488371f64f7d1702e0349389c9d773fac787b67f2f767a402adae250dd216728fa1296803698cee49a9a53e926ebcdb011b7042983b347a15c5be01ef57eff420d9f570d9b70d768237d63896279d9da2094c384491c8f2fedd7c6f8d57806d632e9574ee5253744bd4a92c2433b8a956c606a51839346535e990a5d78b339607bf93845561205ab30aa1a948c964617749a0014feaf9620508c19093f14a3fef36806a0709ad0b682a135220aa27b2253eec5c7229e4d35395d37e1dea2ba38fae6df0d3e79b629df9f829c1931af37dbae44ffc79c23ae527ad6ef7f5b28b571e860d7accdcd4cf761d27022296af0aa34dcd8b94b14e1c17a96c654ca347c825bfbb571889529b57296ff06e78e652838b6988c9d5a83a8a1ad78b0abf8126f7a7bd6ae86a52957a04a7439cb71533d9731eb07dc3d6e8c0bd444c639d98c08cfffd14958e2b65f4c59a44872aff0c3c8fbba18154b1c37e566a3b3d07c167c274ee4ee3955666f494a86df925c106e3bd2e625b5801047aa15152ebd15d10fb14b659eee9fb9c37ce16aed184386c1554cf5eaa45bde4d92149f31839de67df619454183bf1937df6e246bce3f785d430cc59bf7eab00e6d0bfa2852bd30401682cd6ab49067cf77edaaf3620bfff38ddff7e860df9015762038e15170d2bd1feeccec1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
