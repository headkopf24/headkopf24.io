<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dadb2fbb8305e8cce6f653a4d57411d0f7cfe3c1cd6ffc517dabdc0fbb8dd50e118936d4c414da3cf5a28086ca05759224b3f0aa88dfd30fade47182d5f449370de3b85e7e346ac8f8fe5e02af1861058bdbf24453aaabb2ca6683f6716326abf188b48efe1a3682aca27af11e8ba62205ddd86ebd9d977e648295e3d136c8e28a54042bbf0f33cd5b299f23c565c1fdc628163d5aa7c831768dab600eaf0bbcbdd15df9a86e6e36aa22114c2ebed94d7238e22942f5f3d70c117248b5223acc0abd8c677c9699957ff801c88a5a9bd5296a3c2d35a22eaedeb07d5f8b4d99f8a72dff7034b8ee5fa17859ab16b0129a563505c40c308fd17cb4e95e05a08653f4c3bd3f6ae86fe91a875b5c66c923c221b235a984643368b5d2617b9f6171aaf6da8d6594955066a676e245b05123ac0f8edc7baaedc258f32864922c7f191fec37f4292cede4619949ed5bbacaf486ed0466ef94d7be13f25a8612e5ed8c2766dcd58cdbed8d065f0a6cce993cd0cb7201c280a132467297ffd1172854bc501f6562f1b194aefc30b663e0acc4244ca0cbe927225badda5db5102594f6b8afdc1d89acc4160d84b6fa5b6aba1ddb0bd5b9a0b6ae0ac6be29edd85b1987c04efbe6e11347c9570a484a03116b05e5fd8a20b9f38b45b7f2ab2edee8f5778156d0a4c3260a6074ba2adf576cc2be9034bbc315b5678c98a7f4e966c84834eb9c85b49a38b0f3ce11550d82de1ef3de14b163b4e9b35031effcf8b7d62afa6de5ca625184fd04b34ae676ed8799d23f8f5e87476cfe7d1ed90038a1ab72e484d6cb05dbfe32622bac3448a74ddfc55f88ff7f89d8e51f7c6bc3f0ffb28e10ccffd99759c0dd2242f09f47cfa2cea4759a7c2364c624b9441636cff976692ae0bc34d5c868070695e3c7b55c5b3eeb2be42a94d124bfd997d0c8a7080e799c363672e37159e712258d35fe2a0981c3d6ebd066a2eb4912055de5fc4e7412dec9ba767faecded52dc7494cdef98ee0ae458e5270cecd38b37d30619b847c21d4cfc3a7dd8ee1133c2721c66c6bff70412dfc4eab006b4b9a89744b52b8548d8a2a2efee0094c647c7e570b1c5c834c992342668d408cfe5dd684dad25a288592673001c0d79f8b7ac106e4905c5785d32ecb7fe9879ce42743ec764901a2ecf29926943f5bdf0a5da7e062ae991d15b13b22277258ae7b69b85748d627a747c2938ef927a496b8e2e858fb4e5e320a68b5d927aa10c78d2fd8a4f9982e6e2011f9703281b2708d2e2e5c5b420a95550c3ac61bf3033c3c96cb342b71228bca01242853dec8e1babd8f7ebef468103b44d393a3c59b44768db82f1024128dc084df695ab3d238831d6c6b8c94a5ea682250b8c3cf3ae5abaa3a0722f67fe033c49d8f8519cf2f0c3e5ecad036f1522db77a158a05fc3d4762cfa860c3d4b66ea276d6ef257bc5396cbc3ff346ffc89e9e6ee2c1c153ce27de0086816923a72d79ea10e81888b0f21f3a8f7ad8c0ba4bf31c36997e3d238f7185e39e2d01b53529d6af466e624220b680441445c5f93ff1637d51c1be9e131894396e09c8a8129a670f5fb57db20d7501045db006d28441a022b530097f5ed69a25a63992363bbd00b1d7560ec574102a37352fd689cd5760d0de031933f00fb4b551e2246a9f9dddb406e6f1fe83a35846b4351f6827222ae4d39d390a6d041a6c214a05827c89cd16a2515b59f6e43330145ab8e90454346c1432cd08d16382dec377449f12b04e8311f8ab93c8fb89895dc6bb95bcdbfe4a11178a492d3d8d408fcf34d0d318b2553632c1944041fc16df72c3d9e41057eefd38860e3663dc12b1266c78c217c74d2c01c89693f69c6ed3303cd6fc5eca5e4c0b5d0c54548da209ba5c76aabbd1055863fe31bdce8b4a86d0c5855882f917700fcfd841048ddcda40890801510cb528d47dea70e0b256b7f095eb2ed8a2f9931c6c04387854e844cc6c2c3608f9cfd5667d20afa5f56063e3ff52c8b5739627efa3b50fb6d58dfe40c27cde736441c6cc5ce83446afcef1f892029be91ecbb8ed5c4dd2070cdd5a1a580d3529807862cc789b25b6e59de8390fcb2f949538b0d573ee7aeab50d632c1cd456decb6df50826fb4f64bba50babdb435d0b4c013bc1caa0d071d548bee5dcb6dafe1535a0767f50d991c6f46689887318d6262559d8a1f06b88d183cb78be466cce85c0d58569d7c218b618be51af44277f511617e11fb4b88c9c34c119d49b0d9b9bd2d1342052ceb4a184a07d8ebda848d1dd8e1b0da6accc43235a56fe33d9ba6b1110bbf7e3bf5c1755071aa58e1e4dc32b205d57b89bc78697378f344122ac5025a6b52605dae916485b832cf4b55542e746c5231447845149152dbc39e27e9fd32d34c2bc05be901bf1284604e27965425275a1b936f7ec42977488f6d66a9607045d36e502e7613584048ef7e660dfbf30cd4d8efb3f2dfc8d4ba51acb86190832b32d5ec12b39e0b45989c6459f0ca19cfd3b77b3d53485013d29677f2b9b48d20a2eccb042ece5b9e468a2bbda0599cdf57ec4700220a8b5681fcc6eec5aabf1d125093aa13e0a3bc226c7b3d402e896dd2ad5f19329bb33147828d6170154758cdb2fa4b1d33986f547cfe7eb906d89b2dd686d675d24f244a55abcbb5f4d7514b4cf998cb21d7138a2f2a4cafb9a3c88457f573be41e157bd0b42a14414ca2cac595095d1455ee1c8a539f1d742f2be8cb35ce70ecf4fa1ade523c003183ccc421b1dce6758e1539953dd7e555046512e805e8563003695481e3eb1121b22c3bc263d4fe38ac9cca9c7a5c343456e526ff09468dbfa9c8f4a5ced72834e742e460c866c12446e5a484953a7fbe20cc73116ee9652485df72d90c9fb6100924f88a56d6f68516cac54c4c96b53c7c322ed1c05f5cea695f435e7ff6bdb245cf5e70ba028e66bdd27bc2788a5b333faa9ec004813edf0cbefef7b2583a8e3e9f8a4b697ee545ad0620b91a52e07bfbbbf0c673465ea38df5340743fc837874c68b810dff9dc6cd78105875dc9bf5bf3a12b203df276ae1f1a3f6cd9fbc5ee73551da75e7ebc2bdea4baeeaf0b1964c6d62b500c22e9ca49f6d919e6e9c75edc447ac6f08f45b956cf4387d849792e187959ee7c4273acabb1d2b4f29ec393343a5accb7ce3b19d9484e109831d4901771fb15ed6a5d1834bd04ffc29b9e0261feed653e3aee4d9daac06562680c9f7a68b993865b8841f316e513ca510c17801cae1f120d8ff2c129306b715eac27c1cb6b2aded5706a4d49fd583ab91a185e58d372f95605c07fe088e6505876b6a3aea5927e6f945a46d5e1990a9ef978205b82ac0b6d749d21cadd088f6ff21796455db76b11faf58cab74511d1642a975901558a66595e84c302363b84dd4f7afde624b6df10c7754e38a58832b2e652c05c1c01c58b3811910d512a4371946b98c0499b280f58b8b86bea9e119884472c83df91d58058b0deaa471d370d1069a51b6521aa93758d418a6626dcd3677fcf6cc34df8f46f40d3789486e321029ed1dc8d5f9c786338223e2ad1cf1ba2618c314a7a6f64eea661760186c0c93919c204b62d47b3738cc557ae5762b3375e44d777670adbc87672c82cea69370b17c718f8bbfe6521e3aeef56600fdbad71dad7794f87a05a2f3f6529ba93864b965f75d7e4b2d3084cc13f69d7a2c40dccd8e103789b00af941d83bfb11a58cf86fb85b895ae302e98207018b0e098e6769a04b3e8e4b216fd6a88b58b4c2f4b4e0b7a83443c4e7cdb3b573fc9c9260d126d4c560ed495bf63fba5fd26df4c7a70d514634a53f7ed8862db370bc034dc61dd426ba050ab718ebf1dfd20aff3e19dd217df8d222da92925e4d232365dd6688265e4291f5b1e391156e98c0dc8ee6cc8a51304154db71e8508ad884652e8c8b3d8fa909976f82861c3703bcad81b73420a3a25c2df0b6d93f121b022c93fabeaae5d823c0c7bbe66239b70102879a75ee71f1985be3104e6db93a03588cf6d6b4cf709dc838e9d99b6856436761b1816579de06d287e0cef0438160d01590a75fa5a7244023964fef41d74a07e8bcdfc4a076deb5b69e5b0ae641f0ac53cfa922a74942304a299402f4473db87bcf5409276cfc547440c700aba8c42ad0e4c14bfebb1193e2f740dca83e1c0170fbb64c43246c9f02c56647ac6878ae4d409085da1ae66a2e06049fefc5fc34ce372682961894b8761a0b225b9986f51594d7d5b90eb52328beb22f68420c754697395da2323a2b6f6ad90a629ffe8cb3bb94fb98bfb715cf2d35d71491a91e3054cfa9883fdf369921f8752cac933b6d4d11603d09f58baaf48a2c87cacc9a15ed3bd0912061965374b1045eef8bfe6ceb114f1d11f5844c184aeec1e4a07f6a4b6dae64bddbce79356c67007e9441fd37efb1f170539fb5b523b2d54278370dd53f9e0ab2b471e106cd3f8fb5858c1a4013887f683d78360bdc878a36e03f968b913b5a83e38fd67dda9175ecaf20a00a74e53f0434c8a856bd8f2a74d43c53ee6554610068f4f86b86818ddf44d1330466c24245ae26fd75bb649052f656b5ccca94fdcedf3f1e67107031f54ad5094683a70dfd5328d1bd5c20776c6cc14527a7be1e580815dc49ce056148e391086454ad9d4f58e74cb4bacc3d7bd6bfdbf8ec53b20cf85de2e4e2d82242cd8688882bd79ad325f873859df9340321252bb6cf22e6f6aac04ef83556830c5c533babd252071082bcfe0ddf5fb120f5c69705404ac005a95b2a267401f97721d98822ef955dbc7aaf501ee9574c19eec379013819b8884a366c3eacd8d7dfe3cf4a9839a6784f9768518f19302dec0d881e8f5e089471645f95728ea7fbf1daa1eee05346e10cf95a3f209f254436be26e899b48d7d5042385148310ac4eccd9d710f9c76910119909d888838ae76e34791e087497b7a1e953878ad1650489fafa87bcc962f5aabdc4814f9be2e7863930f366e6640174d697a5bbcc3bac39400961e163e20c2d65cd4ee334d4fd398c0453729a6b53241c0c70b9fb1e33571e664c3f4e7aba935702a84a93f29098d8614289b0edd137ab50fc23b9c5dea75a08317abf2a9e02b9247c8e23c19085342284480abe5e8acebb8be4cac144726856165fdc9d38892b9c7e9635e63f8ac6a53aecc6d7dfcfeee36a00167391743cbddee6094e7df08758d5856a4f1434b2b140d3317697f6ed987f42735d23470c4e485b2782248f9afa9cb8db1876333015119fd407bc98394c5fe3ad3d7f18afe69416b828f03fa14f156939f41e628905390fc28b9b88f8764d71fff85513db8156b251c35f115756cbeed2d929abcbc4f764234a073a3a63456a51fa6fdb243025c30a3d6ba7049180299c3dee8da2e32a044e5f04dea514b7ab633416b34c59e0e84b996d5f1dc45e6a8866664c8299149c32bbf5b40c6ca4d697db5b651a384072e8b754a378ddbf23d505717e14561a6f101701868fe6e85ec280b594e671b980b42a1bb74567c3e0fe3288db7f051f945e5a1de0624783fe5e78fb2782190ebd684fe40c70d731a1e1cfb60fba2e4fb73aaffcff033b1cfbdabc32bd1d5ac61184a124ebb5da48a52b4b01ed6bdbcb4933ee57e24d3a38e02cc311866e3b3d4577aeeebb54465e236f4a1926d49837395fd0c29a21dce5b3134a7468f476151cebd5b46811704c815890897ab543958789b282b6561fd558e8704e6462ddbf1f5d65396da4d41b7aa977adbbdf19db4259f2326c4ebdcb87afc20f405795a3a6587f855bee8b07f6983dcb136c10bb43421cc16d727d3daef207df2d1670595b34f71ac1336425e25ec476f515e869d1a14586d3825378dc662b52473cd8a2a41d37bb0aab1f810ee02d0be31e1c4be60df774482e03a132997bbe71ce7672bf03880abb2fd14ef48f4440aaabab94753b8affbe6c151efc1d66131357185c15c0ce625befe2ff52a28c4c5a4f12d4a320f49decf6b19df0cf5b27e12388f959b3a446db9737c51d046204ff9b5463fb61fd611aeec5e27e0dac1c8a697f0be5e94d7dc333e8f549491edd31698c8e9b2fe4fa54516f7efab73fced8d65ba22383f1e2e5ba146c656c8ca8d8c5b7976c150c0c0503e982fe6db10746f08d4151bfe7e613efebac9805d7c6baea812c8eb20f30527239ba17d07bf8cd86c6f5ea19ca8fa5af4797309529225da64900ecfd86a26fd3b7c597d990e26d21cd8e2f868c420487fe8847a44fea9756296a17ab3210004b4b59fc5a6a1bcf1ffa906e5f43b01dff20cd2d6c9cbd61995971748bb9c6702489d7acdba78ed1f80ad1bfd843eb8d92e718eeb6d1d5d550d3e73018421d06532d4cc38507d53b18d9b3b358bc8fa4835081a61534a122c6f74f543f194ece1c86b257710bd1f5e49ee7726051d3d62026f354bd681aca6a5265da7ffe0104b8221ac88fb9712c07a25570c52b8fb4ba99fdb2d04ad92661dc0e23e264bd5285522cad0e69fd34e708e0bed63a9c11acd96658c1b836b08914af0a5117ffc917e716dd61f4d7b01d4201af3c57490eb56287ef012567c6f93c217fda7e5a57ee3f11c411c100deffa5196dff2608c0dc70be1fd5eaf94d550ed8452ed708c752d18becdfc7588e97502a0915a9e86cf4ef10f81755b59f71701fc055e259c514d8208cd80b5d0305d085e3a6637f535625496b42b9e36b7223e54476c7bb67de84dcf84ca5820ee8d7b267e8612763d6c14dccb9a9f195941ab2898b07b025f3f5cdf63c05f0c52f299dd1a44bb3a8220c1359c49567c77ba78b44fadf177a0bc869f3cb04dc945ce726e48195696fd39c2866d2f1386bf7caf58ec224c2234254a15d2ee123848512b501a8343119ed5da6ccedb836f8f050616b2f491adb765f96d7b70ea7f10d05807d675cf5cab7c3fd77020ca1ab7561a277ad5d4b2c6c3e8147418802f7cef12dcf273ede653c736b1a2ddec5834686c0a43778468e7076925febc47e9a97477f3cffd6e0af2c0581db5e59b9c68207741f39a00a8fcb95ba393a4744a598511b1ddcab58e980ab53e92fb613a3765d411f25c3a8540da38f40a5a24282c18e6eb2fe7a451dde5a913aaa9ef4bd6d49c8e40f5111b23b383b0e913426fa0bfdac9e1ff187e5d089c8ff3221f9390a40c5e84db25042ba90f600ed73b7a9302d3af8dc88f1b8e9a5753760a838d90499f22f7ff91c930167c4480093c6d5d92c4ca53bc2cffa84f9b8ad06096f4ba035039a3696c5ee8262f0f297c0720ea20ca887674620b5629e4c89f1654ed780dba1da1838859a7b25b0accdba46a8656178ee03527f0ee69c27eb1b1c551a81e7dfa671ac86eca626cba83907f1f33948cb3603fbe65fddadf8592ec1d7ce92effd66900593b956af8cd015f14772387d75a62cacffe48e1c72de25f8cd78b3ece66d8913eb1bef22d68e7deb2f78e292d25e4726d59b0b927935efccfec70d4c98396e2b445bf2d0c3e1c736dc5c5f1059f85ea8cf498988151168fe4fa13e77a241808f9bfea3dbb5f1ef53df297c67a3c312ec3e4d0c68e3abad5149ee6a49edcc5ea7ca04d5d795b47cc4e8a959dbccbc8eae1b5b55a2a0ca33a83c0dc06dfaf8da738d67eab623ffef8534a9c1f06e485c81ef3c5bb6af47343799250d974e23843bed392f58c46e8930045d4080d1553240483a5598c93df90450e90962970eac9d141924ed335053e0dc7be9e6ef9e705e0d129f03be2221dd5a40b5a0b8e522bc29198c296a1db2c61c2eac16158b0993c598730543b58d14e99d9bd0e123ad2fb8d518922a5d524180cc2cbda942f63454a7e8bcd15db59b9b8d6c2452907cb25c45e3e8a9dfc5a795cdf0b09b16d1d470c0962a8974745ed9ec64e3ab75a372211461c75359faa05e11fc4153ab2256b5c498e534ab58c160e24e266e877e37578b10392a1c7eaf59af689443a536411497ffe3d79b423daafc972bf0521ceae2c70c9ebc21bc62076be2749cf65ab4e5950f3b343b8b0572f4019a337b9d3f3450a58dad482908648cf838589efa0e4be305f827e5e9d108af089e73a813ab8644c1833fe7f1179b3598966b257ed94b608ec69148f9c9430805038fd99c440a31cefbcf7c6e276e411446ba028377cc4615e2d964123ee411475d8f1471fd92039b50d91363d0fc0881be99246c34eda075900e511b8776e2e8e7e80ed23e8d1692cf81319f27b4d19422d1c4243cf7a71adf8de54cc1a5196d3c803470206e84cc1a0571158c2aea4a55c3accccb22a86749fa24bef25a4763a33cebf3e55fffffcaf2932949587647c2d9282c86612f5283d8a085d2523d8dcafa26baaab92d490b9cfaf72b04c4543cbcb1b2d3f7ba37e963b432ed63d877c169d13750c65738ab051823ba58ca6c5e6e9d58c2af2f214bf172b9c2f9a65058b585a9e622414c384eaf705ef35154afe47a97901cdcdc5ff0d7e85f9872e11b57ac98bd5ceacf8fbaf09a9de9570770e70ace5e1880f1defc585c00d7b5e305dc4dcdfd9735304c874f1145c454d9ad2fe3539440454e6b427d330ab39c8ff6416da563c2a5bac28fe502806b6b827b659ac723c01ac7b1322f18cfd5581a0d67e46204ae5d52e9fe2483a583179387ca3e190845b4ce6966ec96ae27257f5639f04220585759cd5ac704d3806ca0a994947db3207058d604cf99e6a11ba9ea8b713e082c25099a33ce06d61933459594c7f45c4b0b7b81fb153ce7161b8c02a3455c9dabc7268bdc1e4e13e902b6abe2172f30efbd95e02fb50d145803d13886eac5d925c7b38ddc06d58690b780fde9646b0f76bceca0d4c6ca8497448d2b8aeb367c94396a664edbdb3570a18edfd5293fa8aca9659bd46b9b8253427d3396c6818a65eba1c3260782f14d0e0921474d7ab9f229dd99d46bdd9a6bdb6df6392525c2757365d4be84582e9e65ecfe2138dff18356f8e4b5f5ea9af1628bd59c901aab7df27c701b45482786d9a0022dbe33f412f8cee9f14ab3b7ccf5b68fe02eac1abadb8ee5e867f59ee27424598883b557dcef1b08b2e8d1f3fd55c5352c5efc65c89d853938f1636e8163ff4696f2167e3d07fcf99e88715f2d5276f62d79f7631f7c8634f22534fd73560e049da1b9d387131bc9633a4ddfef5bbbef4ceb53adff64d2e4425f54649bf3784875ce8c07bcd9166b1ae5c59f254770d7704d26e5d3be7fd4209102efb7dbd8a15e8e8bcbad10f40efed3efce5c36ef35a7feae131c250b667502df5722375f1fa552e8e0549abd7bbfdc436be5f344ad843279c36026755cb55f23b5f7c34e22933c4670abc03d6a1b717b62ac30d39adb6fd1d36074c69a66a28fa4bb02d16133d761c3db4a8986dedd530008bbf5f40149ae8131c3de769cdc2bbd57f047a6691e0e9663af900f431da1b2816dc618595b6d9d21697abb0cb379d14039ecc1d792aa0357111f88ea0fad2635d3a39a546d8ef3be17183829f249ef30f7129f03e569ecc853454013e2bd5864d05635d6f1dd70ef0ba759cdc6e034432e8e24fc53919d788524eefafddfd0e2af4da9d4810cd7a6d6bdc6dddfb57ca5a614439eab118c66a3589dd5ec04e3e7e3cb0a593f01c5d9a8421e3e0e628ce05ae67ad00ae1ae9a399ad03f5417a9edf3e1ecce560d822483e600e868d4f82fe5ab6cd138ecbe498e9c66cd8772da675b8f0f5b90c326e2cce28f72fbdc22b2286258f7f5d38fcb1a3cfaa321936d8dda2efa859ab0d081f333064801fb462a0c8a7f613a30492f5f26d04d06bacdc547aa3218fd11ca7005517294a0305ee8bea1d36db820218802472bd58c2b8e32abe345a653c43a5991cea96bfae6951eb5a23b347223d1b0b28d11d2786acf937c2af8dbf809c1953bf4e7475e9e6f6c367236fe0dbeba8532cdff5c87f13399357fe8ff7714a977b8aa45e58fb9248df02ecd7d27cc52a8653bc3535f875c5e470c0016b95ae437e750ab389d217a9d04c975fd7ed55274f11b636803950e69f0515a6e3f30d442fe10da9f328764fcf1a32e6cacbdad80a0d5f4185344f3a29b999ba1dade980b89d6e0fe9ea7fa8ea602a368670b6f581e125d1aaa2f1f1ca95c66e082adf90a8de4b99ca093a3beac24c3b94e6b0e5ba5cee4f5f2de32744a0d5be904c8d7c773fdb0b284a29f47aad6f0f20363767ff7b24cf9c979a20efbfa798c18d36724e4df4871292317d453274e5e0a02854852bae81258b1e3bcdee8b58805dee3ce34d0611f2a25cc110f63cc7928d16613766e2db54e18e5ca12a1aacd8c0233229fe74a45927baf3e488092555023b1d0ca91314ebf87bd385ba984ab1f355ce4f8b158b3be637f010cf873a29759c5941dd56d685ad15577c28cd19ed130f6e83f266674bda5161cb0fbe974c1f027aa56773c0cef35153df648c7d0b6b40be7df20cbd7baea1a12534aaecb496f233f40f34e93c121035f5a5be0df9900e5f97a6116d28a9658a04e08ee774c050e4094569c830eff9512389dd2a3554545a8a8a984589be3acc7de7a38247fd2e5e484a5b30028a9f28b8d7556fa38cf7315694311819651436fc6f16693b5fcd06b80be089307658353455646a6b814f77a2a1045cba2a70209fa8af404ed47817b02070f040194978191e470141037f52b64c7c9bf2fa638fcf341b1a47e56886a50bd7222cabf4495f5b01c7475367a417b24563c2b72b333d83315a65577755f6a984f81e200a5e8e59decf56d619ecf639a84689303baa5477528b02ee529a5460d8d75e48622b19a88ef0bfd6366c127d57635a87823c92c2d43223cf781cdc23012c8d389a3e037725a4fba1f57b03f6228748874fe987b1bd949a0581a748ce5327d5bc432ada1e291814536cf02480479ee5deb0cad845aaa2abd7b728cf1a7438aec2eaca5c7731054fa17c36a30ac19d2fadf743fa0f34def66a294fcbe8ee6864f76c05e8ec2a7a9548d93de827027e8c1e8e9c220bb27b5e2953419e64fea35e58a35cc26c5a1e18988ad2411e17cd5859b939a72dc30d2099c104662661014be5b82adf58da02e90207b1c74a4ae6e2394c30ec49670a08fa891bcffb0e2449244c68ecc7ff8ec8cf2137d858a0b91dc4391c7fa4f20e69ed00ff4ac92bbc09fff184ac3ffb9505709fcec0d67ba232d15ddf3071e1c46f0eff10d493e1dfe6e975addd7b070a9f5026feaee4fac690848b1b9a3f74184d8ce8ad6b90c299cb425ecbdc795e4bfc41cfa62f8076605272650558bd89a05360f848f74a87f5b087a68c57a35f15ad67f2e2f8a667139b396be39e97974a8762625a1d27c004f104b4d7de23e068ed0e873570d6316b2a4795c5395542508ba059e09e0524eb31639c5985f1b376536b38fd1acff3931c56366f2b21e52c32f31fc8fda3ac8a73a03ddd64c55c4abfe057bf27ac355e922c519f2263edfc01c2f5fd698c822f37ef84e29bdf627d5154f58027047c2990c5367db5b38ab2981899097a240085814b602b8ba8e61e5b3d927dd0babbee6b6e491ccdeaeaa1c4bfadaf72a66357387a81b9e3f07946fdd429bada37f43b6fa80dac4a77e8fc7fc71ba1486676b31a54148bf4e89f6ed5cceb44c2c010073f942fc39648fc37dc72eb215f641b2de344f2690df3468b012713b611346568505ab814b8b5d98d026e66e0d4fb5d5bfc2e8a738ba518c75189047d5871ec0aab8fad6857f6635df6bd89b9de4011ec654ce37332a46b4678d807f2766fc07ca2014975a59aee4775744433385e4b557f402389b30577be5d439865167e4fc095c059b042170c568d6c5b1ee7f93eaf124733e2f7559a7b44d1a6130896d0cb0c3d874de81a96dfc1020c6e73f71d2a544cc1bffa6916ca08d71541d87dbd9880306c51296d3443cb2ce0a49ebf9ece98174c307c4c1830c2d5362c39fc17a723ed0d27d9fc2502b14d0dc37c69f22fb84979852d2d6d532f32703bbe58d2ef3f313a307a54c0a55546c19e59db430e00f298be3d5265e3297aefb751be6dab5a04bb66f997517d7c09f8faeb3a12dacc9305b1440d40e0e47c89c48efaad06605e4cdadd4f954719b34195230eddbeed6a8842c817ac506d95a64384ed63db15169c6b66167ad9205bc6ff25e3c99a833ae40f19b71351a5bb100792d1176be481f0ce3b3427d1bd7fe7de0ca74e4236d632d8572f9fac999f506b3d5d419634b1d7cade56f500548cdee98517355b1d38e5cc07efbb859dea77dfe75568df3c48d20e85f3828c6dd68bc8acdf40abb5ac37c57f647404e55fda57f47a353c4a0e9bb614210d1bd6a287a8ce7be6eaa50dd4f4a928a730b3a6c8b0be8e1f5a373a1fa83f898d09f96b3200a114aed3629f04b809e5a5f1af5b9010cfdcdcf1ebd640eeb9f5e4a4f6052c64be3721b4bd412bd54b96bf39cdec13034dd460e3679078d974f4250c0013a98c6eaca00164b0bbc04880c2b1a55937e09d54173dcbfebd6d4af03e3a20ed03aedbae67a1e181c6a0726d1ec3d0e4ae6e1f0ef8006ec065ad7ee2300b46d76373c0ee0c7e670ca18d2d268feb174b99c15cd06f3b0c86f5fd13c219f7ab9729f1b29e15ab49c6ed3404b46685db0e25c65576e9ccd722460eb7ddddf6eef848b2be448290c2d20927154480e96cff2aa18bb3d6bbd49908cfcdb14c074df19066b1b496b4efb8573289e2942761a7e09575120706fcb2a795b1a98043b25dce1bfcf4e55d73605cba790a1fa0893c313c629e09b86cf7917315fcc595bb5d75563b04694a05f92f582829e6a0632cdc29a4d20e01f797be7ad1cd0f4b88789bc02180976d203948d6629fd01311ec0b8c0633e786621b9dbece372b0fc305300b73e14d8059919d48d821aa38ba61f0b1ba842a509e788c54709b1712f33facd9d4ad19c7cd252602cc219073c0df7ec30d8edc8c31cdd1057bcfccdd410b912952cfd424f2afe405f34b914ac757d0c64346e1a364b50fbd29e0e9a1d5f432610e36af7d9a1b62659ba6dd25ebd2718c3a42167a0d17b913cf11d45cb3fae4d775c98a0ab97fe4c050a369eb7c8212519715249cd6df1f36e850ae5448fe8a1de550fdca34bec6fe0c37d0c59c3b41da2ff04ca480ffb06bb2a117f78e40ee70adfac08ec2904ddc29aa58437b63518467c4f4ecd9cc4a314dd220313412a170de124c33139f7d94ff59e9a6242230bb8b44764dcc1cae8ac1059101a6822b886e43c4d28d574239237a7b8e073b38b767bcc1c7e8f7770ef90a077363704388b61aa09dc8c15552629bd45bd55abb9cd0e4e733610c9a2c93b0e36ec4c59628506ed8a29012431b08ac2624cef8b89005fe8e3f23d6b4f6ddb17154bec290f7d71e7c12574589180647739a02dd0f618fbd597374a20b52f19bce6b901ee2e98fba152081e52eaf4d033d66751fc8f58f49da1d0a014a4d7a3e1130bf928abd688caeca5d58889c72e50fd1f159d81c3caf3087c084d811a2bcafdd6746a77e39405e2966104d97d9f84dc037e88c8296f6551cf775e500ec664608659dbfbe2b6257750314402368b8110c1111e4f91b321a41032d1b3fdd3c8d5bc28b716f4739c5c56a7af125906e0001b68e4ea85354b66ab2f011dfce6cd8b7b9d7a75bec5828f29b2c4d42a7d60b6d7a79a680544abac7f8e060d0a28cd9e32d047bd34984d0b090c2b1328269b5dbd46eb146280f38f6981f007c779861ec1972da6e058f0558265ed14b4cc8e00f22ef28e90e27f66b837aabcb262b7023b9b818ddfec7b662e7940b89187f4747f0d9f01b0e029f23ed8fa2187b5b653b7346d1d5dd1f35cfbb11db42dd8c809cdd211ce09fa6aa7b56528c39ac41cfc3a2a690dd129f5f957d5ae46968d10089187cf6365a21a69f7d227ad3878156a008c3d9fec13876ae8d89a956e884cdaaea781b27b7392952298c94ad0cc0847c958bdaf796391dfa8200b1c510fe6a16e87085f88c43706a51aed665ef248ed7438af1f0f38efb6fb4c7d84dbd8fa017424c5c937eaff8b74df8937307fe8a154c46c84262408927177cb6706df1b1bbb16d1e346b1936a75d3f42168ce3fe0193b1a8cac99896cb9e9fd1510040d5e99d064b05c080717ef2a4ce98db65112824bc0fae067b273c23191b11da56882dc141df22452ced1b083d3e36e6341e31cc5fdd66f4eea041c18e4d6d46b2de4516f4af5cb5e74b8510912e459124c9d8c7c71b779d85ddafd695c7ed5a1c619b36379c61a4dff38861705edf584fc3ad6b8685e422e56ae9766b513b45eb7a8186e32f8b18e8c90e7fda588015c267e5723568c90a6c920bc8c8a83e15ba6ae73e43787d7d14ea4de48886cc211c54c9789e4532d84d3a70176c67c3bc2c679c648be87b28f3b9e78e597f4d2603624486c8e63838bbb0147c61ca8193cd5cf20543a66c113ea2dd22508b11ddbf40dbcdabdbd3555a5884e7f17629aa218159eac84799fbfd0a30572cf89f5437870b05e5e338fc4f38d039aa270729a38c27331b88db46e46165b88db601cbf38e1a99a14f0a09e719426ec45fd22acead6d3ef84c1d193ce519e39f81b113a84073b6c702fb9940a45574778dfad15ba09d42f103d510971a69cc40a712c0efa2ec586b5f5e0e6ad6dc2bf01ce1859281485f9c34716c781e73f618db7200a7a66e815cbc0670c19d7ab0e7c7ad1c787ec200af320cddc12898ba01a93072b7436040b71ae376a0946d21e92a91576c6665bdec9047064688ba74c2e1f4c048faf1d083aaa28c75611f4872b61b75d776b1d704591765418f16e1ee8654518ba4c55e5a121583689f19929c5705b2b04a6f1f75c2045efd12f0edbfdb05114bfe94c516513a2da74ae511f7e169235141df1a24fa8fc8e7e81ce35661d69e4551db1bf9c23e27a2f0a211cb0985843654ee5690940517df0abbe42ab700ac460293db03490a0e4ebc295867beb67ece48776b28d3635dabdd47b13ef3d71964884d06325e53c41d2a8e2cfafed4af716289dcb0599b089be05740e07780165df03baefc3274b5bd5f428d9a71f425d15447b22fc10fa6e41e1d035d664f56ab533866acd76b7d39d11d2217aa52f3267dec1df0dc044f0b36c4304105ee4f0819a23478309ebd3acb2176627896e9a72f868bff3c8f5ca886e2aa08149707e5556892d7cca43f73dc092907248d4dcef24535f360160926154b05dac941c4f0998ce78ced4f0c33f4bf0b106aa562e0ae8086e6afb780f2e8818a4f8b3003c55f1a3431b72082710dce84dc6fc3772aa8c8314991c8db663aa634f8885dde712cb5708af0867c26a164b417d9ad5db82817604d20445efff955fb7c87ff2725fa7b512510c416d70e77b3f6e5a13ae57f991e19b02971caf8699a0fc7df774db40689e68ce6823be3766da12208a703be19f5fee8fe5269b9de0655e9e45a995b99632a2b52badebd51bc45f6be7ef60e018905db118cd0d1e11b2abdd414a0458ec28630b9cb8a80b05cf475278ec42fe2ea466584aaf92f8b828ab699656a36fdbc50bacb58028f31534a4db190168971a4b4f1b81732bbf02c3b299fa0698215b8d3460739454ab4c0acee5654d60186b8e564e187261b91c633e17308f25279cde20b0720cd7476672847ce0fdfb797fd99d1f76825a7e9da1eace3784d1583898f2cfb2c6a8403008eca11e769df8ca437bab90afc1b767b092782ab7d5ab17a5e4886d5721595c4f5498176824713160d7c5d1e6c587c69663c1d1dee3000e10c495a304c241273e775fae13cacf2a034593182d94d073d51da2ed25b2c45aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
