<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3c7a20a9c4956c7b8ce396328bc43f4c9ea77116c060b9de0eead84a6ff7702a25ca0097acb90927496d0bf65dfe5d1dc3d2f0bbb11caf535e541b4eb27dad8b7c17abf617115344c1bd87151600b18e4aaeea1324e13362f38b03fd56f82f2d5c695b5b7c763505a5af1c00282fd8c886d6d576a663a8de53e99424cc438b07ccb8af641ed09fe5f0bb74afc0a51defff05fabbe655a1e46640eb2ec70df9d840816b4c3b8fa2bbfe58e0cdbb17a153436978bbeb71b0efd6174cecb12b1322e6db29da51cff90796fa5691910c3d8ebf47f5ffcdacc59a49d8a41c717c4420c10f6c062f20e00b5e91e360ddc6917eb3be45c3bd357d9719a23fbb6e93bf10c0946000512417555c47f160563d8afcb72af36d59db55f96c20e4516f531ca78eee6bce2faadbfb695a579802f2878b6a8d171d2c06842042b20c86322758bd5deeea5ad5354cdd9849a6feefb88eb8eb289c4585afde86e740dc9a6e50c95ff49c7c102672207194779d54aa1b9473922edfcab86116e78ff5015d8360cba97946cf374c8d5e46133ee81e9169c5376490f1362b35e01679b139722294c12e903ace500a50b37b4a767900ec3e88040b1cce5ba3025ebd6cebd59877a3116c036c25993964c91088ba6ecda9b8b7eecd7a9bc80f0c86503c12e3ea514d15aa3d18c81de29814476c1b56aef3f249f84f89e0ab92b4032cef60457ed78802430a2677b2dbeb06fa6163c1126ba5db49100e0003c5df7d5ce44010cc61eb8e0f2cb8bc18ce43f3f041cae127c38b952e5e29ed70299b9ca650dd4954f1a33aa6c91fa40ea97a1e3eac76822d54b13624721f848ccecab3285fbd8f79313de135269d22009f216b2fa061d136952c822d3a6b6b233995aa6a961f2e565cb149a327625c84666a782eb5ca1bcf2f2096dbe1afc15f8e5d34f0497b846a45a691eb2dda6812bb737ab07111324b2cdf22530de7f33ed94b7a89f41a87297e1830bcc4e20c2c40d69209e569e22b9b06bfb31adedda934ec575b4ec3bf2c256f5544005a7ca050d839c85c6e4b0ffcfe423017872c7264b08d061291b8c8030f32b8c22f197bb26a4cd6cb1c7599083ae30004644700dcb161020e891c1cf14a8c59acd526e9a47ced52d78ec08424decd721980c1f7c58a6afc06a0b4c035804a013bfbaf32246812258fe1ad685003e917a9453493e36a1e8367fd971294829cd2e2b5bc55fed4fe44786ce62a9680d7b38ddb0be54d7395810100cf0ed55241b6d4832ba461d9865ec1fcb1b7970f4dc25a9bfa02835f293be0b537ec4fa63532b26724ee4391dad7a6870081f4224954e8eedc114c3abba05ad27b84315a07debc629df6c54540c95a76f1aabbc19a77a3a9fbb400a7fc529e31e30d7c49e8708515855cea57e077dcc27ce377964aef61aee3c06575388cfc0814c735e4c13b7c1c4e97107b67ddf7f57583afa615fcf1b4f7a634796af49a2ab0a6e899e21980f1cac15e2fa57bdfc3fe6eb4252586a80988daffa6429b6acb44a4a268764a4f657e03bfe8ada64df4679b0013eea8521174c378548a4505564c45ba853971bea353c4cedfec5c55843220f6a668c5f2b3787d5d32b6d3fb4cde4e11e6a7455dd456d465922e5041862e0f7f7b9b9576f229750cdb211db703b1838b02113eabbfecd812fad3b0cf4497f5e09d4189d5e4b9606ee6a3f66fcf199e61089122059d01679b59e1d5e2ec0f695b91a2f10f1d0f3590e612965c083cc860424e114b94d89aed4614447e749724ac2477c9e5065a57c22bc4434c4dd82b038e0b17be97c09899e99f3b9263ba5ed73e253e79e71454236bf8a33e10f49269096db103d6ad3b8b27c91950deaac24e50189d64efbe013b9d4d7df783360f92301594bd15c218255a072aebe64617057d9525d1bdbfd38cee4579ee983606af2d56e73cbf0b8b3fe80bcf41063d45776420dcb615d9bc332fcae47a484f9e2ff9c7c80a1a6235f08ab9a76d09591009ee51da1ae256b962288f04c35c2354a1ac453ec434d1a4b7409cdccf42af80088cf4063b883034dd8101176085d927eceaa6f2fda057913d600490470984485442959a70870e5d39d93b6af9e47667c07fd44f26ecf5c15bb86df01dd4119937953caadf96317133b9fb9d523edfa420d1b3bc1fa45374594e94c4cd64d4d847759a926f16d0d216e20588851d0db75c160093f77268846ae78daa46f947baece79e6b7f36645f2a4ea95c2ef8931b29a646225900eb71f305c745db4385702ec026abbb383c1504f63d3d5a06687cd0dfd8e443ca2579d3d2cbb603a4c35fc0f106ceeab9a0334a313c638351de41d4840901ecf7254cd69ce46411f4d5f1d9980420440b75eec7948da537a1c2feb7e3970e558e4105e4b63fa653d31924bb154d70c3d4fe8eb3244ebc2a475c10d60149c060894770a8af54acb7ac61a48187c8fe1b756f927637c82af50b99f8f8216cce3426a9e45997683b28fced0e35fcfcce1d67a7d532c5526848d6d7b1c101c7bdcd39a59e787dd1f1d17081f051846acf0ba4146a345be656a7ab90e9302910c738e1f2f5064aff463258361415d48e3420403fb5327acdb19a5df87f984c22a8b62a04f565e513289998e417d0da1537230a5be6079b9cd09d653a09cce03e463aa6837343616b895b84a81d755ef5f5ccd675a2d3bd0b7e4033e56ba6a60f7452ffce741f0a366d079740e6225f331f3f3fdba17f7f4f9e2f7cd7010e61668d91229497085f6dca7712b1a568cf5687ee299e2dbbf67242143887ef9f427a0163bd396fe259b34d86afa357dda274969a73d583237084a75a9b470f2527396564e9645b00098f0bf42fd6aaf342c98ae5fe8e5f196a7bf97e75075e85dfe1216e292ea3e84261d25d94cd1781fc4e53e7afc362c64bbf87988115ae40e777cb5751a63bfcd71bd0e0e3bf632305fc112d837839e94f4b334f26bec5b5f18710e231115989f539a0c66cb135452180ceff9f76462b5776bf9a6e2bac51a858f9deb29976c3c6671054373d086651e3fb138304de29df690dfd3ed3e8dda9bcba392c9f114219fa4d08cee8483c35e4db7b1d6df3d94db080917f1cad24d46ce567732c7b57ad03e8987d224a9d9c243c18b2ec34159193f546cdde29894542ca059c4164cc141d8798e97321c7abcd426fb349fd6536d9b9c2a6b6d6db98552cce02c1ca7016598bcd64ccb0cab8543a69bc747ca5aa16100648f11e52d5d19b26095c69f8e837d654930908321bad2632853b7859d55e33b898b07646bd64d7c7ded63c16d3866f323c61e580ff1f377142d00e9460958d901da45721416913ca70b595d134c6d0f324d45f6fbbbc8cb2bdf51e412535bf7c363a067efce2ca87cb22723f22201753df86964a86ef44bfdfe3be15aa85d6d3fe5bdec7237a16cc7acb6c6e09dff9f06dd77186fbd001ebfdbfaf0df85ced5f072381ad5ee398d90216788f1c9c7c661b9b591834662e43c7be0c296180ec23948946829c5d4113717e291a1d34dbf156e67a821e730debfd99b702b01d654f4243fc54a3f0f56d68546a76b41fd6a13dfa40545ab5dfe0313e3acadb4c596d5ed386118eb17c13c142fbce6fd514ca062b66bdf9ee7a774eaf7b6d492354012920b4ce7aea80856fe15da1dc5a7ea99fc16deeeadef0ecad582bfedf8c2effb2f90cf5d288ddd300ea9fad63dad3cfe1cbd509826200b787d4fc3af1224deb8b7c31f33e2b3dba49b6ba289c79f9c326fe328ca63a0e33ad1d91385d28f3f5492deee3d8cb8d4eef6da96fcd53b03233dd2426b271fc77ce4a8c2fdfddd7feaf007276a34e488570ece9f12cb7a6a30259891342507d6b29c9c9a395e1a80d6ea7da3d15ca6979fc7518798aef54604524766218a4577d410f7adf3df87e6fe85c66f635e3e980b0e5edcece1a32993fe0b78a507fec3a7cb4924e2671b8bba12f823c4727af2ddb1986cec4d960fa57b2b4840cefa0daba4f6b20101ce1a7026658af3f3c472189a895990711db70917a8b92849a329c914de7b6b4188ea0e85c40729e457336b40159339b01bb720c3ed7ea3e330a0b6a354221004e5061d6944ac4da3762671d805588df2ea89bf0cd1759f7e789eb5096fab4febe06a77a8d73564683bb3b8b73ffccb8ee0cbd977739ee873dabe82d047999f6f3e31cf425bf0870a4db750ff0781c46e6b044aac80244a528873d8d8649159bfd09e9a76f3b855c82371d0d34491bfee069990db321d79915b48242c9b926cb4d25fe13fc126d7b665ae3488726b4086bcee9f80e11c5ecfd112f9cb0bcb43fd79a9366c44ea0d3218e8fa88b35fd5f508891236893421df93c59e5017ac0d9abe06ec15006b5be1c7066be8981b692f4b6085d306988b4d2f264ee23720135060cceb1cdee9c99006f4f3c4903fc8b3b188a2046d28c28f8084d5f5286ca3a6a1fbf6ba91a8306f6c80dfdc078d16a03423d5eb2e13a7dbe3dfbdf165bcb8083780af00fd14c918355e6c721a9c0e6598e1abd0f3529cc91dc5ded4589a3f23c2a5c2bf1dca4c5c68f2369a590e49822746d35742d276c2bee58ac5324434404aea3d4ca62ee7d2e89619222bdab8345c257a2a68a84e90451adcf26892d6954e34deba0b3a37c58fe6206d964d6bc5543f496dbf19f45f64a0e56fa451aefa0d29d8593c188bb990c7eb49fedb2442f4bf2a28ff012d81862d87f90fbab82f428cac94038e8817047292966f33ff9b6262c2e5008f636d44fe70c33b059ae335350d8d20631b40cb6d1296dace51fa3965dc1a9a65a6b776b9310d22e3327bab0f720e25309490d91eee1b147a1d94c58b6223e713930aa7554d106b2ba38dbc8652825fe330a5a3a4bf20c168c4bad4f9331e4fa8979459fd93a9f993356ca5ce6034fbc6cfe0aeda05f5740138828e93adef8a93225ccdfd1d79879100f9f11f0ebb3a8d1efe15e4e8e56182191ba022ad73ea8b399942d30e6088b5bddb3cac534c9569f0d5727172f7a4bc3233b64487f8f0838a7ad2b99f3483ed9666018454efb1217c723dd53fe2254b3016ea8923a7d6f13068f7bb4d5fc68234a510e8094ff63b43298a2e22b64de703ef087201d2da5ebc9f68ebd2f1ca5001d44a571a8b57d97e1afdbfb0643240b654fb2ad13b480804f588db6677fd95aa2101b62cbb195350495aadfc5f6360131a765d0916cbef508e8f6700716dc833b2c33cd41bdd3eacbf801c6b5b3587d5158b2928e1f8985264365bcbfec924c8a69cf8fee8e6f616cb2cc20e5a7e3f0da66a86dbb015e1e84778c48e1b70607a1ed4e7b51a75657b58b48a40631aff6aab5423af402a6dd9f1ab81de0586636956322932e6f3ca1feb37799808f1dc989ffb972193c859a30751ac154247a5a73a89e509ab6932658c4bfb800e848ed0e40e2688de3265f168ea4b0f97cd4087e0d4682492c9f20144a2564e4f2170e882cdce481c4406c3ef5c0a5ac9c111f53d11d542b8f83287cbb1210d232d187dbc5a7e82361f4009338310f5cb30914d781ae8a142b51519f00bfb562d0f123a6dbc7e508f033fdbfd58f46498be6371ca28c0f8f28db3ae88b1da8f89c92883a25dacc2df082d8ceb88950492e21cd332844ffd657938b37acf5ba6d733f888c99ace627d98f7496a8214d659578c445b8bf958c0fbaae57c7ffac8fc9f116f43b78a1af474e0da588b85c5880972849d6ce776c95515a8d9fb4296128cb3f949169aae7db2a66ecda3a8d916db042dea52bde471be3c14f59231d58f49a6919f5e26c8188455a7314901303ff5f0e50bd2075753ba921b91f5936ef645dfb3c01075d95be9784e04e4f5ad9a72fbfbc39e433fd18b6f2de9174ee500f2e31b140041094082477d9d63a5df2b26252a29d4beb03c246989c1a23800b68eee5636e86749af29820ee17e6f034b4d5e869c7a87fcfdcb0d6155b3512f5f57b493534725ccf69daebf14da74aeef8ac5c8172bc941a0ef5d00aee60ed6fff61adb95acf836c323c52bae3b5e8ec3e9ffde9e54c673e3bccb05f6412b5d5cca96d4067a002239dc2173d776eebd5156581c72930fb6848b257761494edccffba7d1c909876fc972fb260c8942f7ea388eba371cf9ba0474bde7049499d04bd8ba74d5dbd79e9561726980891a23c76c0192f8c7a7819458e435a8115855c3b1d4fabbd50a953c54514da1c669b9ebcbd3bec2b833bb4f16f092471c3e0ebe01228df15e6725bed5e797c900b3f5bb1f8bcb9db7e024eb0f79e5e7eb245cbf3f8e129a09b80d982257b6cf538ffd40b21b50477d501b830c631d68ae5500d6e97599c485da859a870ed530b94fdeff6ac9bd9f967b425fde43ea4e3e58ebd4d73f1ed8cd7f6ddb6d656b98d7a04b3c745c061b0d6803238141bf1d97960c157b4a02bb5f5f16cfa79077c833cb2dfb4466f91d9110c7fa99a4c072494c6784999ddeddb681e9c10812dd8ac547952ba058cf03ff1c0e3e37a635223d88de02ac4957f4fee2b3da41bde81cb6a349717a4dbcd98159c99fbab04c6bbffbaeae9ef58a02132a7387aa7dc5ce63120005f2879ba2e377560ec039646d4757b5611f0cf46fe5159660d62887ebd76a097c09773725dc91eed9e469c52f0464e60146550c4908e2d428816c4f2325cdb4bfeafadb2e487f7c496042c852a8c0cfb4fce9c455df440331edae612511debdb3682d79e0d3ace7712712b425dfd3110ca454fbff89f059a7d9cf5c605edc19f55ee3d01eb4259b9c744b60319b3a87da32c6bad59a160be0a0b4a5a4e9d4327e8a44e62db9da38095596fbca47be361466ae4d5400dd36750a93e044a7ca10b66e963d8725cf907f43944ec9bfe8252b16ce90bd7ea5c4673e032df16530be5608e4a47843f8bc67af55bd23e54bef30f1338d37046f99856e456854c9afcddb506cda82089aecf1465176a2e1201edadcabc7aaa7cb8194639baae870429a7e272d277e4caa86164f6b637e428b9696097445bd649dbdb27b01099e86c6aa32c72077ba5c661eb8b09154dd1af31e263bf78546cce72b0e34d3f8a953e0ffcce39068f2bb2e06b50c6f014ac9b71adde52f8b722fc2c6b2d84b6a5c13091b7f1fa8336609b5a80c49ed52795a3c01252810a4752375e53fba934213e48fe83726c73ece02aa7ffab914988359e3c23128532ed3881e2819c61e6407a62e98bc49ee5edccb73aa5cdb7824079b66426dd372c2072d29aa56ca09130c40a01047799b9576296d640d2ff9effcfc4c94a70e43298326f34acd1d2abc3178ac5e5dd9d7c5da35b036e253ee2560c0e77b5fba4a29eec194c893fa077dbb3baa4beff93d022345bd18c47ec994ef626937afe24e728cd2154a6868b2d4dfcfedbed1450e9d4c4b0fe3c84e0b483f1df96f313f062581a7e5809ba529b8ae51c433f51ffa5d632c1cc5c1c119e233edadb9d34ecdb93b3c1b2d6f5545ab57902f531735f2d301655af36138c0244af0cce210eecb45c9b024cac499064d1025c157ac59b027acd3036ab08bd98255e4d6191b9c34d7670f1fb527fe4d32e8d3404d9cd968ebd02a22585a70f5809c0d998dba7bc9ebda615d5738d50c71888b4aa0ba81aaa4c92862d0cac3d229ca6d26f60dceff314b168b117e3e78f2e395e371f1c30e2c58e1279994ff3dde95b0f80a93e1eb2897644a1f2f4686a3dbd12a75ac70d3d376f923e782a5732f1127e712fb26be96ff61be5b9c68aa96776d9cb9d1a8483dfc51a11bac49f8b3b918cbe27d0d93edea641139024f76fcf462e23223ff0a2df10576123cf11a7f41eaf07e27b10ee6da75615c9c65048fef2289cf182784cc3968edbce42cd3bce61fabbf7bb32e2084aba76c076223988cc340a349beeeeac419e10def9cb84759a3fa8fec2e5277006eb935a9fa43a50f7c4ff650b34fb484ba6a62a7f6115d3bef3d1af67617db9a2b46ec759bdb2ac1b90d548167ce28a8e5310b097a21684a39002402fa89124bf2c01b1c2228ce997423aebc95eeafc331630bdca04a701604780e2e2fb3e78e121218c045e798173e5a5db0dd8e28e6ad781a3e34b71c2cbbcbb225b8cc2b5fc7ac4e59672d3f31f6e60fbef2f115e9b41dc8babc80e0b93cc8bc3bc03d7dc522a405eb03ced906af8217e2a6809d7cc13274a9e27588345497b5a5e8d173ea19ede8588ae7a8f43e1f4a985fa2eea84ff517bea00b1a17b3a12f83478d3c0dc07b245825f7df4ccb799fe6da0eb75abdcc6c9e2705d047b37b629bc6ceada05c8cd5d2a96a1f0b0eed699a8baee1bf6f9c81bb95882b3cdd330af3dfa75ce0ebadb02d87010dfda418e432ea79ce92bef2d29ac0c655af11bf62865501b8c9448da0eacfd091e7c038f65dd9c88bec8f25a4cb9d666a891fbc0fec1b4f8342ff06003daa78e592ac98d29dbe8df699c64f929370fff7246efc1df9ed1fb4f9911a7bf3838ce1d981985adb1bbae1987966e1dff8eeda280ed86eca45490f0d9a215c0f93bd7b7f55cb1a18e2229a4b53247019db0846d338a3d16cfdccb05dadc39cd1dbc262c4036abf8ed64451ae4a5a9a3e509d4472c6d1e8fbf8751ca15681ba05a168dc9d81d2371eb54f64408c8c42087867b493cd0f7b63310ab036fd4c4a1d832e774bc18cefc15b5770a91ee2445f51aff2553cb1c1cc165e477130dc259ff9e5f84a3622b0702959c6f5e2f08d18e69b44137a5a5283732a532f46c1966aed4c9cd3af7a821265fe445aa5cdad26624502ff5066085a8dbedbc7afd4ba5adba9ade054627a27e8969439fcd09add3600edd3d174148d9535e10883d2e16625acfd391b5543f109ce5cda48a45ba544603b7c79e0129183710fdd863551137d1c1eee0b2d166b20f4577f3d61594f6a6522fa45772640526496d86e194d57ba38ea048557c5fa1d2166438e2ee087ad568418a682af04ec467fabf17f832318b59c83f6578df501bb901a3a9dfcf7419d2d240de81254839f92cedb10a74b01b5dcfdbdf54ee4cc34222646bdd13089e2aecb69e4a4077e88d3f9f9d4af87b65778a7822007728c709e3c12b1620e7623eff300b5763a517e991ab267d8ea7ee245a31f1f1ed0a2f1d4748d1085d10faee5c00fa96ef1f437ec5bcadbef0dea7a1b565a14842d4b1823cbcbcd5646638eeebef3d039f0a5424b67b7bcb7a706d2b2970d1f789844feebef8340c2e19d19f193e0a252344c12f92d8684380f6eb7571c00008404e3c0d0362bbf6d1c6a774ff87d1ada29ef5fbb5d7240a88aaec529f93fff3a7c1b689dbdbeded727387c34088420f4b652130cdb813357dc2d6e838d34d386bf57df250a9dee7fa838febd013e14bed1e9588f8f436ec44a7f14943baf54d58d7afe8b6551b92e00a4e3e4714aac144928f54c3e04b48c8c1328f783cc4bb616dc40229e9671e73db590105b8d06b987eec0f58ef909ce6437bf4aab12","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
