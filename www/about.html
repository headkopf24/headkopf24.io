<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2c828fdc6f409fca782d0566c3e57b0da267fe3c1fc662f3d1b4afc07aa59f5a3c44e8d28a6d8250da7c3dca8921e45356e6baec670043f59aa4b3eea70b1e85e1849e0f0e7ff49f1f101e50e138c8172b03987ee96bbf4d3becb80178d40f180bfc207cfe0c3a90e77b216dc4ebaa3c6a6f0240b73591da3109fcfd5b1e416994e814282627e300ea3c239cbfe479fae8c84e38ab73e457fdd11f20e0ffc64b68728c66960d8bbafb45be5938f0a0a775bde3c233ad185af81b93acfa85b690cbeddfe84d713eed5fa4f18a1164376478d3debe77008bd97de3850852697b9d1db22ef13e737b3d6e03b6ba4ddb5b5e277acd0d79389fefbb6beccfad3b386346be696d557feb0ad6c8b102a2aaefa0bbc2d7cca3659a3818dd03979f81d40a5e9b0d620a19ce0ee96618ddc9200b6df31f773b3e71cca5a3bfa84fb014b3138fc0c8936bf28de2f4768ba131ecf7de82175a1a934fc21d11806bec299cdec3a300541da23fb924cb9086bf8a00afa39be01ac70043de7272798a4cbcd734c7efd1b19fde11f465e319fdc36ff1a706b7b5b4192d387755b55c93b403f0a2e2b741ff90d4c7dad87331c783054ddb28e79be1a5ba494c3c84c3ef8c6a21313e618f71c780e3616f5fa29faa66627960c1850285c8c6ff38839e2d1280e2020b27862142ef4ad8452194715cd287ce0d4d209b3a9dda8d157bd816127c3620f6d03a0b5bdb4f8e2fe7fd23490b0a266cc9dd06e13c656422531fea1c009123d9f71c0471fd2609e269324bbc974513a67521d3de68938808d5046f2910cbb8754bcb5ecda35ebf6f890bb60b1182d61870ee6ccb20b11ff9b424f3e47d1e6a1246887b6e7cacbf22770e9ac20b41dfe44cfa0850b34b0ba2deb1adb5392450f881c48490e02e25f7de58ed36ddb66eeb19777c2e45955a34086cb9c292f29c5b25d7752893439f328f76c7d9a1abaa56cf98a5275395dc762838f6b341d153d8fb477ccfbadac5eb33900e11240cc654493795cd0ec382ec45b4c12f8addf2607f08bf7a70cec18037f82c5aefde86c3f377de93fc5785093039759ef490c90b64b9ec8bbbfc8f2969ec7c1abb99e5f0953f63c8a731b90bf6c58f685e18a541fd6b380cef4e6579a3493cdce9aacfacce864826ead0cfc00bdbae3d53007416f692a755357ec211265de607679990a10068152a63aabc4eed3a0fb5efa1b91ed2694d7352f818ab23c6520d8e4c18050bd4c251a56cafd1dbe9c3ecb851ae21649944322dae4900258d5d9ac1ca52e05d70dd32e2c4ca7ee86f89ebefbb17e25d1b6ee504c012bfbab0138ecf269483b0dcea0564c20b06b162bc3f86b6013bf1f28f7348ae440b60de1b6d4c05d0de1e1d3c2a87222dfeb6df18897142bf969e84fcd5c2cdc4cfc2522634d85f2c7a766031ce9482c836c8a26c354d62a1fbe5a17dc4182dd649635811a2188a5dd859e71ce8a3d577f8693c5221c1f8ce0ebcde96f59ce56d2a866099fa281809648d91a2a27c51b831102774143b19346b82087d61171388368cdfea20dc26e9df8600f835b705c21449a693ed26687b0ce98a53d4cc538ab3b270b0e7f7d23389fb9ee0cab5851a19e07cbb60423b020fbcd3830f7d8faabfe9def9c67df89059fe615df8538025486a72a05245039cd2cfa120d8e261053a9efa082a29ca4890abe3a2fb4e2955e060fce7ecb060535df1f4d96b92a96e7de366b5dc159fdcd2c1d6baef6bda36f9ead3fc940c622b3faec983d4392b653e29a440d26c79f5d974c6561272d3fb7fa7af33a209cd0fe6428ff8646107ff1c7145d29c7f67cd0a9afaa9a129f64c6302c6d3aa4543475bf8d14af8e826c4355343d3b1866017af42f1fa971eef129e92c6b3563b064b78ff3f5cf4b75fc9b84d7fe0ecdbb670ca8f5879d04f4df3fe8e59be7beafd610dc6bffc3bfabe85a4ab6d2af451a7ffcec18cbb735202e1d407ff318c0688f4ad96309f9ba3651e2ea43c6e2e272ffcda475d2b118b6414c3af53f26f2341369f480a1f4dfeac9209a8496e4603e2f4656e840603ceecb6836df51f3c47c7568d84ad12305580482b715dc36d8d7ed808b8b3b6341d78d935a8abda8bb471f4c918737580000e4a1c9f1dfda8a0b2df98bdcac83935bca1017a89f912396e0fc8ff3cb4dc4741553713b1c3324c40c1a13cb16b936d8b3673913cf2589723723079158455acfd65883df345d779cdd07cd43501b3414ce1f13c01e04e9a566548dc5b4fcc969d5cd5d4008b70a2aac82a619df7eb2ce1156f0dd5dc4be4dbcc49e76001f3ba8f51d40a045f8bee3b83a47e8db4420e601a4a0baa75c4ce8576f6c3e4bc492ffbae56d60ad86f5eef50fd288e7962d6dde319059331e4f00c86d3ef86d0aafb14a0139e7bbe141259f2146baca6b16952f65a105e204fedf417f95586dc0ede1e1a0d54007ff8b2ad51d64654ce8e1da71f3a832bb155d99181e7453a54a70805500557c663b300a8fb0ed102d8c87abc68f19c5250a09d0f85b566b02065db1d44a25933f3e7324435b6c33d212eabef3abe35ab38c52109ca20cba9a7542eeb9ceacb2c05195992d3f527be896786a857ac055e49f3433b9756e6d210b43a512b2231840e8de0e9b1dc4abb577606affd90fd1ca0b9c7a036f55ccdfb5173136ed6eaa6d94c293d5d19b0a853c95ddd4c2e719a848ee016c42ea74fc1dcb80ff759d8fcc791294d77b3b5ac023112f5acbc022f040a3da29af5c1580e95af6103106bc1c66362b8f4808c807b6d3c01ec170773c8e5c8bca40ecbdb6d301b91fd1eb85491870a49ea932f3a30b3850761950418fbc985fb352385e5682f4aa661190c848dbc4f8a933e47e75b14a27f06685764cfc014780f86beea3a951d254178f8b85bd373da325664d598d48b138baa1282a32b9679781d893103ef6fde892026c6c828d937f1ea92b42606d8237fd06ff98f69684d44a79dc5dbac9ff08124fdb14ab829bca762c076e3da264ebf37532e177fe0059709c5936615720364e4fdaef1f77bb3028ce673f178b93282d414f4d0a98696f7ce72e21a128904d1f1e13ec02f3c10a5e8f7ba0114c35bef36652c0e601e2015b15570ff27a698351e86ba99acf33a43cbdfc2c5b284944cf4b46e2e88619bdd2b7d08d3934e039c60131252c349f1cd3535477946e1bddd150e02695a5fa4b1cd3f8be9d83ab2a4749c61df93d904b0de0e6a38e8e72de9b0f77c3d065b653a12ac0593797f8236d9ddb8e8e8be12626c1229c76c91957574135be2bb7e20833355b225ba45936097c093fc55ddd4f2b20b754bcbb25a119965c8bf1128f8bacbc8097ae40bff94852cf09185b00bebde43f8d4d957a1daee72b29072ac040aa022cf59f1fadeb69e800699c2e80e58e19f8b15be50fc455f97ade14434779df0130c422ea60250713ea80854397ef68f668e63581038aa719bacef60e77b9e4c718444a845e2b30f14c0f4bb7ac68d6e1d994475514ef12d5aa723005a22ce33e0b84934b6a1f8ba74a58c98060e446fb1fde2d57a20fbdfc13198cb7310979a4a6c0cac0a21ee5cd88f1b6b449fc4fee80d44a324b037bb882ae631042069635b811353c43607696b351d90c2b7c01f6a710f1a74c8626e69b7c08ffa902231088915e210c588aaec3009f3b3d4a72ac87b1cde8bd15af2488d815693d70522690832593417ff0b846439be7f074a083144e7d458ae43f72202390c90c19648c8050f10109b7cbce79a49ad7fdece88dc242dc740f43f0c7138b72a3e2c3d2bc7fe762a9543b3b3a0fb42ba28f8a1f28e6f45f3a17b2b870b2d08321559dd81784fc69b884dd507580b440163a07a84bbdfbb30d66e5f60fb6ff4eb429501dd96d6f5e680ce4aaa2aeee9a76a20f6b7bb228be992381867a7d26a0fd60c6c77541edfcf208641dff4bf76f29b1cea2df3d979d87112239e3102ce31f23677698341639ecb62817e336afed91427fe0e5be345c996216ea2c644ed744a872da5ebf244fcfa9306616e085d5a4bdad6a4160db83e59e77ef5d791be1ca2c9af2b34f4eda2fddddcadbba5281f4c337ae576bb35332d1136a7685649bd00339f8c8638a5ffab6886128d189a165e582d125915ecbe6a61ad076e64a08daf0c3214d858f2e47c98e1759ff7007c5a6a3cd4e837b803aba95ed5c1ccefc3c8f2fc5564a144923f81467a1e4a3431071ead0aa695b9f09cc11d5918e8fca34e1b6addf2f5f32162603de04e0f72cfe5c19560138598c57efabe48bece9fa752b513760eb0e44df81cf554476387c8637d437c0bb7e218241f510850f7e1d33da746328074f09a1037e919fc7db0c04667a079d60ead0c6c5f3f4356cd94063bbe927e7fe79b93f46e8974278481877ed19304a4086acc10330ead40051c0d9f4bb69b4d862902257f7a52563493a5c4a9d4212683beb04d4993f8625a4e4393fa8d029fbac557b1f9149c0825a7d66e0cf93413ddae9052f797c3de5793698e2b4a8dfbe57204765cfedb62dc7d7a7015f0953517bb87a54ecd38fb4fe0ac0b8d8ca832202bfdccbe18897637e21b93faead6fcb6fbf00ee2cb8f17e050c72083cb772cd740170766e04ed242bd8cf83cdaaeff1e9b9b1061420ff352757ed3930933a629fd374fc81faedc22884708f44850047e120b6312d9eab121cca97678372115b6ddbd5bb1d55586a59a5ab304c66e68d83f3a204bd97c693fef2057ce9ebc2d6c1c2c8b70b3f5e5748d236fe45bc7ff03a3dbd79991e93e419a5871746705861b74ff355b1e907b72ffad01e54e159d061cf6d9c3e66d77ec29e7c6127bbfd713adc49a8e3fe04e422262f68a672c3c59c08c8049a54e7c6365174160395f35fe78acf98f49bdf6238987c01b6fe538a6982de8dff53e9d7f021baf47ca38d9e37f6fe83f663b62355b099fec487f535a0ea5e2151f8d69a69075f65dbdfd419f9ab09c4b96d2bf14cede2ff5fb74f56426a3405af9a14fc3cf80202d02c73ea410c0160a1e153db57b862ef6e6f5261efd3d8a56e688a8ebd0f1b3699a7e69edda5a9dfbe7b53e8137bec857f2e6540fb48726c87e04501eb492f370866f36dfcd8344200b278bd0db9f2f254e3065a1fbf269440ae7cf74ea9b0c21362f342c6186bb67d20de8f84b02dd3c1697af17d0dbacc5fd2db436ffd7dd0078f72f66f8ca9b93d878bcf7938c4db1637fed479397e0c8949c6fc30ffaf3827077af7acba9e3a0c57ec2377efa516402661ad5d7f0bc35dc71df774d4b49d0244528207e366cab90e778dd728673381966cc5d4faa5e7e090220aabaf97839c1ff59249c33ac1358fe62f845e7c68a30a739e5e75f2203405a30bd3c31d0729213c63636dad4713370fa04b0f273ef450eafea25e1d07782828cb392c0baf0ed81dabe4910c9e0dd42edd3da8227a9a146d25c31c0dc234f453e64276ac74f0e1893c7819bf107477e3deab5cbd0f31e0e676937e3289abd90ecc5772fea9d391eb3c7d356b6457218c3e4190bbf0385b03fde612bd3c2660a948dd057f40af237a82851506b8a3ccacc78138e865b8e00d7f79fa86baa2c427537753f3589dc29057528931ab90438adb6e2e1f1619d68ee705eb6f2e99fd00bb9f3e58a97e4c4dd05b4f6be954262923d31d4b8562b23882ebbef8177c8a6af7577d1c8b10ef1c88facfbc13ca84cd9d7a338743261f01158210f8fc7e93ed724ee74ba87c71e7bc17b8f9126e819f1bf5dd0b1442aa6c072fc6d469c73abfb4e3ca782e566ef2a83b8269f104110991dd07a6b7ccee2c4d073583367ef9203ffccc94ff32814e01d217a7498d88b0340f2d882390d6279d543837e25c8e7f3cb95243d8073f6022ef277df681d0d973d4ca9ceb05d0a97072bcca789c3210d316b36884568bb5412a0ebd00cf8e80c52656d9d04c3dec10bf76b2b9271dfbef29ecf0ba972d7c3f4046d4060fb1c6f2296e57a682ab0b16655c416c5b34790b723173498a4d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
