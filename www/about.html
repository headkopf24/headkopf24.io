<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c72b548003d4899b2564932f1d9d7f74a6bc0c969e04da439b080434121a77c84f303003559bec0ecb7ebd83727070d49a13643f6bfba05319f2ef8c8e979d48717032c76cecab420fe3112f0086e53a35c82f39c8f88082a923a03a722c6b61a9fbb908d2e3bd83d9e085b723372aeda774c51d39fd458b18e5aa53d9fe87c557aab656ef83abbcf8a85a727bab9d436eb0ac0ccbc144a346a6d07cbf31e3e4ed3a1b25914f13556a45e93da5601cc11e2e5a3c63b18e367d45cb7c7545d068e43edc33ddef4af8c90973cef620c244d8321e65ab139436705e38e681810f3d1d0a0a3ed6c39e8fba68cd46a61d3404151e9d5649c6ad07ddcc9f9f67b671f5b5997f624ef967c5b6685b209be3d795975c9f13488f49f38089f62922d1da5bc28d792e743c30c5f7fa710cd7ee78661a7a375580e208b060f2819dafe780630a6933f009f6e160c023877a232ab5fc3c3788ecb256ab540c61ca1076de8351789d8d17267a699995d2aefe6a5b632b5ecf6975579dbae71d346c6f88a173ef5c4eb6dffec84029953b28d2bbe5d5b0474b12c208c202376a6c9f4b855613c96e8706d74eaea7d61b052b1faff1a23a834e32f4d7d34c89e132850213aa78d1d53e0b5da884e394c28fe57772311bd597d1e4a35e3937583be370565dd0597edfe4ed0fa8f31fcdf86c2ba1771834451e1a0e7d38d8491bc4fbaf2d5e002117ada223e78f6568e7d7a4fadba1e21a960108c291376fdd15f4e37a296eb639f0fcb6c7c5df596c19ecbcab4f768cb71a29572f2d8a6a8f841ef1e17e27a97af7a086b8cb841ef52f0c5d7d5c72f9aef7c3e047d8ec45fd44fc862bb5c6bca4521dda3c7320c135beaf78d7ee5ab331d6402efe047acf0d4ed5b2c180e28d6f1dc479a3c467e075b63a4692b7fb0c01d71a57156a0a3f48703fe5954bfb5485c37e37c388338df43a726368fb2346670ba104917e2f864959184e864313c49e0f8fd00614fa6a66eae1441d71630bb2985a44bff7418fbfc4af826c2b88acb06751bb7868cdf0d3302dd7c821f1916bc2039f6c932b2bac101d11c0cb6ff84a7dbe53f56507e7c9d9e6627f2547d28387f9db7d45777c239f25cb54d7c58a8af0c7528a3c42b41787fae6e7036763ed333ee7a76715d575fcd73866177fdb2a7020d85a0518327e1a5a734845de6e2260736bfcd991c846050dc6c7cde4b7c3e2931d8a2bd6c1c1f8ee37b8e9e16ab4cf28244f0bf5ec7b0e8873b08690572746d6b6c11b2331d0b4331ac61132c8075b688bf5279a96b4d5c97fb7e828d6ff996d7d7967be927a5a8787fa99e7c28a9bdbff8b5f1fab460d69795a89bd0763500f453df256fea7ab2b70e12004b65e31051ecd5f8de5f0a6964cac8285a5de550a7d024b9d4783a62e04a376fcda08c496738647d9e2950185a3ea11eeb0508a3671724dd597b04b99066be49ca54f6804ffda427340c37f27b8effc6b053c0e493a3b864db329b4488364bd9f7d6ac9890ba983f5969055f78157d7039fde662b3dae4e54874505b207d202a6068c9d317af0075d42a50c12f6ba4e8f19d9779ce9df799891e88b82b966bcd729152ff731ca1ac872e7882d8bbe8f71bb8405f05c350478f9da40f189bc8f2f8236396865a32137b4dd344f79159859281fa0a4583ed5b66a0388e72052c3be4b3d06b9d9d04c97c9c73592e99b982b2f0945197448a58cc4d65ec1e3015b700d3fb61a9086c75e5916bc86d2db7572788ccf27a9958a42ee34bb3041351267da7bfe0e0cab4080e84b36aefc5a52dc36cf86f19972cb4e9d8be5d11c45ee6fe89b48139ba6f1ef35206c3419dad5ffc3c5bb5396518781767b3d9a51f177791f7ed733de50b6220755527e7f3010e3a56bf68e1d7a2c54f955a234733899bdd713d3f2edc2fcf28106152f092c6bf9036ba9e27f91c39be807fdc805383a64c6cbcd1d1e43ed7bd5aecbf27df8496df7c4e45f01345bb2efe7a5649d32ce3179965f4c1dfca1674584d3f1a20c6645b3a7d65deb8e2bef0c53de0e4c24aa78d4b6e86631ec25872da87d5b8cf63edc9bcb6f7c8ced0227ccbe9b87936e539dafd48b3ea9a53dd3f29b96d1ebea5f0e678f57c6e0fb8122833c116ef2ba05c4bf6113406f691c37afb9420cb75bb56fe992d320bf40b6e5928c5ef5a5f85d76d668a41650a7bf1c3a2e74af21b2092a4ee04913312ece7fafc4d7eb01e576a1c05f519a3a3c092dbdaf6a49c76aa41a5e55df2ccf75135d48dbebb8bccaa990b021488316eed6dd05c144f0a9d3b4ee74dd52251af3f1d886e8c9c7611067241e25e826ac4ab2fcf43ed4b772f1fef92d7aa9c4cfa686e148481efde849cf5820c553811eed42608fff5e371ce54da3423db5ebe7c6b14ccc6dfb90789596a05cc64cbb318946cbfebbc87c0b85f8801b3bf7a2e8cb1444c13c4958be633e01b252ea6ee90014d31dd76fdcb8fdcf6661294f7fdb4992a813b9c3c53bc184d9293a4d738efaff5e95eef05758707fe1b2495c93231580ff414184ef26c97c05d800f48015995f5d71fa43eb117545d555509494fbec7b226f7d67474ac55b2b21d7bccd220cd15dc5c878d7ee9234003f306f634f35a0fe4fd7696d0d449717820aa9c1c6a0a684ac7ef941503bd85c4560885c9eb830a259ba982bcb28bfc81bbd71ffdebb51b0ee2588f80de4c6e99ba25c243ff6950a184ebca638f76892015537fea04798981da54d6f3a840b876007d6f25a3d9cb85ac91ad1db743220693c18ed9595fc455df0f2ea87a7ae0eacb3440dcd119302f6909d96e206a058e38ad65e15de9bf4ed8556be3717bb31e46446a17cdb920cf2d53a4881c1ed3cd6d4cecfd365853a8afdfe993eaf028bddbf3485e9cabe313ab20b1cb475d3520208f6cdc11b14d2a7e2c4648dd10944b206b96d4d0806b0b09ed3ac66785d2f7921980cc5225b2aea90bdaf79b4402a16e80aec718e98c9d33349a2e3f4e1ca91b8d7e9d10875a08cd0fc9d21c804be6255b0ef33dc0e96daaff25229399f6b2d7b6f7f08f9afff1a60de91c20961a14f058604293fe72a8f23c8b4176fbc09f3976ded417676b8c0ddc496ac2cd19fd9a399d5f8afd90c244d08e45b111ca4e817afd92d9a79578bb59f9450e3f5988cb65ce251e46c8457e725e10a94ac513fd651df42b20fb6b61cacba2bf435c8d9f35aec442beec9b269a0e43d5e9930ad89b4982b18d1274bd6831d6501336dcf19a41430ddf5a7f726b58447b742f4c59899ffa0995b2158915033e6c7f2f61b322aaa2732bc64ba0489e0b82f7ef6c4cc3085e957a5c79241820357aabd21341b2c0bbaecb0b5597122fdf632be9ee6afab5ed5a9da8887401538e9bcc798ff34579adab9d4cacc94af152fd481597f3fb3189a36ef156f1778c5275bcf95de0b6238782237d637e64d4882554d75a29999876f427b9925b4c9b9db930ac7be42399b23b9cd24c1c9fe3f8d85ffa48076c9e9b092674fccfeabd367d307e086b9022856e0d8559456f8a2193d08462ce55e7c4bb5df7629a5ee527b7250cf1ac9f93dd24dd326b0b4eff032631115900b722c6bd4f8184e3fdeab2bc1bf48706d86e9a654b2ed9f1423a0792aad2a5dbf4d4b428c795257ac782bb97510d19c830bea0ab2cc6dc5670265776f630a8767050e0306065d9a24e5633d30e66c37ecef7e007bade187f94b90e11b4aaa21d13c2cb5e64d02e35e27f4478bf4e25faa1626c5b57deddc4aac6134a90ae90a909acf9f9e5ad690b5a6622c094f8e4f4cb9134903c66faef8f5a516100d4e3e6f5dda3229826f7c938b8dbc85f1487290afcc57a678074282105beeee74201776731147019eb1c3c3dc2e33058286f55834d3880df56dbe82d7dc3b4dbb89727a238e294e673bc5f45fb23552c92e36764149432bd315e28ffa1abe8c36105360aa1b9172bee99fca5c6708e535163108d28cc352f037b56c9c1f4f691d300849fb47242648965369c8832765f4a211c49e6c47eaee62bf79a45ffbfa6227cff5098eda5d811c84ccf0bef38d6e5e304d1e710304bbf4cebe961f9e4e469091727caf4128c76ecbb2de13daba38d55e9459f62089b94a9e833926f79539e2884b44e557c81e37eda87fdc2c6bacdd614e251126e49f4dff27532dff60ed16811fd0f4b50dca1588b5da5b6aeb30fe21a65cbbaad5300fb0eabf9239d516e57440ff0ad8f3c34c12f6a6ed9047332beda42dfa28a1995b5f1ad91c29c7d6857ec00d62da11dfb820409b94d50af4e787869f46523e2d373b66f75013b73ae6c13d29a3a7a2114ff48f76e484858cc0662096a3e4814bbf962716c12a611b560c4382eda04ad262abd1bdadaaa95482c4dcfe4497354a346cdcc305ed14558b4795d56c20cdeeeb182745ba9adf2a2d6f5905e815b41d6232f23775c83400171bfc717d4c0993ae656a89236e97437daf888eb1cb145192ed92b3484518d4ab732e4b44bd75c27d37b43917cb736acb241c99f4aa251ffa7821f39cd7e6d3f28800a66fb485e2ad1fbeefc700c9def870ac1941ebe631e862930a2612e95e38a23563f9abafb6678b92d7f9d8ebcf67a85efa9875c12786065ec457d3185446a9ebb98568495bfbe1b7f4c5e313e8ae1f1f7f61a8c91b38c0b97a247996a1ad5c73d55e383837bd7270aa51e3530fa270c955d8c6011f83249c19c20d41767346a2be351d390bc1a49959cbca9565e4ec4077ea4e9c54028a056dac6d54425e8275e5926e89a6a490b2bf93eba6806d3c3b47af73930073113947b78df2512ec4056a50e57ac2596718b0325ba5f1aec71a3409abf34f9be5f3d417c2af946c94fe152cd1cddf425b1821f5ba2c04a06b70844e9e0bf0b14983c4ebb10a89468b894cda5fbba530afcfe78653f2096111bb20bc7e998353658f8337c2587772f9529745d4eb616d832f446ad1c827bef02d706ba318eb07fd40d56364e10073755523f00a0575c25b41bcfce42479b64944d5853ec6b913a4054c01de46a1a27041580d9a8b65561021da567451240d952d7e127aa2b952a6f3a54dcaae9e1abc469e21409622d59b295c057d9174aa77fbaf81b450aba82dca225bf9fc19471b099e396ab61b26f8c674a6ddcb74d0daeb740efd4b548f3b66d951d6ec3ae7b1a1fa0fb0ab72de07979b9786f9e0d784c16f975908255757f99043a0ed3dc7dca7391399f1492370b9705d104533949e37d28cb7b1bf68d4e9a1669ad64cc06f10a25664d5d0859b9510ba585d62cf7bc9500d3a1d9c9432b46dbca20b9f71cd77c7554d612ea2726f4b8cea869de99f7d35cb3dc7b1f419ed38f397f41b28aa90f7df781e7527e083cc6141fcb62e20e7eb6e62499bc106c4acbc1dd205be0d7fc61c6c1f17f28b9ddf7c34dbe4f4ae6072fad840d25dabf345421466e82a8f4db3b660529f126af343dcf9503b19188f7cd1266082e9bff6b672a15823f5bd3d1d22ea5b307260139ca22d3f8676c8eccc7b95ae9019c540d04880cf51bb2cb690f1a5b7c765f0f1b7de7358aa8babc2ede5c381e0d465ce62b89e261333ee30f73e4ccfa69a92d02fee1261c124f16c3c3fc75960178737de1991cb32311345478bb2c3f94f96f8d4372bb9fc524375d2bb49c79680e9175073067a4ccd9947b0ad09912daf1c36cba6da0c8a14e49512e20376d5337d0f2b8b9aad09b4a1299d52cae5eeae62ab5822040c4459f91a22bf64e694c7dcf2a05aaa003ccbc3564fbc014bdcf286ca3740aaf0bf869ce1f0afbf3d4c34f9eadb97f09f2ea16585f55fcf05adab9d7414efe097e13bf34be942eedd73eec4c448c6782df3091f160ae66de0ea7b31f9bba5b41345e1c164bca41511d35e8b22259d0c18f23d656d44c22204355827f52cf704edf23fa122e28f8b4228512c5e84bfc55ac68185304af7c3121380b2f80e68ff7cd3c00cc93a5bb486efcfc131cc1de1147a41a7b9501c42fe067cf7333269552287d35e459e78e6508e027a5563cbbe3dcf8cceb9ad6a0a26fea4a62a336e357550bd8be93cf589245cffe596272f2be83335974d59f1978c764ec241d8605e28b9b5ee5fcfbb455fa8f62e1b24f6524f5874faff96c2a5eb2e3e565b60bdb8f4ca72408d20b5e46ee04efc32a4bd794073bc6496556e60490e3138e1a1f095b9b760ccb26c29bde0a79075f2f2b4a469515b49379841f2989c3925e41cc5934081636ba5c2d6e00a0f464c2faab1a9666ae7416f726920d087c63fc6a26357f70f68023fc43d3f0bb7c3732cf733682890baab54039c18ea9a9a8bb1e93fdd056080588d4a84a3b5fedea03577b899f8abbd3762a2fc328a89ba9c881fdef2133a336d306b921e5752aef13adc47552b32e69bf37a9af2b44b147a8de6c82923f23e4613da2eaa669872630a7986e105a3fc87649cab67bd010ab65bcd844b7ec0c5af4e65f80775ba3d9bdd3dfabe11aac890a5acc804806a6db7824137cf96fef9d4d2f46bdba7b562fbdb43ecf496a5a9aa8b9c3166f1a8bdc5d2ec20e1c81ab78a5eb710ea26152f6602c0f8a3fcfa28e572aab43d873a9f54a9ea7a49c4ce400195c9ac657cfea068959a143be626a0d9aa92eb0e631ac6ea7b8cdcc3e0bdc1e713f83c2a480c3e35ca39f02c0765db06848856d3e54340e7b440a5a243d68cad1784f457f128d7708cc5233d0a8ec779222c97bb84c86ec45b732d4234297c2217b628a562a518cd14c3217b13acf0e33cf5635d219ffb089f012aa3bd331f7e2b516637b032d99b904d862f4eeb46bc576503cfd533e2fc040de9bab5636ae5af7a9ab0e6bb62c1fafaedb63c52eee652595c628a50fe0b02ac0c53a1b3371d9c5359713656128a08ee03287e898a00c81142ee875c2321e1d175999165ce9f1b39c99fff3e4289ab1f75f6d1fd0797e956a52c80b7803263bd9ae4ee100be1f5f1e9dc9467b87e1fb6b796321925ba04ae6641517910ae6b67133603ca62fe104938b563aa5c72d47be545dedb66dd7fa21c76ab8be2c0b80e3b389d824de65cdae62374a1e85c7b3972a641f57ebae92afe73622aa11ad2ea903163a42cc1668d4c58991f75a82e7cbb21871810826b9c907fbfb8514fec7dac02f8077be3f38eeec158fa04df62ffd8a5070331e29a6d54cd9db2feb784beb44312bcb5b748d338317509469b3e9fede05f3742586eaa584bff679fc73bc1eb797da178ce152bbdc45b18984b72e467184b4eeefb72c051d79ad9fbbe41f5bc445f68eeccd14786f8ab3fd3741b8fd68260c72d1cd7eb325928783d7f1ca34bc84d9a1b51f2b8064a86e94548005d036f7eb877dd7f40ca26c6337c41cb6140337a143c349da5954baddd7fe61cf226277229d4f382cba029fa9e1b6dc4b47f0208a43f78f93168ebb9cf66417cf69998bc06f70dea137eb655ed1c33c987fece9bdbf664369b94c55e6fb8b6e40a18753b19aed6bc4df5c05c4dbfe6a1d68a7b78eed3877e96f322509756d11e77d5f1aeb5e122c00338ff791262d7bc19d0777288b425c1aaf129ebcad465e28dac062fc985623b76927231d5ca3e32aef8240bbd57e4059544a182dd324510deadbc0b38c3b67fbd9e8a997147ba09daa1431d32a7d9c119da909e06cac41a6aa0f6a3e940efe131103b9a67ebe41a21abe6f8327a25d0de7e039acbfd2ce82a4a4dbfe620f0b4bb39a65d89ddea4c9bc8b3734222f29e7019111c3cfe22d8c19e657f7727a545a4b0e8403b05b398f398d7a50a35d083f4e2e7935eae8799db8853fbc19a35e981a23b7eef5c1a475f43e6e6b0c3c6444270d000e9588c7e6a63e5b9a6708ab391cee6c4c2b0c20b1827cca7474ad6e160c7a4b7d441b93a52de8b6fa6a07f0fa678e110ef948ef6f7f450a0f05b4e83fd67e1b9c156d38f1dc361f94a2b6679ec951f2755fdf6ab4613a07f8b569b9d6cada0bd3afef6a97590491459a48535d8470d32571e888e8e75c3ccfe4c6622d12075027fdc9c6374bc626f13caf2420642ab8a466f91ab102822ef317a8a1dc5af35dd782b4e987b738fcb339b421f9c920085f79cc8922127420e2a026b3319e1bdd85675fdf00616cac547ea405d6660fa9ecff96d1c0e4808cafbb37abf9dbb70d7f7dd1152b39804978fda137b7338b5754dc9abfa306bd2be47d22f71ef38d1a56a035365622f1a257e7b1badf435fec81876a16b1922900f102fcdede05aa63c8e5b27ab29459df3eaa602ef72de027c8a94e50a108cf8bf15a731e89ca00c5b3ab92a4668640ff9b82e657e0de1eace1a7d5b099a2d938ff4c325f9eecf47441ee9c9d509e78d34eb25a611505611ec005f09d2924c51a091eedfba96832abcf05902e254651cc3d9a81a9d6db9a7ef7658e6d746205dd9cf2475062c912daee60d750129bd9fa0bd40d41dedd4be116e9ad08f60970659b68803304793a2bbbb1afa4914bf543df116853ae1820bf8c5c41ed24cb37aefb4a02b33dca3215b1d1e304790962978bf4a07301baefe39af3d5b6f293756a26c09d92652cb3d2e48d9cf357314d194940c29dda6bbd6d02fa963516ca267a4b64f90672fcf3c97343b29872324e38f3b5e1ad93d83ec73ebecbb2ab78c6c0f0a2ce047226b3d0272e95ee4f7b6e1edffa843002b343759c5c7f064de95df22a08985bf01fa630de49d3074b0a2ca112b1051ffd750daf34a3fddcfe268f9989228a07fe3e37853f3be0bafa6a9c2b6d39f7b3b78be0879180101c10a78afcf01b772f966e926908c4be739b3a9168160a665c1f54df5bee8d8f54f60706280655dc7b507c247a9e128bab209ddb9706bd1705f88994fbb4d69b227a69205f00051a89ce28b30d9ccb560a050063b33f0bd0d882d719cac94435843c3bbe0aa08c6b0a085c5e6d3dbb4409f65af818a94bc0cb92a3e4eef2148df1115cea76f5bd5e1a2a5605193e1e1c38a8b0eb7285ea055ab3218cd9f6a75115b0a62341a969807916e738ee99bb901f7d4b8d7acbaae1456623ad32a1dbe2bd7a446de213809b9bb51c0ed7a48dd65d79d2f2359fb810450d3bee121d464d981f86fcba127a1de0c2ddc0115ff6b5a8f833bcbf4fdd45180ce5cdb3418d0fa14013f2d773f4a1c75fb1c43baf8b060c6881e7ce26f2859ecff1b40ce9494962ba45403237be9257f4eebcb5bbddd83fa86e7a98d8893a24bd574f1bed7757af403feb57cff8226b9e9b91b723ca991d3277c4b57b0b64755795a105c5f41bf8dfe1910a5b8b78bf81ed1c9079058c4273ce4eebb2eab4e84cd6411f688c4a9888d29c805895d78e438010f46cbd57532db3d700233fd2fefe64bb1b64792bfeff0dfbcbbc31ebb23bfff95e38aee49132e8a4e6c27c5afb4624d9aa70087693d9ab7d674a5761f6cde20175802cc74d3938b3172a727317e679b7381007463b9455c2f3c6ea72c4e0117ba52e38364d7ef96a646753905dbbc88cad30422e9d12ed8b0af1c48a503fca61f545e2107415280b4bd867a2e84376a20a577bfa14771bc3136bdd5d72251118e2a5db24ab9f101c9ee33a4a452c062ccc342295e9a733097df628db5bd594ea601413d3af958b724c06d41839f4f4a510c2ea147bfa4d9dd1bb292749380abd56bd28b63815ceddd693fcb389382327a6bfbb0fe3a350d8fbfaf95f93a7aba1853ee0acbc8344b581937666ab3e0b70fc966b4f2389f19995550700ac6e1409d681e92d7ed0d1ed761a68825c00cdfb2372cb222955bd63d3ca7cff31dca26ef8445f8bb580c6cf3ee2fa9e7c3239443d835435df4051633820d7407711824ea02f6aff353262a0174302bd28359998d56a89e64ab800ee9e32d306cc2a3d70ef3e2d806ff893bebb50aa146c5e79c91f0c79b786226d39ffc676482b1392e66ee2fc2bb8265259d6c1f3a4cd24f08d3ed1fe4a17dc3d08ab14446ace5e15603b27d85ac9720a70d754203feb8a1477dc78e14a7ce3d1d4b4b90599722dbb15a434bdb8479d3a8dea0016a4c008171e02dc7442523c6569baca51d71bc5556e7be04679dd9894c96286e1f81141deb90dd1b4457f5fb95c563ea1f115db265aa7314dc48be2d4fd97b863a0bd2a39fd0acd9aaf2a6e16325ce4a53fea16a77f33d1981853b2cdb2ce42b295ebfed764b5a2aae585831bf9b2522c4eff94051d372c6960172e46479e8066293edf19494a4e07ee7bae35c528cfb2a45f2550d19f2e9bdb6e30d32de17bab31bf5b982de2dd4bd1885fcac774b972b38c777f4422fdeadad9625f7542af0f2405dd7f623ba7eb13c5fc06b9dc3a4e69fb7f326de72e9b8cf456e5ce37d1d278f70af970ad2131cacb752d0456f4be87b6e058e3a739258c8172767dfa062530ec6b7777704647526be57aa3a2e070829ffde283c6f0f570e68cb9f84c89f8573f1afc584b972785ee86c2382a3ef617795192c32dd11c215a21fee2c94dc6aed4e522b56752f66fd13cca8c9a0c6743cdf28bfd7b4f915c907d3d66af5852ec9b6e18547a67c62c34fa9e17eba1447f71f6ab0f2f8a05bd071ae377bcc26547732c7379b0951fa2f03c6bdab0121d1465e945e17a5a26cb4782640cf0de04c297bc7f7a74cb0e2f1c00e29ec402b95211fccf0e41d55576c5335a8d328bca792be9c7210322730712ed440ef691ea107aa8e4042026458f1ac1d3026d198ca933b699b0dd563d679ea6894b6a3b09a8fea4ef9db9a5669038dd83cb01b28d74815672502948754d6959534cbd21a876d4d451cb2c9dca75e068e2db1de6bbc6d9378a5da70966619723777619dfffd807bb7820d315fcd45e468798bda341e81b7a41a15f1373d5ca9a98f061d3c04279fa88412ab7c98adb9283bde93815d10c64eee89d22bb61d514a8adb185c52da4f70d41b4984296a68f0adaf2956fc813835ab0c8ad3127600fef60a20d900a1f13d34206af6d934b427f7af99928c01341b3f41355ff6fb145f46ead1171904899b912be63c9f055c8990cffbd7d87fa089d1a4547c21367eea427cfcbe7e466925f37e6856d4819f345d6ce3bfbab84039245d2e7fb3b816a965969f30922a6778589beb3e81c23561d4e8fe8f37f53d18792e65dadbdaaeddf7b88f293fb80e7fd8c061f1d45aa699b8c77286b1c01ea17639f05d2848672949561ae8b3ce2f9690e6322e9f52c9c1f65be9089c3fb917dbab59ca62b1865d307f3b1cc72a2ac77fc463c204a0468ac0cd0cc3a9b3fbe70fedf7f73bb53b0ee2afdba55ccce62d6be7168b346d45a3f621a99ddf9138d3c64039e05a32db8dac7cc88f8f67eda2e0c11bba1af3c399c15b07963ce52970513e3edaab39fc98d98c25c1c026ba68510bb27b302f3a964d4b13dc5adf75b7b197b38d8dc1ff9c6beab10a76594fda7ff7ecbdc68e64e77520098dc9f90d20b64010673c74b9c70072362447f9503a7da811f4c14d76db5de19534add66f9ca32cf46e3b25b75c2e9ea425a1cf7a5d389e306e5a04c9957b33b96052baf025a707e543a9faba0ee2e216e23992fa718abd3c2a0da73e1105e097479ed14fdde0e2079f2dc898a6387dd51555d9c998ad14b1be25d7f2cd68a7fc87491db0327198ece849c74b6fb38a091041141703be4f30093d50da2de76bf644aba6962637e9f2809436b6b2de252e995432c6c5227401688ceb546bcb7a318b284871ee62b872dadbab15b6fa281658d8e9eaa1a485ea8512062d76575433166b3245e07d7f379b77a249a5009664ba276b9cb9c9d9c5245706baf421f10ca29afdfa430c0d13322b73f30039e72cf0fd0ec30ad44d2be326b5c1ed70ffd9e42dd739cda96e9b4f385db4fd8b5366fcbbe19329a39cc3f4e6a3e63fc631f52b748935fe5a1ee44900ddf2fa1ed8ccfb2b037c21ea8a885e9b6e3e088f9cf5d76fcdc8b8efffa4ed1c172095569806ec70919a392efef0204753e5e5cd33029ec1c560f69acf7f3d1ab11035171c5e530501344cc164a34e0247be67127c8b23a8ddd2ef381e83ffdfe382881fc06534e5493f01f70a30485f98143c8c2896d206cab5c6d24b8e339a27f79e99d539928da131906db598238a530538e33fb7aca396799e259a4b0aefed757d521764164b424dc3e6ba87ba4d88319dbeb929051a5ef58ab0be540afbfc5d52054b4ed5a72cb6e2a75faafca9fbb5241dbdfcbb56a2f297fb9e21e7681a51719778d799bd5569dbb7cf5ffc837350faae9ea0ca7c02013ae112b30ec867fb0bc2ab757519d68355e0beb891628847e1699aa6bf9d6b6d9b4092015100f4ab90ff4a39e6b9259e068be410fc4015ab36790ec7c212f6484426de744d830068fc9515b6f59326effc61d755f41a0f7d39723986b60634a22d69d3beec5d1f77d6d66c4ef200b7d24c522940c00dbc49cfbeb7933683b9554489e3f18534102185780bd61dcc00acbae973dba250dab6df15ca7cfbe83340b3c61ffd8bad1d8098907106efd8b6336e656de14dd68dea42c6d08a9e2681b45f9668e5508cad0e9590eb834711fdadfc20c0bfc66f3ab4af0ddd88d15e2f46843df1611fdd8d80a944bb1526482fa6e43b419e1d5f556d8514dc71fe369a45325f26aba1ea0f2bbe062dea2d323282e2cb8dddbc73dd2fdb5c27abc4a11895ce67196c9fc8b9a073e9d337a1531e25fba9004c376d8342a46a937a097b1f667bac0018ddda4fb0a8ab3ee4473302f5070abbd81f18594b5e9ee1eb52ff01f2ce6497e9ad5e66bd4be1b4a84da70f9ba360cb1cecba22bbf9d3117e077b393efc24d6c98d68988065a21380cfc2129036938a9eef1f661f142c07b01bae82478c97308e97f9b6072868cf05b6f6a0a92b7bd05a3f458abf6d55fe9300ba2414a9d11f7b9a096ec7ce4e917622b9329340a9405f22c1ee6edee48bf645494103e6d41108af16221547e4b8044b5bbf17d7af5a6e762aafedfaa489ca9c55235374f1d6a47c5840c8a6a735056020674807446de38a695ebdf284d0865d77099a39b0ab75cbdf3618544d239a26fd3565d4e0010ae209c49904207acc2ce60e8279f6396c156edbbcc2dbfb4df0adcef80a2459e1e601bc2d968fc91c667f7b65bb535f639dff3fdef1c2729c798c0c4b6b37c698ce1649afc8a95d6f27d7909c9844730884c4beafcebf0e40cca3989aba26e9c3d01127918da065bd5eb39c4b4fe41f5e89955945f4da915eb4182db06b1c1ec6518cd1b4e69ad573ad623a44aeaaeca9d4708af7f0c8e9415a26dbfd74e07be90e25eec776c1fe5a7d0c35c02cd89e82f41105b7c2d1db5afa78e1e0c1a55e74db413e77bfa348c2876fd1c8056ead684188c4a8414b622f0e27fd00c306964106ce24c2c3848b42c4f362fddc2648145b1d0b63ed6157829673d75538b77171b4d3d29b2aca115dcd3947169383e8086b92124e172e2718acc80f9c7a5835cb529d0f2903c88362b9475366232202c191f909fcadc9eb79f19a207586948bb8bc342d811351196f1d122970b58a39388a62ead2fbd204999cb03a694aeac2edd907297b3a0be623d0b801a7e6ae7267ad5b5579ae01c9b29cf02b6213e56f7300a8199b047b0bfa9a3783e826fbabc55b24964af9839d1b86fd94b2bbe094d6b7e6f228081e684ab71465cf06404879e8d3758b4e748f32a7820c308663c347f65a4167aa00f005553a76c22af6794a1a6e324a8e0a4bdba5bb9a54121e4579c3feb347563d13e912b78a5eb2a522b2bca1cf6658225a80e3519b043b1028ffca0bef2ed6b2276340bfc12dcbe95f557180330fba6c97f8f57c98e3ab08fedcc83df59fd96fbe96b171ce52a195c715eb895d3accadaab459ed0d3f416d290f912ae07437ed0abba2b4189d35bbb980582bf8a6c45ff513b36f0ede6badd344e48e67aa1fb25861ab370b38b65775f3b413cd1ac29ae7a9a392e02a4cbb8ace48d97f276200c18ecce685d1e5c9ebcd6866ed0252fdf1116c453b08c8ba5b32351346308421446c16d8a847124fcb4996dca5004b755fbdc2dd2a323f3b61de4f18801ada69e180566b41ffcea02eb1e37d7fa35c869f98b6051b7ea21a594b9ea11970123b5b8697cf3a20a4150b6c7f50a8085e19d017c55fbb37d0b0645969a7fd8096780487c454f8ce0a082e76fcc550fef4df79d43d537cf024e72cf458e4ef7bb3e1574b9e12eeb1aebb2c42868492226e8fdec50774480d8313f4deabceda3265bf74664ca546a8a9b61eb00e780a4c876be629142c412755721a119a4a3d117f5d2c7bea0cf5057fa9169fe67b5d9601c833e1d3a5f4791087e963f820eba7b02d46df365d789d0abb27c9baaeeb1cb20c772c21ba7284ce274036aed8ca287b4090e2995494f372e887eb74ca3e04671bc641706e6212e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
