<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"19e75df20f05f1ef94c33b6bf2b314743fd3bfbba6c6e305c1b81a563fc318d472bd655f38e24be3fe7a0f7b8942180a8e33d02d65abe738125ea90a5e8091b4423880aa2a876aec93659eb3c3f6d64f3b71b76e2b8f6f44a824e2ff8ea8e9cb1099770e6829bd28006c9b834f4433de8480a74bb01e4bef72cf4d52e93a0d47e391fd94417e0f7cbe4e1168850108fd4599e4dc586a39d9dfc1566a23f4299875962f915e8af78e780c23f0814bc9811f59eb80c9e5e419c4e3c8a587921204605435e5e4cca2deef4fb59b181abebfebccec2ddb928ce160b427d0032ff73241a083a38848877db58076b1463fd496ce1f10f24c92db1498b8882350ad9d327915c0a5f6431669f6258e4443a4bd359a64a786e2d8b8e95afcdd54abad13e1a766cdf05950c49494e8e33629173eb5fbf928832caa92445df1d8a2af7af9b4c62f26619b03da8d2317f7644b7a4b1172cda4ef6073906110781da19f36d19e529beebe8f78441dbfac6f5f5d33a839afb376920540dc06963e21af083c7c617e102fd5141086e34187924c9a0bb91493a82a1e316d64343bc236d33a45f7f42039b7efd433fbbe15f9687f8a5945fb725d2a6a4b4db54aada07ba4a1a1593c1d02ce686e657a147aad36cac615ba531d48fb56373a3509da16f12ac33e5a75c6f7fb59b01ac9caf5f8fa9fc016a62608ffc1417a20868f8084939ce2fbbbf679976e63364219a1c43b6d22d95cf7cb2fad77085a4f137bedd082504d5fb8c8a6789320781444233955ada8676b95af11ae2ed26b3cef8e481afbe43b3d628b659f809438a8fe4123c1a6c8d9fa0f188d4737a3a960100c0535833fc36e24d06b597edb4183878f929b4e4afbdaee90c4cd7d7af23cc62483c30e98f401d10ebd6a79b4f977f950f915b00a92c3897edd49f2c93644f74d652800789ff45d5d9338e131ac1faa2b1c8423e6efb48930c66c1afd680461af194f752a40143ac1e653ccb32348080f2db6dc0e672497dcf998a4437714f6c14ffea52c07f3b39b5014416f62581e570eb0dde6ca47d00594c1c8a64ce3eaa317bec3852029fcc2e6a3a0905d1f769bcac8306d79038e892b6825830ba1200c18c602b500be419428d9709d78ac899a8922098c2228a03cbef1f517048f6dfde7a136cf16268da68c87f861ffc716b912dd8dd3ce499ca9610274dc66f55ef98f91a9682311f4240f47cb6dce3e6d3012206b7f0b05696bf7744399ceb5228326fff6be9ea82faa82155c2d5d842f21f3978bcea992cdf7f3666b3ced33eb1cf77bb5e99ca606f06501cfbd3f8ef588dd99d301bd70f6ba583f319a31d4a3054d31b22aaa8c860f319845c8b776aab3e805f989f5c1c9537b1efd84c30b9f13573c22556684f797f56b736f17227d3615b5ba8400847c649636173098902bbf5abb4e87d39d48b2db051ca14ec1dbc2fec89555ace5dff7a3e05cd5b5c031067ce94bf696fcbee19008697cd1b2c69aae0a7b983468c4cc912e7f389d69e9ea558c3e838879a0cbdb5140fbdcfd06b5770b2def9aa9b9e2ef5b6e15b5e5db77ab5d4082bafc3308f36bd9b87da4412f2c1349c6d17418e8e06024e9ca20e83b3049c496c969f1f8a5cdde3036a792685b45264871fcb3e7ecfb02342eef24a755ad69b2340bbf456a0f5100fad2b8186d1c1b05ee5988bd459c869a84fd70231c78f29f37adffe74eb70118b63f4ad797c4413e7811bd38964885a9a1de40b95f17533cebca5c44ad50f61486a92069c12deb7f6e85dea740058beb28fb2df90e9144dc0fa4d28c3cbc9b0692abfdbeeb618eb245e10ff107bba5394e6f9275867826a5cd95b11485b4822468ec051467d0203c9ca510062982c0ae671b6bc9c74ae39c858e88ec06c09b8a525417c98a38bcf2a682c9ebf15354c8e9bc32bced413b7568650520235054e0dff9b1e4d00b2e47291210a70144ae6260d8318abe8d22be5159f5914ff43d352d8819baa805917286cd8331f6039f5c7035185d8a3687d011d410f185a3c9622719bfb4ed31fd58d93bf9fd1eca7260ba08c6670007e75df179a43f2645450e72c20161462de96a22f54cdd4788c23ad06965c56e61a248dbeec630ec058e5c5f65eda0fbe9fa6d923297d12c59e21762dee2634a5ed09f9a4bd241d0c5c50c93e4e83aa5e6f460c3a9ee94717dfb12dcc171e33ecd9985e3ee253de6bd60b0597c15811644dbc074c62b2217e4cec5c51c3df28db987db5b9fc43f80dadb659d753e30e4466ab0e08a653c1ae0da1dbf75e2689df22985fc3c2dd998e52af3626b5132b4a08e5544312f2360198577883b54622a1a3c91b8d595745cf084a9c8bed10758b20fa50368e5459f66a7836a6528b05a31ab9e5b2c5b5f0dbe4fe4d49f253cd908c9aeb8a62dea58ff7902b02f6266691896b733cbe6dbcfa6a114f15e3bece88ec3ebb0c9ee36006b4f2e24fad0fe464f365983dab17a938b507647e8a3534ad7d13743869fdb93779abb73e1d2670eff161168514eed754c978dd51826000d820b207712285fce6c02ad28151463709bc7a114d4ad73bca7e299227af3a783948d356e76d591034efce152cd77ba38e401330df7f6bf6c16283231eba499987c793c4af60a8860b66900069e9c5e212110a49adc00bdc20dbff5b6792f4acea73c7a689742b19f57be899e05d05e5f028d73f61439e34f2b8cf320229db69278569582281715b33eda34e7ab7d4fb8ae79e68c39de0645f66ef03933659bbcb57a56953ef56c760b8f79d245aebddaf1fc617734fdc21e83950f259dd3ea8f3fc7afd47736afeabc549a6b3d0e2f88957af28db097f947f94739d1d34e22791bac07eaccd1b15d0bde085778d263dc8a3c686aff180890966d00f380daa65fe187acf3d3b4037470256e48287f2c6387e3b5ec9534d3d9ba8c262fd6dddf74fd4b892f3d6f753359d3234d1c9ed6cfea7267b2dac58bd3d459410efaa1d71f7272f431405ed6aa776575220240dba2c8c9232c2dcca531ee1f6588fca8baf4c8546a38a26fdc7f300bd2e1b41fb382469ee7d41daf4f054e6d4c48dce5b2be9983f0bebca2d70c15cfcdc3343015821828b54f63de9a2f3da78eba3be5259675f852c06a36f633986d9cca9cd94d7002d0bd433068ad9271ab822fc75fa50848576d89d84d1c68daf4284e3ff1f8c7a66ccf62c79535980b2e1c06c009cef98ec9244754668e3f97e8b57a46b0d8f9688804925d04d434de7f8dc06df6eb94e7a8d0a683694aa10b2f864203090550a179c1b20814d58e0975c05a67dfd7cfcb30c2126ffdf6bc7a35e0fce7b9429ddd65fdac9cc7d5f1a401bcd51223d6016bb85d83eed7709799111b39f1dd45cf05950adce43cc150d02a0a6a73914337d4ad9feff60cd5c233bd2f8933a7eddf47228739e097aad7c0d46c5003bddc48a4594c507a45359174f4cbac0be460fdf6e82a406c3094940f4212b1520bf68a9345e328cc4266b575b9e897f3c76421cf7416d748a1e5e0172ffa517fd3dc69634e81b246e72f54b556ff2e14df9117d0ecb31accdf7265b523e736a3df184d9a96323d91e8e8130b2090339c82bf4009dae4f9917adcd229774c2abaf0163dafb8db27d08403952968ebb467c01d5d6b916e4e0ed1848aa755c5729fde603709cc2444eccbaee818187f90f9b61c15e0f3e7ec32d7f3032741af34fe37f2679116f0095e0c3895d893c471a12b5e386f41a0595274ded9373e5cb12b5d65b1d82591051f13065bba5a5b6ca580edd47f31489742ce5b8899869a5d0485e1bb29b2e929720406712122c1579cd92f7fde7fb83e2a442e584501b5e70c9d5da327583db330815db07af246ff9bf9fc8c8f579687185fcc580940c0780b748a96a2b015cfd2cef0ed97299000120ce4de7493640365b549b3abc8857e707e3a63892e2e12b0c6330d074231dda1d464b303ac8db8a8325cc6a6ef6fb3717045ec64481343c7e55c82eba0f3ea6afaeb0bfe8cdd52a955c87a6beffc0841cf81d1a37c39e83c51797d3e6ca19c98825fd014d0dc53199322dff538b382fc7533e33c3746b2db34c2a8cc2f8a6fb1b8b380dbae4ebff054774942757c48f2b14e729f4df8be6881cd8d141a694173c6e9bd8fc197d0db6e2198e5727e2129c71df1624fb16f7d22537e85da0213cf0218c7aadd98de2894b12f9050f44d0403ca2b7f75622e45a1f8d3b5e7355626c26c1b32146d11fa6fb651a587e20981e89ab068c717c8e33556bb16d9e1bfaa9ef4c4ac7bda2139a98d9a0b36f6d6b6833c97b66be5e686d8bf25b2032c0b4c26948346df5adb10618b36b810853ec39f65cdc547666b4fe5a97923d814f3ad90939ff10c17fc95556920219f22fd3ae54eb5b381acc40049782bafebda3c1582590db0737ace7693e6ba6d138f598db805688c58a2130b3c1aae6b172d9fbacff1003839c9308a27552a1fb98202373135dc869fbf0fbaf5cc290f1657c62b919b4f80ae92155d54a58e9c3ee3184e582e1d7578ffa35de6f32735f373fa011a8d2750cc4168ac6f9948fb49342b8ecb0ef88cd9a8e03e7f0e008f5a23c5956d679aa2e320a07690176d59d13a4eb8503d71d61a8032c2df9f21447b6d17c3a715bc1aefa4f7faeb6a2a3f4d84b8a8355401fa1f0307116ad1b8f799ee6c0727ac11a509af5ddd06e086f46ded291830faa8f559df44c7bf53bf60b02946e6e42791864bb0fed109628d45642b4bb20412a94839306c4258203ae32f2e90da90c10b5967016a2176f14b01a7d8facb0d0f1cd97ad068b09b8e43f2e0ff8eea695f50db7ff1ef606c01c36cf2a06be613658a19062d83900b0e22cc0fdaca9702957d43c93e9b1c2959f9349b354ff3cdab195196d42f563469468c6c33c868bd8cde5efb3bfdcd709d662a855dbeb9c22747c940783683986fc4fd4fa0c7aab9426f09d0159eddb332776c942b30b1d985769d3082d76bafedecff45c8e2837801f0a5bc54d90a92b65e5193c46cbb6a06e819f8cf45f070b2aaa554712954aee9923ece1588496bf860efdd33388356a9128bb0b12b2b8c318cd25e0c9d059a83010314c52cd2649edcba488582cf93075e1cf923160f00fc65cb0442f93544d95539b473c00bfda76232b6d168c9da15b2ec7d12ef39038976e1483b773a6643d70fc2f3f56173ca112b0755ba80260a37c1e6f76edb952c222b5d77452509376b987385ab6079b981aa5cb4827a0faf0efd773f9fefbb181aa0b0772cd6c563e7155c2a95190d32eabe410ff37f1625fdb18fa9b23b3e08d3e2ed35f66e9aa7f012e1663dba59bc5f0bd007ba54b096f671b76c1d5435f76c4ca0f2c4267affd0145214cb3bcbe38e51704482bbee94ff389b8d7c77dcb06bb9065f2e70fb2cd293ef5a4a9a8b008571732e141647c867caf2456d0178607b225c1d13bb7d14ab56ebe7d1300cee11ceedc80a62f00c04531706b5d75fc4eab7cd4a7e76affa6239d7770edd9d424ef01b83a37c82ee1d0ce2a6a3aab911c07d25ab27f6bffe38e0a0fd29a1832a57e09334b1ff253ccfa4aaf5cf53517187fd4ba4f4055c47ba3559d67d7ff18787d7fd400609f3dcb7427adaf34ddc0e0ceb4b287f5625d30669e4a520b2c0f3175b3545127b803e0aeca673571609b8d2f9cfe9af2082fa162c9817e878f15667b8651623d24355f2d59820acc262f6ddeb9b6a6cea91802f686cb60885526342705ba140fb8aa03d4c23b9dedf8eb1d08bd1c669412d2df1f997f0c4fb3b1fa8c13205a29ccd22e9b5122baf334963c9371f9052e35ccf5213465d244ab3c866fe85a1d6ef6a9ebfe0bb3c68594f9f7cbfa543f18a023a236a8a883809707ed6dd5eb47d713c112ea08b34c79f55ffe2c18d747af3f029e71f7c1a02898a87e8c55f52d274d66a987be76c263acdcf52d31830399a33c063dca996b496306b9951d410d9fe4fc862a2836cd4241c5b2f190482451b637137b70418ca9411b8a88a6cabfdb65d467fca0dec9f5a53888e86617bc2f7ef66c263a6fb7bb0dbf14106ba4db8d24dd8ee8166cf78b22afdb676071b97ea8b2166feaa3b7a8bb9b06e46b42a261ccea67f31bae88c486b3bdf5114d0ced7b523da200b9be3914b4712f0e7b8d7c7b7f8c3338717f26e5cd69c5bf848e358563d14091c8d7f5c6755efd83e2d61923c6662bc9ec9dfc8b724c76af5e6784f5e0f035c2b39b188b3d7bf48f6ac43a15cc01bf4a2079a4400851e4aedb5cefb949875ce18cbd8e16ab530ce2467e99219cd0adfba646723e600722d606fa4d483da3ae7206eadc7b5e14b0742d2f98b0e49ed880f8f942850635ac00ef098caab1bfe9cca00f927fe61a4deb929ba50208f4a438f79d39cff8889debdc2654bda34f347aa9a25450bf68ca6287522910c9d0678b9975150c680aadaa05718f08334837aba355b28c54c02e02e106e18f710a5bb8e2aaffe56bddff1311255376683a88bdcd5919c1fc80fafcef6113b80372ee3b5be0a1b2e0635941e94787a3f9e70e8521035836b007bcc08ded79a6a315c645f05d0aac5bb7cebe976ea6fd4e8d50fc1679680582f14e79e8e66d04f999651323fce1b9582e79df20e77fc22811b3b779f935cf443acff4965b755dd1bc862ba1fa51caa1f3bf1325b9fe0265780edeb72748e5639f15d1533fbf11adffa9b5b1dd1c26ba0a5542338948c10c914eeba93bc72c87b1235c8ec055ac133921ce14e82c43e0184b16ac5c9f2392043958ca47245fc61aa6fe59bff24a8dd3e5bb687d83170554af0b39952764c96e1671e5e871d6cea176c010f369fdd26941be15f630e93e3ea1b3bdba0a33c7a6dfee25e28c3777bf37a065ae013053b511af1b69de433e55bbd3f4797eaa0a9d289092f92ec21b21c487bc6c6271ac739135f08e4fa7f1de3f2a361ea487c932f597cbed43ec288b928a6585482537c77fc365e1440075a234ad0dd3972460ab9c51a7bc64dc511d30832459c1046f3f718b1edd0e1194a68aa5f61e0ad3fd9f8b96946005738e9538caf460ebed9ed18a30537e87adc7993a0516ffa557e31c42b112fbca9498d5aa61d01fdfaa086d8195cc5b4736f7f53e048e2f7f46f3af26ef8f276cfc0b7d73d008bff29c0e22615a9e254de38b656ccc12697cccb65b586c6d911e96bc3db859aa0562be30681f383f7004de876e9c03aba10d069fec8e8dc55ca1e628371893b3b5c8f3e5d73d4a4a639f27bfbecf84686f979f0d67e0cc8c1029ed96c650da5d9adfa9bfbd6a32a96cc262ccf4d33090386ef53ea7b92c78e336c74f7d19f50ff20c8524b5e82261603bd69cc5a74bf4cc8ef612fde552703b9c8352bfa33bbb569c552699d2a73e28ad5c73e8d9903815a0e116d2c93d36a4990c5d84ab73d6a62110f5635df1055413d3eadd8d4179445c64bdd597e646030b3bc22468fbdf094ddf41062527d22d0fae55a3fa4181ecaff307dfc06ecea353bdd6cad9ce410feb1fce7362aee0c1fa60a71f6d47121acb2c95b32fb1927c5bbdcce8561cc09ac3d20a9e4eae653dd26b3b438a61500baac4b2c0e4e6648c1738678e4637af2d273260a06eba96e8cf55622403fc2f9f468d5f94f5c1224bd8f5b15810cdc27b40c9070ecae1cb80b66d1caffdef59248368eb22e59866b3cf9e21d80f9c8fe9b59dedcfbc5dceb5dd46c7602926f57073f82c1fd7dac227a15d7b2a30350d0954254c6783e9937f1ff1813e4407a2ef0396e00209012072025c7bd35f61ad49b1062df3d133f412f30b816ff2e820122598fe13d8c5bc924632ce84e712c2c8a19a23a65b85582285b9edfe8da2802c33c62d7a4fa628c6605059d31869f45c793da4ced3e712177defc90f8c2391d80274c28712bda27cfc11effa6c750abde791ffc9787c70a5ba1fe62800f176648cbab9365b94d1cc8d6f354f36fd899ab606232888497559f72a79656c2cdd7f4c277b124b056562f137937220f133c92b026a1a721bd89f0a9135af47d1b6cbe5d39e959ffc8a7d3ea029bed0f14650655a539706f7b489e45ed5351bc0b34ff30146d061afaddce6dc975259338f4e365f373564380484082f28d7f88fa45feadc0f24b76f01f3e109c12d79557b454e3f4109ab74b19658502a64a1fb708113df1903d3c86142275ef1ab0e53fcc9c8ba60c5b6f7c024286bb94451ab92b460f3e8404d51acb8c81a0a275feb9a61590ddc9720161e544f9f455eb5bff7c974736ef721adf937e91388bc16ca33fa6ebfd576c74dc17b1d731aad817ab1624f616991fee0623363bd73dcfb62b260d955a27629932d3451d3fa5ed99c75fe936b17891d7d821edffa16fbf3a7faa26b45d8aafd492dc487fa23b7cda8ae40379e528e4086edbac79bdea0be4a15c2dc2768ece1e4c1012c8a9e830bbbc2443e23b183335e5b5f77f85c7eb4cab9a9327ed07edb1e7bce18a86cef87247ebc3598d58d3d7b6583dc390a520fca922f109459c00d56ae010f5fa0e0e0978bdb8cff78aaaa7a0b3b995d29f95353f2501a08e656f843fd8dc74af52a80a54208f0a7438fc3ef2c47a298025ea3be2b719353503243cd6b665e669db890fb9aad743f6d2f81aa61b98a70afdd35c8c93dae98451b8dda745840d4544a65fac464123b071e1538eef30e917c74b8e0da50b61afffd00298c4d006ec0929194e8158d5e5918097ff47994fd4774c4310022f9016c5544798a134f98e53bee4386b964ceeebedf340eee98c843a1f785425ae042449c2efa0b8eca37b7497393b15a19915af6b28d83ef0e2563d8fd9f699787bfa3c68fa122463b471227a9a3a9eb235a944090df75f59a63ca2861f3ffa8471033951781350cb37d85eaa380a40f24e4d7b180b0d571cb49620bb6fd0c854959c2d6fecf1ca2962f0007fe08fd48f5f5609f2ebedc7ab8aff76ee374b3266b5fc831c68d9ab8e63b5cb761d4a83f4d8929e26f47be75c9b2226abbd303a5608752d7e073e7a727fccb68ecf0fa00f3de87a73185b81d1e2eea3f8d4aeb269f0dd39a53d7a85b391e1d8f55b3d46f125c1b2cc51b4e4a7f351272312a94a841eaa36b6b5a2315957c0bbd4f948f6e4f4e480390529e49545afb09af298f075c417c53537b16fbeda5a5cdeeb3463dc3fc2294ce2f3de378500d89259c41a85efbc2539a8c18ca2916376c9f97f4c9293abe821096d366d704dc0149b7f1564edaabe3edf3a367e73df92dca4cbe1866dee3dcf7a13688b92e32af56c3fbcd965169f7731a4aae9a551ea64bf765c5029ed7517c28bfec691014bea6526ea4374f9175431dbb6f811487415d060ffccfe8d1bc2422d81fa45fa11afee2158bcacae2c17ff5f492743afe798c51801a8550851b0fa3fc5616a4964d7d4611cc75c631bdb3596c98d4d104e44a0c44e4c757a3bef24a2ae34f0db5f9f3cbe1e64b7cfd1a40eff4ba49d0b43a60959e59e8a59657b0ed2232fbb04fd7de751681b834b48dd6e3ff10dbfad7e804e9382f50925b661cd4ef752cbf55f9ebea055871860342ea39d75aec81a7ef133d0bde8275f1337c57d54b7dfd6e54f956ef7106a2df8faf93b9e6bd2e65a059f8e288eeb83c3c0899e4341f9863e8f966c656c4c65a3214362b835a8ee65faaad1a73289e3b6eeefa7c932d22ad20c97954ac5601880c54c1f9ac6c292c01ca38ec300c491ddff1f90bd85c82fb814bb8445db91a2582c000d0bb150dde093a8079c7be52a1c4eb53021216a552df965846d196fbef8baf9effbe3daf4b68cb8a8b9155716d0b5c5440897416d2fab310e16997d3e08c370d6c1a826efa7186ed6ac1a1f5e3bb8028dd999efaf134c9cc950dbf3a2a0ccdd14180c1f24111c762577872f8b229eb7967df485658ac92ad7cc10c91e14ca38e4f13b9c84c682cee310ecc7afa3716e92d46aae763f374b3c06d82be3195b861227b88e4cff635c86238c4f45bcf091da0f71d584f2f43004b7115fdbb53c679575666d52a0e9dca241126cb4e5a2788247d4b5066aa5ad91225bc640868820e1492b99e41b7235d897601eb0cf43a9c66f73e627acbe86c45e0e8779e0fef8fe9e428f85f9e7708f1f9e4133b241f5c82cb41f7c8a9977f62426938fcfe092e58e54e5f1e00b8fd65a9c737b0f214a0ee8630078e18b3217e2399274ce546fce13c52d7527b462a7603fd9d1bb66008c896bd86823ecf2dc34d38204516f2d1424a75bb975406c1294ee1e57d7fc2839377092ecf4a0c6a443fe06f1085920868c15a5230f427b7dead13ac31cce93ee80d952d7746b2810a021a550a967996df96b48800a1620acbc9e3df0d3f7e124f82d72e1f4a2367feadd7d8ce2ffdeab8df814cad8adcfc6ca7f73900481249eae2cbb591ac0552f501c1aef01714ec45ae6324336c7b781df3c03ef7f6627ba3b98e2fb7f52c0d592535b9226d9afe0127e28a88e8b5467aad72ced83c67f67bebab6a25dab667984b4f85e5920083085f9f9a481f8e0c09dddd3cdf900e35355c9b9979aa60d1bdf52923f45fe13a53edf99f00b926ab6ecf01c8b65482e98960bf437d53d924d5f5d4d10a340742f891258a86373870a0394d6968bc5f92a71617e7f7bca18d3ef18e1051a827a8c853920d9767758762bf61fb2f331909e9f3c1334dd77ce04ae94bbd4c8c0a454021bb717ffe55eb1efd0c58585e477ad9180a484a19a3b36911e08cc8203d40db15bc6e04935f47be85c00e563d798db6efc0b932fdc204336aba367444be6602c2402a9fb785adf8d1ba6bcc096cb9a6a49ae599ed947037781df58a3f3bac8be492ad8630f1f25c705e9fa51ce206a7a0b60680d28bea599a94a7d061bad6413adaa7279ddd09eda6c3a046e10e0d7037a0f257e7805f7f66bdaf0065c998a7fcafa53ef80439102224f969eb4dd218810b37cee25b647ea83e668ec955ef798c7d05326727aaa0bbfee3a698704d66bb89abfdcdd2a9d9f255955f401fbddfcf451069a18699223af9484e06809a4d831a2baf5d9ab410e0f8539701555d80346a66490e642461edd405cca86f4ab73192969e1cacfae8fa8fc9cb3cae9b5378b4bf6558764138c23c76bc89b26961eb7b4e8805ab66b28cac15f149b634d9c2c8564ef40e9701122b9f735a3e1045d25f589ba9147e96aaddf4235304f0431c99889f589ab6543ae22208a647558bcf3f699466d6f0ccb2e48f0e3df9780a4055b9ea70d47739214d06f512beaeaee1da1117a4fa29351e834bd7b3e66a35e074f273d70176eb5ddc25b671ffbdd664f2d48facab5ca05928b77c0fe1c3d4dd38ea3844dcf98e834de7058a66101cd46d1720b284d5b69d3ed4c855076d37c3112279d47f8b12060cbf9cc98624c4e2fc52b13fc481795cf3107f7914ee3d2628e6bb603c5b5f6915e90c1b06b3c5613358ab694475a3f4ca9aa571365ec3a40bbcdcd5475ac4f92a4d83af9f81173e0284b1e0f044942aa743bb5eb4d3ce4f6cfdfa0973d6b07a9696fdcabc4f4d4e0337284f76b29540edd92152b7297e14422022faddb66a66cf3d35994857e59cf1175f0859e5abe3741d8310d79e052c70929bb4c5796b0e158a6f9a015d176a8ce9af1f87529c25c35a5a64241d8dfa82f6facb4bc6b8a147f28eca920f66aa2819cb94ff0089cd63b0dafeb6be2a1fc70765748c28e30176fa7acfae5ec952e7d9f0ee32b37f07768bafbcb25b252832270849537aa4417daa401443c6e046247ff1557a0dfcad450b6151651bda7507068d6ec52edfe660fc1c3c81682805be9dc01037743d04ab7c401a0b51f5c95d6e63575236140189985fc867c1ac79f6b9e426851081668ffa33d77f60f6526f5620c9648ff40fd0ceb30c94fcd048e8a8876b7cc7d23fd585c4b3861532fd89bf386e3753c87e70d217db4817a61976ec4bd5b5d1baebc981c467da1020ca2319821d891f44095da3144752fb495547938717711f8a21150f1bd78a612ab1c6c903bdadfa029239c4229c1d549c8d3c732f1d0aaec3561799e70d2b1e1c30d0b47b310154b94d4d4ea6ee6ac7a493b76d7c90d03528524147df196a8381e3f8459fdf1ab0a14266dd8e4ec440bfb90f0d441f71fc0cf599cd0d0c5b73b28faf74200b77ca638d22bf43e11c51e4bb87489445f5777eb0de42c6e7a5c17bcc8b83643ed193f446051b301ab75aae3fbaa47f33b5ff6e1ecce3465084966a9b89ddf3d9a670c5e59f78b6266b03cda561ee6c0769d6fedb96a874e0419e3c1d8d9ebf8ed225002f77c14776ef8992d630a42128bdd1e0c76798cc47dc0193f20b6482963b07bbae74e17a2cf875e6bca84ce80604d0873fe1753227b45d3c6a52d4b983218e0d5d8c550d8c67f263630e1de0783df83ff2ba8189c55d898e3398c51c65d74867fdb9c1561ed9b97530a7d0bd4309083cdfbef0ccb0e187460e8ee38358096cd13a3df345b1dbce6d432c748c53b7e7a460fc428ca74ce9fceba5e4673dcb37bfbf634de3acb16335c296ec7bf645afe60000d2d925e92da009c336aed20520f0aa6a18cb090fb2d1a5d6ee4585d74e73743b3ab148adff0061111a6377f19938623277ebd72c02a96dd3713784e10e71fe016e9c9ebdec93fbcc917ec35ce280bf7f63f5a23bb83a5c8b9a3c50d161affe14a40b45fd6b8139d5704d92a3cb69ab2b7faf83ed97fc44d2494b2d3ba46dc37a91f1903a91d937eee7124cde87a2ad219f4413ce36fd7928742a969da0f6bb9b28c61d0db8809c444e7f1926425f9b04a5702e8448e1e9e716b9be5430705ca393c6f00b77528fa8b08f3fbded1d8c56e52669fb0af7a6e2de6ca18a1349647ab2e5cb231832d9b71cbdba5bb79aa77cd1f46d276ec3b041ce5e7bf33f7bad505165a507af3e31a4c383bbd7037059085801c8cfc8c2085a1cba91efdcd35137be54293d283e804d1bd253fb79f7570fe65a332fb05229a74babc4f244edbcaada12e4b8405831a88d0f554086adaff972c219cd7916867b4733fb8f100d224e839ebb26e6b68b152d43e47aa1eb37ebf245fa9c846a6e396370d1e97d6d54db027f4f3b74a2858bab8e8e97ebc2c9d47ea0a7f2002c2f7f688f5ffe162dd8aeed492722a93c6798172deeafdca449bdf3407b42f6faaa5666c34d2a8131e01cdd17088a14ac3c6f366d32d81ae2aa89f168a965f1fdefee18f44dd6c40aafb03c3fae9e4ad58fdb70245d8d817dd615668e119f12de244c2f0b7716822f36e99144fe6ccc8ce4d9bca944a056a3dec2c960ac247e0992a1e2652150461d83c4ead54e63d26537d9a1fe36a2abdfccd76007d6d2e23018949cface93b9b7178b38cf35c582ab9b60fa21c4d981387e928d76002d345af47f3802d0bbe5dcdc971f2cd63301c16978fb989b7493ec7f7e83a7fb193bb6e6d60ce62790f9884267264b95905d77b90876ba8658d8eb8ee41ac99d3b295fdbe85cc67ac3853bb2c026b2b2bc168ea1d726c62ddc1cdd5942f1d86b567b5f6e094e7ec1d7bb76c1f8aa12493514cdc70f42b3cfbef6e5fa0edc7fe51d772bbf207aebba26dd62bf6a0fad7921935b3a48520596a73b85476cc98c95d4e2bf5439c61b2ad09848919611739bd123820fc4f8c54a38028bfaaed6d9af61ca538c19d535ac1eba830578d19b4860640e48452b97daca3d6210cb94cd9067e144512c0ec85514560f68050e1310826d3f0c1471aa1a6d99b33d3c1dac6a76169320e13975b39f4533249c3f8641a712bc53a5dc09f591073ca9ac9d006d28e33ba4c34dd4cb9094cb5615b588c63ef22479ca7c1ef687f1f5cfaf9c2d77f7277b9835fe580686f58e510dabb953f353b7874ae24ee871e2845ba30d13fcf438cd1728caa083bcc7cfe35aef8c4760807c449959b3e86aa4bb95f81a5373e603d2a2e4c4862b8266dfa1437403f6a7b351b4d84c310fa800f31ff98b6bc8288d5c39b5c9bb8fb02370fa86baa87bee5f0b9969063e1073c9ec6a78efc31a99a3fb115a34b05461d453f26d6f766f728328f5af2bcc030cf310fbb007036df28417e0dda41c02b472892213a675c4d0dba0fc6a0f17bded1566e0c1641cc17172ba2a8126b6dd3f830af5c19402d50afdb16aeab343f61629ec215d3f5174fc4215b6a7b11dbc59ff21ef2812c9db395e729c72dbdc12546a4974a675eabbe3fb33db635df0c6c6df8d90dce3892b0dd202e5b197a80f67d9227899fe344ebd888cd1ef428b9df1ee704ecb74d9ac3fefe8110c2fa802d64dc4da46591ba05223f83dcdc08e85de1ab406794a4bb505db1ba27a708b60fe237c7cfbcf8f942d3e6d81ce48b1e5d3c5b4b982c0a44824bdf07ee0f67184b459f3a0e2174bffa171b79d6a126fc2a7904b61a485179bf3a319fd26f8532df088b027888a4e8956ed0bb320b1a878d4831985c8c4bf9c29bd6725e175bb049b6e5691fa0607e72d8d0bd76817c075d7432691174b37c7bf1df7a1b6627281bf71592aa381f29997eedc88b9c4fd616b762abbe0b5bf1009cfa52f5d356430db6999df2a00aead1d258c67d45e98c854d57ed01294b29910bd7566e4823a0cc3673bdb6f164ca960cfac39686da50e8ad3daa4a404930391b4dacaba3a5cecb563c5e38fbfdb747c284838e7c29cc370375440397bcc00cd55b4dbb060fd74f45fcfb219cfd4f6788c44b682c83f176d43c938163790c7bfe8f00c68afc5d910f5b2b65f31f27b89c75ff681bde159b6340f01e03f786f9fc397fa5b181bb736db3ee89159068da5b691e79fc666bf699bd2751c4efa5efd817ccc96037910dc590d5a5ed06d89122db31dcf8f4c534e7e6d0aebc7b82eeafdc710ae30e0375117b8b4dd3cbf1243b4f5b03249102874e7e149255f270e00bdab25e828eb811f4807a8e5eedad96374c02e2e0c34ab27cd78f72974c1ea7bc036f777cc6c4215c6921a5b02863a41fcf7bd7e0954323c68da4ffb98c8306126051265140651c891c1b40308c2ba1755d846ab02f29e869bb6e51a5d80706366fefa365875935525acf8676ff039ee8854da125507e6b0a61f40a926ba567e87dd6b446e00c59800dc6bc9e93d5828a40e64372780a89a63e773d9bbda03bc4c854b2c73015c6943691e025d41a5b852b4f868d907f9a9e2d50e59d8a22097aa689de5fdefebda62362660eb5342015b520d24cfc74494fb16f594bfb8795b6959c4c61381710b220b75d12c982711c67502792318ef658c5d101651713c13f000a8e5b444005c16c5fbd292842d603f7d970977ffb4554605f6f69f6e9beaacff015ec2bebc9fb010598e471722ebef9e8914f9312f503faaf807a2266a87f1885f2a5116694c4b1ac060129c84c9cb94d6c61f494147a7c72315d0fb1a114824d89f97bd6c321f1b0c5ca50a9de3844a4434a9585df93c7c40885787cf4894a1e852ef728236072d394f030b6867f624dc61207eeb55441f684bf0490cda901ebfff9f9d7d1189556c1d2034de81fb359e8921c2242a06b6ecf99d1a5bde30d0117c66e672da57bfc7def6fbb17e9bff4b363532b1057f04a3d4a526e3198c3cd4db024f67cebd124156b4caa1d49936f944831be7a8b2e4799bb7f037aa955156a3626657c80500673c47966f9ae9bb60b4433d09b66a963343c4905744cef6cad7a5f190739f48bbd99708d9b0758518a8f742c9e29ed39d19ae9305740ba59ede05a23358512237e860de5896efba76f6393111640f022e44d4590950b59cf1ec63cbb2bfcb14ac88911bc589ea94956d153a4976a23d2920c9e9e919a94b64b49ad61248a3aee1bdfc3ed8ff62b971dd5c6bf1b162eeeb8bdc982e96c05c3790eb1d918ae75db7f34dc4a6e69c34a0978313e70c3e3a6db8232a4757f3fc61e6b3f8d66ccc6a2b884075f9b7fa677b30d08ce02ed152f2553a15a5c02454a434cf11f77bfcc58e4770b1efb8cc6fe232a92ce2dc707782da2e4cc24cfc05ea525a31192aa711ee22b3886ed94adb8b2046f330f4bc0f46f44908404d92d791a1a49789102abee92d3a171dbce04ec1106abae9c4e2aa80d7ed081475da6762f78b816e3d20bb070c79f772707363f813c23ef3bed75eb25a9a928e7b167fc2700a6f1170e14923292a65591bc8ecb68499e8d4ce86211973b662af43374626ce4ad0ad3a25315e6171817f3cd0951a044c4f322940b01242f62832ba9698c62e5648c94c9fb55b85366030c0d15ec0adc363cc2c6699e757404e2be66575540793a6d7adf8474a97a5a9bca3a75994e72974cc25eb297c53fbbd868b6f363f4b121bb14aa2d15d61a20e871cc5a86136544584db48e74b1c4237afdaab394b1d683736a191dd63a787d82a900c2e73502b5493939c8e08eaf7ca4cc829916694d68a88fac4a997839b19071a7d722cf2af247d411265874f6710bf5f2f76d6f5fac2d59e7911e1af646025edd1d4b10b2b40ca31d3df7cf33450bdc7cee6b54919d2347c454146cbf05f42002bca7cc8ba858b51fa5af882465c962a0e155ba33fe17b66a7d5b36b6a7ef6492bca6205d44f72f6537318456c0513e9ae985f201cf2550e40b5bba1d7def9f2487e35772dcdc850463083359d300382ec1567a4569d30f38253a7cb3eeec515329a41b6cbccc2466c615a0c3ed5cacbf4fbebcb5ee7f47b197df721bebc6f4ab953386ea6a8649404fc4dd7bb4993b8c5ad6219fd3d2a106d09c5c6d2f7bb5551575b7abdcf299d9129df402b23d58ac7bff43f29aad0e24ba5cd93f86f4c0c89efabecd232142d74b7fb487abcb959e359ee0dca613d0dd0a6292fa29d61f4804b291f717770b8240ca3ddeb460c6289c8ac444d50d8ea3302d4fb1c34971c769612ee1dc3995f85fb2aab447a42ea2e0cafc45213fcf61930de1615c041922a65a0a146f3089862a4641589f1ec75f6ac14ecd25b87082a1b4d2376f25cbcd020a4e2692c82a439b376360a2e906491729bbfb8ef95b1745a55dae2bd7fcf907ea81035a72b42a11699883494c3ed14ff61da090c9b992abb39135758e20d8bb6ff698ce3f1897eb9b4c58e135e8026aed6e58d8059d3ceba4617a5e59291774d3d5330864cb326c13b4851598c22514de8be2efe265aa3b1e8fa6eebcaa86050b3a56b8816b0d9736cecc4d5ada43ff99293e8406694133056847e3fe541108b5fe4398f919e02f373987606cd36fa88d92a4e8313d7aa5b9957676b73973281a5dcf40df79e6eb044776a6a7bb9b2225359b5c0c6058699baef77455a4b9b5bdb4c6f5b3080ec55a69c8e5e9668d1ee1954f137111854f60afb740553308bb99286a3dfd70a0184c5b4e4871c3a53917e9698d4030ca9140f01060a8d40deddc97ce6a28f2d5af8c9e2f39cd2bc3908c34b93d5ee7d9c675243b2dd0e8af28a688063267a5e7bcf8e50aa9d75d72c9fab95b238a20808afc1a32340b8ad2d28bb25a9e32cf45315d730db4bab769f88bf5788eb1c4e153a8dd21907e1c924ccaf46bfaed7ba1ecd8a30e75aa5800adf379da87b4ca02cdfdf98f2590f49e3f560be68fb8056f4b97af024b58266be38cac2f4f82cfdbbc022149ffe834fddda7d7da0dd1183c9eb344bb1bc0b5e2e3a874c02a22fff5986f1a06e8f3828de3e5e727e61adee15dac7bf01aa0b2bc070e839ccb821872f2de5b8ffa9f032f2da7330d841e8e74c1942e2e65da21b4bb76536dfee1c4e9e6df4525f60ad3bc842a980949c5b4583c3bae68a05dfbfe161b318148ce1a8f9d90a3062a89bde46c09cda2253126b6d2433db5267e08cef951fef73a83c626425c313846f5af3fa635df066a70","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
