<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"485cb634b02f6420df92c712ad47a1f31af52d29880e1641cc95c09987d41b885fb1366dde05966b248796acd8a6a908af7186a23232b35f6b90d2db3861aed87d041d7e4efda657af109a06d688406dc6ceda28bce118bd58350faedff684a6806e1bf7c09e83bd87f944bd5694d94db7a7ebf35a063fdd4de1aac51dabfbfffe845d72e47e9cb0f2fb713fe614213cdcdcef341386a75af44649a2a9c7051fc7ca9c316eff5ca3399bdf409ffd48024661809672c996c339a92bf4946a875c7a51ca650a61c795cf56f31fca27c686921bf7e738bd621f1655df8b72d4bf14c7778b970445e6ad8488612db63bbdfc645c1f6c73f8e2b9db213b52901132602666e17ad3b105aad7337195e166a57bf93173dc5d04e418e197a87135de1519f3de47bdb2ede55440d2edefa695891e3e61c76cd2840006bca5f8b81c8419cc3200a772295da616eba1d991f3ac8ad06b777b359b97c712848d36f0179146dcdf0cd7dfe51ecdc7fddb1d33286b1ae9ec3505772493a9c9d090bf3d8f3a489cf5fd19c5c7b601977e8174e8f409d5ed7679a258918669adbfb887bf61cba900734fb0004914de4aaf4f36abbd437820ec88b70b9901ca7d95ddf5bc8213d3a7cfa6f6696b645509282080a0f132a290307d58fd534caaa6492bb42cce4bd601da856530c6b1665cc112320aef56994c593a30146510245186f37f4d0f0cb09bf98b6bd65cad902484876e895cdf9d1f1976f4ee77e473e69bbe2b190cfb21db1b852d0d8fb5138e004f190a1e3dbb9ce594b23655992805de764b9001e85d48175020bb871bfdecd964da63d44fc5ef1648fbd85fb8eb1089b38f443215ffef8fcc3c84d62c3e1fbbc994c574e554d1c2760b97a218bc2dbbae52dc3e2af7e35389655ddd9fd05af14a5f492121d1db1d98105047dd666e69f84bf101b9a2ce1267e290ffc5271e6941c68928c98371357d63846390d0ec8cd98bf84adec960cde6329589027a2a5d9f06a91d279ec89c85d7086505f0a10ad586b22bddc5df1b320b856974d24d00e3f527387a834ed8a1ea41033c6991ab134f7f352fbe65ff965704aa6f2ae0fa590525cf334e5abe54d5aa162e6ca1e857854ea0d7ac6bd83f7076069e549b5d3a30e926999ef1a07db0d3ae2a5313399a37d67d6ec7afd895cd791bac45d4d27d6ac8bbd6467733f15cbe9e51f0710b125f650216524448530533d71ded4066f8002bf0f33cf934fd195ffd62f97352f2d045bc550ecb1a713f8b02d23e82f873df812bcccf4753ac51832a3d01c4947fa314711eeb8b2cd4769285ba37197189c24831af569cea8980aada2a5f421b3ba6dba32f5de634b599a8e002d984c68c2e0a02b0f09b6de81bf106ebff0ea70e3aa9a41195993f8b8e543d40781588a6d838aae8dc8df0413cb786af606bec0488a390578dd8aa2bb254ee8f05ad657301e817f5673f9e481a342019afd9de8877169abc53b9b09ec87d21ad9fe106b1b2ea4172759e7ec9a9cc7552bf5b296e3d4c7e29973da2518878f66113f2edbfeef562aa2ae2c6548fd8aafe1c8e54dfcadb65ecc56e9af481b9fda6b71dbc3c80f52866be6d7bfeec93b92dc87606a283893447950c698def4667d8307967f042a9b284c252573722a8813f66fb970c7d74876493aafe39b210d553c1fe58e05802166b795d0b35529e25b9561a332a257f8f6df18736596cdad7aecd9e5c2304a46922bedc3f15f92d74471d128a8d0b21576a35c3e51a42c0c8470fc39ccd49d1d9583f4e773084c83eb70e0bb32f8f1bfad8de9eb252df0fc3e10d6b476e2da5a9f8660dee6c019be00c475c6d703e5db2ff029a678f18ab37b866f5bffd580bd38590622d81f4c8ba8e4e93d34a3fb4780df06d2d78cb6860d4473a6dbed21801ed58cb538606d90359b442406046f85125ebc5cfbaeffa1faa69ac6113f5833ffb900e2c4823311c041f54d49b4252744d64b86effb779f0ae41ce5f702fc6c49fc7edeca2b85768ea3e4bcb0c9242cf4980467c4b97e1360f01b2c8b0a20e73133f00c625613dd586b0a726ce0add1d049c54bb7deb9bc12a530e75ca3b708e693d790e320a12f0be51155a1ffbca774db1f5956bc87bce3aeaf733e3ef0921207288d9d7a7d2a68a69a89333df43fbf943fc8462c9f8501a586dee7db89042e41ebf725e416d9fb7848486cf6d53b0de3e7e2335f7c280022cd505ee884b07f9c569c38466c7c3de4864b9dd9494d4edb88ae1e81f3b9a4a01f0b7419e4a1ee395b492619ef431577d5a555eab92a001c8e079978da32077e23fead3d4f45fbed48d3583a602b5deff0ff14ee66b93d26652dc08f4a353322a944184beed765ef764387d5b4fa78b4e270b6681a3416d85681fd947c73039c81bb3d63b70116c9f100417aadfcbbcaa77db2e30b972c891c8b0fc99da6d3ba8a4e8f9fbd5d693f4a2ca4070e17acb1b5f9fcb0111bed8d4c3e70e5ac7b125834b1ad6e8ecb4c500e32462071805c049661329b75cc10a3ee184d292ac09672120a8305195fc874091a795cdf8e801976ff77066154a98bd0411973c4b4381009965a641d012d9a7fdf4ad5bc8fd6d362682f2f7c97ae2fa3d2249c620f71d6839cfd3876f582fc36ef64c1ef71f8b35561cb00a3c5604bed82e0b6c2f2fa5e2f6609d0ebc708e7f2b1c36a42aa5819f0313a9df0538cc01544d851c49f623f49591452e43233cf34e32507fe5eec20f9d1e01c8969e810077f047a70a77345e3116428b20e944ba37c59c0e4ff6437fe340cca8d76b15a5d96bc9e711d6075fde4f14ed938a90e3d4d1c15f216aceddca2f0d7a180bba0e28c3c7e91124a750a3c9b04642e2a126b838c3051a5a84e6ab23254273c187c5e8954657b26cd0b6dd18d1de41b754b605a3f3caaf402579ae3d38d1aaba71e93ff51e81ba190f422f4e8a1daa779785e8aeb71c92baed65cd17251c20702e4d27fee966eae8dc9afbfeda16f25a7c793465662a85c2a48282c385b3e2bf956e0e8626d4b600f4de6744f4573035a10c4d66b44ca343faaf0eb6f7fc7dcbe73df34702ca7840f9f7d88aa18be72c7762a6013baa1ba82be7f5cc8cd027b81f7e514670a51b6271526d9ad614026a21c522fe3ce5852c17c411ce3b58d187ff511cee7c50914e331ef218de65692c81f09020006a9e494ad509639a604247e68c11d108a681212b1071226f861769297b102090b31d56bd0b8a166e1d10d5a50cef4652c511d31fca7670b7dbc3aac1b2fb695d2b1bf5e5fc292e72069f84bcd2fd73f33d4ae92c78c7c164ad9484f5c5585c56b1766445cf0211b0cebfab0a0df5abf7ff317e00562e6b9ba942f109b95af09190a04c9e71601f11b9b15f408579ced4bb17d3aabf29ce7030a1b08a367b1adb83cebf5cf068021110d957a8802b1d155476d5b8c4f9f38aa23513b064354b9149f759388bf8c1e64331fe9cdb32724743bed10c12da8833bff1b15791b793c063c3cd4f2c6b6ccd6ceff6bdb1d98c3479d0505115096cf6398b8a8f827d009b390ef5791d0416dbb6c3843cba4ac339e987a77e808f1c4deaae4801b15e75ff41a7c0040bd18b90ea40ed18aa9cf2a1a2ca046f6e8cd3de6f0755a56b9ee5c085005b99cb5b35fd544da937da6b7825ac1681a5f447ec68260e0aa7df6331365d377554e4d05af9ebb254b3f917e05ae498ae3abdd93e1a67a005061e7d3d6b9f11fb3cdc1e0f962ae3f46b5925168a6835ae96a7ac298e243468e30ea5e7da0bcae73de99bc80fdfb0f908440fc082bf3dc7e27f3e9c787b8bac59c1093e6877bed5ba157afa57c038f6da02195303fe7d428bd016eef7903dae74b71e17916262a36109199b7ed80092fc19cae75f4b7d155af107d00d689ef2b896be5616baddf62806553bbf9f51502d25b14854393d1ec9b7d1ca1e0a02d5b4080e76096f67a6dff10bcac2c79fc3633ae451d08416a3739473fc2dbc2b433aa075072c615f4f63978f72fb07ccd475e761fa66ef6e3119660a256f8f85ab8ccd4a8e79fdc9fd321e8ee9a34e405010682ad356c7ddda5040b647314919d9a63b8b7e1f44ae002c4760170f5d9ce498da47de37ed3ba84e01bd929a10638f574756541681b197189721ce245e49e13f7b833bfb34cb56d0214a29b9d64ad2e72c1d649f7b89ae7cc302216137a1b37ed3f1008e21d3ca8ee20f51599f8c928c0e2f6b3033b1560d056f4157c9dba6ba933b437cbb8aaa28228b11ddeb4ed88097b7c7dd5edbbf8a21629a132b48d2a8e012e110f6fbf10c26ee25da09cf59f988bd41d752b5f342656f944df637fa549411e85f5a4139d502ef982c905549da0255bde61f803e54d09ac221509dcf28e6e9d8136b78c456a5f29c82b90af839511f8f52cda728858c8af1c5ac80a683224c026da592ba80775b3a13c7bbfbd51b72bf48f873ee43c79215b63aaa7c1ae271dcd4775426131593ca41be73849207ee058c93d85b7b2f9bc9b24e69d8600581401990158f15319293e8695f662e0f6a8720b707f6ca4e8d7f668b3ee15c731ed08b7d962bdd2b9d4a91dd5fd78da4ec133bd5e3a637801c5e01aedf93f6b136c2c34124e39298a832e725c344c5c55d229c63aaeb8045048bb319da9ee899527dc427cceee73cdc0726628cf0fd11163c6c6b80681a5fb83fafeb3ef5e64b60d77f47e7c0f65bedd335054de08d7181bcd37fc2fc75b3eaf71401c3361d7756d864162bad90a598df5e4e2ed2b52da565625028aea9ff7b5f01afd8af2248e8d35ce18436757254ae38bafcdcf74e25ab228660a56b9a8f519441d9167bffd9a236f8a7c2a51bf6e9382b8d77eabd0c2750eeefd6200890e5ff8596040cf532325b79005af1e5ae7523b53bf4d614f742130e1c6c69f5e4ddbaa5e78e137c5c3832516bf308f7b496f802beb66cfd9d034cbe5f098a58683b6e8a6cb3f0b6ee7e3ddb05c353303bbac40cef14c7b12101a56b595e40f88f31116e73ef9e75a3b550bfeab2cf5eca7e330e91dca948bf2f4243a32fd16a32f0271a31c404fe82bcf345e5cb6e6c8623150dd59277f400bb17ca5c551e5707dc7c72d60722ca1d24a32a59eabfa16b98a263cf85da1bd2936324dc5dacf859d4911a7cade077588341768f6f515c152c3bea4ebe9a7662035f104439ae42dfb8f4ba184e062541e1ee352a8d768bff4dffc976265d828742afa15a329377a67ca993cfd50f2f250fa9c0eac5da5960ec0c8cd33a5807c29cde277142d4d00a0396feb467b2c708b44935c76369cc2a785fbdac44f59e6dc6114da33a719742f7f8350aa8185e745a14a64f93a8961bc547f3dcedc7964c66d6e5efc33c70f680a48b9a7549dcd272eaa809ac20c94a51f6c9e69c3861bef21d8f0afe976de0214e974f178e3dac23caac559763dce4c07fc4ee824166a6c4e3586d30aea7180e351106a229687887657282774c1fd2ea59fd650a0ed0408326e7af2d55ff7997c4afdb67bf21834d9c967ddd65fbf5e39c43fe6c74726e1ba1dc6853b3740437fbb52bd3165736c12c121950f1fd67337b9797c78109097f45b0581280c4b8ed1c9e0232ea787324bf442b344d1c6524b086557d310acdc491d30b47dfd686ce5ef241417e9dec83efaa64ac4c36854a4ecfdd51acacb0598d3e283886947b7f82e317f35d9acb6d69ff36523c54daa4240831db869f837db508ad8219e444ec17c980d155717617ce9d0600f7d22f82f057f92d5850ebe2f698326c849b7851849379976fd079d302114f057c1e852a7e5e620a411a46e8635d637c646d0daa1e2b119904249333a79f75ce9bd7080437c0a207beda38d12adc69f8ff1d703b44f05aeb3110490c4c3ab2de09fc5859f11ed5b72274c85f1c0fe523e72b0ef2052f17fe4661c4912121f19d136ca0e40ed8fc41418f75027178f1a36f654b7245cb1121cea6e6e48245899ae8c255ff5374d6bf5410d7aa7ade71935e54146f22567ceb6716c2ca7d47259c917e15c8adc96beaef54b5f6feca032d727fbc83db579c4979f4c1112cb9d3774ed4dc250c06adc7b037b7ce3d1fc601c0885fc58dfd8b000737d5265c151228f441fbb9830f85f5e89bd6963723fdf4593db75652802bf4c06c1df1adac05748e14d4fb160c7c3e862382a383ba6d4e3106ee6374aec8dbb9101be1dbcfb46bf20deec606262faa54d14e498db99cec624c94b5f37934bbd27614c27dd7d5a7c281e0de39d6c682af239056d0baa3949d3cccc0fa4f5ad1f1a6e98e355fbc921683574723915dd9afa43535833cc36cb5c59f296fe4d758db2f0e61544ba93590c67b632b02684ed1311939b582dfa22a356271418a8d30e449b1eab8ad3889efef1a03609cae0c309ac2c2c0add17dd03d19500d38ae2c3b32be16a8d782d9661939cb70ad75e5fc3091c7cb482515ec7480b9e94f1ce6647aae0b86672add338b314457f5a91f2854e194dee208c5765ab9d1474dfd178c6b11bc41adf75e95465f2a1dd98b35137d64ef173af7c3df3f218d8ee8f7b8bec8f4955367916f8b76c2ca39e7b4a1b19860e89e7a9c6c6a60a563ccbbb42611ed1fc33332a249f232a3785ac5ede78a764c53437490b07b3db94d2be444c9733cd9de0574cab3455183222ceeaa754da1d0ecaa115f0c08a3c3b2d1e214f48289d2e4284206b3b176b5897725854b4bc80b406ad6a5498758f07231b63f8aff14a3d76c253628b730975996c590a0b47e788b80a31cd363bcb63ac2ef12a4de1e29b883363800d41a0ea69dc663a9b758aa47d6bba6c77820513439dade4885ee27aea558154659bae04683e9f9e40dfe661468399c289d00c5fff42adb2fb2e2cf4c8646c9f8f48bd622ba3e60d4b9149792b1a42dbf75305eafc0881ee2b6bf464037ddc53b3ac63b6c1e2968bf7e86b2a413c608ece62a72e3c17482d0b71a337ea4df58d0258007bf56fea712ec021beb2e768a14381179c223f8832255e40100bf716a6f3270c19e7877b21d0f4d135cf1dbe158d307c9fbc018c81af31540ebd339cbdd0551a9475b2c9e8a13baf2f77e521743e19d424bf8d593a1140c1af816ea962d97c181b0d0ef5a69a754c8d3dbb0bc7b040f6d58ccb47d0f7c6e13870c004327f351c8bda3a86b6a66b42a4f0e070583a7ba50e50b4777a46fa037c3e099393ae0a6515239e6e734d7bae173ef8e625efd3688c77283a12daa188e8422583cc2fe5b724a617a10a1dc45f6ea0ed7df36b19f398f575499feed8e28f6b3233ab625208e9d39cb38b7f3ef0c12383abcfc76ce151af9b9b70bb6c58496c33faafc723bfddea493dfa10fd9f073e25558e0223604a02b9909199902590ff0977877b2b604859614820e8700614d1065f2205808fba0849d510e542073160f8bfbee8933f1e37469dff3e8b0fc50eeb7afdd9d834948a6cc1f5170d37d6a7bd6aec996fb136fc95e73e925e901dd3a31d9f45e3f88a04422ea985dc31321b2c707aa5c759cfe3802212c55bf773fcd22b21a522731f66023b9aea2a5d9b8e1e0b8fc28de920c7b87c77bca65c1c1d2d8e2cf9166514c8e2c8185c412519f83a41684ffff34085adf04632b550d993989db17b9504a91d1646556534040c18a8e72a6dcf21887a7319eb417d7d900542b3de75497f93d5f0fe1b6ec464247dc0ea4cd6aee7a3f45413c57a92451568550524f0f42ad9f053b00fa54ba46e0f05a7fd688d5f5a3c0b2db3118f332cfab000810e42e4ea031bd7a9603aa898f0d8b77654065e0716b2576bdbdb292130d0ffff98be407fecedd15123090ccdf26ec72f88290f379ab934fb11d8d46dbdd53165f1e8fa2e66377a7bded4167394696e22d52d97f78e41fe4c70a74c6dbfce06a30ab66be591182a7bbb21a8cff3d4962eeef0f9e2cff7b00c1802952fc3999ef675cdc8f587c2c5148101d6d2efd8aaaaa489a53fd332e6c55b5643affd569fbe792b4ebef8ad200a4d222369b72589cfeff5d27bdab7c71a2f97456845607d439aa55da154b32f1cc3127301bb6de7d92921308ef242acbce34597eec22d56dadd8c36a79795b0996538c8dcbe4569173cd4f48978b2399c6fc28ee1b3e1193e5ee3546da5acbc49ac3fdc8ae60fd6760b6962c1738b3001f579b03b4a84510bfc43a80e339b285768d54cd33abec5e869f41fac7dbcdda89ba021b83193049ea258651a1bebe3c5270f8c65633929eae6b53858da196694ea9828b1cc5268e14d443aa109f3d0a08f34db80f67f4803322f4bb0cc2519b005d4f4c481df0148dcc894bbbe3e9b8edbf7c6417885e1480cb21b0aadcd17d84e25ead6b26962b101f02f211fba74a2ebf802cf26a9010a3d9956803f5fcb78a44d22408b5d4e2fff88f08e7e521ae5d149f4d7f86276aaefc5c381f7c7038120275ee839aedc043e58bbc39c2a683cbfa889a2d8ea9d0f691e00487be5b228212e97077ecff8a15053c981ccecf26f78a6878930c68aad4c68b410be52cfe19bfa03fcafad6cdbbad27086f433d84aed427b7cd060f7219ece7ca105c2ada2c1df8205e9fac0ddda829e0c2fb7b3ab0700cd4d47cbf56fbb4302008f30771ff9f5f7d893456f36b68d50acc82f9673102df3e6beeb4bbf9ee3ac32f265e521d1cd5ad58870dea85858afb80dd685382fd490a72af45448a00c79a3be9f5720faa85acc158c1990ebe68c5e422efe695f1cac3448dff845e3595fbb1d4c77e0b9e2513d9c893e96cf74b6879725adf8208cac820d9735729d9ae663db8d041248db7f014fd72c31202ba6ad5ae5237adad4928aa5ed0293c30d0140fa59afb38914af184c160a27920342763212718d398b66da43839bd5b80ec0e8f3ee4053e9c1e287b64100afdc936349e99cf55dcc771ca2c508f313dad3875e7498c9ddc0a8d27e8b977cfeb08f9856187d802afe37cdae17d2d1eb92178cb7a49e35b26f722b0cc245937ed7e6b583be10a55ef7c7fd101dee1a48a4ddc0552fc7cc5954964b7e0ebdcaece6f73b8622c738a4d2daebb62727094839b6854620e4426464333c1f49fbca6b458ff4c73981c14ae77f4b636f234158e8627d02d4078f5d537a906a185919f6a493295daec12e9e63cbf68ac44f0418383e9780855a45dec12a2c430b2f520a9ade8e5426ef7b8166ebfda70b89d9c1cf835a4085de8bb4430b37743efc3791f0647dda9c20f778a550978b0ac2741554a00dd9cf435dcd4927d5df17545570cc830bea47c806b02af2bf6b1036f7464255b03b216b34b4bbb286010b0b1f93d3267df1d6dab600b55a77540f052cf58dbb5a5d208fc373de713ccf30bf097c0c860689e60954b43ee6327ff5fc69cd7c04cb2bced81113c261c019b0faaaf98b7f1a22de564be83731853ba722bf1b3f02d99d7096d461f27d05463e16d3b6dc3a9d4c6decea52d23196fb0d0e2688e70e9e26d9f190f4aa015aca4df4fb6d6c7075aeb048ee9595ff2812a70b795c6b3757cfa45b16ea50d16ec776420b46119460025affa38fe6ac65bb58b16b5a30c3d6b5e8eb0fdec84a52975845570c04a650ef4ada020942a5261f20d00e5a92c43e9b0a7d509e3dd7832cf65afec47397bc641763a0a55a8343d77fdb4a4762cce70396e7aad26aa80eb956e2941c9b0e19360aad4ecf35c2e16a755eae70e9fbe6c4aa6d0c7405c50493186447a3ab2d4db08bdc094ab48e22a6b532210c6029398aee887fdc5ca75838308560c04874de34ecc29dfe772611e89a74730470197629c00f3a71f412133c551a6b965717f7a82a5f737b9ff55d82b4e5c95f347450c4de5f233bd371d9d88c54070407885886fcd3c0f31acdae325b05bc4c0be70d48ffb37da337400dd161a1bdbaf732cf2ec0f0870a9e038a955b4621f2d5da1658e5bdf934bdd9fa8e2534c2b74b16d44d574925d78f58c44b8522f7f4a250782edfb43e54bb3ab259f8990fb9731c60010308c17f0884651e0c9da7511ab55d285b4cbd5979763efb9b24bc7ce63fc2381222585756f9496d0de0f7d2ef51623d44690fecbf26ede1364e886e7eb9e6652196265c5864e01abcaccd73f85f60eaa8ec085f88885dc978c789e1b1b4978e8dbb4acaaa4253d74754c7ede1edd40940978901fd4dcbbc50f22b1ebe0a9c7348c2da0bfde7a45390ba81978605f520431276f927169eda8228c93e1a6558b9768de3186b68ff63ef0ceacf196e17aa1336c85decbe74f926c208fe43f49451371524e87ebc74c6ec39297b7c22b73256705aec94275f4717df7bddb280e862d86baefffa9494cc25ea3aa7242aaab81dfd8a30e5f3d1f9285e5a5c4e582037de4b00e9e47a33ef64543d2cc7ad3ce3691730ea9daf8d767a4b8b5c585e27ce555fdac408c62058a93c73ad19dac409eceeabf3d52fc09b6208758ba50eaa0c008972fbf31dd2b15b0005e2a9769b5f42c6cc0217463a1a0a6f85f80b1ddc9d4d78ec2a2ba65278e3f9e3e9b91eac5e3ee609528c8ec4a4803babbad46ac8b74892056d30e0cf5ea79b52a1511574868f5318a6385e17515ebebd5e8c88ab828e20045abe43f3237b30dd98fe3803d074283ac93405719875bcd7c20870fbed32fa9a118bd9f45730204055a497a87838281b0a659787363ba471c95aecabba3ed3e38749bb0289a15a64f409f48ca00fc018cc8567022be047ed9c74b21f2107798b161db669698704920b3111ff902135d53b33fe6120edcc566d61e94d70464840d447ba9d054324777f2e8b870c43e5d36986d975a51945654e92e5c4c7cd73ae6e0bdf87584304cf2d6563fd94779125984449a10464fee83929510b0c51427348a190094d1712a6891f8fb90ef71ec7651a80c61a1afd6c680dcf7755e2e7bf5a7d3906dcd777b332a1f978fb0cd768921a023ee7942c9732f8cb2fd443ad97e55f89e9c1d75ed421a7f00894044a2781ec1c0864c39ca62aff4eb59fe46532eb73993fa1a0cb7d24bd820fbcae3f0d154313eec933b0127f5b3dde3fdc4ea2689d9f7f7b2aef57f35c38018c23dd74cd9f9be531c2c4c2411ef8c09a97059dbc51d5d12efc1bce5ff085b6ad3c12d0d638dca056c60597d584725e0732241b96062d473ab313b47d9f8e89c36721983e826aa2e6b220b842be1dba06f66a2b59e1128371b486ee47cadc7f088d543242590a8c1f79a14e9ea7830cdd8a19fdb558eb4bb92078f30f2d81497ae2134e16ca9f9683ec0699505360f7a8547b2d4203a02bf2f2671641895efbcc84fca38332f4cc43227c435ee6e6fa4ed20ecc5c373a8a918d720b13e283b5e3f8dc75bceea0a0c42f8fc06c0b83432836996ed65bbd6084dbef2a49342009b24f5a9fd5c56ca7f74e990b708ab57439185b8b08dcc5de8ba4aee1bc1f15599df2962b64742949b52aa2a542831516933b59aa257350120da2070383e3b6ed318e6c91c18b74def7cafd3fb036a5a3099265a160d8b16cab2c0d52489cffcb0dce4a529a17ea9e35e33fbe1bf3713bd426e6924514b226349b97031fa9a121f29c08030c6e398cc2ac3c78337ea82a9e28ea9de6309ccc0f9cb5c24cf1830a4cf7e39a00ad2147c6609196698daa70b2ced6f791b53b65e044131aabad89f51400995201f09b8e8ec408ddf5caa7baa6472d26a569340f6043b9d1f39a270abd0097ca6c8f9d18507851f5b515972c0504e7ff1f5535363b5b89b4a963bb3e490134d6370fa9fc0d08781a9d9bac1c5f5c240c11e585470bf240ca60e3ca893dfd338c38e74949b09b7815e3985e57680207a6911e8885615e5c830d5f82264648e1cd69094cbb287cee385c54023311f9cfbae03f9cdcbf3dc443462a54ad1a274acbdf749e0661feb5bfaf1f80d5fd0016d78e2c23877bee7605655b7b1f22e739e47136d9921811f24ddbaaf4670639967360016c82a53dae11e251de1eec214558f72fe07944a888cd0cca2d423b40a72b32e25ef9a34fa57fb9b5e1a13c4704b8c18f747f3b3d395a45ae9e93e75da0a91919eb1c8fd40f63b615c7e9bbd0b17e63810bc79b0ec6ac6768289b44512c730640fd8108c54a3268bb3eaa92f4a8e406f96b3e1b3d5e22e8ac62cc27482069ff535881d4a8708f6cdf167544a64b30e09ab7f3b9c9b6fdafe42bf19a3eda99f2cfa06e72a8a08dea5254a1720603b366ca330b96166ede467a14353dc5f42b0d71cc51222e3ead23dcaf40f592c8015475b4e1e18ed8559a4a02373948d0d09e9b05e6a8c60d2c159d235976ee3d093da73e8fe80c62f00b43e3ea5d9e658c5d795b6bf49176e6707331dd49e871d64e9ca5bfbde648f7996b99dabc060793c52f1c085caf793dcd2ab5a4cc12f9644da65b6ee0247392a0fe7f5e7a50bf47d0152541644865e5881a883021efa5f880d856ca8b79c198da3c88a282b9adc5a47643e09dc63903678f4dc026dd725dc5a4a9167ea90c27cd901eabab2f28c59e1bafb1c42bbb800cb8d3dfcae82c0a145e2bc1a2acd1e9f4d281886130ec08fa5f69788355e1e690a5dae3f7f560db6fcbdb16c73ce66f6c4387953f0ced0ae95f4b5bed7830649ca54deabf3807caaa5185b1f3830934f79ba8e5175fa3707aa6c2743def2b61ee72b049905fe8aba06c9df87e598550343cefa5603b716ff6e87128f3362e3dbbe33140f87d80e48a14894ea6f718c45489ca12529e77894fcd3b8a5c629cd6ce236c21cdce6c8e547c7378f9fae0175648c0ef62ad47cc91932a7067a3445ac5889c038149eb27ea8b6ff4af8cb371453784261e447745fc46fac5a82307d6d5ef7e9dd1ee7b9a7f72267d9ade7bc9a73f193a6e329d8cc6543795ccc01bf3a64c16310bafcd459a5296e75df1af2120a954426e23c99faf17a138f9ecb8fe7ed719111208727c7ae00fb838d8b1a6417822f43ee2f6d992958590265a5efe6b2d8348577b2c7769842b37ccb1afb5fe8988f84cfbe890e2090552e0432b57612741568809c515096094d4cfcd0082231d39d35a689abafbcd654de589bb5ee330286d7054be01bf4e1a59be7876fdd777ded15a2da627c2081c549bb96d0d5e130a6eb21fa4dc984a0eb88fed08e9b6b610c01befaed58c173fd1836d858225a73b8635f278ec538cf0b1a5838512563ac79c3f37ec22d9b9a525b1abbc3a933579b311ce6c71948b6f430087f6fddbf49c8eba441d45ac0ecc3042dbd56dfdc58fac020d0f839cd88626e63f71f27dcbd6a85d4f6d7be1fdfb0260bb18381052d585bd16275e5ae4d75a283d6bcebb7b17cffb7c18d8bb6135acace572a06dc978cea2f02bdfc3a1191fc712a46cf8c57423ab28539c5f87ee976895007a8aa03ed7d240d6073f5808edd692812ed5113ef95e2a71f4f22c690b09ab873d627c64536278c1cc9db94cbc7599bc2ef3b26a3b8a9a6f184a1998a0bb87f06223e69f6cec454b7d227990cac38c8fd5c64833e9994152f4c4f0b64101dd62a0d312fd3bc85bf1fb6d49cc0955f68dc550231998189e58ed3b077dda109040940b1aa6be50373f22f9e6ad4857bdcd63cec43f7ce4217a79c679f035d1736d045f179f8f4ed8d7765dd31e9adeeb857e55892fb0fb0149b9ce0e6366ee276b68815b9a425f56d1b7b2c82196e7a131c99c268b3137be102ac64598c2b669d4f07bed7177763cca1c4e770c052b56c77be4f33282e5a83654a23b1fed7dc7d5f0a40d7d100ac6b95bf47c8133e87036d6cc9e4110c0cfe22b7da57e5f6af0a57627e2a33657310a43df03a34fb93a07bd467545b28f64ae0e493449facab1a49140cf808ff41eaaf66b741150e921bd760370b275646a62bf50395e8a60acc141a2387e8c8475ac89a6318d68b0afea940b1d3839ee867ebad13701eac262eadc45998ecd0bc23da1284a908d83ab2f70e106f6b912606d8c2b512dc106dd4e1fc03cd4363df11d310c6dd0457a92560a52ed4349be0ac6ca3b91d12394e7b03b4f2b2168019e25f349ee816bb67ae702408782de8c0e02614201626e1bce84e8a31b37412e186cb190fcc439e10d10e853ed702ced3934c9bf8a11e381bb32d2fbec0874bc3c94bfb025b6bc44a209e30d3f6733b1709228b8eb94d84ceb54ffdb1ef7aa1a5cff16f06e11695067020cb0b7dfb1713e1f96557f3b4ab710c93c89f5c44c74f83927fb692b52f8deb298730135b4c291dd8d006c29150768b31bd768bc7182b0cdfdb2e43a911ce29b73e77d5799659d10dd0e1d785ac2859ab1f6bef9f2067ace2dc8d2a7eca419521abb560d599acbed305f3015ca007c23f09002f33d4e79877d4b25d014fd1aedbba7381067e3c1039204fb4ffe2a335f1e152dbfb4cb11caacc368860024850d69a9ffcb72d90802e67de22e313db8d403a3a63e70ed98fddc6216208a678084fadb5a4a864ef826b623fcdb4e77c83f92b868f2381994fed03cb73a32ed5f88377d03e15bb4ff8801ee58015bdd93cd7a4abab7e9f023eb68c3a238a57e44fce339506208609bc750eab226693d995177a660b22d82ad79bb87d2b0cb2e6e774357b670dba9ccebc5218ee4580ed716193f5973c926e6f1fd0274e669c38a0a54fa5042a79bb0ecfc5c7d1b1fbb9b5136ad9cfd5b56d3f2e87195f1cd4992d101dfbc83f9bb3b5af4ec0c10f042ac8891d8ae47b4a36b014f11c926244d7bcd4f35b07b82b6d10b3000ae2f9bb6d5c19182b738a1453e84296bc2a1871ea5e53a425a9667a3c2573285bb423a73e1f50928f91a29256553570a9775f0a4bfd27b2b0f609e23156cf1a091f49cb2af3ed7ef25a7b7c8674db06deaaa9f4d8ac43d59accc02289c76caef9d1698b98f751d57eb49837282e504cc6cdc41b51f8b502731fda02b0fe95404912aca54eb8c78267ea1f77f3df0c5c048a95c89653efe83ecea2e511b96542c3c8b01b6cf9e5a8d4e4e09ad1ad1120b3b86596ab12adf666d1621f2c43e3e52c685f02e2fa3ccaa8e74de7c9dc951ccaf1475b4615404731b44bbab6ed5806bd882f7dfd7663fa6e903878d58dced672383d139f0f666db8ce96b724d2b2150dad2038142c4fa8e3cd2f215fcf626c2c17e53959d0526317c67fcd6556ae152d5cee9108e3fd2a68251ed5c89c42dd3863380749ac2d5a7dbae022cec9ded0c50e3f547bbc21ac4b4e41cd6e0c0ba92808fcf6e87453b1c2ec7af5f54612f0335ccd73c1273d722ee4c26505e99782ae231cd79b60e0e5652bd6721c57d3e1224a434a20d1ec25e36b1dfb417090bce32c4ed8ab33c937c740c172602c9c14bce6bca10fe60ec471b8f60ce77c9331127ff963690cf98ab40290acf8d322925055c037ddd496425f0c2752826d8da0e25cb7f2fbf46d1ffcc6a58c10038720eac1ad56c8aed11365de1545b9db9d72d9cf8b4a1181fc776b6581ff4b263042ccd0b7bb6743d89997a58a352a261c6a604f27ae056887135c109e75ecb971246db6a4c0d6ec44dc352c3204854054d142772cbcef006ad63c5c578370c079f2ab9d832b1a0f836427726ffbc9ef1fc10ab4c1db087f1766f02a3aab4275e05f08aa12f1332ddbd93b8729d9149ed3db587ea5cf5a3c4607374bcc579dd38ba98dc5fd377e61c1f65be95eec634fa30ebc1b5809a03762b57bb8222d0092daa532d82962f2a7b7ccbbabb7a2aa9af132cbfd8e8cbd6b3b6cda907ffb6f1efd1ca119511c0f5dbdf1589245c9ec01e1b5a88c78a0bdd6e1cfd01de34f2d102223a8987f9159c3030d952e7c0e8abd4a84a87d9406d60210f8b71a1c3c651d862e7e15f1aa31adb74cb1fc594e42a684375c173c3938e82dd061666d829825a0c19f0159ae86fe3681184a6988fa1303544ef2a5383861670afed5ed067c26df6665cf06c45802792b43f0ea908b2dc222ce8ae4327910c68f013b32da55512932c23b0644b20deba98e61a0fc65540f2472995e1d344a32a74cc19cd3457dd3d0abf7020858ed42476925b8be5617a0ebdef4a5ba684028a837f5f3a6c50274e558cb4eb01dbf91e3bb4114bf46a43586038e637049e372295882e594a26fe481c3b68e2338dc7f8751c17b66f1313fabafe3e91d54e85b4aa5bd6a73277e0e283a5d104a2a609b8cd6785799612c51b14d8b923fd19f48c888160e6e23a6423236134a0208cf07707eec6c8849b92cb1af44100bb42a04af26585ba55426052a5f0d341c660c9d0409058da78a4cf93fbff3a880b73da79a91ddd7f1b55af7f97cee6423a5e0153b26d01f213ff23ab248fe5bdab48d98cde6afe9b0a0a2e2088816c3082561a5efd56e990674ebb4b98a6691566de82d3b1a644b49db212f265d6ab2366041b6d59a1497eddf750f6dcf42064c1b863441ec9b50240ce66f1f42e5c8940300a8cf33ca27d806dd98b4023608549fd71f9c5cf3bc3d275721624463806ea760c513e2860d624238d0a88dc1f9269c735defb73908dd4e17208f131265395f9dc5d1899f56ae0bd2543aa8f7789f8332eda91574bfe51e77c9a7857d77a4f74fd3fe0105d818fca4074a2ece66ac2303fe3199beef7d8f7136be93b307333c9128ee37e839429d118a9daf0a3e0da29dd8dc01240b628414df313522093c5ca17ad6a68ca23265308ea16a6142f4e93b79cdd9eb96a7688bf1d752c15cdfcfe673488373083862ab03b58f24144dbb1f3d89a2f577148865be163e0ea7c82fc51fc8cfb231ae053dd78370cfc4753de3cf6327c0a95d62c1a6a5802905e92db64b621400695b0bbd78d907243ed03df4ff6939d0eef7a9f7590cba98901e7c99d73f8e724de6c944fd58c443cd4cb151f37b0b6aadfbefb3651e21c7efbf54908c5e448eeaeb371ca088c201f9ffd8a9509c5a7b108ec5a326e6c02480fa3c560d786dc8acc3cf1df33d0d8d85058c07843d8ed6d86b3ad9fff367265eac0f80476f91ec95556c0243285163ac282bc3f42309299073719e4d8c7e677558bce8adafdb3500506d6a84d68c47fab3f22fad49f384bcaf4408ff1dea698f76dd2d2cb92d1db45005733bac1bdd64a77f5505a020ede4ef46609057027d2c46c9bf7e7adda59c9f2623c4bf50af923313d77cb193c76878cdb1d5bcb747e2dfa68d66415e8c493d6c7b2c05293dd3a2377bb5689841e82724791d3f42456da54631502bf3be8c8b18c6221d788b16312ade2421463bf9dbe9163bc9141fcc46473fe06fbb0f19e28adfe5eb880a2b2e37f9140c47a13a35916ce9ef10d2951bed52023e64897969e8b80d0bdcc79e4892d937fc051f295ff38cf0ba48a38112153fb21c76e1d1082c9f03bf58f1f1bd7f47ed325818cc5fa3f5a951b290a5b252b2a9f11dcf27b998a5c6ef5dbbb093b5e547f2069e8bfb00e52ba35f05f1b26cc929dab93d550e584f9771cda190f47716fdd469827938de15bfa12cea2babbc694452ac3de214dcd4e8fb557fe4c1f93a7b6aa5636209af3f5d970c4b927aad6e37ae63e41a5b8b91740d0ae4908badde92653307c37aa845d779e95d308e091bd11f8edbc3a61536c07eac946664f94caf90d771b9681a00c9bc05c3e301414711e3918cb0373bae59517fb6a0e1f08bc59b9ceb4775191b3a41b136c5d180f5973d1db6c2403195e01016fc7c33607e4a7569db1faeda81893330d1e3cf44b12df68c424fe3d214e55660acc626551368fb58f4334535a3a178c60eba5e939d00e445b5a52dd994571346c09cfa07036cb30736f949e2fdd2d7abbc17b32e420facf664a373f0c20c91e74c70adc80c8c42b21c917b42854cf1753e0ced2a0a8decc38da612249923e086c2e6ab5211e9ab711a33f31b8f292ed43588a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
