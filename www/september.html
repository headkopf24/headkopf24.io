<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"afed0e2bdb583044d2ab25f684c75b88a3d0c64751ef8e2c6dbfbca1fc8aa04fb62e7ba7e728ff85975c6a4c3c923fcc55feefff01615adfaf2687f128e6a639d0ced322c6ee9c961f13f1f222ab920303a0c692d478a3d3baca5fd554fbfbef081b6263478ee1dc62f443ea184ed116b2a6ba678fcdc935e5d1e4d794fdb5941f4fb205207f84e76aafcaa8dbb6d4f299bd933b32c26fda883b2e45736767d88bd9ce794a420c682d929a4f194031c812673cbdfdcead6223098148b09c05d6f322080e512d5412addcff0a4f9ec1d3adf9568e1b74d89c3d31282fb66ae8a3e51ecf58af68d4ec34158b365f9f935858c8e44e2019529b9e1d1e075de4fb2ee7c35263bb9aff02e15180119ff5f4e6ddfc9161fc17a4a84cc195acfb30b8e1b565b59a78c03ea5fbd71beb55184f02ce7de0ee7982164e297cf3be6d0325d2860170a0a16f431a1057b4125766da4cbe0381b48821013fcf3098975561817e3896fec7ff6bfb3f70eea278d8658505f8a20a19ee844c5e316537b9255e0e3c81396e6183e6c0f5088cc854537a2e2771a5ddf96f2df7c913338e548c4845df05e4bdb56a2747ea8e69abca561d8d1916c33413a8d6484900b0ba43c63911ceb4c1a134d68a5c32d7aa94554864242d7a38c93bf120ffab26a9cb5dcbaec5af178ef14499f7dd65120c9e630079bb7c9e8a74de3290b066eee5133061831c5f639930b4bc2e0bd7bad4cb3f18ec6dd01c7fc37291577d1251069151e2e7e23e417079548a2debb050998093a71aa019a729f66ba3cec844a17dcfe919af3b39548b63b85cb659499c4c7aaf63c9efb059ead495db51a5ccbfd74478079af5d24ea5c2c6713832fe6adb6dac6db21e658ddf075d902ca584d88c9b78b9dbbd2cfb1420951bce0da0d5eb04ede747d599c4a3c05e5b2259dd336698b23f89793cf40e5be98cbd94bf95dc596fc6e428166ffbf39929541c6dee424bf377bca5e2694429b462080f9f79b033da249dc5646dadbd3c238058c52c46502f36ed0aef930a28624561fa3df57d5a5d6f9ab4ab5f20a409be2affe2b1bf098f9be8cd6ea64e9820cce165cf235a1b4660199fc276ac1752abf3204c39cc06d03afc800c20b711c44415d5c2ab143ca7000400af9798bc169f5c6537917b4560e5e10b9792524d4f6bf983d55755a9b3fbbbfbe57531af0bd5e700cece2f1a9618c34bff7914724d77a6cc11ee202653c539f904676c2cbb59c52d434e01390790a4e2d03648d240eecdce5081f1a2737324f736bc4cf0d598616a5a065c533397c8cdaa50ec3b8840dab2db80f5d87e22b5be6fdfe3b0939d72978a58908cb1d59571cfe2edf3e1ae6f56990bbed07e51a45ec6320ac0f02169dc78968595ddc0a8c074a216cd274641f9fe462ffa7a8d7ed0bacb8b3e7991458446d000c2fbe26ab00d6e70c2f2ab072ef0f026b8f6103704e8e5e6f900fb88b845e7ee990833a0f55b2514e7b0116ef4b51a3acd138a1d948dce2d66f6ca99e8051a79de97ce4f824ff8c6f131c862ed85cc74d75621d470e773a01c3f7134f3cfa4c99257db16ce91b611d0e2da4d3fb7f250c25caaab3fb5c183520badaeabddbe4020fe6a018b010cbb6ede8f7ddcf453c25fcf50216165db508db479d143fe7590e0dc270591d2cdb3baf39c414b7a830f06b8e5391625440462cf94ec93f2f0760ee2d2315fcdf60dd0b93cbe212bce8054d9cbb0d254fe59e3949182d168df151759b5610ba51e29c63ca72d302e5982371476fac24729e83e80f360cc3d07cf91a446043910bde892b9138e9bf955e2267ebd8a3c73ce387dbcf28a84df41c7b3b77d76f0e17f647e808fffc912d04a8253ee7d05e9b68ff258d7e10dfe53920d78d2b8a701417641be63813e4f39e5e5fd91322f43a288b8e3d1e5dd54f8339568d008e3f4d124b1d8b218960ae663a77f1c1e2e71770d5b837e270358350bf99b36b7a7c329fadca81d93dc73f04c14cac9b39c1a2ace0bafa53a0d6aa33f39acfd872f9d80bb79f56450839da70111b53ea168a5c5d7785fd24507759a30949f4a4f1c58bab627aef6f23064363c21605dd4e35e0c6fae1c29236291c068a697de58c5374ec2c8cb87cf61908171fb9c26c1afacd341dd77b0786183d9676bacf33709bb7c68dd7fa5f2b105cc2c509c90e91281cecb507d707dc18935b33d7fb575cefcb7181a2236617430d4b42ac636cf84b04f65ed2e05ec1bd24a014a884fa568448dc4438b4ddb44d98eeacf960a90b1a91991606aa3a8a3d38597768cabcd19db1f24f46af428e0ae460f0a3119fb96c5282bf999bea6a52915b5687e24f0e26aa43c16b95a00e0cd30f3af89e3aa7f5d43e7e4c26df4182c0c0cb403263d1950668aabf3ae8b6d5096372d392c5359025ccb8180e53cafd56c48e1341eb024c016ac4b05043bb8cded3eaa2b30b732fb677e7095c11f142f65b9bd236296fac248a310728bf125b190401c2f2b42103a04dcf97695ab0f72f388816fd201a7dca78912586f4934ff9c2fdf8283b9f6c22514c0cb1ed7f0258e395922610baaf688e15974d3ff0db67385545632bb8737983008a3455db11e8278c0f1554a1167490c01c1d92097927cac6100648066404413ed66efb9440d57c66db84ca0d697d76d8afb755956c23c59a368f3c19d04ff17c32adeb38e59c186c30e1cfb593f19a4b98318bf9682715a075dd273be3de181848fed642f44f80f7290d98bebfe746dd7ad0d7db8dd260cf5b8529e846fe650f658334f0b7310eaf6572d11c493aaa3dbfaa9a8b5bd030531e09c4a2dc540b513721471dfd12825b1a17c5a039bf99e434eda2b311cee4990b8f33dceb36067afb6b4678adb7adeec79cb7e3b46de4109b135e455e64bcdfd6efd81fd4376ac93006bcfcfcff0aabe8fe1cf17cb595854c25a801ce8a8681e7efad55bea0cddf035db4c7b0c06ae7494c9a9710bc73ef4fd74a4e499c3a018e455da245ab23cb924ecb0ee7399e10c811ca708b5c399d045e8b7321187ea1d437eca23bae82606483729c8d3f73e37877e15f86cd59e4b1b91f2db41d1e4ee79728581a313dc8e5622a99dda931f2abf05089b794bb78dc33877b4b098fc30aa086d45258eeaad59ecdfab1987754ba684a10f710d0134774d2b330ac4b7b11bc01c1613922051573d5cd2f367f509657f660748f1b0eef93780fa704eb319e1f1858a1173bf748f0d8b0fb4f70d4e360d61b7597edea9149ca8b5df7470bd4265a8395bc277b2ffa20c43f1e3821315189cecfd1afc58e7f554d083ce7eabf97214e9f04f486dbdd9e233920294e168a3a7bf95fd1714cd0fc355b2d4b6e7b91f833b8a8b5e8d506682ddcad0cf79b9869cc6fe3ae67cd3750012223af378c42155e2ea34980130fdc45b6164e7f14f33bada2f40edf6bb770488be3abaf0ece77939356349cca2daa0b12a02794f277b4d5edd9a2d0a48c2dfdc431ef4e17fc3ca1e2d012c04cb4c6c7b42e950ede55103c6459e2b3aefcdabaa71ddd6559680c6654fc9377db49aa14fdc2329c72a5bb5d697e0e3b7598fab899f69fa785e9e7f5bd3a5cfdbe995e2d57028bedf67dd7a963f46c334004e9c7c7c3b4713357005c97f77c360935759f7cb01cda13fb4dc75037aba1d7aa8efc2c76ff571faae0bba735bbbc80f8409d39d815a59dd53df8df99cbce9d7f9748ce3cdc9023386d6475e1d29e326c110d2a4fc1e4564576fcab1e3311aed10a45c73c895022ed04c2866d5ef26cd42f80aa9abae55fdc25e676bd453fffe1858c138210e452bc7f3dec6d01c64eb50fe061da19a5899dd93fc85ae90e3c2e2dc483f11fa2f1102d4e1f2ed66b9eac778a17f0b0eef1411b29383386e58cbb940b8856ccbe92efbea8ac5351c98b37d4ba5c8c1e914ce0ad73dbbf4291581b2a8bad3925041fba97f9738e74aa3ff35920a3b83a7b887321afc99093f5f0668b856ae7ae5373a0abc3fdc4b8b636d08d4ae972ebc431aabf9c5900388d1ed417d8d1965dd64545bfef50b8dde2a26295253165d3565e65425ee709ec5e76521bfc6d37d306b8668b26868f78de6d272ca3380eee149200620aafecd67dd083c24eb332e28640440a706b2d6aaa2b87c842dd4e1cf5cd87ccd296bb82a7769f817b707da62279a254ba192b3118d395661364210d566801d8d7f3b6305dab919f4bd00973f751c2f2885757b746a47b6b65bbe6336835a619f91e6769c2b0bd8f85f0ff73de8da4e557e40dbb55d1ced131b32d83534c72fa1069789069fb909242be269b6d9e3ec058625c27f53a1fa711f61d060c4f5adce3349abd1320d3425a35c70a65f213421c566f2ba382c31e86be1695083ec02ce1ff99ab9b8eeba10885bdb48135295da049c122a543c5b85347f9c759ce3f9d008a4257969f0e699a3cdd9851731148022831d483024d1befdba69f970b990e4fe654f75128c83c6edea7f6028f07a9a1cfef15a157ffc098ce9dcd821e73030640bf5fee7a3a6dc8647d2e7ffb4406fd8668ab8a5e71d97d798b5e3e213148445410b45840d9b1376aad66910142cf3166fe90b676b11967e918021c9f4f61f9dd7d2590f0eb0c5b35c88701a65a94be12f27d2a687c0c99d845c7aec94d7553bdcc2a661c1a142620dfeef07aae85ff7f1cd71086223bf730297d51585d6ea7be2f9f0688484309cb5b80700bb4f9fb71e391964320a82c298fc5699e2801493e0a5d2800b8dbe461bbff21e78e56ed7607709d4783b4ce0c52533da7336e67ecd64a467a670026682c3e1f832aa8cbdaf57b10ebbe9fe73f0a9a09546419f0f0f4e8d36d2daa40a200ff81b0b12a012199330fadca173291adeeb22ee4e39c62d5dbad8206fb2cff3a7eeedf3aa90268d1cdf46fa1134b11c91951e46dd7c5f2a80750e180d79306a8a8930208675c330f9b7239b4e6354b5944083570559a1fbb231c9c8b53bb330b1129f5a6443c2d870dc3378e1ee700521460c706f1704a875208b4fceb32e41c88dc9d52a332a476445ae71ae551b43c95651e4c5de4bed7d71804880551ddcb92ffde98fa493d194296a580b7346fc9cc2bdf0e94131176a5a0f629ea1af3342e4e421173c74829ce022cc789d3850e715e37a6aa556660e4b7d9472e3165ca8aa879e5282dae8456335c971ba27f30865bbe98cb909df51a04ff01441ac402fc0c584d3ba4bcc9414db76de5ff687d4ede1c2f99b5f4ffb16f0b271e2a0b1926a1a2d227310d8b6a207934eff3ec907eeb43b275ff95ec3bcf74d5b1fa821e8290577994094333d871d1031cf5c2e0ef73962510e66d6aa7e067a1c3b35ac202111502730f054f54c629f45d0609844f69f45ea38078d4656fef9a04edd69c4d4fbb78378278f8103e8dab1e63cfe3a4426895a8cd1c7585417b5fdf63ce9e5744e9a35fb23341d364c188ddf2afa3ed694c64214f199d8381d5feaa773b1a8fc1d92e7a0b02e292f4db02fc73bbd2aefb75dec6b54ba730c7d337aa01f7b791bb2a4b16ed802a67d5553f43528f4ba01343b4ce18a5811c31996c20eb64855eb1a38f0a7a8a6167d174d45019d99a1d6316dcdca99b9768f87f4ebdf08c9bb0f75622cdd8a79d1fa6271ba2e4fd4256f5e1f00d7b50c4739f7ebd21074a8a8264ef682b3798819647d8480ea81b85cf0a0c21c2dba257a69c93d3a3d7b6c53b53735384fbef8c99b13c280457df10f87ed73b423f25d06970c9c6cac186df56e77f8f71d0ed14eb2b8cd0c860e3c71846e8c383094ea1944c189b93f9b61e6b7518bc4775be6480d9e7ef9f98df1038eb90edb3e83ea196354015961f806e1049bf51506cb720bc26cdbc428c2a6c5f05d0d444edb965e7a31ca0a93eed448f349a6d96f90a75f7556d10c6145d387fd6843ce49935a4285b9a34c321f59f3c7216325bd52857fa8bbcd13f533ea5cc4d1fa49df7b55eded9e0edfa6229ab39d1ada5ca5b9620e3501390f630247c26187daaa989c5b3b6b85357dfb64a8c1872393e6b26957863b47b1690cc299ac0f345995473d8db2099d610f7c088a4984f5bc941b10204f90d042eecd3d4410cb13fbc5ef7e5ba39ad49366ea5133d4ea41bdfa0c86ccbd92f28455a9bdaa64506e5379fdc4412a188f9bdc2e3ebad75807bbb564fbe3813c983fb04f8872b30a46218d9c2690dd55df7d1bd711331827111f99a7c93e25ed83f4cca83a981885aa6c21122aee49107d73d2ad154e5b5c0892efab63e8bc1f50277ba8109cdbc0f3b23cc07782c19344e0f509bc2dfbab0b962c2dece8b96247150b2cd6b8b0ba1552137aed34705075f3f86f74fc10eec951675f00982c0575d6f95bc118ecce2f2c5ee8327dde2457588e4df0014c507e90199f580539b7dac9d1ecb4c56f7be37247d1d6bad42df526ec3e39aae937fe3cbe285c29ac112303f9ece435d3e6604e24abdf4f4518444ee28d4a0848ccf3964ea98d0a7b4a677fa8c56c60f14823363efca1aa1f1ed0828031f34d21bfbdb83bf06701f12816cbf2dbce1438ba98c1579ee661f9e13419720f47c7af842300188abfac9358e175673b070ecf09ef36ba570c9555dd02660cd5de65014d3de9f0b06ec3b7b5b3599c159bcd7841df9699d9cef10f1983209a380491ccb13eb290d64e4c1c0b6a2ee41aec74154a64d93660932532dd0e566d6a4a78d55d41b20cbc51b6928ea43765e130822e289d2b20f1019041e1a63e83e0216717011f124e8d5fa938de91b68097a19d7667f31c1e2545f9918317931d43716884094c83a5fc8f1097dbf36415b1abf76133d210f8d8a4f9dc01f9c083b1e422ea375d10cc1f37050302ac992a2b96e59707ebd5fb46cce1511b97db7bb47ad6d753465cbd01fc9739b0d80a2eca14f6b01f0226e94b1ae12797cc9339ae5d11f88feb8308361940ed43b9896d983cc38e70761354f975d7539c1f1ae3690bde9b83d59347cfabcded227cb0973ae3a87f4dda49175ba1328f70f8afa5481bd0650e819c53acb2b14cde98b31a03da2537af0b40dc4b305acfde530081cde560691fdec69560ddb6b42ea45a72b5324e43b2807595f340a83f4bad7c3854ddaf936fdcdf2f5a14ef71c23437ff491999d0c663c952bdbff7ea4d5fee5b7afb3340b9c27eaad227acd69ff506c99594ed3db2fdab8d980f6a84e04edc8cd0ec19c4822e8cdd641b7b0ade041ccf1ec08ffcd7140aac9ba3bacf045cb24372a69c56ffffc7d65a4c7a3b30af9e981f907e232b3139e9d641e30c3d25f8721c8df529eb5909f412144ab49d7e25ef5107bd22e11d7eb70ed5d9319262528127ccd5a5ccffb0c010dc6c082d12c205874582ce29f5b36d3c4efa1ed11ba4bb4e06443f76791541177cba98d036cd6f6d7f078067a52e9c959e8fe13630bea44a48a97955790c151aca5652d59561e6c99165b2811b38b08977ce8be6583b6d2cb238913883d9a8bfc2aadb12ae2045d593930b6f204345edb6a45dc11056d64b9c0cab082fe80c5127f635c4733cf3f65c194e24e261e03517473cbc16e536139947c6b9bafd1ec14cdcdbd42e17ff82bab6ce20fdc379fe4a40927a9672dbe17fa99db3dd63ae5f17a801653fc81571215168d8c674d87f85bcee540c0261dc09d4ea0f0dfb9f0a0f8400d9481bcb40adf803b729f69ebd609d29d58cdd574a599022c4b4cd8aff24d3fdb23028885f06830d48a31ca332f79ef8a3f2605a98beaec80f6de1657c67ebdff2464e0f3284a7bcd046c50db078df44778fb4cfd73cfba6999a2585fbbfbc56a0cffa219be803759d935361df7083611c8782b0b5543ac307e31622afb77647713086a5dc2b1ada61bed9f049dc29bcfcd83324f33869d0b4c83921ecb587f06d2fc354939cf82062897915d31cad4f6830a3cc8f0c9049dbcff75233d000c19225ca1acf293d86a43900994bc78396921426c89632a4792b143a2ff981a1efd4b63a916b910ab4c98a831056e9380f5f63156c28b574195eff663d92e091ae9ec7ab792ef355aa898530ff660cbafe529a2323111c315859a779d24cdda9e11ad91227f48d657cd81a0900639c9fe4420172251df19a14596e5769fb0d501bcb6d1d7cddb80d312a82f36d961746120a32ce80bf2e5fce18278f4b8be77a027bd4b183a8433945167294c68eeb7fb85301c9cff6230f98e23e52cace7e59b5d176385497dce06e55263dca6fdf8e1e562c3ee5d0ee9e03c98c45ba1acac0b735005172ae0f85976aa2e1cebcb3be249786556b250b4550ff3303beab37a08b05f52e65c80f69b308bf9bf67eab25de2465af9b7b19aae470eb8eb757fd7ded08c26b98e8200275b2aa7fbb37b311c14b4ccd6e3713332dacf4098af2617f6480772d32ad62ad1580ca675817684c68f7c883e19d7e824b6c61305fe4e25c903d3294c9a930551837eecc899ea95b4ab68e428dd068d3475b22032ca6d5f62f1e5fca0caab383ac6b04686d78e5953b4048f54a1790c18538a21462387f3c840f786ab29b73e110abb7f826c9c395ca474b2f78f9fd4a1a190c4caaca0419adf66d568d72f4b51b6e9e15b6255fd3726e3a8b8e2e09596416ab12badbce256c39fd6c2234b6f0f0edf64e1c58af2507cd599ecbd7cf501ed6808fdcdf120fc4fec6f9a529a413f1e099db467504f2aadd673bec8f27cf4fea2cf8c7f271ae17199cb561f62a156980164079f529964385af03d9dd239d266c15998e0c593b27b09b87e86d8eccaf6b0e2beac92274e1a672f3072665143b6690f1f1af2f9dac0bf30a9434df75aa93cb376a978a35559ec038d1da691031547cf4a412a77c1b86f036f3d847f58431708a0fbf0ed7f2046d8e0d72b884b94120cecfeaf17a15ab1cd06d68dbdfe3d7d9f09894bcc2596b997f45fd25346b77eaa82ab0ec7e27487339cd9e8f5ec82a38e609f66b189389ceb5b6c1c759ad96df35b3013253c130a3989180bd2303ecb289416ad904f2848432312928e34b14ffe2ced7a1aaf0ad3459563c0c41a6ea08f87f8bd3e32b6f27e36bb83edfc483be447462fa654e71bb5333cf19c7a5b41fd9b5a4eea4bfb7501e3123cf27a40662238243a78b161bdd91d547775f0c94f0bf270e959551f3c11db3b7c43eecb75120442eb3337e6b80cac345da61a3cbb538533759644a2b50ba6950b0061051a78a352b00693fb41e95b9f571f1705760205fd56485faf2d1c0f08398dc2569a6e79426789ebbff9925f4c0c4e65ef6edab18d3836fe1c1438c298981c353ba1be795aa6f849041df4e1ee64b28f0f91abc1e1f448fcccc75301cd4b7b19a4d1ad191297800d15adccad2942fdcae5606ab6920b8db3cb5c26bf70851b44cf7880356b495e35f5290ec9bf9c609040eba12f792f737086df694973895caa60d23cca589b888a5c426c33b0b991407e6284a5ea5424d29e83a8bc960020610aefc4e91aa90a1ebf7b13a519448ca614708b083341469f76fbd0c0e5c1aab237e93901e8381b1cb3a0f8602d4a77468c0c30a70c57b42d749a729081d9162511fd3595afea784721e3e671e176fad05b1afb232d69d274422d2b3f864792317f42b94748e1a8812e6cd08ddccc735a93c9840a8a53d1fb83043f807acde57a47f30024888655da9f7d404e661573d5e405c22572bcaa8b9c09c602e8c0ac707da7d9f704f1feea14ffb8fac8ad95f23fdc8ff53a6ca643d647141313f9ebf57a385cf134fc8bd0d35f4ecb63d9278c1e656b5ad576c24956a5a6bc469f2ac2dbc1218aa27cda79a6da41564f89ab7b6a38c692cb4e9d9a8bf93dad95ecefebecd0f0e7cf5feeea8996173ec8b46005ad9129ca909b364f93b12f9edc10ace71e2ffbf54ce11ea5dc3dd18c7e08d8b34cdf84e5c47735e30fd84a1181af6d742aa735a8d168652349b9cd8c38c1bc408bf5ccfdd6c1900abce6cfde9689756ec5400b4ec434d2e25248875ea48cb8f7b2ba6b8e553629e069267be7742809262d706f8957b3661b48522a544933c4f7432d0e36634180a014d1144b0df3671975d2b29099bb8da453c2b1c5cb984bdd66a864a28fb290ddd3317c819cb11b501ba1cd45d23bce3a812d9e9fd78c78b65cfc639eb090a448746389e7d651d818743a65e3216da2a8048823249672c689269f5cccc8e847c1e451d4f367693e9514c0597abbac3521a9bcee73de20b0bdc421a1fc9e0d2c622c442d08ecbad1dae258d5d88852209c2afd675dc2962336b2ea28e6b0e051950333729dd29fa302b726161292c2b5440671e470766cc2132281085748633dcf528dc35368f6903681a9dd9fd52ab561d10ed4153af156b27e53771115d7c084a26a9af8dc27ead003a4ec3461d75c2434dfdf26b591d3f5fed5e4033945656b28d263987366447f82ba482a3ef9353913b85a8e3b4ccebd29040042eb103a42db99646de021c19cc7a03e6d4f621a60e75b6a96820ecf5c65710ab63a31a522e28bf37b6f77881041ac26c2d6671ae00e944cd6892e5873a5bf32f0292313e10a22dcea41d7f726027040d55eb2d0982ced2946965f04a9ba2144705f7925e1dc341b0eda6992bbc2b7f3b7fb2639187e26002cc3fd01f974c61f515f5f173c5c826218e28fa9cf560ce88d3b7ff3859a9ffaa2e811e3b19461dd3b9fc2e2170a90689048bdcf67b851634e697de3680338260af4cc012c2fa89a80d606bde446a4c8ada5a36aedb39197de974ded37ce893438502a9400560fe4b5f7313df70d0d9e5a6717bf85e329a23a3cffb63fa8549105c91a41e98cbf4fa724f570e265bde413cb731a3a9d87898a3a3ee1173a55fe92c3f7a08839fe93a0d25c39704371a1ebe62a45af90f66e5e4ee0ec4d2a848619693b5381f49fe5db696f9742342d1b44b068dfbe3f267a717f4827761e77022d4bd28999e16b4818cd316e6f4ad7d9bf85c0fcfd1a649ea5cef22caf3d55ee9a10af07abe5010af5fc663ee32421b44f127307c33d51256aae58ef7e7619e6bfc1e80ff406c585f02c0b93164b8bad4f1c7e4a8acc9d26f311b2ac743ee61a228cbe43a325d5a82c5360fd55dce4ec71fd4363997af4aad5ceac23eac542b36007842763ea6ae7bdb92c58758a740246618b405d3e07cd220e74f84f05883420408b9484b86aed39a8a261a8f2003d8870003e75e3fc0581199c7701782643e46b1dcf6ae8ec1fef1c0f6163e644cfa659285d7918af8886353099d66751dc5ceb13503eddd0db79df65d51766fef0debd1d843ed12dc27e956a6c9f095d1770712a4ae17c045cb29296927804c8ee69fe9047f7a6161c8112997cdeefdc970b13e2a5b18ccbe1c9a0eaf8b1aebbb74e12463376af5473ab49a62da1f1da92777b5e082ea54becd0fc733f212569223c915d590616fb79d3a369b1a87ea87d183e3a7709b9719afaefe0a7a9a02180709c29e209e5cc06b599a0adf0a9665a1092846cd014939348f7d164df5d7195a18eda1ba5f03e6b72367b630a2f00b941805644f508a568bc37441e141246497af227c30b8bd48b342ece4c8e053b58899f961191351cef2fb78f7508989ccce2f44eb7fb35f20356dd7f32d3aa9c194cf62cf2d0941a523e2bc2f3c12be349b9b580a313ba5585f62dc01bd87c8fbd34117a547701289423729137c24a7bee861060343259231160e6ba86b58dc31fb5230d158061dacbeee99ee59e560674212989341ece2bb016ff9e50a5180e06def5959556627d925844aade1d1459acaafbbdca9c4896673eb52aea7d537d58507258fa6369a4a38650d0c1aa0b246ee5b0d7f47a86d8246349a22869fb42f8ad425e67fc689cf5f7b141f94f97ed523a60c35ea0fb307f721bcc43d0c72f901542912adc0928ca33f9234d737e97b8c44a61c3981d682fb01692f3969f56b8bffb9622ad16809078f34d601257c1e33136b79d32bae9cad5b2fbea502c1f0da6004f65184833331fc253df739278dea01cdb4adbffdaafec97990754fc6a5c19d9926dd5aebfed3592ac04cca33b86da9fac692a6a135929750595709b9f426a31d15f38f4f14530b46fb5ffe0b15b2640588d1b896bbc4061e6dbae3e6a535cad1df9c6b6c534443a108e67330f15490a2ad2c54def57d3fc3b28c79d74a3a3f7434d056e7e7c30c884d994eaae54e246206d9671bf441acd5d9626363be0eff8eef8ce53001be2e86c10292f090564a3e45c97ee8f6b79036f0be0810d91f718d3bef3e5afb30925c4b272b4a4f8b2f17c18c8a41edb601ff522194498e6df2e62c6b4928e76dc0294f01799ad78b78bcec107bd5e106c89eaaab1a31d63530a7e1638260c89d23ba9c7b1092873ad35b0ebd77682384fd7da97396f0224d2e5343658653140c15c73e0dedfbec30c7dbe988d1f3201f20cab46c7893c2733b7992287360d808f623ee6767f32908fbecc06b467d61907fc68e0d7f76336d32a5548da7b9d6cf184b6d96598314d923b6cc6c3211793ff886db97baa8a2e5fd724f09ae5c45f221d7105821c1d83016408c7fd99dcf7df1b6fc32f5aaa15f8266361482352006175555bc60099ec8ef1775c7e9b372ffdfecc24812e91a6c38503b72747e7a2ce14136c9972ba853fc5e6dacade8aa294e87f592cf4d8d91ad76fdab9577db65a72318d9617f0d20b088d05e257850f3a5e3f1eddc3c1adad1c5b7eedfd3867b5552f2abeebe0769e87596d0c3398b6b55fe6f293e9e6e5513a4b1694678a8555086af5c8b62a26d17368a28b842cbb4d73c564739d00be2e0642141e9daf58989c9339709e99f57fe96f6a6da07a915e5fe74576c096d3c2e4621f3a0a0a1897bf609491b6a876a4260a3dc9ff999f69b426626e3b056dbc1b3d29b46af6b2e33a43e40b603568f4f67c509e55f0c4b6256bbb83abb64e5fd96ea99006d4dc326949580e0faa0b7b32fd44e647baacaeeebdf0fac2de2bdcd96245c40d0d15fb00e5ea84d5932d8a91582c2f09291f9999b89aa0aae9962cfe547eaf791b56520460027ec9009d64e822e69e99b28a3d9215c3c5d12b83a8bd1b902bada497fc05a129d6bed110095eaa866fb6670e7f97e3e747e0d314506c97e0cf7e9aa5db57f22640896c8077a80242e87ca3e667898225e0e94286180fecf775ae97905abc46fff4089672af75e8c0719d99f6e96b294a8476155dceee9c2474d28f9b4ee7b1f96f9d9f69e454f418ef5f62818f5e69a01ec6d64da015d91abdb2c224233d2c66c41d97161eec09fe5dc745310de75f09fe42e848dd4b0d5391807e942ce393f0235fc969cbbb7b5278ad53c38a6f22d5d537c59f4b5827b4ecc8d46ee3fd84bb241235cdfa7b38b34493db6ef04107568f21609155f058db7cdc9227e8f498a06f743063da727ff5cfec809159a4358b1faf992ea89cabf18efe05cfed1092c938b3cab557eb5853f10d6c7382c0a0a705c480b52b4d9251097d1bee6e7544137c6debbce505ac5d182e6a9f25b0a9ced2d7fcaf6d3aeb010815e7a314fc73dc6f6819a9644ca05b2197f526158f7a82ccef33e0cc13c81c3a4c815f0d4c167456061499cc4e507418f863030f2c5f8e717ff1a8da7d4f79d162c1f64979d6cd45722ddbf512788e042a1632298b65c91dfcba033c73a9dac6ce65d05885cf5b2945b6b6ef24d10dbdeb89f70ee493b0eab40d985adc8830e530fb39b7b22fb2e89bc596f15a4535ba9264f04ad7571c8d3257757fd992abc1091655f633b414f8a8ab1523f102c32fc90bacda5cda33c19e721e9f7a2a8c9f1111f4e8cd6914777a2dda2b32f767cd9551c540eabac8119507cd3d58de8e63ec5bf9b149585eb084c435375cc96d893cbec744b35d252b76d2b5ae160c51bf7345a3ac89d8b8bd2d6d7e62c26af050b6890321a7e36479d8cb67abd517c586abf96238abff4e8d22003c88c16aed2f69a57d197f77c2049fce6af4a3322d6efc16258624c64ff8007b972d66071833c403772357549c5df16f45f48958577477d8891599b4ddfe8090039ee6b3d970ee7573ae08186b31d0deedbaa3c670f1d2164a79bc63874bda9bfc55175b8198ed9586e60ff463cc8f06879d23ecfb34225515e613f3d12080223b2e65e18ad6d75ae4f24301963182d71978a28eba1076fba452a83d78f44c379901c0958d6606c72c205a0963765a2af28d4102b2da2bde5ce4b096e93c1064306b237565263c0a667fa189f99b03c614857f431c3bc66fd39b18e0f248b2a71643ea02c051a5cf89e24ac30209cb43250662c6ca13cc66460b1fda135380c2d7945d54b219843eff5174c845250fb1a75a242f98b0e06fa6c11a3c8c8538394237bc1b0b4ffc929def13542389d38ce37a4da4f679c6b82f171b4e8b6473347b9c90668595c0cc5aa925706f85f3a57d33fb8dfcf807c2ae15a29bc64af2a9901c702a38dd7c1a7c8b51bf1d0bc4178169778692f7543d4ab29fb25aca027ff3027c103684dd8fd1107c657a27cee6fa684c47d35276414319c443052c39b31fa613eb1b9f88f2c99ca2f969f0186bf205f4566ea1b7f1e55751e30e6b6e7b2679d80cb5ad8421e637832bc089e2733f9d4c8c4cc0c29ac513987f722751c21dbd3c264f9dd70b44426dd33f3f40de5ebd795b819727140a0746c9cfcb3fb0dc2a9c46e42bc24c496e2e6099001fef6ad1e95665f510237745c0ee1463bc2c505b99fc2f924926d7928e44f6d6c2bc79601e3da3427f9ea004312f4363d732ce634c6f29a3ccf4b8e48a1d56a9c8db31c14c288f6df69ef7f28359d5e12db566932060cce62ffad5eb36ec83dfaa1d5e35c63116fb7d5a289e8d1a0e217b129f5db04e16e746ee745bed7b7772baa2104e486f910cf333ba4c8bb6d1e20713e3839f9c514f75b626dd545d375ba7f88f57ff91139787844b53b2c3fcd5c52d0fcabf0113aacfd6867bc369dcb6e8d188f5961c3f3d9ae8396fc87e5b2657e2e16b0e6416beae66cbfc9734e7b0f07a225442ebec400ecfc571b4de946090a88764fd8de0b587b30c8946c40dc47f32711c3b2f17cdb947c67f8bfef8a45b9aa0c2a30ef446b1e9374f107b6f2c901d75f838715e30f24793980e1016832fa2518dd4a7c0fb6218cb90821957bb8b3cbfd515bce52927f0734a9d641ee1b81b4717a876a85b3978f85624d00c0f33abc34bedf9a3dcdec29a578aa2a6ccd411101ffa39211a01a224fe67b9cfdc0ddb15aa28bd8be252e7b2d2051ceb4e512ec2bebdcdbb2f743a3d2974bbf3bacc874f442de38f4fe7ad81674fcd9bf913eaf5fa86037b183744a180bfc5b1d0df8857700f83128e9870861855be9385e408b52b9f569f55125dad6b4d8f53a1b9bc8f7bf7282e72ce69070d90c98c6d9a4b0e55dfa64eaa4e9c743516392296d4dad36c6c09e9e00d17ae5629a637e21c84f29b9e174c988a40924b11044aa17174c4182fd633145d6b0f2588b878645c102801e52196ed76e4cd17c96487b58e32d6119bfc130b57d4c8ca7c119c776d9ec339b85250ba81ecd6dbbe28e32ff632b8434af4e73f6b086b89223f55f182d6fe1eb63444ea259de96d58df24a8387b1a1ab4eee912f9a87aa55d59ed68e92c180fcd97f8256b4618b173d30fd986fbee901187af3889417285b368db158b51839e44b4f4634bfb6c93666fd8ad3de5f5a27c4b2532988be4019bcbe06d35117772661a52009e468ab54b30dd2bca9f0694c9981db2b970104d13850ba83c92b4fb8fc47c48868e2c38bb8d6f02bb4dd3645c82f6c69af16df0c337d4ce6fa9b0b9733b1cddf8848758f01f539679fd5632682f82139c991b821a3bac9525c2d44c70aac17feac309e878dfb56a909d49cb08ba906347dac0e2dc4c3a01f1e8c5485d26bdacdde9f07c6a92725e8c6730e33b1436fc425e555837417f9367d890135e462bcc231fce63c047b5af2851fe2cd2112f1a0fb4d6c1007562e9495a9796ab58ee1979059f8009fc4efcbc83d11843fe9060d50ec5327ba07193204226b97cb6a694edbf506781f88f864d967c1293f100141afb0d6fcdd5429c91b1605cc5e14f77a1a0acea5d3b516f6aac31e9cf20dba6dc92f91d204754fed2de3d9c95fa86b2cb2a7d8808ff0bb5487c565c64474693d4604d83082e9203e38dc80000971b49db846cd5a2d0831d3ded8d70eb65a77fa4956c6ab6cb2f63ac79638843e8e5ff7a2da28bc85adfa4b56b3c754f97b2fdcfe981f907dddeedf5104cb5b7b5dad5ff720c72644e3da4f76f96bfaad4287948c6c46a991d42a0b85e52ff16dc5ac2ece7b32dac21ff657ac5b56fbb9594b22a6a092e868fbe2bbd8d508ef80b29605bd453f3f8a6d9362624ce45f43bbd453b990b8402ddcdc847d243e6bdbd084dcc6f63c27a7385e98026c07cdd93cdf210e727e2dfabe5a3218acbe611460209a9a9c831ae3cea384b82078d60dc554cbfc970c52853a9e9e5ac64ec1c0b1ecd3b7c1895170f5deb7b090eda14e2575c51597f8e13fc6c92b5d1929e098eb4f0ebe0bad2de3be9aa1bd2a4b9536c8a9f946efa29da38e34819be2acfcdb1dbe88fb92133636e4d1276fcc0003e1258901fba9871ceaf6b7687f24147d37c58532a3fb0b20871a7c43f39a7017f7626268dbd168020f9c2e47d469ea85355de60133323e309ed8dd3924fae8660ea13de70d3251929fb0338e84fcceb9808087dd7f2d7e005950b05ef733848651a54afe05bb33bb45f3f6fc9d8020e431ccf544eba05e7dfdfea39f5cdb0a7d190e1ce4f75f3518e8598bab1ec1d319c6400ee7fc598332733c084315639b484f8daece7e55caae74a9aa21410b1e1be243396dd3e9ca8450e0d6bec26a57e9deb2907c623071722eb7ff1393f59d368e56baee72ab85558ab71642bc83378aa4ca95edb480cc9bf0d2b96f2a89af047674126d8c13da033a259ca5051ce9ffe63de0329fc2c15123fa5c3e0bb6dba8cb65a22c1cb281bfa67925a12b0b8e5f1e458d25b90996f76e0cb6cba00cd6ced8efdee9c078b21a64a1c4ad212620340d3ba9cbbf89d3ff1cbce91b35d5a68475c36e66b72004d5f021230b1ae625d32935c2445468257b5c482a9220271616919d64e5803b228d761c7e889b6d64da8b2aae5aa7b1591d27c4662b3bbea8e554f5da5feee0114dc30ea4fcc02d0d23a676b911785dc353484004bc22fef9de0871662199dfaeb72e90f6dbf4857b44da83fb975912c7e9a39341b21b0181eeecd006b671a3d343179b99f8027ca3b8838dd54ce963ddefab31598e149bc65850a5c524d4fe3e6b0707a25901fe7f8fc10f37242e8fde51c98a2c103733e1d32aae5801ca23779d0df5015a47feccf4f9ffcc200975dd9a83f92fb125d09a169e22fc2fa40b313b21434635b8b85a02c2cdd72cac0b1c62e11ad2cb28453c246ec75c0dca99fb7c7cbc488b8296b5b44ba0889e2589adbecff8bff28cdb38664b740d17d947d610a135b3e361d139d45b07a6cdebdef296d930a1da266293417363e4149917c86e5b58b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
