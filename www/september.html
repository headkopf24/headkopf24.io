<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"660fd4febefc651e662e2da57363786fa84a05a6e52b7d570fcc50ff279a8bfa95e89ac3d8930d02f26b3e8f88513d3c0f67d2ac90a0eea19a1f310d9fefb35f5bd902dd3bf631d372895430dae14d1b3fb7ddc0eacc4f84e5287ff2161ed32fb05dd8366e2718ef8e51ffd397d07b616a1e5af687c3074042d23efeb2ef22c5ce30f02665bbcfab0017496aa0b21dddaf9fc3f2bd57d7acde5ce162fa11e40ff74c60a868229eb676217ede3d9c2f3a91dd20396b26ea487dc456234b69d422af6ef12a4ee5233a154c319bb5b9984bde94bb34e62239d0613185d9ab1c08d186a91ed3126f6e60838c3c58b3d14a986b9fa02b59b2fe8fce49d74f0d5c8f484a59d5d07afb210cb5af638064ea21ef1b53b188ba40daf65d447997f11ad1fa564f0da19dc4cb15006d8733b124c053ecb3a1a99e1f509eb6947959b67d2d94fdb010f3f9d5f94ab6ac0cedf6761bfc0bc0c8619252a62617156cc159314c4cfb1d7e4810ff8614234f4b8f584fba3127ee02df98fda3b11b62fc09ffc64d4ce6ca8486c4d2b9a08afcf00cdf58ae1c7be7ad3c6cf5ce3df93da414b602fb827f96d4964fa6ba0fe53a9b2e5a2fbc0c5738e1951e7a8f0b235115515faf5f658e858c0fffb9e902e9a1163c830d58d32f6351315c29fd0c2aa5f846dbc354b4e4787b18460a6b8a1c0c9b3ced93e8a491aef28e640b399b87f4a71f4b19f088f1aad1ae0048ec1d3a8d48ea80c6df5e42a5684e045bebeb0284884236106077236656db7806f6da5e372224a118b0c06bb34829de5c82062d3c799305bf9a29aaba1e65786d285da7a953ca3867b7928206f3899d1df5da96ab410b1e4b50c38258d3e3155808edd3ec6c83fcde108ef17b8cc11f6ff3c6d8a60dee346e70b398d6046069445467c0d6635698a936b84ed62aa1b3318b4286854b05ee2254e8789aeba5e4953416dfff69c0e862b2d12f2dfe00ce29d1e1e6db4d174702609a8344d8fa37bb0c826f64d41f763b19f2a49c02e13549c9b7aa8c503775f2ed35d1bddc5916681431c7a08d60202a58ade3062107513786079ca73f0d962b3d7938410bf97870843bbcf98d90296b245fd8cd3f181ea795c7172eb70218803cd0ec71be2530dc14e134836bf7ccbee26be43e088732fc1d58278e4dfbd15276fb293adfc271eedf7c9cdc3d5aa1feacd691fd0c45c774f488b05f16b1e39a7ca03e0c4ec44de76c396c48ce890f510cd39c26caa01a684df4d02d9229b68b4c2a7b65d6705ea8035fceb193c5404e7b45aa1c75256b7bd3198ae5bdeca8bf491758713b90d4f7f849808578b2feb4f0f1e51da42f880c74d9e4d88642be0c62d30ebd41220f381bab87f5368755b233726a0e682efb919e1ef818dc522d38078d757ac3ef8fe8e68961180c1e40429dd0f04fb068b352114b03080ad545a5cf9b00090735f761acddbc27f87ea78ed53d1360a9e019016fda1e27e5f07efd55eea2edcdd4ed4982b90afb6eab5d7ede0e3045884a177864c6947efd234df72b3c1afff2fc9e2a5d7cb9aa85e190d0f4b6bd82fcb9d2a72f9ad9a154b06e73e78395a536d580819cfeca97440e7bf4dd138509caafebc6d56df167d05b16707d2fc34c9d6ab2d7daa7a44328fb695d4f3bb23ee9bbd9f360ccdd8ac61733a4cc44c6a96b441b7c3ede962ba86547c42ab0c76bc4cbf752dd557a6d22af098f1dfe7b8bce21e3bacc6f3839da53fe5060f7a079097315dee227dfed8a79c730467e4b2858b8e8888face2c04479a86c3b5d8117ee620e2c6b5b1bfe36dab04669ceed1690aebca7feaaeb50a43616adf92c6f4206595dd96be73b9e57ba8a2cad358830ef0442c9645aae339335bf85d274187256f6a712550266901767a8fddfb84635fea447b7846c3530108d21ca696f87b580f0e9de94d53e43000dc5893c23ea7b8ebf3d50bc76917b2f7444e5315883b8956d95f56cf5b1d8828d66ef84b167777b29189101551fa24b3b267f89acd54e4fa16572f27edb2e1474709680f1faede72bfd915c0bf6ab26f5215059121b539ffedde93cf6c752e27e216c5a823ae6dfc0943e3279b69daec8251cfdbc93b6d9edcc53a4deb6993400da12e87cbb8d1abdc355c62a05be76a2494062bec4f14667a186b5ff551d96a5467c4541773775f34bafa34b471c5697abe0ac081839576d984d4d3f4203956d2af9ef9d1416b7f37d71938a44ad72a30e0f40e62f3cd63364a44b8a77dcfa8735291c44bbe8a145235981fb0b5a865f090806eec287cd8a2ecb20eeaa57bea3b6dc264887adb029e22c115e8a4435f6f162465754b2d4e04bfc4eb936611fda534a97aa51a9f9227314de465276a198040b60cbbe496b04e865dbb2b137fe994fdb7bea915a717406f1b9c9cbcb3e6a3f251ad60793d1db39828cf580c0dde31c568410f43f39a9721bb5b0fb14b2db72baac129a73830d1a565e99e1d17e89678d3b675bf924e18f85c7456ed53765e62832a6619d298d4ee06dbf1a5ebdc8dfc8aedfd643bdbca07564d0635f9039dd84652db9f684e560429da071666810206ee53f22b0747a8551bc3458ff64e41bf070e587f11431134a7e070a6c9ed1737a72c8ecc14c3ebce8448b2ab184c0c78f38da94c0041249035d2796984a9b6b172f970c18dbdb6b056ba7c1deff7e2c10886ef6e7a9b8e411cad9b9e2ee218541c130d0fa0ae39470e4e6575713d5a7e80852322a7d4108026b9539a9dd6bf7b6e8858d5372fb4de510ea45130ffbb9e9dbceaf970bcfdf7563a9c4768aaadde7aa7b601877b5d1d3d5e0add16e7a44ade173db37ee1cf0e1913171c4a4c8b50122828e02f1f422dfc85310cdfb2f1bf1d239f5ef3759c106e170e53a7385a190bc1e45ed11b4b85ec6a740770c05680ed65e94c8170233e9ae82a78bcb00ecc0865f6de9f157edaab6b6989dc2fdd7fd08acf75fa311d15f0a6fa289d7cdcbecf616616fdfa018ed76ce525a7296b908097b47cbce0f04519fd7270addb99aa7622bf9d133961cef58d12f07d63b533ef2e9f65cf650d7aef3c03e0c7a3c61ff16985ab92cfb16123ae3dd2d48d0e5144988c7300a27f5d75e9ea66a6ae3743230eda27d369941a6778f028070d1970e05ebb07e0f72bf4c398ed530cc97f6c157904191a4594c2adfedca17206a8ebd86b8fb30c73067b032c08b8e65e7e2fb8daa2a2bfa5dc5a89844511c786f2f74d4f60fb307739a8e0e9f9b7af5ac8f4c4eb8acbf3c92b84ac6ebfff01f487915a51247843f9ef81b065aceda1fd180e86e8864d1f1458ebd1dbf7f756476f5bfd9a9f7646ba85e9cd67f7a0d1c0bfbe6595baf2b9273bed3befff76f139be75dae50bd4428bc985a25dd1c92575e6b768bdec92b89b0dce392b6535d6e2a8bfc0268e80c6e134c8efe6e784304b66ab0ce9c0fdca184b95e05e92cc18b4c1e7e813b95ef031566661bef1f33225c0273edff1d1ed35b2c92093af2a7d17256b65ce348ad89ef0adda995eef33e6ae40491863da2e4ae9de8e8f9242b54676cc0511223fedc9b750558562560eaac1d256d140db8f32d37919acfcb7a3a368b5d843011482a3dfb19521a51712ab89ea99a17007c699bdbee5969e3f21808440e650b9211f3fee9a231b9d2bed8abc148df77f76f0bfa4dd19d5115aae545cf23c8309c773831c2b64fd8453cb7a9288d09c4507bdc7dac09bb78def56abb45d2ab0ae1b61d741fdbfae9d4c73c969fccaf461c09981e5a426a132826ca776049f8d11bf3876ca771e77c1321b1bb46f233536f06c27363d86f7b404f81d31e1da9d49a6e67c2faf57bb0310ad19515331ec3ac8fbf047fffccb030d0e6d3e604a11384cb4e803851e2f339abd047f1869483af551753ab31d017dfda377c8867aa7a982accf5f60466317d5378f4afa45b3e4b4a37d1c20bdc18b1bb18d59353bd2ec6c380c11ddb4297257b3b982c7e94812f5cba60d1b88e0d3cf799e3fe3c77fbbdab24d14a65da46e13c267e3cd5e59cd896fc9a2c9332d39b5dea19f8d810103db12a2f7d4ec96f8fa913d6558923319b75dea4e3087f31ca2c62f88ef9d6cb1f5573edbab314ffdbdd11b9789bc0eca98c7de4a34164172f70284b3ad0a47d2a1483ce1a72d77cae256a123acdc45b172a78491a7b5f3f1faa48404edf35d90b49ecb4f2784f3e01a1618d4b17532200a86d20625b1fe0960c8250c0f250698a256d863880f5ab2fa91db0624c040018847fb7215dcba447a1c5e82e1da12fddae4d051c9b868c116678a6f5300702cc2cf94043e66f9edb1e04cdfafcc3e47deaf025c3e90652e190dae09750339d8a3f1e85547c5ec2ffe3eb120aab5f2fb194095c029c52696ed0da00d98041225b7e6c0e1a165b7803b726e6666250a9d163bb99111adf1bfe3b19d1a898e4b3f94419bb19c075a26509d9eb9ce9b019321e0e976bc8d71f3d9a52d22ee5d354118a2d1cd9a3b3c69f18a92bc2bff5275511beb8ff21e33d9405a8a20d4b7c309c2c0ab17b519e89e63260e7b6d01739c998497b394c5b841685e29afa362d43b29aa7dc5c35ddddfb1cc1ade6193902859360a1790012eed883aa9cf7543e99fd504d6ce0030f1b46649337ae4da1c3da5a04c9b1c2ea53bc38dd8d93eabc59f2b89eaf7e8aa31cdcf083267d3af313c76a86e562407d311a7d240340e1d5298a8efa29ce43005353798d0d00faf03aedb65efb082a85b62ded8842beb3115b7370f11da0aaad0752452fa63efc786d288b87ce383edd9940a19e1b79a6de642a04c778ed3e26e8e4b4d46ef227b9864f1e3e277d458384b569a7efb8f2f8ccd82ffbfe88d2926359e2f38b766ac319db156014dbd9332737d3dd61d4a3026708179e31bb0756f32b846a84c4a4230eb65c19a73093a987b0266e561827495eaba59f5b8677a1a0691fea943dc00acf8fb81068671a4f043f93bd04883ba9b70be673b3e9b212e3887b292b17584f58331abff08469b98001eba81986683bd1173602b2233330122ea62036b545c55a4d88d3b3166a8e7e1f31896ba5f155844cc9c8a2af38877421a79649b53631097c2c5f9a3c53d19a39ecfedb7c1559b68f9ab6d8af5d26f08aa9dfd1141a5257bf901d0773c77a62bd6ce5eb43b64ae31d246155101916e9489cb398fa539f90175ec88b0aaa41318cfa1be4a1e2347fa3bf2650c6e70e7fc93406c5bce3b732da9c8e041ab5044e4a6b5478218cf7e9cffe6b4dc67ec62af97c861ef79cc56e21839fb0c016b0a0a281675ca8926e172d7562394782458617768769f9367da705a7a977cdff29d76878b3adda8de057b94cb7850ee5a667d5dfdf41398223bedc3f499c7017f64393c474e59ec6ad4b686b0167be3f2744f14d4c6a34d1bf485fe9ae639cb9246e9b3da9d1e68f6e004f077ade4b81a6bf8f9ae65ba76a0b8d79628be4fd632ba9fdee7dc629308ad52d97c11a8c2d49d56cf86e083c18de17a414392c60dd3f33ab535ae7615e3dd075a714484062b49082ea4e435b98e55aaa32702b39792dfd14252eab2e6c5682f8aa0162bf619a399bec10e171e29c7572937d99dbaf68375e7e563d2443052877eb45a8870662a5c4be1110c9c397331eb1e12040b65a523b1889e36a591db56f27dcd2c25d3730c5bd539cf5b3fa944a13281014eac62048532d75ff83f1f15aa9b1eab2ab6a517aeab31ea78ab33ff00c4fd48d6bae40fdcb69935a7e10aba60205e713edc54a5df83367b8f5e5a5c49a40fe04d8b824c9b6c601c8ee1690d657d64253234ddc25eb657fa3e95b7c4dd3dee08a713defa273896d66ae11ce84996821a3d1ca4acca47ccb87d92611646e25b746e4f72a0a9249383568e70431d2d820ff557961f0f43fa2fa5b9d84a342fa278174c0319b381b058dc9bbe730d1b2c61295999db036f017794449336e30a17028d84d04764d3813ca3f55611c9404b5838799fbb2ba8abb0c196473557ca0b31d1e293576c45bdc15c91a247d86d404d1631a124873dfaf2db43ce18a38d2682bd02f385911e552623ed05c41147621afb707b1855164e3dd8c50c9c31b703a66fdca4d148b7bdb9803d92d21be79c9ea109400bf0730f35d89e5b76abd5b434ddb3da7b2ca5aa80f977645d440a6e4e4e9773f36ff555503ba28c2c6949a82d9734e1211d98fb253d87be8ead6dcadb490ed0ab5d2e58c54cec0cf4f5df0ee1041a7030b24ceab0f10c59bf8835fb18855c82e2e96053a7088ba27119848db9e71a3273ae7f6fc87a3ab19b3b8492238283181a49d030d67ace269ad415743de88cccd69df62669d029aa60cbcc87f32e83fbaa8fb090e09d0f8dec9402df9350ae812581a22317374a9b88780dc4a024d1f0c0d981145c5e56e9da644bc8dd3e3fb7aa7cfd79ba5e6b14403d23c5f611307f32d62202f889837eb664e61f4f4409994ba88308a0b2901e28c5bc305a525a03eb0abbe3ef22a2c2307a00d6c89d30c20a09e443cd8235030670df36bb20e11042ce22e7a4298fb77d0d8a6694f5d956866f08f32d030e7094d2acc1860379eae5a9b10bea4630063f64a0b9cb4d6b99db1606caa0752774c064aaaf0d48a686e905affd6c391c70e38a045c2a58f144b9ba867f01fe6a9667ef9ecfa79d52d27016fe95e86205e494e92f3ab3e5935538a8488fdecd526ecf77d1c6f1be2fd57e39b20853b15bf19d7fe69ecead4cbcab799157127c7af1f403fa34ee8d2dd36a5158b61998971c3be4cc3959e918886651f9bc267110235c88a79a28614cc1183660fe936003bd0cb1a2a5a221b596ce9d65414f2f5debdf48928dd6c4a59c322d739184f7529198ecbe7780510d7eef6847387551c80f12f8de339caf14fd10b802bca3085573c77673232c57137af9dad591a37f216d015f677d13d96e391155feacd4071fea575830534964493a4f0b216a77b2134f806d8be9eccf3a9ed9b979d5962e24789f45da40764505fb173a8fba7f737bf11a30089da399debeb283135765502084be4bbfff798a0e7caade4ae549a69f6e5933914fcda540fafc9214b2d143c3b26bf83813b25be3e7a363d16b227518cd19aad02a63390dac53d4a6454a1c3462223f4746895e4244a7b65687ac013a1c61765aa04267ef348d61759ddd083b04fdb64cab2fc77ff32235729233cc28b9e6c131e710f6aa958db16749c6d102f6363e70f2d51db3b38277cd88ce0759ab04d5450692827b66bedac65b75c008452c289440616d426810a66254bfcfd5b9f1b0b2b067478b2d19ebf2360cf6afbd05388f7398e7380c71839c9e67ec45abc3f251044e41ed24c7f0d0e05a738a56ff52c1177621dbe476c0aee6d86ed6919f4eb7c3a5693048047d1b9c499739f762dfa31d7f24a2f8302385686d012cd0d158e89cb0c1979eefe991cbccd9bda8ce33c4c2855a58b226d826ecd59dfd823033b80a0da73ff3932cc1155494d7fdc3edbd9caf7908b893f03aeb0f2f00dbe35b1034dc4d872b8cecf4bada63bbea91ce1c65378e6d20d75524b6b92644df1cd76bcb6d1ae34a3c2a8f04a77c658d5a46ab1f89235046427db48b13c4bd8957dd8b45f1b1e09f6eb6dee5e1ed75832d97e4b8de262d00984a4af8cd0bec445bc5a0ca1671478122a910799ce73bc5dab3e773fdd159f104708f24fea3d108e0a4b64bc7c2e861f0167a4f66392700562daddff1423d5182f8a2ff12fd11cd7a82f773a6c6f9ea70cac6446996a75e8656fff2f61586bb89f3c574993a9a827c4d6b388024ba6c579e399dd8ea456fdf5e52a1b26f57f042163b85b344856d59c1f581320339be05a2a2145b2a9056f2dbd7471b93a3a467d24aaea9b1804f1dbece5ed12ed511231651fdb89b647e2fbc9d63e7288be98e5ccffdd4f11a19a25760d7034754be3fc113e3f5534da732332c92be517e033573ff559cdcaf10db318d12fa08a6f363ded7a1c1319a851eb2e52b3292df428f958e8d405476a488d83179adeb5b8e854531b140d1c7c686a75a1526bc7ede175f3df74563325982b4666e72c17000f3b22069d99d2df1c29bfea194f6ea1eafeca59e5642fd5964e2974023ba6be564d263db8d4e0469639328de3be1c5422de58bd01a40d8ab6bd6c90750690d0c5f423561a20e595f89123cd47dc9d933a8525b4a7a93cd266f71d8a90e49512b682833d31b6a8e1a264c05c6ce98a7d682350d4fa2984664d46e84442e7a198e3e7ecb17cc913d637807e2f34eff1e05cb4c73c959eac921c113ecbc4cb8f503555b263701e37e824ca30e7b26a4f2df6842147e8dd84d25439c277f231a71f39084259a820d621be36debc4ee66fa3d871e5e3a3aaa3afdd22bed8cb4609912545d878d44eb2c4cb11d3c9c2732f4443ac44e6d4c7c94146bc8042edccc7e7423a16dfd88e37304a8ff716de072f34935598c12eefdd7f55c3b23a812943a0ca128242502f088124a21442b253d147a427fed50da90155f2fd08c10065151ad09cec79d5f57d40f1a3f44095c72e1fc295929e279b27b6f1d3403cc7abafeb79df889c7b0a581ff0a483de9a16cdca4a225cd1c95c2709973ada57a465f32c6ac957233b702418c3d5e82c4d5d8fe9a104bb8275c5d2af5cb2d35d064e9c30734874bb567e6374da9abbfdaac702088165dfaddac6d5cb411c9d77ec5e6952244f77421754c36f96b167bd0872601c02298b569d4522bd43b9a9995532e685e6ab4d7207eac9f25ae467e69adb727950e83ac8266af7cb5c4dd1a5e40e5af2899bb4c577c65c205ef014f339b352bcce1ae90619b09d3a9d457db4b323969e1cde8cd5a410521ca5574d38d08df718b20c935212d50821b899d6245f5e3f5ff38edd91b62b2569f2e9b992d016d3acd2ebc262b7c654b2e89901c7ca6dc0d92eaff75b8980ef81e317a2f1dbba2a710e1b71db3c7b256a5ae83bf3cbb3011a5f87c9d6548b2f5b8f6001c60755ce4182c6fdc61180469a6cad0371a52e5b35aa7a5d68fc9e7a753c33af3f18fbd10a9cc16f3b963777b4fd7741e96068b95b4067a396d9f635c9550d529767700288d60a93103200e9ba573101dfc8725c2ea712b725fca9e0f7f5806ffb8987d71edbc978c45ee850ba24391fdfe31f8a05c6122d277e072a997edc397d811da97906ba8b1f0e36abe0500fc53b6116f2029f0506c5163b4e0a0b621ed94fdd19d68c18a416f7eaf0f763606309c6f2d303dbd50fd072cb2d613b25dd406d277027a65509b28f1d21e0bbd3b8482bea258612dbe5308e1a58493cb2212b18e9fda203b497c47a3f86902bb85d5810f9735d1e66c8aef9f364ce542cfd6add6ef09e57bcf545fc9d159537d4c4497df8fa239f102fe936ecc13ddc342c01accc307ada13ec5723b9bd386085c56063071678a994e47e306cb9931ace1880673d112a33646d8a6689b48b208caebcf6f3f8a3c96e03ecbb10932f7b6e02758d1199882fe7143fdef7ebf552a24879624def7c65b02ce76ed9f7f4a80fe1f724efa7b9a75b98c848394921bf6696a219f0654cb8939457d5aa05f2f11537abc5629c1a1ea06dcdf6d32f2cabf533a5f28d5beb28e5fd053ee1a28f1ae6c2693157a554b6a1e6478b50386578b45cac0886edb7bfea0aa609ab5d7d332975b8bbb7ec59a0f14fdeb30acd536172ec036df5181ac4cc6a3270450c8663975ee9dde9cdd8f62c8787d079e6eac14ca461a79b9e5e16140416d7f7d8a821ee5310ad2669117ac607d69191b1253f845d5270af9dae0f3cffa7c091f0790acfbfe99124ac3ca525e6c71d76beb78760cea900032362f9e5478aade2357ad0b370803551271067db967d4aa47e2b5592b69483d782c3da097fae03c2f570d1019d73d97abb64b19ff735ba818b5f5d8233c0f28046125b7ca1826a31f7d306b00abb863c3b35c6aaea5f8e2638ca6f5e3bf8f01d96d4ce6c370fb78b936baff7cc945030590962074715237ef4e3bd71f7e20c0904c16e72e92aae7df2e97e2ea6d897bda832462d0bf0d166b40f7b6c55d0b68ad5fbecfc449aa154f8b61f1795c2d1644111352c30f157d127d9b418f121b4c5e0b4666dbdb05fc454f22792a9e223b3d10f9c5695c28c96310a1b499dce5f2d3d0c875f4824920f9272de0adb586b4e5f303a9eb8e9d5331181629e296739e0b106c6cbfaea954eeced9e3c0bbe0c9d8300ca8960c3b22534325d088f7e9d134c7117499ef9e8fe02699c300160f975183b20417a7127c946db73d1f6fafe2ab5a6b296e82801af2a804e6ccd6a5a15f3d9732e9dde4639901688d2913ef08f9f9379a1982694ec90202b154530cd9de33b3492b99f702edaf7b03ccfd42d0a96130fe482fd1909ac4dd5f3975341644b2bb426c6a0181ef6e4a43a8e718b6c1cb2275e160c6c55a913e4de35fe87f0a73734a75b92451d3a330fcd23bd168657bb055dd2a6a6fabcfd365df76379b9b29a1f5420be626e3db43d76ac9664862ca55033fb249b26876002cd5c73128a85792a83b198803ba5305ae706f930b4815a8f4ea519311149239344da8d30009fd9c4e94f57f3575b4b97cde4fcf44231eb82153f4b9e8d07fa5332a5f3308104007b29fb65a9abf5d9a7d319b309bf45a6fd6571d82e944d4a7ba9ca13b5caeadbf8b0edd6309ca6848778572a7fc098d8bda8d49cab143cb691dca0563736b602c0f29aaae93bdc0807d5149c307d83f611f9ff839054c734e93171462822d49581efacec8023287fd5887d7ef5d07a433e9fd1e047ba1f5fed2729e5da69e23ab25e15683a1d9638a8745040bb3afea41381df2f5914303705383ac6c520fbc69653f6d2f2d4e55c6ceca0c414b4ccc391d001c270811d4c32ad99106a69cf701dc98a9fcab6331f4b2417d2585bd08584ebe812d37933bae618b1715eca2f8ca57a0f49e0ae72ee0d8f6b6b66c1e54cd82a749796a3dee8efb68e1cf83e4939e5d01b7b9f6a77ed700141195ddcd4fd9038d3b7f8ccafbdef2cf796d3744501fa5356a512c67dc4880355739d69bd7a5068e0fed3b9e72b7896b94a86474907a2f89958d33fe859b002820b8387b383ed11b55b1d3e4febaeab273fd829ebe732cf2cce0fd8dc8f4c7ca5fd61758112944ea62c22ba8801b4bfbac8024e7bc68f0483a46dd266b24949e50589b9b443e129afdd736d020ca909d147283aedeb342726015860b1424129f5c2107a826dc464b42ebbb31c4b4751cebd508db3acffe8986696bbbb668701254d8e19a8aca08fe1c79978544e866d55b9fe930dcb9e43449934033c21615db719a4c33705dfc15bc573c96f5ad6ce4c6bb5da88030e66f4bd9487418502ac8327a6bf672da68a5cd326ae10576b289110ad408fbb43394c1abc684899e1653ca30bf2271b080a0416e317be00d890a08b5fdf4ca4db3798110869e704e27f60df7b6a3026b25c9712aeb57c68ce14fd87663b37ebbd290eb7b085ff2a55c8b2e47096c1639d58ab58448ac99464befb3b88194057eb25bb5874d88697e52d4a6432ea7ff2a252a4e78fcedf5f4c77e38086bbec7937da2af714f1a5e9d8976ffd82eb6ca0237c98c96b613b04c21644c61157239ea9d98a303ea6cbd5e72bcd7c62b7b8ea11a7a6af3dd7c8d4d5bffd0dd38d5c74cb43d9ce40a06979d61ccd1d8ac37fc588f592dab80f85f9f9a8f2f1b7f52edcbf09451d90b12704d64496e731a29b0d04a322b5baa658b40e1f07515763ed61629ab196d0aa807398bd2b5a4bfac074f8abde5eab99a2db0399916f755e658cb6790c38151b2d269c283398742f2c4b099b1320c6aeef742bbdc70ded6894e40f6595ffb0a00f9d156598aff3799cf80677c0451d4e7dd2b676e6cdb214955327b46910aef9132cdd7fe65b767f6ab11b4807ea9b58402cef7b5d230acdb9108dfde589689a14ed2061a1a63cc11206af01a6565d32005a48c55915af3d5b54b5cb8ba4e25b9e8104d8d27fe595aafb90c3b0d4238876249efc476929710e415b878971e5f7aad3c3c40b1aea7ca989f00ce1ae01f982c81597f91fcb9607caa91891fd9edcdb52860716a0cfbd25fb79b8cffdf9ae8660e147bd745442be20ce573716bfe74c3682c5b167c945ec52ad3053b5bb5c1a3ff3693e761f45c4a782e3a6e8c38a7a4c0f6d4cb266376a20a5f473de9d4032e5b157e702dec9cf990423f8a63c42e5bb8ccf0406bed71d865d6fdee0ca654e8dcb3a82bcda92ea669628c3d03a726568698d87ac2aa276df5f6a5f4aaa31b39aa0f72bfffee27e6688510ba88bbf6b689ec4b6a3b3f534587eff94766f1edbd79a63220c6ce11e52c2549f857533480c2026296a39f537b0519f9ad5353cd9d53677f1950224d348f00afc59d9c3aa6408eb5c2d453b8945dca9a23d0a84d5eb12d4b92d4db39184205135a35d28e09c801a83422743a088eb2e27355048850a02e15046f3f421e1d24126222d14ca5f4e2c0b5a4a7524bc8d37c71ee0aa6ec737101e3ffd08f98dbee44444a51e3cb4088ecdd2dae6369090693e29aa7f9829872f8db10ab6ca7763ea83cb3976b62fd8153330fc36a831070bf5fafda37d2f98cbb1e6ec884e1771b54c7447d53de1c180082e89588a6bb053357ba97402ae861dd281bf50e5a4cbe42f66b13870c5b7dfa432bca0015ece7702dde259b9de30c067ba6485067e7cc40c204c8ce533e3a7e572b2d24e1de50329018fc7b3cca72f40ff227b880b00c829bcd9b713bf16060a8d9742851f654a1247c4d8754a40acf4f9469e738edfb528a368b526d61d43edc5086b640bfb502deaf3edc285740c60cd3c6dcb00f6b3881642fe5946003a2d0e1b38f8ec232d9df471441c1f88d7ec0cee97d0da15f3dc8f6b959806bb5443113779715e3d24d30a42ac2979c7e75d22fe328e16ca5e3f30d13d4a7df225860208d8f702f78295b0ef601b837384dc523a080b8ff05eccf8367a55ebd51f2d5081379603580237339a632372f7e03662e840ad618e7709e1817ce9320476c8044df492a17e26de07768194e4b98bc732e80342bd12305d6c7c1df2a6a870720e38142cd1610989fceb3e90dfeb5228c9dcb02d74952dba3f08758c099f07216c0c110acd9b7ce38172b066af1429eb57845fac2c4f57bd654b4f093fd8bbab352eda5280ca6f0a5bf088a211f9dc1607908fe575ae0111faa0b22eef65d2463a14c7c7e9adc6107672bd109d79314b9157a550cdf216637f60aead60c79a9405e8d100791a14d2dc9837236faf4a7c7c910d381e01199c09c3b472916e5f7a25ab6fda4314b7998d83fd5e70be6afc53fe421cd31c83ac9ea6fb6b1f3d5d411211da9ea650b20dc29b35834df96d7d0074909ab9c046e9363307fadd26a29ea84970ec6bb97fc304f42ca3f98e505132024730f411082d0d7521fafefd3f0c12a625f2f30bea362d39d2adbb74c67eba2cfec975dcf8eb94f7270c09088b2f7a289a4f7daf89dd3ebfd4d02e87f0d1de0cdeb132589af0550e4093839d0aa7e603c28318fd2be7a3a11e8b25e5b14949ddfe978f2a059d328dd8eba320adbd9ebc8de858071cd348a9404f00a9b75db3fb8e41a48b2043d371c1e320c383a4dbe22ed41f554317322fc56ee5059ced43824c265638698577e9a6d940144285ce1af1ad2c161f02670835e5b646cbcdd04cb8eaf8d010d141c1cdc96371a24edfa77bd26354fc6e2cde8e1b3ab2ff33f5402fbc1314ab28fbb6b5764435134fc487f0205ed47e25a3c0951289ed2a44de7e2080a6e5c9094df485485e8969ef43f97e4036874c09406255252044f3188ede0599301864e764371a6a6d0a111b5d37a382c14dfb2e25a6de200b6e5ddabe279c118dcfb1c957703abce214aae66400252d3981769c925dfd0f531270055510b77573db874df972a3503ae3a5ff11ab09bb9bad262be0c631c0037881477fa735fba50fb0e65093292ff4ad639ec7be6bfd46543666586923878abd79cb59cd81c6bb705c43119d31456532358c097acb355e6fa6b7a9fb3fffda96e4ef29f5049b45365059e1537d3e3c9d43803709a84222cda80ad0679d19dcc405488f8fb3bf4d5fc4083dee005e0ee014092a24775fea37e22d9ebbb79812c937d0d3db1cb31e90a24ae65bdc608ae2d845d07589ca72f5cedfe5f0b40238e058b92b8b5fb465c7b0fb9d805047c519a23c060748d2585ba7cab0302e7fc5b3523077fe593abeed5808a57bc6fd03919a8c40d2582f5ce2a3c5ca5ab88a19864f195ac2dd4f0201a76aab66a0df03f4164feea04bd10dc694fb6105d78f0625f800cee639dfd1b1281e10f32f988616e36e25ab9ecb84f1e586ab727b3f166b82d8ce45266b85a98e07c10a8aaf94881fb91ad362de25374ac508f8c124ae713f19b1a83e886a026e61f1cb64f2764a4de5b300b91ed241efb92b5db2b109e7259680490664abbe6d414431e9444497935bbf073ce176fab29d9ee97938e879dd7e0ba0def3aaf3c96a52e6356a069569ebbfe7cf43971b825eed0efc78bbe497be39ea11dbfe247dfe0e559af2c39516d16ff60cf70592e74ddcf5995a94d57d3622724a9bcb54ddbad5d5b84ba5bc258fd5dd65b056d4a00fd8951f1f82fd2b0b22f270b69da9faf298133cfa4f8528e9e89daf8d4cccaadd670ec84ba8c8259061be1e233512c38f5b22525168780a8fb1f50a32315a4cedca4848a172b46c5d3ab4a4a3170128cda5f1c9d42a4e236f515dc50287c7d13f61f90d96dfbfac06c8184b6456587d1c63fe78e62e8fab261111d0253b97dc0508abefaf0b39c4df5e4fbf1c3396d24f53afbd61af65c01c1508fee00bff73784f57c9e5567a5d88bf889fdfa373f0907a7089e6edf84af30d593f8c7a4200e6d81b214f398d66994075faa18b106f02d18c86eab65ac4afe2ffd679da2568fa784a7827bdf0e219eb907af485ece581ca54de7a7888268063f925aba34b329dd22b9c946abf9d5369ee60b266581016aa3493c1895db6ff7eb5005e7dd289acaf982c7021c54a965b84ae2a6dab5c5c6e4866d81093cf36936c5bdc46c24849e8a6d1b275727ef9dcdcbccf424039a6dfe518aec0375bfd13e6e3b37b911a147dabd6df8854584ac8fcb163195f134f05ddf80f16d3cd28ac879fe9293ec7d92c0614f83a4a00d15b6463bc3bc3cb47a143d02119bfe8ec80bed1876536acbf391b1c672492c6b5d14810fcb7c91c58a869773a52cb6f909788297350a3a034e77a5724507bab70ff5b1034e4d402112c0c78ce360912a7be06fe2c4e6cf677f4000f6120e60c190efa0ac871a06bd1e26e5d53683d222ae44dfcf2a1b3e5f0835953650f22932bb2c7e5ac60c487b92777a2c044a6cf39b8d7c5e24f66cd3f46cf071a20a445999262f3b040f9383641243f2af430d85de65c01f3765003b22d930f6dde09ceb1c6cde1b6fe9bba32996271cad55ced11008da21367f2fca37f90149ba9ea72c9467cc7db655d52efe04133490714ead67fe777f663e9801f0a3a87f87dc5d3fc1552764e6854033ffa4950127697288e5ea5230bcd8fb0da31f4c625b471be294e129f9abf3ad0187864a2ef5c0e9df12e65850a007213596b5f0d11c83eb52773f144eb163caa7a8b05dc9e887c995abd06220ef0efce0e6340a547996ddf2764a0dfff872e91f5d9ad11eeb6c2977d50fd8c2520f99236a9b7685ebabe784c89890ad4826aab319252ed3aa9218c04701e909e3d4654388e9f22c1630e9233d12dc73587d634d601c5da7169c831e05ffd961f96c1b449d8add3b2f83bd1e74738116724716f5643569a27a08411d089035df0545e2352ec07a5760c1cba43f2768b7393c3a17924275f20633cda5f0d594512ebb4fcee7da488afc9f5dfe1a12bd6bef3162c6a1fd831b3ccad2ab9deefd4c624a4711197196d7724b9a8b8bdfa786c8693071140dbc667ff4b1dd1d75dd8731eca6a1f668c4781c1ad5d107a75c6b336a9f5118100166836c811ccb3abff073de1b1f423324a37f86ff276c9d6e46630f2e8173bdbeea9c7d6b53068c08e0b0b2a0c3971d34f6241c49660c0225ed9f97ea414b8df2067f4f373d05c0e3f2436eaa50d82ff31f900f8c362f0fbac5dae926db6038b7b536d32d8749439a11200c4dfd243a71310ec267c24eccb8f2d87b4a43b322d9459958ef17950e4f3c6664be38c8f5b58ffe49d922f1d2d9442498b6a61fea8807b8308940d3c09515aee57f625543af9ad2f0f969fd4b45c9deacced91833ec35e655083409b088ab0504b83917379479af136d62df90b3c2212333c3ba513e6358ffb1d05ad01187d6995616f5501132c2bc483226a80ebcf028ccae6b79499d13cb66c855bbb2163d21ffe323728aeabc9141902cb63cc7fda4ef855869250671e48f385891238f9a8b0aff4b995a39357a1a1d6c051a7d348b58c548d825cb8cf2e9929d0283f8ff83a3c1a31124997d767abc612e4f7a0e889daad90a218c59c3186baff452b67060f59d745eadfab46086f68515772f7bb663c93d2e9c7915e027cfd2c2b4c28e64fe3c636f09c957a04f25b4022bdccceb5fb57a3d861eee5743b414dd7eaf236e61550b0cf696b05a5f1e509542a5694c7987615b5cfcaae0e64de8bfa63b76ac2df38e2ee8d5b9923696d639072f9042f958eacc928455c4caa206233cdf20ae4d3b60579cceedda47895836288e16d168018321b2bb82944304e768a61ea6a9be8ea5fa984dc890af7641181b6e9b11df6194adca67642d8d2b1f8b9b99c99f085a630b69f550c8b3e838f107f0d4576069edd791237313b705e78ba3700660d37a4aa1c576cb38e1db51f7e2cf54e0f04ad787e93b24fd9bde07e094c4319ce5be12dc67948b0a0200decff48b9613fd9a9d517ea056a3770bb5b68368d93af3f1567f9e54fa92c473fc7e4323bc164b5c24babf2c8f98e69c2f6e43d9aa8d9059a49a83861fdfe659ef4054043ddf08d76f0a59ad63ab791fc7246c26179404ea212a6fc64ebfd25002faf87f18fde9e074ce9b8a405cdaab25eddc35ed6394e78096563d7a41deb930822f76f1d351600503b17f1506e18541ef1fe7a8efde08c5c717405f04262dbba9a0e9aa46b8697d78d6fc0d0428b7962848a3ad2973dfd332b6d08e90cd1956cad1a2b31f0f2e4550e2036c37a4ad57afbb91c9bd9205f58b3c9cbf9b8843a7622b7f7a65f8f8c6595d147e0aad11b1a01696798be01f058e54431706fb3f2d3f298e2abce6e439af2fc26bfb80d02643e835ac8adf7f1f4ae4180957e6037c6807604bbc0502999f150cc8db8dfaf6c62bff489b7840848eba85b3a8e1890194d7237ef46807e6c6434e639164508406289b80978dfb3b9e2d724c9068303265311dd79a0d86d84b2dc3cc6ad751c203e45cd6bdca4b3bdab434d8a35f09c5d63a89c8ff3dcaf310d78827c7ade31d7baacb18b0ec4a95cedbc27da6fbac3d4b6c0e1a3eaed70d27e2ea02a403a22d1e2883c254c086a5f20ca68c8fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
