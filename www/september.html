<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09b6e798edbae6052e22b0f45b68921943d7b6d3d92f1d99df5b969b5d52d6ecdbe908c7f6a6176d43c4c90514101e1229de242e2fa8d90895937eabb8f3412d62df8837a5deea3e85ed4e98e5d9de28c76790dcf16cb129b19b59a1b155b246af813810d4f2ea1dc5eef156e6c58724dab017c67e6028083a7fffe55e6d7f6e20a8a510e12b0dbe4e3a357e8f587463843385f47ac63052f3b68864fcea6b962e7b9c29d27f61ec26b959f5b9feb67578476755dc67624c1b9b6e858f072128e6259ebf8928a8a8535b662cca2761e15ecb4a66cad71edf4d72c5c71bbbf910a8bee6e60d7e097e12a379cd30f5f6a5b6ee353153f49e39396e6f6eb6e12ed3ba6b234a157e86be5980082a2c443b7754ac4c10dc4c255055ff4f32a2835b041c91b95c9a41f71b5497bfe895be0511e9f5d8de4b38601a9a741e310d0951f7ea7e48cb0f8b4df0ccd3781c439dfaaa4327874639530d0083b687a24fecece657bf38920d74b5dbc8218d3cdba3dd7d3af48915e2b79673afa73ee424af43c368a6b7b51f2dd1aeb6c7d247f9d0df6a5fdbfccec8b3bf65f293561d5b075e21d314ef32fb38241dab84e6442d07740d531ff911dc76d0359fcc67a7a2a9ab7cee120d817ddfb0bcc6adf546680b4965def755542a7a6b988e078f6576d19ded05048685993d06d028fbc665d75e9b0ec80fa4d41e15d63d10ccde5c9fd874c3d682339375ebdf351e96427c4b174814f72b3a9e19204fb8604f50c298925a8ed1bc5e9351f4981e1f7c5d27e613992636e9697a341bcaf9d1ada858388fa226fe3b308ed5c9cb6c958d28d7dcef6d2423199a760bb016420b041c242a954fe63b9a48fd18b54708f505060daac7467193edbf7adebc2b156da5f9bc2efd19c83f2a3bb535268ac56c7a1ce744f039e7ff263af897c6ec2e7c644dc6c3907f8d1792f6d653888f47062d708c405c085d7b213818ddc7d94231fda3f301dab4681830532e02fb7090cbbfa9aedbdfc6af536406475398ee1369b1e5923034e9ccf669f6ac9bcfc35f7b490c17fcac8b4e23004cd983804ec41b467e0e95102e3f222259d7229fb2a2f8ce7395b2e29d6676455baad805acdc3c0d957231347ed05d73e70a49cf152e4b3ae25596f86fc9fc9cc3753800e886d22e263e06ee2ecc38cf2df3c5667affa280303535c232a7e51657915846ab9c63a0f294189ad31badf8b941964f056abeb52c9f97c2e5f98810e6ae1adcb4521ed2d4d4dca8f1148faf51235b956fdbb3a6b5b28c65b532a73b8c417f8deaae49ae08c2d5087cced27295aef92d56c58c272768b68e07b2d843c08864d5bd9b518aebff2fb8c552fe2e69305172dfc058ee2d7c6743eee1c1c679b650b86d22a068cf5640bcead1056e4a1954cb6061d71201580d1cf9051ca242905ffff4a2093f1b2abf04007b1a5039402338709bc018ffec6ce67ca2ec9420d4e23be5b2289e6c323835028641e091ae22fbd9cce2d4416465d772d02f9f24f42d8f683ca45188bde356ab87641e9a965906e9b769609f896b68290b8c6815477da1b270fde265b59c6c992df9717a3076d83fcd595748ee556814fa93940fdf3d9cdc0a41ccd4f642a8be5fa94de9a61ac1230899276b543c4e38d60637dc23d17fc04331b3dce8324a85224a33b0c9e8a962135b25a56b03b859b38f31628d195f0907ee05f949563fb4c8c0f3dc723fab8f3ddb13545fbff6156643a82e984c3dff654bffacbba07ccd7e12063f3a96bf3294e8619edb88f12b84c6cc8bd9980d723aad495ca1f3fa32c02cb0e5483c305b6eab97555872db78aeed6b16a182b22ba9eb8552d6690aca8f2c08f2ecae3c448db2c1a49a0fc3a45319eb8b47d337f3955511744399f9c169289ffb508de05d511a57f98b03da62af9a8a389a2c4b9b15553c0dad56b1c8f8510fb87731fec084be7911d63b38fdbef1bbcb35c8a52759d8d2b987b682bc522bfd994e0b8e65e8fb84e7612ea15e563b4fa89a2d91178b770d93e45e03524cd03f969b0ed6bb4435cf52ffec15ffe2e023673f64395da971c86fcdd8a89e5e103527c3feb5db0d54d508e7a37a0f846b4dafb5f520160a11dda11156fe5630d26ef09e23d9535db7e0b4c5d336c82988fc04bdd01c3ceb52948fdb4ec48169bfc5ee87d39c9a48e5d6dc174109476c458259c87c04f603129e04f115c5136d46030098ad61c629d20f3e9c9ade0e310b57ecbd4dd3c6363cdde758ef82e3f4a9fadd5faf1b6edda85f40f0400b285b9680f5ec05145413c2553402e467e73465b5f1e6c636bb45fba5b8bd6f726b49543e1b9a34f01195c8c3c132535fc6e31910639dd72e80d6ab7395888b35673e6500784b71024339289f7779843c1ecab7f08ec474bb0c30af2b402b2698e247e5c4a30fb93e7f67c8541d9689ed8dab98d44ef36f60f75e97070fa96ad9ab297ba1af196e801ad09a068f70c4629c043c9da3f8e49666bdf12e02f3fc88c787c8def502db56201ae99f952a2639ef7236faa0517af3e4973843849fdf466416e12636a5d726b27647978af60bf0000916258dc4d12a70fa0196b1b203e448fa6732413c4cac0ea0c93b22032605fb70fc8bd83c2ffa355411fb98f3a6962f4bc2b0e60c2ea490b0d45c2e45cb44d4457ef6f313fabd1a43ba1efbca6b143d483cec1743e60eaff952649d8cd3c235aa9d2913d667dce61a9f2ccea31784348392d9c4c30f205152dac2d019f672e536ddbde92307da3b1b969cdad4749414730fc0c242ae1bccde7667d00a57bb1c7d8d37b02403ea39e09eba03d5870b27cb24b5caedfb4236b58e179f9b22b5f9eac00d5cd30c1397ff3bc7bbd574051e139b1b2d5745e77a4c2776769965e3ebfeb8374aefbe67bfb86433f6a5bcea11fb3596dee028033c8bc9d789244bbb63c3ef0e4909812e103ad683ce28af7afd97b17a633bff686c9a8c175b802d61ee5db6e3120d6f26d7e15b18cc994d161f952f49e2a6e70028253ffbe631acf4cb2efaaebf3cb1710a5be00438a1505c0a4a2ef46b141c26f092302252a6da60d959e96413c2f55f7b992c30dd78c44f0af03623b9e7946b8ab9147bd6930684413075b22a99ccbbc89329c2b9279049bc2dd77ee204e692c73058a2bd0b88e08269e698f965685739b0636c679454eaa324fc770a8d66c12fb0505b902d2fd56aed5fe1827a9825761f4ede0b11cd859e049676ead817f8aa9fb04b25cbe4d555b44861612be9859e25b773fd7831b091d2b0ac6129dc8241ff1ec110f9bd6230b3da320bde3223ab8b58bf4b77e0b2ac837b70a956404b435e69c4e3c64397303e1a7dbd2af1e48c1b168f7c2ecfdc3808a51c359227bbe483c94ba9ac604b6445e665da2600737119c26189e25cdf87b8a15feb12b96b4793b65501b0d5c722cef3f06ba131280c5e047be00b6767ac0f3d5326a814ccba8b7cddadde565a55d84d2b64787c3b5bf8b9860e13763011a10cac06036748f29b086a43a74f215b842eaca03dd7780cadfd782f0b96e7d1c725cf29283c293486a6867aee0fb043e6863d12e5b5d458b26e2ec99f48e9400842fea7e986754cd1c17b76d5ac4debc55a6d20b57d8beb21d7601146c731da29efd9b60246af3b2f5d0beb300378f04836a592b61e671f3309e13490aa9710ec78539ba41a934e6fc3183080cd6b2b5973b750f900f0dbe3893b9ba727c4d9502601ba4f1721b567ed8cea1406dcc2702e737827bf4a4ff2eb6963fa1de6075519c994b1ecec0ea0d407b8fb5d0de22ad4ba05a989d548684d4bfc6fc61cad5c1f47b51f8e97df30484f1861fa3f29b4122dbaba0d6d4d9312db71f03cf03cb30f5692d7c803de9321c4b0f3f91372d19bbc24d42d3de92754cc5d74c1ff91555e5e45f7f55e9747ac53921c58773b60d4a96c5de7dbbc2e85bfba8648f5f2e75016a5ef42a2b5006f59ece6cdb2ecfbfbf02f060b1e8948f65f52b97410adff7f2113a897b6b4d242e9438afe02ab821e3f9c3231b5d8ac5f53b98b8d0220b52bd86645cf3c6364afdff7d58448ac2d0a6c1e69041823506b9c990b6fbe6c2eb11bce630aeb146605e7de845ea70ee312f06afbae4e16342417219a59522e6862018d0f40cb622385c18eacdf4861a5f53935c7a64bc08b813f9aef5d04e67dd359d777a8b32e837a5001597cb4a147566e0b29beb6b67b05f93a72c582cd58795a9ccca111a5e1ea677257a8c057e94d1ddebbc946d2268dcfbba7da1c93c15e007f2d6c076ba8dd94bde6a0b75d9531ab8feebf96d973b914a6ce7494e4014749b8129acf4bb45ad0fc041f690a632d2fa94b8b4e3063132334385dc60f993f897c1a9df729f6cfb2682338053fab4d85d812c857658fb583867688a51b644d739c04af4da2c6a8ca80f8f5530448c3e36a604d2e27587aa50b89b41204e81e7a6c91e8b5e3022680ffcc3b7cb82d646c3d0cb64da5e73cd70fd8552bdbd51a7409d76160a030f750009584ccda3cba03113b61b3813879b33d0758a9cb5e3ceba6f5ce8ed3ef2f1e38c75a4efacdd15da32b1d96d60d3e4c579a35f4dde8511f7e7b7311ee19bccb41edea80fff42afd6b901f681eda71ecdbef331058330978b9eac236c040762abb2c241b6ae91df7efd7d3daf15cbb2d31d237e7f8aebe8c888317feb99324f503b60b9faa5fab5782e46e859a4c7bf08e825658d42aa6d26cbdb6782bf8eaab2ab61f7140bf04b704e56f0455283052a43d5fd825fb1c4aa50a02e0dd98dbb26330752e194c8f6fbb746d1258d6e79553090deb2f749aca7d28edd1431abd2dab87e961acf8436e414454cf9d0b93e1fe3213a1a7202cd279d15ea57a73dac78576a11c726d646623df5260e7a6c05a7b7f3a9b46bc12511c39979f252e9d984fd8bd6461b226abab56ee36c7126936b94a262bab3920a850f4190a1e0d79d1d0f5d683f6b6380905c964f87e62fd4cb16f10a454147498cc4e4ede6de2bfe4a04c8c7a72855faa312d8a28056b67fe4a5abd63372fefdbf1b7873633af3e8c5161a8bbb530543152751902593e98ca494ea1eb7a5f65216b92c993e774cabb9bca991ca89992e81f05d709837f7dafc66f6b5cf1926226559cac45fc9beef1bd7eab50a274fd781161c61d30f36c316a56647ba5c631da69be2886c2aec3636c69728caa1cf4718de2f0cf6834d11298a0b211e8be9a7a3e73d8415ff94f972fe58ec241fa6f7faede48294ba696e6daad2c7a228f478c3cd4a6b1376c14f2d0b2472bb232d2f9ba7f8627fa5ad0004fd429b0ae98974dc4f13fa049be094918825c5e4de6ede94ec03bdf23dcafb1588c0b450ce693372a36fc7749e1fcc8882a613641c133e9b0390141abfe79640e9f4affeda6ef3185fbd34bcf5870d5738d24e1272d45d873ae8552c710e0d0de8d6f538b5d8a9a37883ab86839ba0b675915339957f7ba440b2e864b004a312be352f233ffe4fe9db3326d17127e5104a160ad03c07e65d98bb71fd7f1c7d017c2003853906a385c3cf32d92c458f9e4829c2507a63999cdefd4c612388958e9a88c4164c04b9132198d9ec5f97fa09bf7b211ce26e1262e4d5f370b828b361cdcd9a6e45b1b4019b85d9470e621ec47d3e16699f21c73d7ed3bf43a6b509e5175097cba51ec9c88807b6734ddf5a97ec3c6329092133384a919e8c5a665ed81f5c9882f1de6520b6d309fa4c147aba1e245824bfe55ffa04256b39a01e81abd66fade38e63c3fe4d3e8423c19aab42a2f10cd12a30b15fc44b89db0cd20a31f55e2fb3c3baed0d12beb1d6efea2107a655c513bc3fdbfe662b84a990b648d89d590ebe32281508d29263c887987bafe1deec344135ffbf949524d5694926e7427da24f4529e0afc52954a261b6415b7824ccdc24abd5428b7c4491e61bbbbfa943d38cbb3d71a7ad66e8985aa5ed52f3a74f47ec11335bebf894fa1794f0e4e126a814268931e06d6540a5f9d00c72ab9979a6b38d271619bc02d422c835a1136ccda0d0f7a2b04ac8e4167b78717c8db09f607a579122467b1bbc18d3917b8f5d38d17b6cb4fbd711127f84882b9adf5a812395730cbb849151dfa20e03fbc44336a1cc6677a57a842ac950e65690830414c89c223c3e662d75f29585a4a03812b693509a0c130f672fc3ebbcd9a849d73e3d35c8c8eaa773e885407c6a07976cc46527699563d23d27f2cdc43d6324e1ae93d565bb050a07cb8d163e9283216850aa1a6dff9e8fb43f0b13159d23813292968662ec701a0e7fe4f358f23ba8e7aab6ff72ab2394a1874ffc3849f6dd49b10ea499086d1fef1539aaa703c06fee1f8aa4f12a24d0784ceb6420fcc4df9974a18d30fb7ce76b37ef93cc57a7245fc473a6e812ef4e2610925b9c9d5cedba5d77fe8ee0e2531bbcaad7e6e05b16336f6b431d042e96db5438387db5d8077a698dec584edb4c339428c6a8e6195c41dfae7f82b1afbff2093a340bc7793b9c51c407647fbd5196ec946dc48de352aef978644f47d1a94731a9f099a5f964f297f01456071815e55435c9bc4c3bdf73ede1824fd894683021c5e3b4973a40ca58a67d9edcf223e0fd2001bdbdf5200b51ecef79bde557582a73adc583d3f31c69adad90234b5b1cc3e64bd335aebe737321ce57db3bb3941dc1e501c5949bb954e087282f3736a2fc0a1dd40f1a1b6d545962bb849dcba009089980c09d0c640734d9d8f72838dbca8b1cf2d1af21539b60f2e045adb862430ad1c4b1a6f078a7cd92e5861129575f6aedac421ba13a544cef550875fd7e339713192e679d5318cb1e7e55dcfc86ff9138250a4056b7436e4efc86a9ef5e224d67ab2b89aaf094ca15e4cdce153c35b3dc7ddb6b977edff2a01be97fdd4c46069c1f8e69b76d45cd903792d1d67da752b545e9e8f82485d9016e231b1419da91b55734486cde6ed08cb814d6a44ec1e58ac4eb32f6a83f31ca97884e7c7893a63abc410f87f23515ebb55a4aa156b25edf15cfdcfdbbc3e30516f67bdfebf3ccdb0b74fc1625eca4b4d1d9eb3c53945f1177a4af472190cdffb030830283c2a733829959587c900b6c846856df16a5de9621f9eef46ec226d0efd4c9b2e40928288e97ed4c483ee0496d02b7974c329a782ecbfa5ebcd67e513a4fe690afa7d8aaea4fbda9152fb0711cf8dffdbb1d8ef373edb98ee6a00ab07d8c0eacb1028165ca7a64c7857f936c11a27598bb8f130b24ba9deae06dae76d572f8cd3c842b1cda8dbd2bb5c3a87c746f534987c956327112c1ab7c9df551f55ce08778350ec678cd206ee15bc8f5275b19220c2b40617b082c8182841a733c63c9ad65ef397c343a8233cf484addc2aa7d3187f4571cebcf17ba4e3833251609f8b24a2e70619d1e8ec6eb968f1a222caf4601691f5481876e8c5dd8e2868ad7c65271fad7c0841d673a69923372833776fe9a1a0392348a3865bbcb061f7ac857e9a4f7fda854d6e92fa10ca2465b54ddd80479dc1e4dc532905f8bf7f693511ae4a6a7e7c91624ec50795f499d0d7c662428a2f999c4b2c73dc503ead3d8bb61b0d929a612c8670d83f4ccdf74c27ee6926b8c82572ecd4c197422b64adb2274ffdc5188ef5911bf321c739edfec9c1688aa6d40ee5a3e1ad8ee77e2c62d23bbdcdae532edcaa1500ef2ad564c0d8c2ee5c7e09786014c20b1b7b7d7e918311b7b89c72ca4c25e8ab625e8b158172570d50381b9ddbecac81615325f0b62f00aad2a4978408d90e2e4d4cf8c7f05f478e0c0a081ede35f729c6eb5f57067597cafb58423cb7105474b14b4961a2a712e5d591fa5f7da3c0af10813be1988c23251fdd7cde73c8850ccc46d3324921f90a6901528591032b089d53af6181e8541fb886600b4f3655eb3d99494aaefa1c54266d8bcc687057326b242f2b2df2e2d6fed2f5318248ccccc8513f3c269ce908ba59e65e3afe631d3d6b95f2470dd9ab3f4fe45a548f537e627aacaac5c6e6f5a97e46852337032e9fa8f70bc5b7ac34a400a1f20488052a0f1b618abd5f442f5640476f519e1fe2e6d5adcaf68b2d742aa1eb5f290e15435d3c39d7ad58639e84def3945f7ab28b2f30f04e6f84beb6e4adae6a76bbfce70ae7e7beda662084a90ca5314d5c7a1ad871ac68354e7b72106d33bf67d5436aa933abfc7bf69fd4a64540a6f66beb913b537383b11b8f8e55ae7cecbe2b4bcd53d15080d581a705574146c8ada4a825eb3bb8bfda22be36c512d3266ad5cdc487337cadff4e9ba63666296082389d31916873d108b39d616d520e82afceb362962a45fbbeb53a58ac299f32d5a9e59b5da2666e14a8f09eebfc1097c7909479a94236e5e68b8a09f0a682530cf860eba22224ec1cb50dab1aa94d87878e23fc089bf886e2cbf055a010d0c09a9a39e526766f33c3fb5c07314f3f244875fc268256af338a60989adea9e510119225a4433a7237e8f2c575605852c472d06f53ba753e4b3cbf1603bae9a5a6b9740b5a6955510e7eac5b529e057955568e2434d34a1cdcdf9d2f9edd1923fb8f13347e25c9ad94cd754b71bce8383edc98f6d4430d1e7bece6ff5d03bcb7a2c3acbcf982dfc25aee7d0c6c1a5b7121379d8a60540e4881195bc75ca2eb58ba9691b321e41c161c7a91eb49984a08080bd5c484d0f46d443c4ecfcae624f74afea71ed86d81c85682043f6f46fb6f3d40a35de4d5da8b4ab77c96a2feb2ef37541a54cc04b2728c070b3993dcd6a65beb4731bb0d18f1eb5a7cd6600ee2a2f2466e935aac01303b7b77c06ec3bcbfdc01d910074978aa4adc3a9e12703e801d6fc37b464b32477c70801c4092042b04659168d5a2e2bbc2ae37dafa9518c88e1fc53037fd47bca33b0f6237d867d951e5556b431bcc77fcbdfb271e3aab4b4e1d4b6d186cb793f198880206ac59017110082f10757f7b1d62308732792bad3f44ccb38e6cf29bc200aa5952389dfb54cfcf3a1b760bf810667a5805ec545c486d7fb2705c00ea0092971231df8887caa17ee84ed557cc465285b99d1b62cf511619fc3bc01b0f5c569f1573ba45731d13353e5888c6b222b462e6e87f4905e22f291eeedf82f85d12eb3d09888283f15835d6c2471c18a3852a19216e083e0c474409712255f2f15eaea02ef9c3b0e3c488424d3a53c12aa4111b6fc2419c0fb581e79d97e778240d2592a7ab4b0905bcd9451d53f2bce9c6e7d4684232bc1a94ffd823ce0d8e85e139b1c58823b0b25bda51abcab9fbe40864eba41916573d104b52c989b6e26840b468c2c2f3e6496f37b5d8f45107db30d0b2bfca99d9cf7d72078386438d5a862ddbb925b3b167eb56d879ba3b7aab816ca38566b2857d7aa92625bb1a277bdb4925d46edb3953d8798bba9cabc6136369e4f2df28e96a2e152824481b0dc5ef4c3e5c1933fc8b7fb127b3714f15a991209e685c5ec36c08375f82b954b4b8f679e31bf437668b566fc8477105d13829ef9b816afcec996a896a29e7147664cac6a60198ee5dc48066b679bd37f6297b0d618912e31fa316ce9a48cd83de69d2b436539d8b04a52c8fe7486319a8296267f0b9a2de1a24ba124f7b385e5a8194cb4130c4d6d80c819c9b104a2111f5adf29d5d927c4e8475ef502620b463b41353f9816c3f7ffc4f8c076f9ae13c516a3058e598d4c852ddf290e164a6e892870604de3a2734dfc4f34098cc12463d8aef311dcdd52a1979416603c4ce7ee1e74844c2daebb6599d069f9bc024c52bf6156e196fc580287aeff449e3cb039dd7e047cd22567f3e0eb650bd789404171b57b903d536508c0df9716158f8a68e9642486723583f7e894b00443e3c3ddb906e4068406d34606120b8b2ef627f6157dba2d3c48bb4e91afb59ac637dd4611c382f621bb59f1ed66d36673ff7ae579698e5f706430f67216af3239203f28b6953d3515534e3e431b8860168162e6b2881513fe182221ce78c0666e2e6d1f3fdfdcf03b1ba8be7d389c40f788d417336ac272a177c0ba99411cc186146837ae5f44a4cb058422afaf169d982e4b4c3236dadbadefbd2a06536f1bb3778a197773e455eb23b5ce8f4483863f6783024fca6d13ccf63c0b11bf57dc4a9b927a7f8319085a55ddcdf5e14397e56f921c178b1670b1103796dbe355bb4d986d1030ae33a5b7b0124f95e445799e8bb705efc976e397246d48999ffbdae5dc21d78ceb79995b92f457e2c1ed1100d10b8dec4e3c49a411cc69400fe22c10370e4b42f53e371e45e7b2bdc33958d6c7f27583afbb3e029f5b049f1df38bc77f4b5146e74d5905cbe16a2334cdf3b9b788d2b6eccf57fd1c4c3cb2e730e0fe8bd976273fd0cbe1aaa470e839a4c541611fd45e29154a98567fedc02ff80cf6e994bc9fd82b49a666304b79cece9c53d9e2eca96ea937d88d77ed82ea4fa4cd50dcdf4bbcde773d1738b99b3660998f9e9e899c84100c894547538a30a3ec2e06a76f775c0bc7d46b823aeffa476701950398045f51bea0365d899cf8075cb9b997d3c188221aa850bb249f135bc072646f30b5315085e44e2895eee6238761c71187d88c89b0655c29b72df3a7efb9dac7a310e10585511658ef9495ed6c9aad06ea0ebedcdd4d8566506da577e7f11a1ea79014cea639fe5a227d8b785d83810bda0dc134b8ec985f8cc05c515c66080d26433ddabcef1b4a37fd039bc9b5ee322836f516d5da7d06ffedd979fecbaa35afebec22de7f3d6e6e6ab4e3ddcb987c2626fab440c851f1b0dc6e0776fc2d8185398cc2681c7fe4683d91fa02c637eaa28c1982f91f8c5c393b77fffe4ff0d6e46f9eaa6c935e8eceb679d557160e1b071c496e641d70f6250fa6ec0fac918416fb3ab7a13db8add6c72b8645b65e397f77b1f57b14b2fc451a9b43c93d19f1b30c9e826e8ca9eff3cf733ed1bc8cd76c86fe303b70585a051941ff134306e40ae1aa421ce6dc735d5a603507b5b8a813bb5456d463d0e9538534dda9ff87d1eab7da3b14b53ac584710ccd7ed02ad305491969ff618fe21d9f640a86c9a9d00622a6627d5f245427758b1258881add19c01bf099ca04c73e231829408eac52ae015cd1cec109aee711aa3080cbb289ac9e780eab452b815732943f04d4b1e062980f7c49b8373be02a96651d908ff2d07a88a716b5e7de736cc1b040e51fd8ad172be6228e7528b5562434306973e04a4e056bcd1485d6e746f77603bb8d4ffce30758f633144a6161a6e784c33cbc3024746134ccdf27a8b005c40fb6aca8c8e578cd131869cf9b9eab56d1b4c293c72091f4a1ca2179d427b587f36c8b6da96f6f304bc21497cf0c762b9cd70987fd7857f461076a49e1d418802f524dd143cbe5d6308c46f944ec55072abd3bd69dd7fb341e7f76d4656b6ab6af06972e0dc52d1142b0086db53caef4311f7104f30eb2a56800d55d02eeb2ec609ba8bcc7245b07ffa5380718355f0a7d3c2d63c7fecbce9d90e5c6a1e934eb45b0dfeb7e5f956bad88b81f02418eac457dc55f4c8318be3f0f08ed0463e6b798ba550f9266f5bdb2548ff9c59284ab47d97fc816896fa15d111d588b0ab6a4f6e38c7633a39e205d5d083a5d8b2eb26774382c6bc97dbf4b9b75685787a523a0a5079ed67df21fa5053fdedb878bd7a209e87d676c2ac9c2ab04e5c1cf4436cac7ca19b41eeef8cd0e264e3e189f5a17ac6897cc15f5f388fb159e19a30f1f0e773f766294f361988d89eb68d729ad727927611e34cea2388f263005509829b4ed8eea28e9b14d5628f4ed4bdf91398c2d0d7efad9d0c661a8239c039c9dddf3703e7e3fc258e7fd427463f9cf56b300ef3049e20a83af51adf47259cbc57fd3d9f4082fcb5bdf2d1d139889ebfdabe820e622b770bc20b4337aeb35b71a6bb2b28955ba479b60622243dfc3c0af2135e1ede5974c2d385ea8ff274690ddfd8fb31615e8da3122d5b1112128b67ff7231c2222f8b19598dc8e866ab805f6d0fed1b8fdb80c62c92c5317712be14ab7d595e0df59beeb63f85a8ac3943ce01fc9eddbf86156259d5a5edfa7bc3162436a8b1e5007ad47fb729f47052a60f7d3270a7d8ef6d42dcf9ecb70906665ec9a68b031e7f4fc6a008d22a8eac9b2ede612417fbd335134d223514dcb55a6deccf982c46f9a99debac6e623437a366e2485fd6a62b2216c0e7bf8c999b5aece96c7b81b7755be5bb989387f318acee667277894a1f8d668ee92e199e9000ee07a32b9008a47ffa2677b15f16b4bfa74d5f6ba5cc30ce75d94cf344855082c03049bdb3897208ef0c3b2b3ec92fde4f9fefd51083e848185f9fe2b9e9a7f7fb0bf4977d59de46ed6945b46de086c4b3fa4b22a76baaf58f32a1d83990d956315e8dd4cfdf38f52a1e95cf9c612688919ea950521469767e35070bc5d27a3ac88554ce94af3aeb0531fc74270da81ce1ef57b1523bf8ec5eee30b7ca4f2dda24b29aa54efe6dc8aafda185a3feac5df4ccd656d8a73002780d920e48ccd012c7605382d0ea0d2eab8a40f03168c6c913839c9ab96497448e900674ef3295a5d04ab51262810c37c71a314ef5a8eec837ad0cbaa961702f9ed08e19b6c12defc270b8ab157f74e773f3b1c23815df03af13272a68aa50ed8571285fbe97d4100b0741b4eeea7b3e68e6bb465ec47f3c3d11290abd969fd15d072f2bbc687805d4b38ed74054617d23aa65dd4571e10690cefa7206843f4e3b19c29da34a4fa3910507b7f94eede8c9bf692b4f254649663585be5c5209e9864bbbd34af383ffb30e0fb8ddb0976418fbf50f2a0b94e71e70cb17bcc9e66664cab347d9a236d02ec49b79093611db12c6e0e31d66b782f585aa701ea8d0ccd6f9cacc43f7c8c046630cd867689da2752e05fb4c96d98f2333081439fdd03a9e35c695f3d2518cf33f40cca2a4c1a60b24278f87f97315459c4c39da59ff734a34c0456bcdb4f49b62b89b59faa4861e803da07b1eeaa13028247e1ec799db4aa43885721d26079ccb42bee7358a6aefdfdcfc849a6cae1ec21d65c8a85a9b263bbb96a8f381f3f3dbd1fe5179426aba02439fd96b6f0c3df59839164c072a0be74b145775cf6264557992263689da09ba41deb9171d478dda4fbea970221aa78ad4e022e568ede313cb2c1a37c0d49e4c9e71e9eabc222d36889c1bcd2d718e2a85925f870e01361428a76c51acef8487536ec63e1a9977a4ccd51f13804f1d29b291eba27a7c46a4421d19a8a83b8491179a67be370f3e72ae37d7c67ecdbb0a3e2dab615ddef654673c159b323ad5a99cf212d57ef4201fbe37a4404dfff270f48890ac1169ad177480a839ecc183d212a637714b64734f80704b30137f8c41cee69f78619f5565b76fd10d52e35853ac32695abdea3f91c6bfc15b48c71003c0ea1a8ad7496ec236510a42896261170768a7dfecfd81080fc298bbe41449aa31bbfb0277b2625041117f42ff45ce63922306e53cf8ff6e0ad02c99aaf556d0f5f1bbec3482f4f2d55a70430e89602df6481494d0ddc1a102e25a6a8c3a51547324514059b866d122297bc5934bf706949455cf064ac9124555036985798933aeb0ee945246f3a0093db8bc198ab2a45351988ac4b465c6fac7fe641c83e0a7233f4e7d7233dce63ce033dc0b74967d4c25a03f4024a56ec4c2007be3b61795b1c21963c055056765a8a68d15439bc941294d9a797fb9007ee759a2450f30d8e9351effe3621606f8510514aff3ca996ab88486ec60299e4d50333fc658580a214659b096068f9f5be86920d0b0188295cb697beec9c64e8858d2000c62a2b9f1ac87ef9049738092f04d4d3b9ff6a5d37565b4b11dab83059b672900f0e0ed006182dd0b674aeb3d36205b3397f92f2693335ba2d3adf9ad9da43f2a56596423416e6a95814155b8b8a386dd0cd2327d56fed54a201e67f664bc4d33932bbfea1b188bf6be9446d2266faae220c4a9ee6f5ed2cde9c67a1b68c1c4b703f533f32962156d62d5817900b904f29b9174740025f055bd6d693f64095c6e5e7225485d1e3e596e2efdcbb9d4201ce4076954970b6e6a587645f1b1ba88e1612141d14751eef297df641474d9c5ab6918d906fb7e045db1478db92d0f0dc5b3b089d61d131d4edf81c0f58c100a03c99356bcd391e6269c384d26a26937597843b12bbe0fdb3a44480996b2fb444fc68c3d9b5873b505581ce10811c3a4c351a16b1665b298370a98f329caaa15113947da8f7543590e1299c1af1407908c2b4fbac6be0db087d917dbdb8f93bd6961aa461d3c6d6605b90ac9caf19e10adfb194e788bf6f9477946150e7f27223d0c74763d4f8cd24927c94abb27e9b53e7fac60b75d43f7d6f1aef6a58c41dcbf0c48435e3dbde1cb3f47dd0d6bcf7258e14ab1af1d601b008da7642645cda68c94bdb261132812ec7a7f2d07aad4c330ad15d7b1a39652dc41239bea42ecbb4fec9a96ab056ba01c08911e08072a31070a16098c5f5ec5ca43ebda1b3fd12d3266074334a6ba323fa6ecce037746a0559fc62997c0f549f5489c6113c3f048fa0949877ce7d87136c08710454a8f046ce2ccc7c51efd771a78bfbd474843c36d1f0722bc344d2561022559e9c3c24537f0d3beabeef87695bd3ebff35ae0400cd3057f07d74571d604a7c6585e35e09b2a42c017c8cc93ae810ad94432913625ebaf19e1214a90ed3c5637b50d81605a6d70aedd8f87aff758ea9a85e6ca3a849f4c7dc88827ba554dbd1037b4a4ac8951f5fe15ba1cbcb298653513ec9c02c0e6640dc115ade148be55e4c970a06529ea1447948b58959c4cbd84d7aba6d5e144e53ed59a67db58026d4a3243208ebfb94d4ee53a821f95c7a78bf3a2f179aa7fdeba5ac69ff41d0e651999ee104400b5f09005500e4eff8d9cc7c9a356585cfad657ceae3377cded7890c57448b2dbf32cf8a0f5be04b0239c80d08d1026dbb0cc6e5598d3819ede281c4c39fef83e7d69d67dcc205dd0257745972e34ccf4d6a65f535a3acf089b5c2f24216b450f6ef5aca0a18af1b1ff464e6e49080f9917831377df067facd5d55740680eaa75718cb1647b2d1889b70763312116138dc41bbc67e56d01b26e79bd9499a1f5c14e7faff87bf187867271f629c7b5bf91650e8ea55ca17b980c6d2580370dd0bbf2e6afbad3325dd90705c2e427dacd05fd3e115ce49a4cc3410a92aa078b74dbde5f046b0a4be61e90983b45bbdf506cc26dd8fcf2a0859d17fc30425746043864523988e9236621f8979aeb5efd6bb76b9278170d4fb3881982bf9cfd46b51529541543f8de93149e6b78c3d68162fc54b0fc426bb14ef4e7f653761f3e71d01d369388800baefd9a36fece4fa8b7081c9a6ea0703f29578c8b1a9282530576999fc06bdd040d31f428d1a930a6ba823e64d10705cfb265a43f45579ccf697df523c0f5c56e80693c3b50cb6dfcdb607325db5b97955c47ce422de782c61fd1167cc444e4d22eaac8d5da3379f8f834a7b6a55666e5ca965fad92cf4953746bcb40952cbac20e42afc15b703b7e57ec616ed2c5ccef1b40e49875d255a70cb82e527ce03e1873463e9887015e84d286df8b5534e06fa4c09657c3fcf463b15e17638c707664e300d269d3bbe4e1f7b50182c11e12e717d20344c651c4ec00f3fb1c1ee06196bc13d6eea80f5f38c56f277bb9703155445e9aea5860212fefc42baf6922af081ecd034d2d233f046876d03ad5e49e61f79db3e7d4a3eaa1b45e9465363d3c6ca45a31da5d96e76dc66851d89bc5fd65738ac521d069edade8be2690d761d7113f2750a14a84090094f8e203a38b74ae77e0789a8b5d1ca0564dd6203b7d6a8d41be4ffcffe1339984472302e599264757c0aa89014fdd7203479ad2730afa611f38242d99a0abdbb37fd3cf955ab6572fb6bfcfdbe2f68420398b9b3c77e5b0a490b074bd1b8366a28782b2db25fa81c2ef726180ed240523e387653e3139e78f7c5c38a8e6a8e3d017f7bb9fe65f408e8666ef1545d15364fd91afea38091d0c28b67ac36316189d9f9ef39cdecce7455c0848b316027de0de6688d3c8d253f6b7b30101fed4bd58f2b7c1d52800ffa260e40b27465c9a0424b023c29e196f0258c414c31101a64de10260ef952df7e4342c5b9583f572f1f0057d1f53922f31c7e8c8561b2e4050d4d6ff54dd0a73fed2edea6b46a4334cfaf753cd05620623035304317da487c32feb7991333fd89e41ed04e7d59dc6c19c68ea6294a86d1b26753d39b2523b96d75ef0950dc2c4ea5dc4bcef76cf9a75d5890a430dcd02840829b0b4bee074e0df8617326e991161c00d244b00dc3cff0f719bc3c5cdaf4deabfbe9301052622b9226d5ddbf299e6b3e43024703d5c81965d1d26c326b7b23df75e4ef0861f36134cc0942bd12d075277925eb1ba52b2eb2facde52035431fdd3ba21194e96ed61d3d5c633e34f7fbdd6db30eef4c0d8cafcc4eeae0f26dbcf8c1a0c963b2ef5170e21e04b850de32487b10612b04f638cbcc888ee38ea75e765a8b7f521b937f0bc7c349ede2a407f651ce1d7377ed8c856bef3cb83407f0f19391ef1873d0f402ed859551c2a0d3c7c62c72283d038b1481ba4ea88b828ea9636e1bef28a91397a3d944ba5358923e24165436984f1002761685462801bd4613fa66de1d5b33100bd06069239aaae4dae520155ff4b820520eb703fe301d8ffb47c272b1c4abda574c667c7ba34fe1885ed764ddf43ba70b90d9067c8ac33b6042b0cde9f8189d512bac900568ecae7fafc2489551b33fed59054d717f73faf8af5424fece88c49c2c00d06f6e41cc932126b6c5e81ce9fbf0e37a64ee117144dd297550f64f61aee0133fbfd74437a026a5497bda9657467bf124ebd9bb7a948546b902c7ba10c1ad981b2c2df3bd294eba3a3b292f950a8b6a8dd2fc5e88b7a62f033c0210a2660d93a96b16717e9659b03826b113901ddc5e5b0a9649456634eeb8ab0496db03eeec74f0d660f7b7e0fc120329994b740b071272fde15b9d54757876d0342448d09ad73a2318a239237fd52a10b7cbdf312cf4ec603aba9071a0a274dde13ce63cbd43923025e0ceb3d69aa8eaa5a9496e7fc32cc5461875e51e8c30d31c39961ce15b7707a44eee0212655087798a996e50a1ae01b09ef2a2b57bbe192b3faa9929cfea3c5ca5e0e023b5eada8891235e7b6a2cda5ff8602be739d467e0729dc99e2d8f98bd3105a3c5c4eda74aca2d58258d71ceeef33101ae66dca9ba37f19290e2da8bbf5ae92fbe9fadb0c62b55d1d4e4478b461de41bfb5834eaabcf9906ed356563f06bc5999eadb002e7c834a37a6679a7c05d6e86b649d2af670da83bdfbd67eb1f659c90c29fcdb95fa27a4222d6eefd74275df9a8a8158a2fa5131d9822ef70f5df3b1ccec7ef39ba4d099be15b38f200c249442e3bcd6d48386539a196a9479a5b224098620b265948f5ed5401e43940c87252565743106940eaf5f925140ffbc6626931ca1a361f9c83d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
