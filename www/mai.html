<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78da93baf0d045b11d2a2050156eed4a051c6b67af945c421b0a290781a306ad7d8e9ccb62fc53f71fa44097189fab57819c4190e85ada142c4c97f9bbbd21941e69aac2d1d80fb7f1f5105fbe37653cff969ea61ca5a22f42e3816086ddd7ee0e9dd05e6ae3a7235d4667d266aaf7f5224cbc8b4b7871daac2dfadd6e1132abc2d24ec6fe96965a999e1b0b866c1d3f27cb14902fe7b38abb3fee4d7a6f442c68c8726201074b9ca381567618a18f85cadb2a71fd577ef2afcc5925dfe68670285551be98578a2ced5deb177036fcbe268fec80ca2c5d4eb4f20c4424f83f8807675506cde8735f13089b3b67fd6e59657ed594ddd0f147dd3fb7807e2a3b5acf78aa5c94f9c28118febe9c3c710cc3140a3f292fc149939b1e680f5e6d5b6f3c9dc755764d95cff710cd357c826fa4fc6b12f8f5c59f6cdc8c02784e216e81cb3dcd8174d0c1b7c7cd22c00318523104325e42be0b1864a9a5233930d273e978bf9bdd3023cf5ee3e53f0cc6c124d3192a179bbaa1eaa73e3f125d7bb86991ae11d1c99fb2dcfe06654341953276253a7a9c8e4d626de3dd5cd2d37b99484673eca0ab19c13ff366eef2a26ab50e2c44b2b3f9e459feca19081bf19a3ec95837515bc2fe9f279937a7bcc85efa5c8422a8d4ab9aca3e58f1bc7e2c7438b77056f62d8d886bc0b766b165f08555fac251b5d1cae5d51d2e3e65ea1a856b0458942fdf6e2257ad9bfe58c7e0b803460228d4d8f0e0c715f0318b9e0bcfcf024c5578752363157c0cce64a47ff172629d1eff355c1de11994d7a74858b023d8f916604aa7267051a821ea4b20632fa2e11952cd0d9c33f48dfcbe9041b4063f80a40e76ffa399f33cbc59c98234db71ac8bfc23c41db084aa507b72883a61daa21cf9fa0c5b1cbfb5b5f1c57816916b60ea1b5df3fdfa4bfb960e91a52832f39f2a705e5de9d9dd9bca26d1359a0b6b580ab108f311c970931dfcb485d0fdff518c618cdec0fd9442556ed13e6dae2dca27f91dcc5f205d4f4d9f0d96e8042ce9cacd798d0846bd8b1def2aecb3caad8c6640c0a17e472d4c03be4ac5d987a9abc8c6966dee67764653cd87ad3e4944945152b4771281e6f5451a3964e7841d9b4e0ed65a94e2024168400cffa9223555c03deb56b0625071271230c0f90eb6af56ac443fcc05648f210e3b0bc89564e628baab14e238af442c48b2a104e35c1a67721f4155b611eee52d0b3cf014818f30dcf8dc817dfb65867bbb255dd6d1688b5e15046d4c14abda9cebe35693e46519d030132895202b40cac03078a958537c2d88b6e86c6612ba9abd17c07a2153c7361ff3e9ce8b675116c1b22e2aada5e73de554efdcb4a158c44323ce4f181ea4745dfe91f5f7f62ca29afd136ee90139167934b44dde3cf5952cd7297d19e61c9aa5d2cb39e85a76b5abb200d1e29c6917943896624c4a122b53e2b6fb6c8b3e98a309764c4847399ee995071b422d81a555477b20f28de8895dd3f5060b585b140ee63b42fec0d6124e508a8d9aa61ee859d42d3051bb1feb769f5feb89d0a051e7b0fac8bb357560f433a1335c72d92262e42e0d3e26dcebab513864eae2f8d0bf2f81b67e0768cdb61c157a223e63e797250f84e807763de81aee7b0ef8cc35973ae53053e8eae9697f17aa24036b0e6a0b3dd6fb793c3438555de3d9229ccee640f131b82b593eb8e104368784e4f6c8b19e2bf9a7ef947d4fb5abba839e019838268b8060edeb65ef4332425ee973ffb47c4c1561ec0cec4b914f24a07ad08e7d0e09c78a85588e67f943e4cf5728961a5abd90eb16d861b0679b027c5e4c0dd4a9b0e8066d14e99bef3f92075ded2ec70bf8c7dc39ac01f6b658d2cfb2c5c26253fd7c2a65fd5fa1feefc07e72141c9327f530363d9f091764a40f234682223ec2096259e43c223ff4ef6c8f513cf1aa2a201fa6c5350f68525369745b1379582bd330a02aeee429bc2276ec1e1d5cfb5ad7fb9b4b339deb837cdfd523b725a1e3b7c3c6ed601a0c185036bdc4fba0e1a92c9816076c2a3f9726ebd3b05e23c3397fb422d423fe95173991aafbe986ec28d4a8e7623442e57e95f733511b915596efb03877413e916e2c82cb9fc35765c67d73044ca7888db852c6900c63c206e66e683fee3d422698cbccefd68260aa96155fb6a443100c5dddb49350e63ac6af40b9d345878a5d982c3e649c7525077fa793aa335259a438f9a6281fa2c5c943face5ec67aef4bd2318806d73f81ebfe7b5ba9f1b14dac6b9a4d80dbd2fc388a168fe1e7475ccd5ef093b852c58420549ead2f2166b1c6eaadd928e5caeec9b2b1916e2afd5632a0d711d3f67ed87c54501cfbb742cc6c4c646f9546b6f807c1205d88a9c72e04fa1d82b7c0e5bddfe49751f5cf30f03dbd4fcf63a023ddc5b55883c409fe4d92aa7dcd7450b25078eae189dcaefe7f602b5999e7bec9e68bad6386c74a397b6218e490c56a27663495e4e1892c1359d297a437630298640e2ab392af496853e2c7efe5926db419c48340ab128e40abf67abb01474a207189ef78d225eb2180647effa1cd4daa0973705ed5ae442e4bc422154c7e5b697e8f4a7f8abf5cbee105a414c6261272788d30d59099b4596ff1ad06a1ea60be18f1ec786ec40f6f4a5dd035ab5d8b77e3e455c9616fd56b7bfdfd7d1b4ee9ca9738be16eb16e413a6f89649f7e0c56dfab2466e33537d6006bef511f2d563830abeadb9075382da9215eaadb257d09a7625ce1fdb24b07dfe3163291049bb728728a19b54db169782c5c993d208cc9457c8c05dc82488afac45130132bb83cd12737149b7bd8e089e3a4374db246ebefad572487b64f804a59cea8ab304a188db579371bb176fb8cb12946512e1b612593e7c05c1ad8abefa90d0906c7725d2725b2c18df4c24113c8fd5a1f8fccb863738157347fb737b4c395e7cb88ab0c72c5e21d0ca4d364bac12b9841bd41be699deb094593031664f2d61631484e0f8bb2b00db33ab35893266ff3c3217622fed0995c43df399cba6dff292462e0957f1d6dc1fbb19a22064ba51619ab90698b325bb328fb50aa6db5ec93c870ae05025054ea2a97ad9cb3a70e2663f491aea35f0f096ec15230550e43fc2a019e38cbced0c66d1c5ca2afee75e8eb032828c7f98732176c01acea7c05add76edbe9f4c1db77acb6767724b19e9ee30ce3d0b933bbe9d14c571363721fbd100863349811c0ff4a2d55bc05b6d3dd6151c154691af719bcc89ada935090f5df216904c3d30fb2ae4687b404c14daf1a5acc9c922e22e68373c7cdec8215d58cf027245d6b66e7c06723526c1fe88a03a2f4ec78185e7754a7c926d1a8cc158ffc0c6305a9ef1be4b9a643af71fb12d240f55bd76e3e6c9fd4d8a750a20c113b3db2f6568a12659a57862e44dee13e7994bbdfb3185bff4a58d4da1ae85160b500b908b6311e7359dc11c2ed15237b7c1bc3b63e42fab2c9eb57c1d1e311b79065fd27ed87294c58574f13cc3690539f943812829084297f6f73bc9aa6d4cbb8270bf55c5aa4cac3cb1d97d7964682b276b2b256f9efbc46b6d582a3e7e0986516ee4bd06297dd2e4d16b00867e726dfefe5473ae14cbd5917db63779f3207e8fe9f125fa4c750514fa155431d62ffdd42211681d512eef04cf32a26fec26e58ca8d1021e175f5eae1cd5d26a117344597f7ed4cfd323920c12f4b3c37dbf8a5f4281ea43ed80302c1beba4986367fd972ab1c7526ba683ebe73513da0b92f05a0d8f04c523fc68987576a13bffcdb9f9af43d2b57d8d71dab9b25ac8a997fc90b168104bb7a782cb674d05228b4da5f648dd66d3b14d80e499eaa9bab080d1a2ab4a9a4cadbb7a32f7ff93b2d0bd9205ae77b1ff50a795c169a728657acdd7fefeeb8dbb6211142d439cd2dad5ab6d3b884980108dc28e1baf24db25cdc3e5ee5e96c042d9ab4cf8c1da6e6347ca3d8be6f804afba9e407a411ad5a70b275acca7311d6229c065bc4b87053816df2bdc9e4e4117aff131b39767c8bb5395880962c4116079e0470c0039ba53027944e8b7b71dc0e2b359858cf5423f13d1c4e06761342e41f3091a75a77da1e34bfbc39e043e1e2f42ec011f1b86aad78a9fa937ea3f7cad77f4ee055f445dbb66998ffe4bf56b649a617f869cf46042580412c0f12c7d48eb36633a28a4e200b098da09c00abc64660e832b9632f2d25c105c3bc018338b7786a69209c30bab1583164274ed33769f4c8076f3971bc0f0d825d575e8dae8018eb11b122b586dd182f812064a3b3dc993284a7323bb3d6af30a81438d927e132ae65f94ed23aca8899dcf86f66f71bcf9ee424f5b5aab924802567b275663ebf6cfa642dd4184f913a13bfbf17b7bf0a2716c5acc49cff2a15ba34a5bfcc3bf64c84ab2a40c470e507dd549921d6773cded9f36bddafa548bdc022c9a6eb91b6aa49440e9dbd14f49795feac5b7a5853e38e79d56d205b5d1e577178c66734917536431030d56108084be5736045aa2580458adb53f4732caae997be3f086ae3ad93f1bed6240f90d80c986128ca8b07a820c488fe55128c92c3930980f55b046f2d809be74d6d327f2f4ab4a3211b3e04d0276ab0e506d3667405620d7c46142b4d15439d5893dc5268901d94138c6efe7d5dcc0609a90a43de0309db2102ed045acdcf4d671bf05ec24029d3d599b0f397c3c63cdd9c8478671121d276c2e6e337b1f4e415899d46a2ce3352d670bd0b7fb5a49f744693d8c1a21e4b226c69569dd8e3484a34e9d3b92b1ea3964650198ed97fb46f7c8af75644f9550218d8cee1c2f44f186c28915554266c27c0375833d08e78e85776d170123a0fdd2372bd4d1f9e4c5ae5e9f8c1d7d961dab97c3c599995e27b66460078a4fe88087b7343b9cad2f92617d13cf2a64b5911a85b3895bacc3c2400971975ca4cc3b444731ba072337485794357090a94e2b5f4ac64790bc5e97049f3441115b543674400fb8d2bedbdae890eb37690105688222897277a9a494641c4659c8a73453a0b8fe195c1f675c54420a428ed9867f9fd70af32a91d5db3d2dc7febabdb5ea5586b2cda73cc449da8d817a49646a905ce4695ac372f176bb258e3a7849cf29440abd7b77739209266c8389d1f36167dfa56388cc625533a96bcc8eccca60c418076df7bfabdadef4f93bce26fa38c9dce98fd9059590a9d58edab52b6a9886637e53ad08f9c2498b40e8dcfad71c995ed16ddc66440eb6f6a9b68ee3f57af42f4d45bce69631dc7eed8105580571e3dbf448b721a6f71345987eb65cd9f7a9773458ccc166d1cbd0c37ae7db0ee53e5fcf1749c9a0b62ccb837f31c902e13250e84eff1fb5c61acc1e9a88fd2896ff74c2e61c9baeb2259a3f92b378ea0d4c18e21c6d1fb1962d709a4125e27ee656b5aeaba27bd62e28cc8e09987d50a7f6b1bc7c64c7edda28c5a7b0fd3041601fc3332c2899354ec508af41c53ba47fbcb76d06432de30fc127c89bb40d07375419a14e95b3ae0c5d3f76eef50f9d6b0d36ecc997b06fa1c2945e202d9630ec7ffa7fa3a44e1a963291b4ab9a218560ef2dacffac8aa0cbd42f666a39de8b421e9e6eea368f7fa2d909cb611a95a16be92805ffa388cd7b57a1fbc46b1faa83111ddbfdfedaafc2e58f5c1db415d44a967ded1109e66a711ea036faecc38900d4ec618240ac12795242ef6aa6a4f48f84155482ed1450c8cee48f1f6b93e43a2d5087ccdf585d4a7f7a067f264d66b7d49aefeade2e266fe260c7de2c316440d8232eae29018e312bfb4f7d9fa645a173caa7594cabf239fa36379a8f110b5d15b5366aee733a20ddbe043e41563389d35da571b00d012f5b3f8e78fd14df14238c15b0b96126b4d04af71c2f4364852a26c55b88a131d77a290b61901aa914441e1f5177df9861bb7194bb49d1cc7c4e0c815e8a3fb264a9a50781d7d969f9d9a3dacf9a2ed05460e14a9b1ac8cb05e08e9732298106ed17c1fe273f06c28061967a1b37e05ef1f842c7ef72a79d73165f04ffbd25498688425cf4b87b359e793337491c40542855ef8250ff87a510df3452a84f25f62bac5f0438f332230d73ede26dfa6465b5e00313f221c73173979c40771afd559bcee9acf2cd8f057874b86a28ba6c0d10a9454c744977b02aea6c1b3c60a139e25bcf981f903c53c17bf95693e57c10b79b7768acc75c3e4f01b2703af2f45d61ebbfba88dd6ba991e7de51ec574c63cff4bfb451523bb3d75309ed4fd219ea80a8d0fff78f471c44fa035baa2f0fa5511e1f7d804b12798a9f266e0e07f578224acefb94f54d5579ba2ee5caed61cf3b4c1f32b5b3b3f988313d150aac9c2f0361d2cc3210c5b3fb812101f01ce54258d60654c98bb7f70a7c8973c52c290bd8def1735765a0a555bd8bdb81f747f1273ca3ed6002bdd54079666d100769f0db7c77e26817fe8034218158e8e02770c6fb3ef970e89e5c99041f29f6f6147dcb174c35bee5461b894124a2f38b5846186d37bde21ab8ac1d22ed7d8eeeec63f4802ddb7ce99a3a385213b9f10351f9b62c88564e8cd3bf4110b1e13f579723c4d9c4e1eb3a7d073704aee095ab29b948b05f9d3d40cd0490315a53f45dba2434eed38420775f4d83a44e4adab57c7195de99d425a385a7bfe6381c09a0e6a9c1421bfe216f3290cb575f389d1d2110b3381892b4c2acb18e12e3fe55022fc50492fab19469f261edc2d5939041551870897dafc7b94379132adbf2faa08e797bc2b4ddf10890200d1ec1e6baf5d89de18c80c335663f37211717b2aee4308da4137491ee421eb970b0e803c4d424d9aedbaeb92c28cc18b35170b700d41581b4f271d9ca011a98e2e8af748f8df88e7cdbec626e7feadfc93d00c3d69eec7085fc1566a6f77506746d9845f32f06bb570963d72679bf3233e0f361b53cb08a0a80dfcc6d66c3adfc650e1c38b17fc19612c2ee3a6a4ea9edbad02195f44483f90029fec122bde832bf81d2c0cabf4927fee4563056a5d665158d94383e4c8f416009f18a49e2df2554d942a1a1b6a09e351223076a9dba3830a25ad4861fa9059cd77c643104d84e8dff8669a12ba5dd7d7cb980909da2f70a486d9d6437cc5504191b3009300c2703d942cf21c6fbac4919937179b83d7c7e6232ea61d7b33ca53971dca697dcc539590297b55489fcac50920ee7388fa7eb124a3577dbeb0a75c77bfb240d69ad8e3c9f7273ce6d8b74b3ab6abf26c382f3fc381c28858a1769e1347f76299fe283a913d2bef3608387a7e3ce75fb8012bba37432ad0df9aa3fadaaef71972eb966f276b5546e23ef76783c491fb2df2fd926080037063227fb415fd75a34835e30ce6f9e915cc08bb30fd5205649f689fa47e8260270554c73bd0aab39d0f25fe349423dee2ea4fbf30a3de16b277dc1233d688019c9de02750a1c87d780d0ad4368198f1266568aa88b798df8d7c4583fd8c3c3be88b2574210513cb0920952ee3c21be712f4d6acc265a71ac9fd83c45ba35bc75cda5b88b41a3bfc9c3b07d28533fe07d7edebe907d0a79daa017ca6e10fedd76a5581bcfc097f64fbaa01bb50e1cb8f3a4300d2e0d76ccdaf4836a8bea5954108d78205fd385771e20b602a9350d561d8a0b065fbd90dd0a08abeb5b49b7546c2622324d76f03b7ffe144da6543e8eb6c8b92976911da25fb5d9562511f542db0d1faecb79c417be5e3d96b2dea727d122636cb3c907233aace34aa2039c4ef1a2d4e24c1ad6d6733fb5f85fcf29f4567ef0efd5198e1f6434a56723452690efa9b02984d898897924c9367e72d85779762e97831c36cdaba84d983cd04192ba2302602ca904a644a6744231fb5e6b89172144cec0589565b627e3c2f0378c0d89d4e2fd108aa5c01e23f38ed7afd6601b3b1193aa76264402ce2354addd9d4d49a7c4826d232cecdd61f98867bd9a3ca326197de9426ac8744f432922a3cd8a5b5972ff740f3da603cb0821ba4585a8dd4d5c95994fd471f289c5b4b92ef7bfd6ff2a8814781a362e8a43d29da8d23741435a0ddc96c2907bcfdb60e5cf530ba46b1b3917fc51b455301809a3dd99ee0ae7525cbc905544d6723442ef48230630e6a4651baa9a82061c502cd4f24f95321d538faaee2478f5f113b603d7a4b86912da23781b8954f906ccd745ded5fea9cac9d8002337d3364dff082ea3a24664bf03ba0095694e11f39de86dc2d876138a57ca8c0601b6930892ad4e3a599b48b6083bf38a92176d97a21857667b20f81a5dec9a925b3201fd2ca839524a9ec0984faf8d62c6cd857f3775dafaf2277c8a70a734163c7779d2f26b5f448fcc4cf874a20422420aad6e8939e0a3d80bc739a23fa20d19351489e9b16440f26e7efc7648e7e27cedddb5b31453a3afbf5d7eb82595afbdb06aec84e0cc933645a7654c194d59c588b47e1f3e4282dd599680ff2c686dc264d95e845aae209e050c9c850f923869559599a132b74c5c3d414f01533b8bc7dc12cec815a59b0cfe9115a4533f605faeae37f7c1844090279d654591e8865ee73e14c995d727cd04c2c6db88787cdf9a827106fe72e6ad62b7a405d27b32affdd68f15d59105db9c7054ec56d4fa9e9a56aecca721deb14b7b4c738b452f23b32f2843556cfab18cce2c71082fab258639a9e6b528ba280b36ca675239f684140d5c583e6758b88c46c8fb59a272bcbc0a1fffed6735732b9ca575fa6bacbed5f9253a3de6188a5b6b2e3ec60a35d0753bb379bc1728d569c3373dd16a483d4bfa024b9b97e745c7137df26023782f965cd550c40cdb2b41ec9d831c7435f8b5783205409768f904689e1bc4d29122b47b187db30a6260d4139e40570aa88ef7341886ad50d66596e573710b01a62a99d8a58624b5ad2b093cb90c3244daa593d9b662cbabe5b950f4429479595570f7de84be6c74ec85941318b565b6426ce4612055749e341364d9cba34a1d506d2136d0f7cd39275307e8890bdbacd271965e0503709aa392c71fce04e0283b48eedb083a46c3b8e8a702bc17549493c80eecb0a34509f2232fe485b3c2576a58ab494214b920beeab57c516e227a69fccf4e462ecd3e3739dcbaeaebc660fd889e7faeac5028115f0ba4df6f9826e1554bea8ead8ce96934ca25570c17dd6e0fd485849d922537493438c0a8f1c77fa87eea9bef9d0107e39d3e4a034bb5e3367aa075e3177ce455d22b60ac000d0dc9d6948f008a214100d9dd25ffa026320e2428793f5776fe11d274015ea359ba5d924104e516866e687dd0583d8edc7f943ecc0190e12f25ee606444093eef0e72784a8688bf524d5e3643956fabbd7e5630da2a7c4527c50c91dbbf0dbe1cf75021899f333fbee6cd7441cb37a8dd78234a6b0dc4557b13171dac5a85eedfaa44dc3a7d14a2657e28b929fda6d7980f98fac8895f70dc85ba2d82c0697fa3d6293ea7e41a955e83aa3ccf6d715637594bac65062d7a5e433b899a54f46cbb7dc565daa4d89d1a07e730754d7568bc282720b41c4ba78a316123ee37cc8d8ffbd536939f1d0e9593f3289344fb6e61b785aeb8e38efba7be15e8bc4efbe4004e6d31ab40fccb781c3f3534172b34ff925319332d562ce0ad17c4b8fe8c26deef673d5366c6a7e18d06b0b23f0d698120801791ffb29de8d49a57d4b5fb0611e34d7fd03ab81208bfa515b3e60866379800f849578cf0fe7535b2bdd02b85e2a462d0a78b1ac671774ea1edd51c494e4c6e6250b00194e568c6212b410aedb0364808af6a39d134edfd04f835ccc18023501c457e0f7e2fc32e96970fa8e8c36b8922d7a75917f2357f42374fdef37a8494f13abc477f9e4b4ef2846e4bcc35391d4aa38d062414f114b14eab618a39c18382893723fe9f8f6081aed3f8807463016cb016b4295f3c0ea63105c4d3cd39ad1fff2e8af1768febdbe611c69d360e4b2f58b1abd1d2e1f1ec70d2033933c909693d0910444ce81962a5ddb6350a3c27eeba9865afb5133e78adb2c7ffcb01235f33fe2b59c5eb2172712a299011d50ba17fbd7ec161d1cb30d168ef172caeae15044b5bc6230302431181d4e3e8404c7d8775a731ecbf8aece0eee090097e5cfd85aca1dfe9219574986f8581a9aebb215c707e00f7578cab138f9c10d12dadbb9718832d776e82a8d6c8dc10904c9c3a10fc93c6916f92937fd0aa136b0d65a4ee05738ab079484a133ab43449ca8dfbd5ceb25fc8941b8d6cbbaa9963feb9faa4472f51dfea0522056293a02199eac8d3b782f3b29d09d02daa6460b569e2da4efb24d570073085e817cd07735301ab724df907475b1b2204ddeb0cabe018fbf26882090996abb1d0ec45fbb11c5f617ac9673250c9e61e089aaae24f635475ffcfaf7068e6f46f77c1aebaa79d1f2b25bc370f4012df62efe3c15a67535324b8d2d460e7414e1e4fafec9eba4ec3f2d45309a84d190f1b59bfdf09e0ab1c1dce2b5f4ae0824d69a1b5c4d9263ce4e21f333657e20b3c2994d66531654c7b37fd692f4cc9922fb54e4c56d9c30a85270fa7ecca91fb98c23b749ae4d63f3efc792c609f9c463d36fe9a97cdfc3b0de8bc372f7b053c6ca4d5ffc484df293679abbc572f6fdc9be66eb1302b35d029c4f4312cbf77b726905c35de77cbf310d28d31a0502008260f11fb1e682adb0d8a3d3afa259324af005c89e27c8281d45d464db8e399f1a7cda3817db22644abd90e4cc84f3432b80e45867149973fea932fc2dc1f0cf92a93351878b94553263dce51bd42369de0a06901a195933c0b7f3e12974c847aec96c366209fda7ff5b2e93e5bcb7b016d933c4b8b7f670f0fbb99433b324d5978aae251e2f166f789f75754a039177c4fe667db8c01f780827700c2c0ad12dfc06b1f19d4a287b7dee6a4f43315776e78b34a35c6580df553583e31a57d069c587880b806950817e643b36a5f213b1ca08ef9bdbd0d5354b0def493398f91b2ba075cbf8bc26818b06370b4db7700c6ae12edca413b923fc7798404c3ff15de896390421afa0464897c97116dac6aa19387d588704a59376cf892cf83ab582fbf6c850fc540f92808d0b29166fbe67930957a2e7e4ce8de45d63ec34dc682dac019a2d8161e6c17175877fb2c82aedcee1b006fc78100e32b8edd5e15e791b56a6888ca734edaa4260b3533dd2fbada75f8135be9f7c8ad7db889b612ab039892149e0b82f366064fab721c8580cf63031bd05742a639873f6c9189a2f1928eacb6784fb34e8ee6ca75692f12949829d89c92cf918361cb47ae0a3b20e5cb71123f7748f50f804dd0fd3045fb8574369c53eff61686999f124bd07894afd705e2a4962486eda903a7819890a6de3ba56736527ab2ad40047cf8526b5abd0ab9afb4dcb546970716c42dd91d0c9adb4aac0f25a68193ec0578a959174f934cc80154dc348d916df667f56d2445222d3650dd80c9ce9b96302e530859cd5057aaf1abeb4a61d9b8974c0b05d7a84f7c86cf50aa01ac453e3f69c46fb9104447a571a78d9930d948ba650e95e633a18dc1d94829ed8161fc5f0178ab746a41762a7cf39398801654aa842aafa4d8320fe8ed7b08d79e4fb7ec1e3a108ab89771433fbc96354e08aa3cd5b79451297d7fb1bfba945559e8cbde7781de088b18dbe0f89457ea53f0c423e7a3e392c782efe9e9b50e3b0f08ae07bf32c2a0313eca3a63f10e642d7f0ed5ea8d2b64bd6c8ddbd0957b916011ba06fe65807d930d137a55ec264ee3d45b91019d2d10138134706c9313b592960125e69be428136f083cf2c76e927c8a30c0fd7d6e6fd8aa0d80813a5ae2e4b2517f49ea30b40c9e73710a1c331517e50085952de718634f65ea720a23c7556ec1893da5d623d068c0f63ffde07f781034dc952b4e2b296b108a2390388259f0d4afb760f2e2c5b1e1e9cbff30878e9633033440799a66b2b27be464bcf28e699c4f7af8abcce83c73c52caf53c9b1709c4743c8d3d08d605a02133482637b4d45389d1d5902e16f36ec83803435f1d7b586c8c909aa338d16d84fad9a0222675d8c01357f7e39cb881db20cd19567a4418e5d8e98da07fd5c93aa36cc691ec03c41bcb85f05ac0b0effadadcc63fc42c2fadfee4ca4dc5c887b479addf3bd56518b19a6d5c9e10e19c4de70837134ff29a44d317fa024b47fcadf36853863b61f14203a4638a79ff6f057ac1b45931d240687597e39b5d2a9fe6b9390e911de9b75b4ee106e73e5a76d9f49ddb8b29f19dc11526410eaae3ee0c3baade2604f4853d167ff82dac1a42361627c6c0b3e858d6a3074ebd4521e5e2c090db04eff1326be7e3b68c8404dcbb363aefa58c623e7daaa901841a8f869f6355102c1ebfc525dd8b673d0234b76dfc87982ffce0af1d1e0e60cae4a2a8d3f02c4fdab876d0b44ed1cdcbd0df1bfe948392709f568ec3389ded40fbaa4d0e1ad7736fd39ac5742768d69ee181dc2e7e2545067d4e501c3570c7a029ebb2063520f61a06abccf25deb53f0d83302bf78ef6b6fb7464c05ab76a986c5a4de546dd62be361ec4b43cfab7e1f9d77d3220a71977e71cd9693271e7339ed514c965778794eeef0e1d820c9fc070f67141000e25ca923167eaa4623a15fefd4d89452943121e4cbefc8601825b9db940707cb7bc71b6b3383479ceded439c2fde7d79eca46836736d4b2865d6a7e178703cb02c5915b5262c4ccbd1c5f24779d55a6895cd2d1beb98104a4d56d9e83aff0662a659ac57da7f0050ab0215f5d9e7524ec0197665f9478db35b957e5040d3a44eedd10940521adb247dcc3e4e25f90c62d524349a50634656d2609614bd39dc320d6f30659db873bafbcc3a83b9e4cb2e8d1a3d9f2781b7d1ea67c07c9387a25c7e9364f5f9e0d4b64072147ee787bfd27fd03cdb4ca7f6547260f3363509ad7a8268ee316e7e71d8a873d476d958eae1467260144f2697596755ba99c75b6ce588080d216839ea5385e8bd983262eec7ae4f88e54d3a1607b52add42d916d2b16c633c87b5d7bcf15cd40a7916f6872c17f826b4f0e728484aa4ebebf69e0cdf852ee8ce4644fa1b0214b4000e069406bdd9e5c210ef523bff67b863f035396ddaf3d1206ed5a18a0649e2c256e8acbfca4a4deeab0f28e4fb7a5f0e0985f4712117d2037cb84a845de9dfb8552a98da0c9f60a7bbed45a58248baa4445a3b21f7b0b8a4a555b00a7ed448f8c289cbfc242ab1eab2f511bfb7b09e23ec1600962be97dac1e69627cd7da1637b0d98e8462b86b0e08bc17ec9a378cfc3adde580c74b79f7b070f999c6ae341f8cc7c944139139f336064beefa1e8717731b7b9585dca21cf9883ce53b2c6ae3f30049750efdae569616dbfe56869e78ff373a10261466e1d80c6c48bd522f2fe9b1cf4094c9f246d12fdc2e50640f3e6bc61b2bf14b25ac257d748914febd8496e294012b6279be840beb37eef64face28548103aef5f11f4bde2543b057b1fc1837558049796788dc717d01b090cc706be0fadcbf5e901f6a067ffd169b0e29f8956be0bd108ec2fc57432fd612d6882e5ca2bacce39b8b0ab9ab94966af14e407bc573dbf16be89fe7a6241373ea0004a25d94a640da3d295c76d8cd7c27027ff8837a81e47417bef182fb71dc607870858147287a724ae029f9d8e1679c6f17e546f2f3bcc4c1d6e6ee7ee0187dada2c9b6dca53628d9806cb56546e8420314db86ee8865c39e3ece2588ccf6fad7ead50245a09b02f5f15fb3b64c5ad37f586413e72620b8ff893393c9e4dbf595480ebf617c7a51afecc9e37619114e5995013e8d84bdf9cf726d3b4a86ea9b53c996592deec492df54df44751f57cc0e9c7a68e5ac86edb310ba1f0109546b3a2d24d9389498d6ef42bbad1fd9610add0415eb8470d9084cb6cb0833db846268617fe53c5f8ab8930d63e082821e4e3a521d787b725d775b0ba9a141f07f1427c16db12283dada5ac682829241933ac86bfb09331d66985cd7006c061c868877e74bc2be9b5ac98c9d07afc7c71f4eea2d83da0f06a417f5308992d6952335872202a73cd26c618649a66874e46f09a232cc877ff1f5e00089f689bd08e4030c6cba971131c2fc03b7b15d7b69a0c58505af771dd0e7f01eb350df0821ab5462d75e46669806b057d0d1e6068b7d6bbea12237479bbdda10c170a15f5b300dcd448e1368925406932358d0b59b9c2aa3e4eb462d12e25f4a9df101f7ceebc44ddb0fe9c34e0f8212b1319b625a44445c25f85387f0ce81c58d36a5ecb3628ccdb909c95f96f9f5be46394a1277e1bda23b5b8a41da1a9187bba2a5153400e9bef134edba65ba1546194571271d45d44b3f73e64819acc54eb614e2b5d881afe3c149419a777bc112bcad664c1a7e8563fe131f7d63395ad367c379a0bdbea41aae430f168c165d9371fcf8d15a2571162e21e160a56ecafbc71b6b16e34f126cf531bde34f026e76a20f85da85be9a38999d5d77e8f92882a357e702b8a13f12ffad8617857196b9328f038cac8dd97eeb8e8d3d9001709a21b5791f767cc9525e0c80d8e667dcd5fbd4623ce4cf3b4b440522fe14c6f66f297ac6842fec71f508e3a08ad6d40c1eacc39374de1bf25f51b347c546088b5ebcc1ce6887d3767df5049c140facb16e702d6ebf661be50b29000086f02542e2e905a727e076cbb872995cbbd74f31e14399554fe86d062c4abff7c7dcecc6439ffda5c1ed86b74934121c73bc01c36bf1255bcd6928ea7cf2324ca81a44cb6b77bd1f9a6152fee5c7659847639b9bcb1416e789eef3682e0dc7a72b6d44bc536221c67ade261719fc3fc463d34dc3cc4f22a53dde4de1564d1b91f7f06c1de0c7d4001c00c184280910a6e4fd3c75c10c87a42af09aabd6ef1022727202fa83a6afc6c85c316aacfe7b66494865833389e02c5fb3a2d94929e689eab52893f4161f98d58530082d610a480f1643ba2b136f59aa620e261dd11bcbed4085016c9698c272eef632633bef06b9cdbebfbc9b613b828f8f8dc7ef2e629e142c391cc60ea62a44868cd0f6aa8386c515f810a387e20d96cf2a37e4d3acaf09608c4847b771c1e9bf9cfd370a621a03a77e1cbd5a07adb21271748508645f51492cc22a4daa668caf054562981b4f4c8fa6a14e708bac72691b7e4439834c2cc7c9330bac285d62e2b1095cf7da97d624cd2e392df753951a5a8de2a76608195f0c8df8d208e49f577e3b5a72eb1066af35f4478ceab4c8d1aedf0f703ad455fc6976c0ce64dfca6424873a8f42d82d5f8e317a539e3877243b92f408257de2ea6f2b3dbdb7944b9ec60c8505581e59b49c47bbc159f197e26f4adac832a05f9f8798f0657139b95d64d5ede31e573ce3ed787fa3ca684f8ddadd32549481836eefad545e30cccc1111e153a5c0bdde3795ec8f7bfdbee5585c94d958c037d84d417a3802d54847c86b7ef9266e47a01e79973067a1db40b7918eb4fde4e757fe945042ab9328331108f6720e9a6ab81192972646e9e397b3c3eaf3df33e6154e8482cea6a2fdcf38155df66c49293eb1ce39e70a83314ac9339533346cf11eec73eca8080dc5ed435212388cdca9d6a1fa2db5894964336ffc86c4164acd82baa784ff6f2ef061aacdf5258430573f6829195ddf01cbc3cc9f1ef12783562d5c3415a67fd16c76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
