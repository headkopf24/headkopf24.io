<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d71252c3e48b806499f14a316ae0a27c42df49fb3604770ea8726b3e5e65d9e5fc3b7687d684b1b193b3cac860c24068b8ef7f092a165a84c100e2055ddf2a794c0202107f2e88139aecb893a5800aa0df7c901511ca055ee0c4d925b8b6351cc12e7ba2a55e2422b32d73f5ee99e6671f102db38a809ae0dd314115bbfdb352f7dbbef078cacab9f05ad88006203f5a020cbb4ba26afbe9996f4d68c860b8bf33876474a1f14c49bcb469a7f70b16c92875be24d180d0659389ab9de49faa91f340737b58acb38d347d749a92d86f8470a8b0b304c2172c13bc9ce4c33f89126d1838703de8b595dcfd9a04c60cabdb7d85858eac1ed9e666a35b8eda7b1cad458c8b612797fe95cc889e547f93d539d4cfecbef2308e83bc39f0fe3d89c1e6d486ded5efe7dcd22fda03b6f1262109d3c54ca100d458635ae298a39e67820be863dfd83d8d3f3be73fd6d5341a6b628f7d2657d768c27b9146962e49917c87efe40b4434869ff1ffd8aa24eb3672948e61598e72b90e80e957fafeec314104c7d9db395ce6355f30e71ec3f0d66ffccd4f49cff476220dac0cf96598cc3c8a2dd1ce5bcb0c79c32aa01f22d70d145e323f9c834bd67713fd075c5b9bc44fbbcc3a86d7cbe36e6d3607d162f4a063c76f491276979a653de6d35712151e2317384eaad8acc866badf07ad97285cc46ff02b96e8e58bc664b5b7365a6afc6c22bd0f022053769ac7d93097ed7a0a5dd96d8f24edf66ec003d372bc826745fcf8e38092e579d56d2be4bf06038b6f0c9d761d576accec23218543bd1ccd4a35f0ac46e75fd0365189f1beedbf6bc2ac3b1603788fb08ce4c2a08e489ceb73bac4739dad7068893dd591ee0783a92d4f7e37c3f1d99771b39b6db7ed159bc976d7cef8f6c7cadb7c6ac4359a059d404c74b993f5acfe90b3b50621b8674a8199bda7430eece81c382a7a4d610ffe1c4e172b41831d9418b3e8774cc60a0f121ae4a8a1e51f26f6b01c44a76f24a95ed09cfb856e4dc3607dc2d095b4b27681051021a51e92edca817cee3d12b4d99f7ff684d47856ddc85287847152faddd27e2bc84ea8dcde3efa5e54d148916df2d4422a197a8cffb42d934feb43a92de940fc64692f3646028f29184e59c03fd495f095ba0e674c05bff1b4f1670ee618ffe577f345e223d858ea09a42f494e41eb1790be42d3117b634b7ac01a8da4df5045844678553b1b6ae7d4424c7f35fd82fd5d14e3630ad543837683e91fd1f18b8402c231ddf76283accc0b98f8ec5314aeff771fbd23736127b0be5ea9535842ba686c8ce1d9eb34fb9257380a55af655b52efde3a2c4efe84bbf7ac6c0b516c3cdaf5763cafeb7e0003dc958b99a1c9d184a2da9e416692b57b4b726a824003043cbc77129c06799482be67c0277f6c91869c831357ea1f13d8aae6d4e1768fa383591d99d5ce42a9b4ee27db37ad1d8ded5bd23b992417e46d68603899ce1f76a9f0f010057da8c57269bc179f5bc55609a3cd43c34c7c7d7d44442b9a55266da38e7e98948564e95525f3a4fcea82483b02eb814041bd2b1394298a583508c366c4dd405fac6e12562f5f8f55724b157e166a8ccfc91f016ff68a1976b62d4eab70535ed75c195b35b8fb03382c04e0116722b01a7a072bd9a44a1f31f66692a0c6acb8c452c02c7e3dd6f6e804edfb8d71a5d48fdbeb55d4643401a629b00922fabe14f1e6a88a7c7e938d9a28ae4d0c6c64c26393c77ddbc9193718153bd11be04276a22ad31ef6d0276bbc01c2e518424a11ec5f2388fc8c829dbb354bae11f6e39084c9ba39857ccc2896b0f54bdc6d373b8a44365d8c371013ee5550a1c337039ceb71a2ae7a1dd64101dd2b59beb47bc447c1a03e9fdc02b1311d8c95ac483d55e4fa24756c2b9200d0e1d5d7231f535235e33398a494cb05bebcdc4ea8b7ffc45233f310f1fb613348ca2dc6211c252e729afdee42a6f5e48157eba491568ddda7b7ca91ed6ef4472314870fd2e1fa22832176b80b4c64a5c4afe21632efab6c9a0727828becf5aa108691098451ba7b5cd006ab2abc7314a13ac5f7109ace8ed0854e5fa2b96060f33db22c1ce2199a33bcae29d77f720c134e17371d43f409275f0d2c88a0d4bb35dea7cd78b2cd6a448b662e3b4635aa6c45dd00cd3e73f9467801b76d5643148fc643cb588400632a75a453e58605cd0c488fddb17adc09593cb13d25be6ed4c5474a9738c76f2ffea3e4244ecd832affe819f5839cb91cd401a7edcb7627e09619346a4fc72fe63ffe8186e6e6a3fea7aab81c7eaf2a0402ab31966d3a8687a777f398751879a807160c504e6a3a1db86d9821dc14ecc7d0b0b98d99612931e4ef1eb62c92df9162b5e0232eef01a61e1a3a5eb571d981bf424f98792ac0cd7d11825d07182f3e5420eef347523f85288de0259a959fec1576a88952e19afe6e6434ef7f5bb5ba0e9976e20d0e7425a6216881e73458e4120b8c88d823913b82a15cf31bc0bc823cd353d29f894380eea252e3c0786f6103418729ea6a8363618e42e51c8e6ef1b1409a7cc4d19070439b683857bf3ad817c94c388ee049c744f483cc0143226c3ab047fa8eda1b14d167ad61258b53f0edbd720c1946939a71d27d2a4d510716d833aaa31f212190cbfe0ea1efb23215ce157f5ed05d7e83da687e744b8a379a08c8c3e49118b49b9824378a2f70c2e8354d47aa5c5677353f615a938db6615cb6bd5049c1fd92a11172da4a541d948246ccdaa1e048a1d0154c0f1393041508d8e53a2ac1e3fd5e51b7cc178bc8c28d8ca9314b0623c67580a842d4ad6430429f1b6b709d40f06d0f4ea0cb371e538fea2bf5ca9cefb906e3a3f5c7fc6e1953e8570b1cae9e8afaf6407eaa2ea6879d56e28da6f7a86c434ed381cc3448796d91380daf8af0dcec245163a486247378cf5571e94f36e2003d086c8e5669effaec8d676fe2a905da2ae0bf8b542db067d3a97cec6b4d79c7e0ac21ed2a9a46b8f19783ce2169eaade9c3e1330b63989b98cfc706a0d057a15ccc00a1ae80a436cfac935454fd0b987e1dbbf9fa7166ad24f6f79dea4b7f412d34dfe2d38034477419a4097fce1bc88877769350159b71de17434aa6a30d67ef1688f78cec51e04c4060d51c0f504a06ca586dd5cdf1477ca4e3c629451851b27dbfc43e2dd0295ca50d5cac3521265aaefaa5e2fb37aac59ca63e04164adfa67fabb0a10c645309d2dbe90df1dad7f0b764c0afed01d01bd3fc486adb8af74c302de6bbbf1ec240a206a5aa70a76942f74436526a26d7c953b12bc824c7861bad34127b8f5da884436fd2849b4ebaa7be79571b83af082854e76d8f50fc41aebeabd903e1bf3287b6969507e89990b3835ee06abaea304c1591ffab543a968f5ea7ac3e36b7f0a2b5c21fdaf08b129216b1a267d707b265eb0ae4e3d22dcccab416b822ef4e7779564fd8167a8d87085cb144a5314fb640fc1a260d400b0368a18bb875eda055c9a36bb008ff1b764fd761de90760c45d9c7093de4c4b39f8ab674a959505adda0389cd7fa7d225d446edd7184f797a21b714ef4731a10b19d27c4882f228e5f99dc1199289c5149607db3c0cd9cf542811e96fa919d01aecfff581d229ded8992742a70c4aa4434440d3d67c1ac7ca5d2473a98c73ea17492c4bc4c4a84086153c591470a99a17e4d69dfa52a77e15d69a62775e8dd2ce43349ed246e0cd5210933838d0cb30cfef43c2ab3e185783d53eae133e8e77a3c7e5ed7c32af052338887a5ad7f5342b8c23a58af03f9acde4ceaa5f709f26758c744a6ffea6664a45cd5c7d3e8cdee74f826393b62ad2bf222de663ef4e8f6cb656d7c739abb009e49d08128f8ad66360fc3f45843d42f646b2c55c9b5bdc0b2c6ac817873f200b40645c66456105e86d49683d37525c623130d198d8814d30cb2f6eb3ea666df41aa0db7862cc90ead24762c11805c03737ca0b99090be8e4fbf5feb708b20a9f7273841692dbc5ef4bff10f170773edbcda3b8b2a0c70c53a7ca41be1082cd562a1abe5158a7c7187c72c27f5d51b65f8d623d46c23cbfb03d1634f98deb4012c64ee2ae2404af77e7b43cfee2f8105cc565cf2a16fc1677489b5dd0bf4cb13bf3c3ebedb63948811e69fb9ceddac69cf39a153a4803cf0fb1d755eec4ce097c1af0aab6efc0fe37ba343af5022f0c06967285689cabe0a7b17adc96330bb3827bd921390198de2034c17219c8ffb8230850f39978747d0451802d07e4801aa517fdd0522956af72d9310cd49b92ebf8a654834dfc6fa63a63528cb8c2de5b9191f8eadebfc6d72fccad59e93cbe1c8f1efe6a174aee6d9c10e2452243a44e7a7b4e5181013450e3f60e7a98e56f26d70f7492d3080d66bde2093396b250f3b8e964ba9f70fbdeaea792f96b5e557ea8be7661ae52765604e9e34977f49e28ff61e00387dcfec71fe6dcb1ffd7862dd2eed1a78da2bab3cf4106a154b4b0f795bbc329cee837e92f8ac1cff03d58752f871b975fdac9d457dc625a5519993d164de489c98d95312eb0e02d7d54cc6e3b65fdba27aeba8a634f12f8fcfacddb33bc48a5287a9b912fd27f8e287d035c2b87391f10599e402b86ed3b867b5a6184ae0c5104744f7b78d555ac257663b535aae82e4eb8912bcbf9572691d75d5013b115e1ae504d5ec2e3fff66ca28511e7fc6c87bb8e95ec7ed6917e65b6960db034d3b0849cea91b664121a033825a02bf0b415d1137533ac1faebe2bff4c0cd98ee9228ce4ebd2c95cbe7422b2be0571a832f0edff4274f738d45f51563abde8255ce338c27b40afd3bbb141abe54ef6f545fa330c834c8be958c4ec1ea5ab4ee19ed0ce23cc127fda51c016149f433d1fec9db188e1af30bf3e10ee3b1239728a26733271216b6162b02a2acbad3a4b9199f43d7911bdd26823ba9901c31ee4e601c9c9db3cf7c4275257ad2b7cf7360ba78c449ac5d358b252bb300d2cdabfbb4c8ebcc3f89cd10449fe1c32324b7c32b275bb6eb8a9b37e13c03efa56ec2369d08a8dece3fe9eac82fe28e4f99d33e4d81910e578ab229b0bee502d69f7e6f8f9ad3187ad507d10356d3ca5554edeb3e187829350c458cd2a4f599528ee1efbef317fd5febc3137db887fa6c82d9d4c03f301c6bf63315e314550bf7e0eddb1c9710568c0bb018490eb45abc53595d5ffcbe1fb29af6bf8c131bfab8157893d7a83f6470613793d5aebdd5b41a9095f4c37a97246f242202bf82b77b962dc5d13d645e8525aa17ef1e25380f4bb14954bb6f18a5deab19c7a056eb451794adb86294784afc0d54c88ee0f8e9f22e8378220e588200764e4d1a5d0197987f0b736c7015efbfa55c5f3afe64bc351bfdce5d613563bf1719580c91a734857aa29e8b178256bcdf8892de2ddea1efe3aff1978a0bcee0035e2a84741d3c31fea38fc3993ed0b9049dce592a1ec1ba7f30363410e3a355ebce61f9a282446d32f8f918d59da84a12637e60243b4c1ad5ff8d9b2226abd68ca33f50c0ea425decca2425d69c2a1bf1932fba2b8b442a7d374e8f1d6f14f99b48e9cdf12c4d52cd0c4e472d389aad0122e5352b19c5951bd5366e8420445e63271673b9667e4facab03373071bdcb474c66ecfd7530a2f28b91022820bc858217185432b8871b9ad135729c96a31dcdb275d28c9ddb5cd34eed8ccf32829c484d46a190240c770704e0345929b067e44719649876a8c61872bcc7b05acc6f369f9266739895ac0ca8bb5dbe0eb8223a18f24398a63301ada370c1f6cb1b0c2b08c6187a51faad243ba91e4e909bf289765f560f549236ba60bf481550ac3b5d2cc93206c9bd8612ad4e9e976e126f4581c5f0d5c0cf0117aaf46511513edc92ead83a4eebbae096c03edafcb0c1a00e1656e6f708b0fa7fc12c4495bb93a829ec51bcf41062ccb1e72b138a4e8b178007ec6b8734b44944930714329c112766ff969747ec9ac82f6a49158003ef5bfc26dee446ccb19c0e125f1089f54b0c147c918a74a0645eae772b1f829310cfbb66717ef4fe824b7c34d5b41a9e5321ee92b8edcb33890885937cfe35763462cf271cb6eb354643c7c8ecbb890103d3cae635cef973bcaeb57b3ecc1c4803cf4fed2915e24cccd5d701dd941f75ee4ba329abc2290ee12bc62f803c118d6d32db6e44030d2e4dfb2e0c4198bfe231da8c787cac75a136ce4f1acfc2160873300841fcd20ff22ecdbb7ddff4e825bed2e8b936656ba9e680b50c03e79efff71b411791aa0d19bff3f8f0c2708c2984a38ac78994fe37ad259f4101ec338596043552c0a07d24f444cd78200cf241195bb0aedbaf9f4d8d1d96c302ab4874532968c663d8a3ae30b8780286edd37e3c02f1bf0844e7ceae2274dcccf2837216445d71f42c8407d70c7b289ff99cb86822e60bf612e25fc1caba0c81a7eb8459346736591a8753a7d344b652a981cf7fb7ebdb6f8d6891a6da76bf2682c566c12c09ee357b902ec860370a73d10b500ef5dfed685d2e8f99de524de9ec3e6e5f8b8fb5614850de9df40d09516e1397c4884e8484714d4ad4ea99028f4d3256e42cf2d25f209319fac6dd4e600bb4b668c97d8f3e9ba64bf5ccb1799f908c1ac61c323332ce697547cd65f8b4e2c12d34424ccdfa4e5aa16d814d9e4600c859b47f166983419c4bb25f5055f955e87b9efd7f5ec04254ed35870acf002f6e6d53187718c38864c352e991e9e9335cde937bebef18abe3c95a96834fc8c64b955bb0beff63506af5c8c812cbe8c8440efd01a0d46b13315824f5a747b3f6a779eb439e7dfba30a1d46444cea2e90629052930f0fe22fe57ce48f1ec2654be692af79efcceb14d6ff361ab1fa72763e122931a97e20160783e3f4061a38190c20d5c24c0bcf3c59458ded8ec8ba7dc7ce81411b411061329f98600cc2dcc7d47cdb3a5de58ad71c368c753e02bed136c9ec67dc274062c495f22f08dba14667be51f573a866b4a5a536714b6f31bbf180d82d928e9ac9ab6d1acfd990f629670747e5019b54c917c85c50d3e75b1ccde7a4b7f8ad87c201cb0fef7ee522e2ec30506cbf0502e2d273dd1b3b265d3ec2464b20ac601bac532c80f27fe0793cba5929d0cb2123f52a9f793d5734e571f71ee55889d89b91ebf828528ec753cfdd998ac762084f3cc4afe9e95c698fbf028a0a51b14d06c1d0e341d855ada3220fa750dd522267986aab0ea3c6a52800a9aab5038b6b6cf5a00b5d4db0273a09ac8bd906cf85f9fffd91f5e16a68ce9653dd2326c300a9d827148ea245a9ee9c8aa5306732efac32c5fe571d188a24597d75cbce90550cb5db5b901462bdaa8d9b68e7846bd4054bda08e276f41dae8d196bafc377b040b5d4729782cfa54a17f0f7f4fdec2f41a1e284f968a30bc858494e4cb906e7e0866506f71d48a0de63f1dd87274fe1e75c0d871cc7de06a09857b2861f0fd636594fb46ae5db6121a663c0c1e914d6c9ec4d3ca5ac0d98d8db734ad7caaf2c1f57450c393a47c08218073c9540a5981b16894ea1d0189f21350e0f775040837d336e1fb46124cab6b4a0fd5511cbabdf3ecdff26255dbd9f25864571e4df053efd0d6575c38afc38827b18478ceed20b2ebe8f2ef5fb17446fc7fbfe9087417c6c77954a8b8ef5094db761bf510cbc906bc7877a6db59a1113a616bd2f5cf15a80d51653e0c69b07111ba9f5ea406570d32c1bf56f35d76c178304f607937780164de0a725cec6d1f3dd307d7dc142cdc61a28700070cb9166d48c2948d94fc4e398e820444d19d12d0a2826a507494823a9b2425296ea092062e80ac93db450a92b5fc324e5521e4f6d463443a1c69148b88c655ab362be4a3c5473a87f4f0ba8d6d640d7257784070a72b178c73537ff55454bf98dd61c9d112715da76df1bf7a7fae0d53b5ed66e7e52472b9795645a597eaee704dcee2192f95fc8a719cdb28731858a757cd9597e7dc6a4189be917fc32bdcfb524fc9dd26c3b1f11115d297e03d2569b17c6065cccac57a2e9469ac615e673ea097c126bf541d2ed0fd6132f1c65021439b4f541c2d31d2034b687e7dfa0424168a61d5c15b9a67a0d45055ebb3150c449bb007a381cac39739514e6e64d1d90b7d7078b6ae5529149cd14fbff5d8deffa086d3d978965dc846423f9603cf6433d8f4a7adcce963ca7e07cf62586600f6f0cc565e8dd77f4e54e41ab0b91582087fd19ead429ee4b0676619a2c8fac519ca9aa6d857c0d6ff8e714f2d4d2b4bdb6c1cdedb6789b57597e8e3302cccef22198afb118efe830009acc2e1a1371708f17043f6e96323f726e445ffeedb02221e4a7ef62fa8a29f5354d79e403e5465894176f34c33d0df9348261110a0b1bc96e4f7817c293cbc411b0002e469ba4c0a52b327429d660f82f6f158a4abc464e1fde5d2406fccb3080474ca4331dddc838b19c88d217a60843d83bf4fe26a1c8dfc0de58544cb5d970f47b4884d2b9dc800f6fa12bad288d867442ce08b09d5d3c8f698a36c5c83afea822c62a751d36b579fa804d71ee7a727f87851c7ac22caa0cc39bf213618ebab8b7a31505d16739f3dc7405853081d255226e1b11f9684d68f008a189b5fab29f63d756fad1c8218b2915f171ea40d05c0854236680862dece847fa8f563e6e5796f8fa6e6e9e7c5b48285d77cd3c4eda2141a6e5ff7b536de47f60877009e60141d8870e18f58acb06c0f711ff7cdd47dfd6424d75d3aecd46b430bd59b46cd80fd15e8f1dad6e29bc4a28441a2dbcbb4ab86200345c37a6bc6b5ef72ef600e44dcfcd1358787fc4c49ab4c6ff96f7def3ee4b0f3b521ca7705a0d8d93ba68802e146daa87126973791126289742582defb0372a6c13dcd6382caa3db6be08f7b26947b34deb460985bfab3dc2f36c35858015d1b7edc642ec7f097dab748f99de2805f6e64b1f04b24b16d23830b2665ee9661fe2a8fa95f9b04f6653bd8bbfec87662fcaf7e0e45e506b1f45389257b963f7f5bdcdd4706a097337df79075d7662c12bddfe53a4c621cb87cfe2a39bce596c61f4546676e4d9059030596b301627e71477ef6a89f3c3a374d43ec3507be44be0affd135ddbb8bcb7a6ed2e1ffb0ca4da93c26c096122f0ceece55e6614179c0d3e4896c849c125ba6d55fcdb538482adbc4772e3f5e39f000d4d387ab0dea6e85cc180c37ad7bf5e38dcd2ca5ccd930ea4c90b8749420ef78990d950fd9eeaf1465cbd28c514b373d9f8db53c355ffc0120a1e23f73c91b94f7bd8403084b235840be5c86ec62d137eff155fe823d9de4e5a6e05420d74b54714503a6ba7e4105247a84aae89f50c717dc71f2b034fa58d23fe02c2a047ebb07a11b763361664a5d9f08e502022305428f26f7ee88e4125e1936ca7f9063ba53f3796cf9b4f65af954ee21b1fd43a450bc9169b7df5d4fac2731e3aa9955f7227f614cae27b6c922724f341338cf8a0f73dd97cb1d43ddd03f51e3552e7b47e18f82d1f96b7245f77fe78db74e23305c779d6472c08a284579cd3a8b752d021560f01204afef33b5618c11f8e5e96477cfc2ea64040548d8985e2984013b6107e9d003825345a66068928cfb18d99cf2600b6355229225ef3aa79ca2c6b1c5a1c36e059c4fe4800e52482c07e8d52bbd3c3ca644b0c39ec5c70fdf293489e014dad6ad50d5214684100b5b410d5d337430d1f161bf717bd6d8dadcebfaa48d40ced048435287cdabb2f0de0d42beaec0ee2e728bb9dd31e83af52c5d531fef06c8cd276351390c00cf73cd606e7a1aba5fcb9def39e0c648b7eeda67229a07c0daa74fa7509019eeb0d5c5fc07e984680d8172719600faa2f4d367a8aad18357c64aa01a008d9d24c86236cc61622f3ede2649ac0d7443e32087d43e944bac6a08f96858cfab81bc01427a8cdc58b6fc66b947ad27629b314a7049defff915a9bca850e2b51b4e04dca161bcfb8626c90cabd03cbb89b934dbf52ca32961d1929f6441464490e80ccfcfdca8df66fabd58fd58b98bb4af217a87c2c3813e7f474420ed3b43edae9ece35c5a0e8f0b3014e55afd97f9e1f8e27c1ce367ab9290dd41cc8229b8bf6bfa6acfe5e35ee46f94125d75d0258245409eed1cedc139dc41c5135bbda3ee9891d69dae8bd9832dfba9738ec16e2c851c0d1f7d283ac716a2b8f9a103889bf864c57b4f04159ef6c702a3cc35bdf6259f6a903855f32b06512ed93f31021cbb3a0e78ee976325e527309598f48c8eb60f41ffd7742ef1b9d08b2228fb50b29cc0c69ddc833f2942d750e0761ac03534ea1b7d5c4b49045419b8beb102237780f0e891932f80e42731b089fcff16d2ba124f9f54efe8bd056fc89d71b7cf4b1c3c265f6cd3f92d09aa6a20f381ae8b86424961b752678a211b339953c91f7a275e1f52640cd2c69f68fc542f68aefe619912fb38bd83e2818e18533f6c6b2e8a0b45736a64dd5d6a9c2210f70c5d9bfc1ee655837dcb00c1f53e1def3055e08851453a26e7788e62aad726c0be657530ca3d7159b2b789e87b97668f4634a7558d855a8e5c030d85206c80b3f3a4aa253170fd0bcb37b4f925e2871c370b153251cee73df3937af068f64e3de689366512a7cf1cdf3ccfb624cde808a1f9cece46c11265b9e72ef684b97593e4544666ca23e3cc8264dc5f7d83e144ae1ee0f0b3669adf55f70fdc417f766f257146ef757c3da43794e24368dcb3b6a11ca4c1d4fa6527d4f96fc2634da946bcefdd1e62b2143994cac8c305d29806acae2157a78688671fb49f70b58e4a02242fc8a676f9052fdb9efa8c95eba2d26f4deed85db9545d435bb886e3c844b3ff47ad1240fc030864aa2b7cfc743cebcfc9959db8e8b39513a3aaef861c11bb174b4eb8507463887af123c28069dafa7d091754745a8235919ea52e530fc18a34cc4276ed02eae28cccd616d6649270a78197b07bb2668b869812791c1fbbec9236ec7ba94ada4474f27080b5210c097f50a63e4b6e7babf344e364c6045168b499d1d165efee229f7974132739310b8923f80dd1712db91622896d3d05c676415760a17694cd8d3fc79c409db4bfe356415b6fb61f62904f21d4cfd48c9685896640f121cf79fa09f2f7526d35feddd0fd827305d8ea0ba7071ef182bd19fee9f09db588e4f094ccaa8a8e1dc2d307f3d3a1c9101d47e36020f5f911c9dddd813926d2c8a7ad34da9fb62b8d0a77d1cdfed6c89af74a85e9ff51d99c0254ed1a2a37606b4286008475f4c2633d465e925ac7bd14fe2fdecfd4bc59d2f7b1b3859e6462020214a473e0fa0b5f3543131bcb0c2a21c18ac36bda27a261b198faa543aa03f132cbcb770ec9efc58faf767d236b8d1c43ee3e8c3e9ad9524d9eeb1d409f5f1a63d8c33d9cf386ff3329d1a3483eb9c78c6237b7669a801661a3051ea3dd749a84ee03966777f60022db37d258b996718ab52b305f162bb3995480f7d04d38ab9fcfcfae410610d3142308605b165e41603972705d59855497511a5f35f8336a8d5a7f75d18fd8ab4185ce05b182b40e6d029ed32c3ebf356f288bad99207930405c0cb27dc623b0d9f15aabc611ff48cb49e688f6c7ac83cda971cb176cc5aa1832fc664eeded56378687e889601e65d453cec919f6aa1b649517bba0a845d98634bb8a28dbc97c0edfac6e2284ee4e80624a3bd61b525cd3c8e5699c14fc8581b265fc7765740bdef5ef89f2c8b920e7ba381b5a580d9a5401eb7a4262eedaa9db638c68293616919b80b514599ffd37c4cb25ca4e8a6fd44ee9761c3692c3c0650be04a635af942340968ff30589352ab5ce839d06958fa11c9d7fef6cbe499d67defb39210d5dc881a0a7f799497977ba68d38bb755bea460cb3c932713c2abacb017372fcf36661936749fa89270666342699867b410dbb4731e86acbac8935e03c706065ea94c4bf2676cc8ee5923bd3a7fa5cc62983a8a31b38e45ee345e5c8acb57b148b4166d032a1d14c2f718af728fd2342c1afb694b1f23fc82bbc5471b65af716522794f14aeb751f2a0d881f1ba790c2f0e4446dc5a2a636c414c21af4e4a03629b467e775bebe5bbbc5a6a885094029b106e8fe4f1385da3e5c8da3b2ba16f7cd5933d96b61f4da5f611e176729e33a2fac7a3d1ec4ebcc5113ecf8f86ba4bfaa721dd5f888e81566b05f74d32d5cb5d0698cc18551537e461f76197dc277806c15ea85d2285ff30ca1669bcaf3d1408ceea193187e5a0852f4133ea8fb49272d6ef7324310ea0d3f9b205b77a6f47c72e1d121d4972eca17877a15e3d87515d8c95ca29bbd65156cd594bf5cec5023c128b639d91e579459d6dabae91d0b751003cc294cd9710d8557446c4738bba86b2bf5a997c2ecf4afb71547ffe4e9dc1d9d7d678876eee4512281d69a5362731345d73a923a87a7f599b6e55cfef5fa9f598758299ac12092958d30dfec1398a7c4b90a2a5780f3ef709130b3b5da794aadc91a19f849cf006a4c264cfa6276783fdd66ec2cbed5097e1739b65ef2cd0232fa4aab00ff2511c925f0954bf7a69df0902b48c0e4e519ab37fda90ceb278341227550962d7c5fa1271635396c9ccfc22f81f19cf80095a264b9065fb7cf4bb36ce09dfe5f809c983b0781c98b0f3eac6e60802f1121feae44935bdec8a503dc60440057fa2309cf26203af376a1bf7c9cc0479ddd6f4ad25f87aa60d5f3a8226469f89392ef74cf610f642446920ac416b1bf6b0885f4b29e64ca2bc8c75fcbe629971dcc4a577f4ecbbfab1dcadb17c10bae157d65c83388c9c2a5d179c23819aee5aac5ef2235ff5fd9495b5480e82f8038e180b5d2dbef7337776aca0d32db2a50a9401d13a1501df967d8ec34de72403495891c320159d61ce73b16a1ae462780a325db5cf2a9e4f9c31e6a2039b2ac5f9ddb5b0003efcc6097664805163d35771845855f2d7365e4de38a3fce9c8c272f92fddbc2c33be5e080014ac9dfb0fd0b2f9cbe1a4879835c0bf64e419970281f0b1de4514f603aac44e8bc7f92d3ad1c697ffb316a5592c72fb33c12f4ff5b0f09b4763ef4cafb2f4c69e70d513db39d71b8a4a195add128b8ac3bf5854edc093dd9fa865c7ccb9e25758c1aebc0112d60c91312dc82fe1b02008058eaf822825a0d5a496c7962a7697a8872b3bb8f4018156eb52c4117a6938c4755b7e2c400a76f7d7a3eecb8abafc33c95d5e5ff94542627055e091456b74edbf6c86de53033dfcee949ec160c518b9f01d829ac327df0fb2306e8f94c5505ac255008aef19feaa613ba7d296fd7ef5ebaebde44df237f9421d9985905b1204b7ca7c9d73ee510c29212c613ebcc9b4db07119afc86450b6cb73461de9e159b30a98903b3156a06e85825108d7f2d8fc9774acb4407fb6bcc769636559fd189b5d05fca09442fcc2f63b5833f3f5bc4136f94a3391db327cef9fc96398c086419268387c1c9b2c4d914d86722c012cb537918cac71bc8d20da0268428440464d279ac073d833a322876fb5b0dd2bf895d9384aa6887a0edf1f7a79272e757c31c00521f716d9b66e3b36c1ff0ec16df0080a43c7c7c68bc0778c602a0c71a6e87e50deacb99a996005a7fad7cfa1213f0d0e40598caaba9721ec880c82ed610c9d254e2cc8afc51a95ea83abfef941bdcf417c81bb6f60fba60e44fd5c82c96e031cdb062c0b1999b75a8d07b8dc0e3794a02162dfdb8d813842a7e525580d0b5b59dd01ac26c78095b1bbcc3a4d94641d02a7b90b661bb21b1f0a4b2acf246d0c74a40363bb18b49a7dc23d74fbf355c55925d2c1b003b3b779b1c253e0018c5f6105632451efa501c13866e1074f90bbf5eb2fee4d6cbef3c364eb461c22574545f04f6e12dda718ab1eb8deb283f5cf2764d7d7bbb4bc503de404037e10c3e447eaa273aefac1402383915645904960fe1478706dc52ca2ca57ce32cd4a6b2e2427d7a0a18bed5879bbff753e7220ac7198422596551fd6064954e5fb61109182792923479f6784d9b6e7e27b70af55afeb3c52a4247b72f29a2b95da192c033682d94869b5e90426282d440605f5bc6c56597c9bd8476822fd0658399bd2cf7986ae524c279cdec507f1deb124344303de0f84590a932efd2f9bf7b38ebbe2a8b60694d6557ddfeb952d5f91c26174d0d32761f7b79076405007d6a2b10318323af76e5c67a8c65adf3e1c06c546e1064ebd95889428c6576d42ecd633af9e7aa99c80d30b528baeddc2f836aa4c40f1529206a182040b18142c783183dcf377215668198cca946f363fdad5036b99c22109b0027d41655458042cfabb95d6de939710ab75b1d50a38f5977309141acc880e0836bd35fe8fa9d091e6c07977641a881903d4924193371c0b58f6da78982de8c733e924fb5b7f59c2ed509e41e703db7128090662f09a6dae84b7cf44e9f04a23ef32d18ae42389ce9bc8b450c1b6551723b812e3b1fb2fd566d4b4102129eee0b768e1b0361cdc2cc9453afafddb7b53cc3c9d18689d86d86f0e4e54b3ae173f839c22e211333bd6cd0fa97f1331ca58174a289804fd38450b60ec058b93ed6cc960a72a77688ce36303fb2fcadc5392ad0cf0e36628122c1ca4fe7f65492b27b07fd575c9ed6897c6168ebef8ab72e18a99c3f403410ddca187ff7e62ca77ff920e67b7d3350ddffbdb53345a39051211a468c07fc8da76fe3f0ec54c91522af668e4cfc84e637453b55cab6f8938b564cebf99526788bd2e1c336e0323a91d0feb4413d54b21362309e666b16405e59e620df1871096dd90f593b04c5c187adef8730bf9fecff3cf08204f191e1543920a40d7e1dcf36a6ba7ae3ade282383aab889f3e891e4a503e64ad483889532da48be2592023c47a391b401c732b3c8c482ce9912e7d2b19fc24596e87f356884a2de6694b1a31120e9d832af620c5d1fa6fd8603da66014d8503ba84ac07c99069e54f1fe3126866c7da7f6f22723f68e08b7b3504ea437ce98fe05e55389e527d1a16b7ef0fe0dcb0cd724bcd64265bc2ac2664dedd0d6c3ef136dc0dad993fa54a7d9f1d38ade993f0f254c57316980e7f5b997844fcb3df068054118530a215729ffe7c6a121750601506d5a80f1f91474099a0ad6740fb2622a36305c422f32a01fe6b4412a99ca1ca8e7b5423c5cd9f10a7a14d4af8cb72d3527205db7d310ebc417bbd4dd70ccd63ae5017569b48bd1bacdaa45172576add33e910bd8475ab83ab0c8bf68d169484f0af870c5885a0e8190a50024fc5cca7bca98e6146cc38888a2d8a802887cbb835456a70dcd55163e49b9ecf888d7cf6244dbe6435cfde47948ffc1637bdcb47e0792e7eb7c02819d9f0f504253e3a0368442e3e09f466ffd88612f3844517fb2fc511eb19de3aa8d97f0d1e2a85baec47bf743004d5f09748eed603f4e468b2c1834c4a8d0f2edcffd2097a363d33d2ad5ce54b080ad5f7c819ec606648df85a21b61a4dcc9b4e45423012c08a9d99f11a5006d9717d2b6540fb8ec2642f561f17922907015dde25c52e1d3252406075db8c583965bff5b1e9e59b5f4ed77dcc356cdee7ec56da0116813c796dcb78b750b93217cdaac2d2c8d2ffe038c0c3c5077fbcf8def24ee052dc15ec3aad9730a291888e9bdb47322be1ef3d88badca7846ad15ddbab193b6f13cbdf1619fcb149dc8cfbd5583c6776fd4c887103ef916154b4b162af43d5227434821a81d581715a7056082910398889b976ce10164bfce9a473b54d8903db56639b8c79d7859750df2e1fcef50cafe51c9167f05a47e47d1537ce6c634b8c88a3709e78a49153827cedc5a459bc9b6413f54919fde9f3c455b599e46db38e3e99d577c0b3f9dd277e17f3524c7bd2c8074a8a2cc2b8e6adc1b3e1437f6b307dad4c13a975adcd125dfc6ee7311f9d6db82830150d7aa21b5ac28295670266ee724a6ec50a73631030e93aea887f4c5ebb9b93875b7ba96eb5dbce2451a83070fda5b3422b115b62f6665d439fd1c45cda23c149e43e2fac3e48fc359cdc8acf386eebef72abbb1ffdc6b789983d7560b29e4caf2a56c06b48d9687da87a7c499032bebe813b9cdad3b07970ad741090fab7b5bd87da685cd1b4dd2c5c1c40a4c986b5b7af61d7ba15445c70f302351758d7070405bee64e0c71d32d931ab713818e5972ee654c41f0ac789ce45a32a95947db24c7766da60855c2d1b2e730ed8a71fe4287c78b3fcd03ee512fbb4b031e0d1d41c91d5175c5bc789d27ff3bda499abbd3604c1e8c94ce8a9589c9add0128256c1165f2ada1c06658b8ae864f41753cb5d5b19d7aea27b35f117696cb96d583e3eea5443f53a3fd1c6ad4220d1fee197b83f59bce5672654850714f1783815da5a80988337b6e3400ccf70781d1a9efc106bd8ca5c4a89902abb97f6cf5d2a86c249d932f071e41533e03e12018db8ad0f4c7bffd2a2250529f4a5eeb6feebf260c000f7ed61816612e785f98acdd11ca230f1df66859a444091a4a39a64ae4304fe55161103408f258571c95eef236c7f6d83a5333c69e0a02377ac224fdbc0bc9b0a0ea7c67bb57f585c134ba347ae23f8d33717175a1585a46995d93f8ec5b68ebf06038c496378e7d270bb16b44e598fb8201700cb5890562d1c65a3c9b684526a5aa0cb873c1af917f1d6601106c6e511fae6e51ff64ba4647d711c8d23c11ef79bb9fb7163cead2a90856a8a5bd871b9a219df200a4d3953a19528b0e7ecea7bf326693caf828913683a5c7bd72b0ad12402d2308ed9599d975012f2e075439b5880b1237da657475011e4dd3b85167329e5a63d5d7c22c3f09bc9c5a4ab7b5af45a193bb7c3cae077695696bf1608fc94204ad5c4e4a673a37c1d027a8b8da7964703e20510c4c691592a1c8a50f88a7b26ab1ec7978180d9a87e682a618ad68ec8c1814229f97ff354be5b312226af7dcdc24edcbd9cccdfae217f6387738a97393c7d2a4eb6d0592417d35c1c22fffdbc87af5d212e52ea056ba209872cf04eb5058773b742f4fbcb66c8183d9251afdb0ddf1ef70bf5a23eda39bdc3a0392a068c6a500519b6027d3c06993061e3a5f0aa8557e5bd56e43967fdf369911a45ec5a2faa85148225bfdad8bf5e2017ea1ae7270227efe03f8a58f412cdc0c2e04bceb1d6bbae4c7ef3a541605ae02baf5b2e3988f668dfe4452e353dbf8dc1945138e286f07f3a2ddeaf177c4c7b2fbc3839ccf60da54c22e3f1f7c144d66fcc35465a708837456dc86917866d7c3d03c7c306e70a68d37766f49be2de15d854143f6971f0cfae711bfef5f02f4fa114979645a86f9944ea2394c31a2fd0c9a9ffb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
