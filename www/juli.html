<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ef9eb43043193ad098662394d0591a6706e5237280ec7c511500927864d285cdf8e6111c547b65163f8ef1744ae2d302eb3a2bf704f7bfb06e1c6bf101f1501e4632f2f6b0471f353cdc203c6cf1a2e8f78ebc62bf75832ccd4f031c15b7295e0e764056f3b93298d1e7380d00e9959870ef20be482a036a0eb859330eb51041d2f069b8d8e564e32cea52b28f8a911e554491967ce67115dceb9252a8ca072b5067b8142f2bd5941d4edbc7fd4ab9907c1555b67b217c7105231f5737bc8e5a7ea2dbb01c3a86ff9862279d455245ca1f449c6b2bc5e3a2b5cf0406ad97906b9937433da1dc79d18338895d63614821d53366c8a817f3d9aee2682a40c45271d23e0fc564449b5e811a3255d3ce050e59fe27abddb75d85fc3f66cea3fda180098e8117d6bfafde0002eb2eef96e044339a75157753aeb1ecff4d8ab703a798ea37e4aebbd7e5350975d194e764cc5a6b36bc324a8889f573c49be24ad21d87af1f3e1c6b62e2c12997326b59d6091632d551a15ae65b102d5228881d12fccfc04797da6b0ec6af9a2ba3caadeb7851aa82ad7899d9f76d58680be67e860ed4522f631c9583dcc83206e596fbe41f802130410a1e6825480023d2fbdcce4f9bffecee400995b0315bd2d5d0f39525962c38c3ab6d7337fdb8f50e328f0755397bc1431af7a2daa9a77c3d67e64f776adf00404b56706f6ea3229d558de5ee4a0f3e18419d973cd8f86e722e24e05231fb294aed726dbb396aff6d07942ff6752906f10c3471b493d25feea7c8fd0e744340fae39e4aee3aa6c9ef0ba2e876219d9b549132ddddabc0cf84c9052c8968aac44efdb88f9b93074b4e51d6813906400109cf461433ad64bc8d77c05d2511256c77563dcf70be625a01d4694d3ed3c624c3f209ec3b2ee36a1516b364988e37d2cc1eed87dd7a89888b900fea239499778a0293008912c4638a5daad5dadd9b70637bbb2d488cce1f7f47e59ae20e596449d334f18dc7a6e05203fe789a905b7ccda5ad424b84b5f76f02b0b1dc47d8a438bc6d5c58b162bc6af9ac53132e87dd314d7d4a7ef4ff3c7ead2159c33afcd1a08afd7d73480f4787ebbbbc3f96256bb90712a7a8a3ce90558c3466c7c7fa3dca43b854c768a72e0bfb6ec186ea99fb3b91c75769fdcb9a0bb4f86bc6ed32b3f6a6aa8ea4ce83b0210bd046c6a33243900de51c3e9b04eac2628338fbed09d18efed583375054636c756a428ffe06acc2eb22a623d2986b0f006a394a38d27a51868fc201e1fbc7c32010cf2e7bb34f4eeae9397edc363e0011868801f22bc784cb1266cf8c4c00e05f3589b7e4d2cc4cfb4d945c8ca746405603e28194d8828180698380b86c5215c121a6b10fe3ffc6bebf42fe6fa636dbf52313bf2b22a749eb1d14de3075a82aa2b4e5ad6c770a4a9c0539bb9db1689471e7b3324d594ce04f664b0088ec84cbea1078265c5f0e18042c64e272c93fe140b53ffafe01e6ca887041a8e831cbcc82a8c50b91b5df85bda6abd5d47a25b98b03a6d4cfb00ddd648e03cdf53922bda5eddb9d5b4086888717a577f84c729af16e0530244d7f5ce657ef15d3fec3b7db08a5b7879301156b70cb39f325ea010cc0ec14e126361591a6007748ed05f497bb4e897817da627635aab25e27ba96bf18c9768608bc07adf7f010d13c179a94e4d62961061d4fc9d4d4de28871b39b3fe26d13393a5162e13d6de0519ede1ce90d8ff93e26468df621e3cf4b58c1037aa4e1d380db6a7a44ee941cf08f582d19ad1ce51f777d0be79641c24ffbe9feb89485642016cabcd2b8ad8f2f25e9f134818f940d1289ffcd3d426e86bfeec0849b1a5c33a1f0f99acc58164f0674806e84379e891cbe4dbc4b7fc93f41eef0d78d5fd46815b2bdbb938f95cdafe796838e387f7405e0e6ca9c91489f2e91150d9797e75e6bdba76d4a5d68b6059d24c307504a45e7d2f398b8bb477b88d8a2ae898880595b4405cbbb36edc969ea4edad26fce2d3d9adebc310db998e385ad81bb06fe06266c38e9b27da41b5f03886ca23572f2ed5431b4c1dafe4e8e6233d5a30243abe062f019d86343f75ddc4a7e199d2cb9c9109d4defe2740e98cfd274c35d9cc4f3e5819db7402eec9edd7ae91033f819e1c0b3ae1692f8792c89efeeaf737c46beb503d09b8367e6b85f74fbf4dbf5010ae80f100027c879a482ef386a82f2cc10c71533d9bede01689112510d22843359ba30ed02690005a853939edc2f7be7f3f96f45071a5bee2def424ac270971dfcafb5352705d05c27460333bb5019a4672ef9d4e0f4cd3faf3015448ebad8b907554dff3e5fd27883f642fcc18c8fef2d58e3cdd099c93b0d197f57f7def2c30cbd7b2ded7dc33000dff2b24f19b5c10ec645e2bd785fe8a0920f5c72395c4308ba0f0b4c4cedc000948d73fb065d52f742cfb3b7b81766af47682bb51bdc60b06cc02d8bcf4c1fd8c8dc88406f20d46bd96b200f64ebba17d172349d25a626f041c0cfdafecd8d888e89604a53c07fee85b3c1dd3485700197f8900d2307fe3dee7c08fb6259dc27e10efffdc4218f9cbb7a11d11d810696e887323c32320e241fdaf1d456765f9da5f10ce7d7e50d1571b3f6ac7125d2b7a641e420a986542a9c47be9a6fea79db6c011ed1b222e94ee9dde647d779ed273526f009c2a820d0c4d1e304ae530aa4bdc9b50e0cd97daf9ea7969415d02ef97db45add59a90814cfcc4cbec48f68bf4301c8807df96f0fb018b263041de2bcd6d7e02ab172d02fa2ea1522b7c3b735c58cd1997390e4f3243866ba79685d74f79e41cafc4c17df3f0d182dc66a38b4ef50c648b6138a504c2864618a4285464cc40426a954df2395fab3d07bc1f0deca2eb72dca731a00fca3ea6fb512ba40491ce79fb48c9f70dec79f05f53f791b23a674c6141adc00f2d6a7e872affa1d9cdac2e6945905235be949ddd3a03b0870ea444839d1c96f0d1b864811de308b6aa87274d968e99da44a88e4b234d3708c17f2460e86ac3d735d029d845f79127b31c2a55b91e342f4f07cd9a0b510ada92a7a82eed421f7403a18ce463a1d67551bcb0dc6af4faa1f33640b0b0d66d99d64d9898a632eb0452a5d2f6a8fa76d9ceba56db89a8c9bad1dbf539302fe62512c55aee917967a75259955491f79b64e9658b8044850ff17e3e52dc432a049e309e365f174cd95294ba2311d4808a6f154529ea7903baf4c8e9e90a35fd26564eae1816c90a9037dbfc7d763a44cb5225b7338577a337ce9369170e6da4fe793400e94f7f745402ffd2809a7c40fe00fb1cf54c1d43776e840514a9a5b6b0c10bd956c91f62413d45db02a770023bdc095cb2db05261348d022f29443fe76136532dee85652a2279cfbc708237b15ff17e85ccff84d83f8897a59ff3d4ef80764e96705239d46f6ac51d021b5a165566b30136d5229c0f4c6dc76e59432e59cdd2893d8700811770f22bd0d6f5318f0fdff1a0d63ea8faef5d752304f1af32736f4f3c05a4ccac24c4ad7c6dd4c7944a0f12dcd9a186e38364a2b2115198cd32aad43b4e7639b65945caf60b2bc655724a6f059dd9402cb02c55d5f794ed771973f6c87da3d8917bda8bf1eb238a50f0e01d0dae0b65e0c794486e0fbf547a249b9fffa226e33514d77a6aeba43204c66be63d78165555429ff0da8ef4adfacc02cfac5baf8d57a0b4f50c3dfcd989edf0582a97adfaf7adb663f6c9153086f0a03c2bebdb17a372eaa98943c7fe599d0a40aab55972b8c5766f2f62c4f5d1f58ba1f53fd022bed6d9bbeacde9d9fd21bcdba48e516fd117ad74076a177632bc1920ed12238b745b64dda40b69b16a841e8c1317625a04b5769320ed7172315a739b31e1837575f065e995e58c5964573cbb66928d02389060cb353eaee267fcc1ff9947fa071ae6b715d23f2d11d9306280b4d33842c48a7d5f4abb13c5265d2dd7b1a85c28e4999f234039def23c498a3d68d314c0ceef0872be8a8d813508e5fd1514b12ef641c9c6b225b438e8e99d67f02dffa51ef151ae890b6c5817275f7cc863ffd47668df4b7f9966970930c45eef060fe0bf1a4e62c3ddada503b34adc7d884c694f79d4bccf7dac847ffcdb4f49728765929e81b9b8a815a85d04662cdc2f962448ca5c77368bcf9fd8f98603f4debe8230455c99f9fafb2a4cdbd0dd8b5ed2fe49249b723373d3a8e3db49c8f6e4d4f6ddaf48be9072c961a0799950ae2c2b7eb3b522259e1df52d4279b87071f33c1caf0cec770c05bc065506cff0b455c227373e75c16e6eea7a786e7e67f95da5cf2f32dec8989324ad5df2443051cf1bac98bc20cea05609633e13f57d6c019bcc23e98f229d09ddc4b3424afa710f15d6af34aabf5a6ac8f2d7bc6f84de4efaaee329dfb1919f2cad0e881c8330ca8154873ca8eca370b38765f7d3f108e094a6487fb70a1249aa8fcecfa0cd6370ff0550085cee938465376b1445c5d3fcf4227da9acccf8cc9f35bc129fad6095f0595df8d90a5e919e87e52b6103cee6344ec1d483b8bcf95d8a6ce732b90cf063db3880ad92dcd8bdee02466195db91e0a0f95944e61344ccc164a5e03ed2abca023545b51ee2f4f83431e701110ad0bd8369505cb19e21e7c748e9cede498ad066bb54b40ca253654143ca3397a68ae7569515c45219f50f06fb2767f31929be72d1dfd5209cd298e313edcc01b233e9de56fd65f70d4ecf420a19a674908760b431e7a2afc51ab973bfcd1320194e50cd49018de68775e81d9cd5e96df251cc759a2dd10b1bc844bddc259ef289b153845c4667e93d7170ebceea4f099d4dc89dfa1f77a9272c579b904f5446c826af9a421196b26576a3e2341b826534a6974412907f03fa0a78131e960aa11407c039690948b39a4f9853365dcafda61b1e57ea28e88f57115bf83171ef63a1f123583b6528017ef5158e8093fc4ac56585dae6ab207f2b125350f0edd847f39bfe187b428af71a04db67a520c1baa486ebd038373df70b8268eea35f0ecb6432760e74a32ace0187056131ae98cf4c28c0be84b7d064dfd22b2d63e81e35407633ab21f2dcb4480db9c330161a0c85c84a930b1e5d50ac7c7dd21d88658fc14be18cbf24a5bd797e2af3dbdc681899ed68dbb96b6cce93382983fc3eb7370bc04950f372f08f49a31765675f842b13632358029b5ae417bce229e1bfa0c7e9961f7df5b981328142cca5cc67e835a4f44513612d986719c3ae6f26dc057eb97e3b3269350ed4a22abf7b0bf6df1b5d36bb71e7dff3c3b04a27d25c21fd019c57eec6addd44c9c3b8486fd0159e89b892ed833a05e9c4a755197f7c64b58c2d0fd01b8ad281a286706c2f8c9d3ecca071e03e423a6ee279687864b574c9c90c6406266d07cf47f9b16f137edf874f5e3851175490d2c1fd4b017d58afeb14dec3e5428b29c21a642f61013620e8336871991beceaf72e4a8662f204c783468d60586ffa52dd9d380c0deb24c9901d9d915dabce80195039d9b28e6082eca7425097e3c0e3aa580737ed54768a6cf5d84198e6edfc9972a0f8fc5086ddb27f9c194a8c9d3beee6abbf8db1175c1a83a716e7eae255e61b0e765b638a07d5457014a5b86fa77c2cce96ddb5ceb439932bd11b73c6948d94edb7cdaff024d738ef1c8c336d90577ec9753b0c7909dd001b42abd860094a6b0fc939b6e870997d83e65a50661155993db4b956139934978876a5b587cb54b92583b74e4acc5a9382294c3e927910a434a252c0c5f0c813bded4f46ba907aa45625acee445f1fe45a68c65c2be42f8ac4821653555f0f107f737faccd7fcae89cb5be881dc4ced85addbbd90d2a46a5419bfd12480a80c95de39ab82497ed6c12e6b2d74c6060ac40fa5e3460e8bc47c938299fee537abd32089f905ede33590e3be3f2f890f255bfa80611c28ea9e82ac5da0dc1c83ad73338c06534c9bd80d20454220fa28d9c8cbb001eba0ea7d3a640fc228cbe24f4c4a638dcddb0719b8146953d146c6643cad4bf188e8ca352c5738a86cc49d7893ce558703aef41559b0bc5a96904aa4c4dc5cf51987331ed380f81b21efd3009da70a50f4adca869c3e86728628db2792629d8bccb1cbac4b1ec9d88f171cf8ac760c881644d171bb9139a21c35ff01dcda6a1ac04f02408a95569b8f0f5783d9d012c4e987a673f149f22587cfc3d2a21ec7f9e12d784975f14ad67286b8dab141a643f8563606ce07c448a91c9c4da06fb15332eb1864c466444f2757f83189033aa83e4991694ef609f87a6a9a3859b767fb0da6d38e4b24ee3cc88fc44f3494465dd4c94faf62c8d62b31f5987fe9af955ef886ddff5927d5358ce0dd52e42c06de02414500f190b0387a48abc3c7d1060b16ba308d399f67a6ee3e3e859f77e247f7f661d874e3be20d002f2c4078a9832b7aab32314737a8468e1071c4fd774db92ea3bfc511072925eeddf9b3076650b925c6ddcacf5a1cc3dad835a4d9eb96b1e0b16468a23c5f6f3e86cd1007410177376afc9bfb0b4df826e18f50c1ec226ec9d74ef46185521bccca2c541f557dee1ae5cbb6e0f58fc474f6f1dff255264d0bd250047fa26e7e65006c8a8b29aab1c78900adb30cf5c5a515c0ae9de220a3c132d00e9b2b82edafaf82e17cdd3f6038a15ed6d4007b03716b01b318f4b1ef843258a98075dcda29cc0873f8b5c38e465ba9f5fd539ed12b82d5fb3ee38e7998d2276354b66e0f20df9a3b1797e7d278678e281c06132123c05f287cb0c01bf0db30160698e748256b1dcc0b02a1ec54dd1ea8c1f9f1945d9ca3818f20f49bcc8a8794efa314b662813798feebc90a93cfcc1c8f4bb95b9740886e8d60c8db7c227feb512ef8d8cc4c77ad5ab3874447d3b12cb7655b4b6fad258e8cae0c8315023e1ef9802af82ed06c327f91a51dd85082f6635aaf732eded930bfe4813e981850b469675e8384b2cbe76214d98cf1c32fd040cb39ae78d67c3eb220a3f0503ed636806bcd63fbaf5cabdc342e291469b85c28b32b24e5b53c762d26ca190d69a8a4c84be2a12826a9b2307a9d2faf02ee8406ccd2ede5acc4a6154ea07debfc0cbdbd2de6ff8ce60241c5222bda76a8b579f2c5a45b0e733168c81f2a83099c80fd22b9409baf806fec5a26480e50d105d5cf8c15bd95b8db202c5c99b9ae84f2d10f489e79fd66e021695d59b8d5135d686e17cfe809157cf4795fe50c7243aeb27af048ad720df615e7ab2491fce4a55ac22663de1e94b6097128bc7db3fbe9cbd5930d20e415759e9c40ed29fa56c8175137248e1f10e720a235991846fa70d8aca91273cd06e8e34adbcd36ccc2f990b07daa4f955f46a507249a5b06f5d4e8a1d32dead8609de80a4a336fb71210b75bc7afc61b09798339644396635ce784ec374951107a70997b18aa45f161121c8388e7a11c61088ebdd91914cf9b37e41f17907fe1126404dcb597e17d9150bdaaf0aa33103dcba2d962d82b31b16b321c098704725d08cce1e5079976cc2a0d90529d389a9b73236a03a7d066ade118a2ac8e5fb746341293ecb8de1c430bcaaf986d8d69328993192a987f12255ba4d08e7702c7c6e0fbb8b462b4c2ba748866c47fc8bf60f28c7ec5d4ad885d94fec4f7621aa5742235c65eb0d2a2f56dac3f85ef812a9be02eb37dd04a0d4718b618744a399feb4eaf917bdc48efcb86fa762e730571442a63bbf3271e6a65cfe2a48ffae32b6295495475b0c102bde25513a4b7c0ae1d9fe6c5f355007eafebaa02bed23cb78a090516b62bbaea37dc7ecb2d797b50077aedafa79f8453d22b38b89cd162d627d49cec9c67f5b92a6eef96a8d92447d324f3aeec11a66a8ab88f65150ace0072ba59f110b225f9a7a33d4b8273a1e3c8bd3e72b7f084ee1c26da0977b37a045f7433428bd1d02c281e20574f2375e256bb1c7db252b285d03235b0411eae825e46076249ed68e86c849cb263faf0dda985c9a2b7b8d707eba921cf2c03c30e0faea38df2d0412f8ce349a5a638544b91a7e0be2f5f8b912d385bcbe55dcce56734ad79bcb42f59a11de2abf6fe6289f5d6def04294039e13405acdf11d3d837ff04200a595fa17082edf126d8fcb53c8dcc040d992c5a367bf62f8ae15694d86319a0052872b58b29d4b2fe42503b52d821e21847820ff78c1d7743f966a9bf6d9e78a925d75f375bfb67eb22267e306806f5a846fcdb29cc0f6e75c60cd99f15dd8c18f3ab3726eaa2f94f02715f88ce54005dc832639c1fa0684061e0f05b00a46aa39bfe561618d5d82929f9ac3225d2826606bd6923ce92045637baa9df02853b23cf892ad21556f07c434041390525f7da4b8dc50e99c24f10d03f147b6ac1125f395008b6ee0f650a074bb57a187b00f49fe04ec16ce9a9892975ea4d6e1b01a441743efd4f247f15274d9155a5242ba8fed8da481cafbdad8e9657f81c30a8fe36ee0074fac29dc8678376b699bf58816aea1a422a9ce250949d25f679fdcb4718e19afe394cbf9e7a128afc515e668b1411e5e22e447fe12988976810852b97ea06735b3d3cb73b138b34eb77013d6800058b981e91f7c4c98c277e28d6c5749be35423fba5643ecbde0303fe7de772709a4e7dc0de6fa4594b5ff511614b97751b2b95d95858cc9818d1b869aafd850a127bd31699d9b70736d1a1b0a7105f7643cfbf22d4c5ace42923b7e2eae2c712706e04f2964cd227e3b4a09c54797bb39bbedd42c646f2b11b6499ebc1b9e7823b896422dcdf1471025a60523018d9c868eb5a2c0ff60dbfceb6ff3614f2eab248c328278ff58560a258f288cdc602f1c2caebdac0dc2a3518700653a62eeabc395ee9778e112a43fe33c096ec687658c017434f6f3ebd95a74f377987e5e13e7070cf0345b1321b00925e2165788d2969ffa3535935c35f61b2539c20bed602d3abcbe9a388698279050cc44b1eb6401e6f3e637f7c1b5b29707a79f37d18fae2540593830076b61ce46d85b527f80e13e8634422d393a67520500b6de17416d3c3c5c7fa044d206a8df525b04929105f0e19004d7a4b827fb26bcb4010099532043f54cef8fe1c1b6809291bbc77805f86c3515177275a36dce53ca0839a3aeee4cdbbc83ff788becd1f432dfab0c1af2f2420ff105837fc0ca1be39ed9a5bf416170574296ab2320caf316b5175642cda8cfe5da75932e8715ea3d9df24c54e5e182ad5cca8d87b1e0dc2a8bcb26feda1195f584e92a760a1147a36be52280d7bdf2f8afc6aa1c07b6a6a9e5714392dc5aaa134e295f86d4bf76f759bc89325dcb637e3045e1c1cefc0ae6a6f8dbc9d02be3f2b992e434aaf88188638afa9dc087d6342cc6dd797c770d0f7abea64b8f21aacfb6134c6e8fd2847164b690424147a14e6b639161aeda30a130a424a5768d91b923d8515f0845737a052ebba116158707fd9fcb2df18c9050dca108aafba31bd293ffcfec05cb0428fb1ce184e934b72450b4d7c73afd36f2557c825f702f42f4f203841475069701889dd1cf6c57501589799b9513c39fc91eb657654d4c09381ad90353f87aca55a9642271e4b8c0b69c19d8e21eef1d47aa9be8d92ee81a2e671f8e0aeedd7bda745fb2d64f26ee3fb61cfc4d0980ba78d1200560a6dccb1eb68a552bc31ecdbdad8df00a99741244e268781b698d4baf95eb3d02d56311926d7b769839139874eac43440aab1dea62ec389cc8350a76fdc69d644cc165e52df1d3625ae3509ddea447748cdb5527f1a535b5b43506d1a0e8e752f6e1199438de626593e3112866a8a3cf1c8f9b8d6bc9e07fc9c53fd943d05e40d7f771c265a3d9d609072bdb28d4c6e493163149e104870576606e32704a5c0c00079d350d965aa68cede3e2c3badbd2e2d94ed0813c0f4baeb6f6c33150e751d588ea693fb7f6b0eb284250899139816418f9b9535fd3f61ef10fb76b795f6c8df9de092c25e3704f4f12092faf228c1f75d1be196dad78622207ea9cadf89a5d1f4f1edf0459cb8b8b6f23139de979392d1e814a8f7c044835cd903a0e940606ad25530d2e538166195e530fb98a1c27c6e7e404a30d6ce2abac3ab34309ccc30b3f54e90708ca6f4751a54aeaa71d06566cfbdc9ed993599010756905a94d410d4c5869e2b4802821b8d4cbdf02fa46ca92c6c5ce7eb16058645352e77c86b340b16e3d16b93fdc15ec9b4720887f93be11893c2cb864e3f09e41727555baa2f35769aeaa616e5ba16bb65cca1b1ab4ee72b61a01e14b5bf96b812b24be8ca6ae4bdee7f9809fe7ccf7e69f000f4cc3421bbb260d3c5a41653ff48f96cc933e53711c32935960d234edbba3c494a54086d49282a8d558cb7bd10c2a3d28fce95bbd51a2d4af71cb6c88454070b0c8f45203864efdcedf3b2084c261e330b76ead4e4afeb0681468536cfd2ad4282f32c819220fa9572dc856c579becc90c22eeb55907150d8f58d79907f9287a025a974e395e245408e8187adc44d9771f8a3b50fe438b4be11cfcc6d28523eff3245ca7c8b545a3964d16f8f0f237e8979c5696f40ac5ca163018013f97df1a396272aed641dc611484d665cd1c1a8e244ef1286572e049581375970b20c2f7a5bf0092e528c6456ba23bab3572badf8e055893e28ce55c38768d3e5a63fd3d5ddb7a50bb3a9f2718bc12401f22e7d961053b94a77d1855b6fb365f0937b373d69f0a905cfa7745cb0591e3bc2a3266f13f59e6d83098ec09d152eacd3a23110568a2986b3954a59189da4229077b67c536abfc89b0920a7a12719c5d73b4b7af1b87885933ade23e799b6f441b57a06eee223cd34d4874e10d13ba6933719416ebcdaefd128b5ba75fb2ab83d676b19beefe07c63436747b0fd35699d7951c3671585a8ad5ffed261297ab67c0d02ae537a53d5592080fd4a417bc63290ba8177857dc5546e3037f8d2280573996c28311307e1e2c25e4f70de5f57dfe7d2e8563233fc43603c0ea899379e00b41591ea45d02ec27f888620297180a251a960a51fddb069e8a91c478fcc1efd4e2e60074d37836659d524967fc9f7168951345a10d1e1e651e44c76f3b4190f5151fd2d7516708eb97e5a06fa5de95123171a5629ca2da7150cbbc500e82b9985a3917a6281177b6a3d2032c191f2a0b18d4afa26174f59c6ca7bc7faabfe0e197b2d4f7e0e2756642d9397c88fb657ff7bc53c1d4d8a99ffa150f21d5f2fb6b1e028d71cef345f3a351059bab3c1b56c8dacc0f041c79739c23a9288d442c721f08f96fa73ad87dc9145c227b635b6ed571403796733fa5bb4a6310ed717dbd59100b4ee49a7ac10f2efdf9b418b4d5f5aac5e29423a2e44e11aee58d554df97b8ffa81451fc49daf96e4a7a08a45b6fd313913ffb37d2f53da47aae773a822913da779cf2ec5c3910349c59293b9061c0ad62eceeb9e1c06c14ace085a99c4bdb33357dc16be5f7d8ac4ad4de37a4b2f562e3a092ebe6c28ba48268025c4f715731a6b8475588cff3fee980a435381855c499e3556771c5fce73e418cb730274d08434bc5a3d9b3373ee0ed2de11e82c7983de30a235fef0a24d0a13f5dd362f8ea7874c0297541311a8f6e1a15b2faabe7febc17743b732a2fefa81ae6891db41187318f129f1e08770c816ae4ef9a19c5207a9a201caa3c124180a4f5a489e9399b69299cf2a850518a83542e67cb6187bdf42ffdace1af2748c4c159c60535ec851548723f6251356b40fa79cd081aa6e5bfaa598cd8368444513d0e5fa9b36d199c9a6e522b58d134686d3aead32bb8972142d1f3ee21d617c5667358cc0029aff92fc64915140e8cb47d29580dff32d0f2ed767f8b0f1e63539947d09310158e985358a606357bd8e4cfa48dafdda2032048d560f53dc521696d339736027c7a64b050cfcac116a85d4f4388ad9c6bc9aa1eb239c88831c590515e7e58a31833cdb6568bfc408294f0c222ec37af6ebe211c5ccfe089da53e51c426d94a17d5cc088167860d36bdb782e80d79e682d947994dbe59db997d6bfa9127a50d09332d56ef9f42a040a82c8130cf64b7eeccb66b32136eed7be0acd84f9e2c5ba785d6abb25c99a370c98fc17f92a35a6384ff262506431bd489215489ffcd6383576b7c4e7f397297448df9963f7b98ce5ec66264ddb74f65b9c0ac181fe6c1f085d76ca596fe30a75cdeb1b36bcc61937b95ce054612aebe2cf28b725fc405e4caf494f53a36880cd477ae4c583519a03c72b96088718efcbb05a211d4dac2ce382efc1c2c0bcf606d3d435ac04fa1970372712641b4e936a56cbd4ff1c6eebc01f7e04b3c1ac16fd2595545bb5e3fc431f42953ba963c0658bab9e151d23c1104528c207fe06ea343e6f69c1b5b9c67b6760ea2fcad7bfe13d08151a32cc8a3940e5ad90b4a0f8714fd03d307f7f69919f78a27843417d1797d0e7381f91492516fb9e456417d8c41c49ea3d069d6bc0bfab30bb725c8bd967f818c0600a7c66ff8799aa8047c758215556b1b1761f2f266678e832d6e6193571f720666887482e6a0da2707bd25a3b6382d14c69611a67e8ad3c861ced0489308d6917c8b5312d54bcae6b8da92e16bfdfb19ae45da63bf792b04a2213cbd0b08679eb595ed8e7ff8a55c137adc4581bd2cba25642a4733872f34f0aca85ec94866ce7bbd0058eeadc87e9a1cec0df470fc1952e4396b2ae2ea0c81b06b91236040f68498dd2de19c13fb9dfaf8093acc1e143fb27a98abd85716623e82b51ca085be1424c008e0e1a64d2700cb1edb15b81eca2753ad18a083d991af0898abd0a74984280dd2422a5796f22cc8009541e4f4461c40fc36429d0e1b9fc70b7666ca4644fa7ec5aa8bf1613b30727118718c8b507947e2b37fce75293297c6059b1fba45c93d67b8d6dd13e90abfb8d19cc5f22ae6a5ad0eb63cc58d4020433df6ff7f69bb75e1266e90799951606389c5f8882b2f34cac80aff4f42e74751548b592180ed3651e01f1779741498f82d6f6a35d9bbbe74fadbd3e26a34b7d1b69227c02adc4279c794bc35e2d2384e8c1390e8366fd2a810ac46ee548deba4a84d163a0b02e1db48a66bb9b2ed2191ff4b80d943c6656a15067fb42787306b5160c0aef3b1e5c4e02353eb7c7f80dde902ebd4edeee18f59eedc14a9814aa3caf98b341d27b80d157fd58581478c799aa7bd285fd5a9acaea41ff90f7c2375840cf4a9960aafdd981257a9b86e652189b639eaa76a64583b2f3411312d85651d707e2755c3e4e63565eb20c75b39b3f7e2922e89e7b26ba82c5f16b22f1ad7f35efaddf05fcb313d373861eec650c0a52bd1fa511855f33cc2001b25c295785eaa4ba44f93ceb14940febaf7ddccd401ea6789d54f16a4a1f6fcf5fa5346aea78b7f5321a7bbfb3310171338da35c8e3db7e485ad57e0cbb871cd96bd31a7f9e770fb82ae4d1e344c3f591bfd9be03bea4c0dbf23998dd1310cb6c78da1c616e59b422d2fbc5c812ce19b7979659bec5cc79c1bceebfac945b2449df78a457635edb5a12d3b681d353c655dd33b55ff570144a0c6c4197105304303dd11e0af7ad8985ecf61a1729a9a0a8e892040e78438aa45648a835c4672e8a713b3fe02acb076cea6e1fd61a9dda4ee9e4529e6c6ae188f1927c657124ca9871c9e62ec9cf3af4a9e5e8cb34e7f0e30db32d50bef8a1a4c8e6bb46802b6c0def937d16cd750ef476d64d2f0c5c0bdfa3bbf602aed1f9ea712ebdd14e0c98309bc14c361a195459ab5f21f7ecaa499d98b420c0dce62cb214aaa1207dc3cb0fb587b3f9c2b130403a318516fb48a41762e49a4592d7145b5edfe1e75110b164e9c3b0dd229ec6684f36f07f6835968de758f74fc032cec8bc9b91960b3d9ce4b1a712314b2b2b61aee911bac1c6a5164a86d7e8745f7e0da0a3ddebc234c9547966a35eea871ebfeeb09323d0ac3e11b955b805e58ded5f9d3dac8076ca0583ead32faf3470578fb1d2ef095175721676a07b6dad6e7c77fc51d35f52c75f62a8f3a4d7eeaade10f249d452d686663594c10758161f80662454c009228ba089765358ef182089a3f3ed4fffacb827ee57929a9b88fe513c5fde5c98394f67c5868ffb1dddad762a064d9c9c9343eda25773c7c81adbbbdcfe0a2d9f8a7c392300f6e5232a863e29f15afa583176037e76106a61c8ea8cfa250d85ee9bb31496e1d794bc258080b26f27f11994c1dd1f6b001896c4a7668588dcc92345b313955bfcf8ebfc1872517432faf02a8e77ea625fed2f1ca06adf2c317a53bc8300ffbceb1b1a3afca3c9ebe871205096576ddca8b2d0f358724b61f0ad7e599a568bf959b707c6482e59d6a7d01caca9a40e9b28386b187f4c1c1c5b51603c8d0ae879c56d1623cb4e8fa087b6b641a9d494a1940e4f158dd1109c612104c5dd3a3f9560e702879c43cbcad6540f4589bd2204315763d56f1f0263d248c97f474afb2a1449f5cb27b95390d47db6f2442a6c5507159d9d73378dacedb5051ee7be3b7b704b16b0264b3639a0b440612e01b031833000aa2526f57d3507d667de2e70238f623f5c215300a5b2c4001736c3ecafdfcb22e20bccfc30c75ba199786a18c1ab4cec37b75bf4d68715d5405447670f4d263a89a501a0074e68da6ed664e18896275d1c1c194dc5af6a367695fe58ec0e46e0be3b4a60663f191ea5ad2e89dec69e1241ca39bd3af15fe3df7e1eb518ae24efd657c77c6d275882a6d4165f51cc4f47b0cbf3880d6a0879d804f3ec3b359e3b672683f30ba89837ce47d8237230836481bbd11f759774b7f28139dc8b4773cfe6eaa921c206a8f01f30ff6e64654748e5ef603bb410d54b0441164cdb95d35a16e2e56b3f3841acd266df03815f6173c70ee9b42a09f322c2a6889d09b26e44d3244710f184ca7b8bb1d6cd51892cb4cd9ed541333cd2feae8377df694075da1c1132d6dec5b5598b2e4fed6998341ee9a854c45cfbdc740b87b10a6aaaffd52db2527f520fe0aba544e1f9b124a7d743f9fd8adbda677e03c066db37f94216b919dd6f33f1baf36e5ff4dae1030f31604e7f64464c8984aa90134010b3f601b9256c61bb75299c82059608758ee9fe75b2be11418b79d42035ee1ce808cdd41bf57d41531f62dba5fb9a9393dc37fdac599dfe5a371320005c4ee6e19bc18010581b7fb619b2e6627f6f7b1e685f8298aa760b2cd13ac42dac7b57af6b6db5c4c4fb870ab96a8660c9b53b1d142fb723215868602f676a3dfa58be1e181d2835859295d1ddac08b6ef0e7ea95f16357faf5c4042d9e05ef4f34843261da950b5fc991b5ffe3cfbaa2220dbaf1ca7b1a2156be64c4e32e29e2111e2c7d24caca855510f230e0e7dc124842cf2fe6129ad8f4e8d560034b9185822a78804ad9e2f268112dddcd3f7123aeb60962ae2263f8551309c00281dc688058e64752fc487597ccec8b6483e224fd3ce983340b587028ef3d33add21bf4690324da00825b9ba3fe439fece80e9df55889c70c23e4ea29430a9447be67f61402112a50ade6d121cc8da084047fe39ea74a681410ec2557c2d397732a14c65f8cb8c70e4874548d5c853245757fd0d41f4ddc41a508997da39f7e7180869e0de818e4b0403dc2ccc400c3515792b09d51d4b7bc7bafa9d4a09c3e8e7640893a00f849c3976a167b4383ccbd63d52f4f10dc7f855dee2a270a6a218646b76bfd2c43879c71edd3000a0b995d0925a4bf4dcb88735ebfceaad2c24f8d4cea701d5b12f0322f48896b3f1d567879d8f906a142850ba06ad1e9368c63172e7d4141e6f0edbb84fb03d97dfb4bb62da59d7021f967943da3f2ff6a8f3c55ee9a59e38515d8543120ec9adc632998549c430fe522838928aa3130a1fddcf271396e39a3cf020acfa3df049d9bc054f6cca638d4dce30290a444864a61cdeb23cf7702565e1e77275bf0760e6dcf58b8e0f75f418670fa028619168313bb177b49f8620301cac17d9a99affabcb326b0ebc72a0f02152dc910c2d9e4cc9ba14c3ecb939da705599e7aa903361d931ebf87d9b77f61b22e408e4cd0798340958919fd0820ea3261284e00bba87a6b9f88ab66121771b8b9bf6e204790a9195bbf0f8f1369c797ca11cfa19df0ca121b0edaada6ea807c826f7bc95a8d7cd63e6fd4b35ced1c7c621fc79b9efab5ef4f794d6b4af8322ad489b1458bcc7ef00a55cfb95969a241c19b77fd82a97348b44219a0456c4cd7a58e29160d259f1a1f5ae6ca5ff260d1d5eb6242aa71a4ea2a5af9f6a6bf7701b22397bad76a5b1e53dcc5de2f86af7a58e872efb50c71cbd6154d021dc9fa6c93cec47ff9e40e77aea9790be10e416863de7329ed4d47d7b29b03c7ee766945087ab0e2fb0fbebc8a55ac1ece15cf62b0da90d4a0b55a83bc2767c13d917b1c60d3e471da9e67c55de4b69003e1197421440b970b04df2045437e871d24e84219c614ff46bbd21ffd9941170b6b6e43ba4989123aec6a924393d8adebd40e7110d7921ed36b721a8ae3157ee1b07b25f87d2cb1f83f26d1a527e6f21374dd1ff296a68789dbc271b72a3b6c4bad29da0545c37c1ef76b76aa8da3b40ba6735294b96ede92fa11e7ce00edc5725cf694dbf8990b3387500d6db15425ffcfbf93b75001dde5e98296de1c2f38fa6aa7443d8e439e7a82a8052214d5d8c5839124591cb21e6f5c2116353b28389bd9d2fdd606161a991d399fb102e73bb5bdb42b08dc7b5d22edf3488a03ad87ca46d4766581499dab6f5ab8a9b6c420009372f60cdc63375573025a6660953215060294de7a03ba8626457cdf59656b4dc8a969e8d3b13d3bb86b160bedb8a29963fac7c0fb72f9ae77a8d7a98c86f717e92288f91203ff764a52cd1a255985cc6ce3977f626d38f8d904a359859770ce3b352b99bc7061993216c7cdb7aa71ddc47d0e3977a0dc41daa471151e2755c2154bc60d4b761cee1d73489ba588eb094197c0fb8b4d6c5f13d92d3af064056c7e59b813d543009db103dbafc2cf1ce1a5ebbc468e10f880e428317fca117c15f2e2ff301ea23bc0a08a9b1f273a868ce8093a72914adce4475d76df6fc6ce321cbe0876c9e1a637ff7ad2d17782397f9f78d9a49754a2bf31a523f3a5376329e917a1e2fcb22a44dad62d64211fdb90b987b77a68c741ab27ff79f1ea64490cc4642581b9053f856b6437d790d7dd2f1314dd9c02a6b39223da1c7437fad7355ba810147987798a0b5973560b9b5d7d8ba29ffc026380fd9b572322c5dbfa0c191131011dc707148069b0cce8f03d361d32076af08f1e23c4fb1f88c89e36ccc1582b4a52c91420cb4a618cc8a9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
