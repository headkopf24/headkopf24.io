<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47e6a9054c50b4121800bcd30f91423284cba805fd270520742b287c054b221b22e7e95c78ebfca0622eb3f56a7b44026820a7c697d6e37fbe3132ea4824744abf2208a902e24a48bbe091f6470a5922e065fc176cf0e241514e2ce81c0011fdd1763ff410254c9ca55279c5d3c61da8d6e20a4f4b3e62d246a1d552d0d797dca351643e3a40a9229662bdd2d4747c990ce94f04350d8c9b5aaff5dd6d91f2901b25fc9ff61c1290cb01bd67805827d5688872acedc2c4998634476ba7bb0ae6e6d8636fbce86795322876f5570d7ac2f3d1d8f074ad896d6a2767bf2107cb39249f450b883bafe357b0e33d121c4c4dd2c4260f28c1f36e88eca48724f26f81f10e2a9c3094516bf54660de95a507c7e8b3971ea0664bede6d73c0403dcace49e5bd2dc7459f6fe4484515573e91d4612e1a9ce73eba24872a6232b902f622724932a36ada37c4630982cfdee980709e7f525e1248bfafe0b3dfa02cb7d42f47b1e0c06cfd3d65fa4a54c25dfe063961b732a757c478dab1c5fb42759ef6f539caf7696f01592846914e58e8a2b4baa7336f6428def942e8bd99168bdd72764c8ae61f01509774bd846edeb90b2b2ebfd1905818b31116b887545374d574473b686e9a139ea2e0b016ca59b5fd9dd17de376070a8c393f56030dc9a312379ad7e74186fe487d580e54035600bee73dd8ac9c5f71e8ec4b72017b2928b8e25ffbf7e35842b1ea18c5d304706c83bfc311f457cd12edb90ab950fd43e2efab17db7b9e53e243402b4551d7cb4e67a2c11c880e75bb33e59fd17232ac27779a280919f11b0906335932b6cf260cc9bb28dac2a0d44c3ab3eae78005d449dadba7ae5f6440d6d12a35e5c5fcfd6ff0db1a38bf480dbf2befd465f6a61059b391ec76edb905a153aa1e942e30bcb77b81398c1cd36c5454c6e5f31814c9a1a8818da376dc025e21fb5cec1fadbc596acd7d3ed008fd847efa9f46403db2f4549aba9490310aa9cf9453b2c33b0f800169b053b06148d67b29bed604eaf85fd313ee10bf6155fbf40f6c0edea625e9590aeebbadf6268f3f935333e6c71d5c49811b8a98a47155c1ea57d88a61d164b917e15ecd0a0fe7256817b8e8524cb4399dc28a3141a8578487e53de60d2814e31e76312ee78d18f7b7ad3f1b48f69c88e936cd88e606aafdec0f2e8af9a4c46c394ec3c7f34db4a5751dad06886f6d1218b63aeaea95fe2f1588f05990bf0a90811c7fad8229d35a8ee0c8b5a61f8855bf717ae94811318ebd94fa958e315fd6587d5bc5396f5bd9264ca8d5263a524f2760ec4a1a731136a773066dde4314466b08a0bf1c25fd18533b02a221c50852aea0211bd97e421b9b3ffa0b5fc9fcebc6bb68abc3a99cf3cf8150935eafabc993348143a70835f10f98fab56ff89aae06956aa642a149139f88f64adc4628dd8ad11b2e9ebff4574ac029390cf3088609c6597f9d154146bb39d3e641262cc6df51a3351411fd42d554c42b2b2db4feceb5f1a3b2b0c2c9e3bdf52bd36303be627c11e01806d40149be1bd49106f4e42bab8846a93c2d9ea1d5ae65e74293e7aa83e466e5a830c12046cf4a4374c823efbbc05d57ab37cc526882a5f177d8831dbe69228bbd69854f2437a018c80e48ebfc2bffc2f74eb5af245e862439637ed188af72471de5874e3af94537ae15190475cfc1d4ebdf2c9a3396435e58ffc7d1568230586546ecfb4eeeb71349f043979edecf0e4d7edb682c5e2eb78b2550ba40071d3bafac61b7b29d63803b4e7d8245d53f214ab1b25677b809c24a991abe328ce4cec5cbaa42dafa5848ce4d86566077e3608e4ef47912cc050d36887df5dfb47d6b6dbaab4bdf928e42256df572a7591f3ab0b406341fd1e0d5ec78006039d4fcacc219c5a336fb722b1ea9661766c58e021099ad83c9a129b6dcb9a971698dddf08152276b82cb976a33035a2044b92f879d0a524d43017bd971a1e9bdd95214792f85560b2dea714e22529d6a729dc48e0676afa67ec00a51fc76548188e424c76946e04403187e701e2aff4a776852f2fa31f873ed1ca512d6c66c5511495bbd9abdf71ba38a8601fa7a1005e9afc84384fcc3bd9fee85955e338c5de7090ca136a92b64c9e2ce2aa4c29c506f48a3e7045f89f753ba770459f74a2cfdca0d79ebb4b44ebb3ac28fa3c58e9a958a99ee9c958239c591cc5975fdf05ac53622269a4e51d609da7656007d98fb1ac79b802b4d2b6b2889cf8957f6861a37314272390b8bba7757a63b54958ee6a88999238dd96bb1cc0e447cd0929600fd360fdfcc58f55397126daad8bd92b5c7b47d9481a0076730845d178c7809846e9ef1f593f9097b95ccaf3b98bd66d1c12fe3bb73889f97aa4c874670d30ae5faec8bec92e8288f0b7a741e458dcdebfa9dd98497cc16cf80aa60069bab64e4f5fd49e696583da15b31c71f0afd729f21c155d77c7ca58d53dc728df1fa30cf8be2028df69f176daa16a90ac17a999275fe30e88891d6a29b9b701bc246c6231bcbd20e65057aff788545e0a63062ac59afb588cf51ae62d4eb0bde5bfdca0188fb3b2d6cdb104a27987e82692e5b2d88293365066e5bf602e50ea18e0f458fb99db19102010e8d2bdf0245a05c1af484a8fe08381af1b43ae5f244d1a2089e2716605d211a0d7d8eb996bbcb98a5fbcdf91979fc935ddbc4fac6deb78da29084e5c05f99c9e2cd8ff62263ae6e72e4ae17f9c7cd1260e31fb696c3acfc47158bb659736c3bc0f8e5df74c41c8a0af1518e94eb5ec006d7ea5c494f9e048aed438205e7a1d16aebba2d729a111d99c9af761da5f5227e09fd0f08ebb408aeb77dfd62c452116a4692921a7882f7b22512df496a7a403d72975c94ca7b452412165894832362a999c1139db96bc2ea4ee96537391b22ab8720089feacc558c878ee8ed2ab4b723c32017aaa6597a18a3ce30376f4374be58fd337a3d6e5a2da80d106b41273f0555b18b7666a8e64b1079010b9f8990cb42906f0370bb797fb7d3f1df5e49d1aec0f727141473d7ccba4aa1b84cba861648a65133edb67ef945f6d325ba080ffe4cb4f91ccc9a65efa00625b49d844518b919c5281bedfc951228067568ff0fdf2749cb30aad8745f894feb877a731e2230996a15655852716e5d895f8262c84f9da9955c74b9fdd9045fa816e0f2d1823c19f5b569946916e0519a1dd056a3c1ac9a333bcc6244ad35188fa0070276f7398ef7c11a33688d2c9b839750a603d245a4c71098454092507d9320024cfc6b64fcb16adbf40a6903992a2dc3e427c0204698ed0aaabe209a1a6602f069142e0b2338b2f3c2bfb5a53c6295725d47b50c8438ed6ca3df2b932ce2b1c85372d70d96918c6eef3304c366cd970c4e7c605f06f0a975c42a8f70dff017e913a2de0d1bd088445556b6c1514c7bbbd9befe7bcf95739de2ffd8e136e199535a2f806461228e06c9855aa306b3332fad811313614644009292154c2dd8edf3de9915f96588d7b194ca9963e80ee784067371de2969d8174c2d810da1df603b3ed5ecee732f0ca318f97581f7687ce93d4ef9726f3a9b55a006917e75bed6e56264f5cfb46e18f0f5a0d90e84dd133676dbd1db1a19254342d0e715cd42e7a48f5b3a5d8ead477bbd2ec83198580c65874a9ad70b68a9c442fd7ae2633a070832ceba9efaacde8dd7cce5a5c0f8f36d49fd8753a8b263d196548fab3f2ead94cc041aa2ed7d701f089e6b315711572860240b80bb8c2972dc6de1a68048826997566d502b83ad818fac7d1d1a9ed9b3c160dfcc3e0a0c2418ebf1cb044ed65ec7afa883084fb6ad4b34950223b46e54edea5e7e0d169ba742b67b8843de11644158eeeadb47a892bc43f1bd209cc3cfa0c8caef2b6d894d3fa7072c7f2f6213886cd241611bf5029abce2f709f86bd8f8cdf738b338ba271c08c6295105f5f440dc7828e1508615eb4c9acb25b2b66bd7f975cac5dd22a181073719d25bdb9a3e1450bda3ad026ea3169a83146303e322168cb96e2a1da6f7c8c7cdb3872c43278950d6489db90fabdd5440977b02a1844d6bf89c8a2b2f40638a5498a1163b7d0afe17d0c884d2be0ecf6296113224f989d958395f4e742bba73dc0c26998ac1d086d1114c88e571d16b89c321e7f28a5b21452e8b5ffbf8d8b0b79ec1e709c9d0d81077d073c341bef10a9381dd6778394d549866b36741f5fa20a0fcf30ccc9ec446d4dbb0a4697f937adbded8a9347d2d0cceaeec28c3d6cd74e4dcaefc2e701260830f095320dd806844444fb953d0d6e43a2917ab858fd955094febafd55ecbc448b06a387be932be7144950d0eadd5635849a40607de0ed58ae84bc14e54f87df257fd88d4e109ec0cf40b6250f02c340083053c030060ed3367a7f97c65894d3a95d04bae79ce4c8518daa1a147a2d00726aad1d8408e87ac250fe91024448b799f9f84d5d283ad05017abf131bb18e5308aa33fff3fda7ec9e96a6336ce29038f52416f6e55ec99b17f61f4f43d62c11d4e2408e73d51d783967a5be3535f8c930a7390830858a7ed950279a3c2ff919d001278a7b4da6024b4d3b6b52e767a1181ed621789db6123ac9f5b3bc295cc7aa89083cd76d32c2babc0842ee840eaa52372ec1a96c0c091386c15dcf387aa9d8f6b68a06f09fcca75a6a6209c0bbaa112e6ed0fe7a6b601eee6254f05eb0679d4c5be170775545914d1bd1485320ae400db65465ab90079f1e5822abe4673e26fa5e3acb9830eb163a324f4a56a4adb4c4d0d3ed763e7b6133300271a5122ba81e4c80b2dc36f1c5d53c818e61ccc68114d168ce81072b17d5a1bb6941d828ba956b94872dd06cf64051b2ff96e2fe39bdcc0b6e38e6f9db712b8ba3e11124351d0984a5fe653c4b464f27512cf0dd9c32fdf176f29f6398cfeadfa92c7c0dfc1ef71f7f5e96420ccfd4f725d7f60b0237b14a0ddaf4aa59cb7c898cc6c23a9ae1532244242266b5cb1182d9f681c65bf508edce987d634f83ada7fa5ca0ff27268aa0ae21a8943fc8886659808f53a99955702403fed3ad51c6d1fea521f9217735930dc9c032b4c5f10d8c3a95e1e6b969c4d5ec7578e1c760ece00a9bd714459b1cc057c921b22b16851ae452c4117a77645e4f3f0761da3ae9c500e01fda292685458274623f70333e92cccd41ee6287d1a4f0d060af2556b1cfc1d543716860bc4612b941c5a201b2a1844c34943e342d30729f56489eda282ee1c67c60f4f66428bd9eb2ef59c6dadeba3de6f6f4e8c0bcdbd83fecaaeb39b23b19a0864eb5212a466756d92db93a3193836ef08347d99bd52398c79221acf3e5ba6c72126a45b7757a6258cb792e9c843ea2fc3da74c826016f8aa8b69cf6ff404451002ea5becd2acb410fc99b5575bfed7cd108bd39755bb95c14e83bd88e0355705f56000240de2050199cdef1df0765c3a91494aed80470580cdaabdf4660225a36134494ddd034723a6499b2657e082582e06218e0c7abbec55a144bb38724a5f425f806d6382e9456a1d7db35bacab04123c9669f8562cbaffefc849f5ee0525d42fb2338f499bde064c81152d8266f560cb7e07d9f2d9d12b3c3788649614a9ac5b17dcd327aabdfee74c394bcbb05ab54f36de3498ea1126ca65f61934f7358ee435625d7b89e2a694a2a542aec6b92c2426e55ba1e92756a7022cb2b6d4b5f9cfc15a7d7dec70a9373a83455fcb3f2102e4b621cbf767fb4bae09f6ab643bfc7b504d065957dbbb208e054841ed446552e53f0aa97eae2a4cf23cb9f5f1e632e3c6665a2f98765df4d3ab68aa6f9d95865d554e693532d103c75c0fe8d89963c78ba5a8690728a1d0c0500ed9071be104d13484056e066f3a8369bdc4ef06a37c2cd0db25cc58e35b52b2a5028c93787ec8b96a9e786575286afcfeda9f218ef0562fde18a685e03dcd1d821c785bc81e2ce90b8c75f3fa730ee4af6d1ad03cb389a7bb2275033996300d49bc63b98faff5641f01caef4eff276c4e4e924d364b2b88325fd817b76d38be6e59407c01d7915495de91f1514671418766d4d71570d78144c20a5ff7e67708523a016d244c6e1b1966dd23d9a02f4efa00c837e306168dacb1bdf4cf623ddb36305777dbdf0a1d0954140bcf23d562211eb420f5ea3b62b479d28590bf4b869b9829cae5716d0e4c6b78c5b88ef17003ee4e358fcbd0b5a233d4c1c0c451b798a5dfc6db60b5dabd48d59622d1141875b741a26f6e7473ff3a8aa284e29f6fb02e369bd08ad6d92cd15d1adea45bc24b8c5496e68f7e9fc41135b255784defb075e37dc9e98ea0ae34095bab146d8bc29dea4575ca39e527c75bede36f96373df30dfe700447f516781683a57e6c77e45d4e22861a5307b09c4181607f3afd83cac3a7d9ad00bd62e5b4fc3102051ada4cb018d97a9e6871136450e86268d7c26176a1dfdf760e4c7b51e37b8c4cb47a3b52c9355832f4c8d797fc748037a685558c50ca7ea0ea77c22e31aac39d4a4658eb67a89f77bc29e9dfde9a4b652f3c3b3d84f780e1488813506207577ca193da79b087d2a0ac80dbc61baa7ff7bc8da81127747fc1b1332e2c5277a90947dd8c984792b396a894857e98c024578c228d73f3a85002008557672e54e4e175d57635386970d6a98bdc3dfe990eb847663343b0bf9af022bc88891961693c50443abbf47e5bab9944925a15d7b1cede83ef71ac364669f4efe59594c706df8527cb459c9051806b57b7ae9041c9a65a95cdd3f37c65dc18fed4d3d25502d8c9d5701218358995edf3bb99331e50ed8ec4a69f34455d0f4bc9bfa02a0f255787110a58ef6b0c29ad082e37410ded285295416d772da246499e686a13124cf47b916a9571da5be35c2c1c780a283a80c4ff000758b2883597f204a2171e2ef90778f0f69347c5090f07a06250ca4fe64b34f8462f9c6b914a29ed01680543f82c5b82c1337d10f4a6027425b02bcc6d07538b7d6261c06abe7514cbbcc2aec10da9822a7dc2ec701dd0787fc7b5fa1257f6ef5a00a55b7163f00c3c912e9daaacf6a6fc94798f58747574055a3f560fe4fb01d7ff3da2d51609913755e082c5c9e7e7d2eeb262cbe2bfaaad2033eb46905ff394a915397b994df219b90e38dd41b8dbf463689bcf9e4cbec1d2b138bd7413db471cf3b1febf3f5e0265059487f72a89accea6eaebda6958e75c83c6e25c6f0a137ed292eb98bc03b4de8d9f101c346de2b9aa09dedb7c7dbb629374bf2767d1c6edf336d4341a10625ba534372d2ab455356437e9b24ea1622934129974498d861329f45feb67d77812a1752ad66a5577fceaf57d01e0a5d2fa1d67a3cdb1f1bd9d14dbc90d5986ae2d1ef1e9e5d4da928b4bc34f98513f1e7820e50eb386b2753b36cc7c7fcf766dff7068888cbea62e59517f06d43e918b2d4ec27ba8e2a99fb173930f8809cb82b45db820b69574954b0979728a8df164aa3da62eeed27a4319a284ec84527465f180eec2aa2af764065ce9a4bdb317260e983047fa68eefe67a74ea1bcc2bc122ec3b294a8438331ba2a40bf22ae71f762cc53500cf6c13f9c48e108ea373016365462fa3eb285a1cb6266ac1fd9a022d361846b466e917e12dab80822f945ccd8b97c0ad2971c0125114b9077b233b2cb15554086f3ddce1d48a98dd44f9739e895fb2ceb01bd9ad537b1b1711790388b1ff09f64d43757fb6f99c010142d3724a4ba8295c49232349b2b9aa617e8794e3048677410453929e18a4cd09d94d0f4dbb2392c8b6e9b804a7bb3440d26cce1a7ca9dd5da30ea90a991a0e34f27360d85bbf0496a0c4836b63bd97fa9a883bd1154ba97478037e9676a3f2f1ee82861a9619114b43814ed19f846ab1bd28b84a0a2fe34b2e85d6de2592ebfe0c171256d7aac1518f695bec1ca1138b78836626f139960c0872fe4b6c839b2bc006497c8b9217e9ce3d3896baa3c303c9e9e710008420151e169baf29748373fa92011e6e8ab01e8ae644c5b429c102922ef273cb5cc13933350cca269a354716e5353ca71ddd2744641fec74a6eacf0129682b0fa285e0ef8f520f70e3f440d1c23b54de56209bafd591228fc4de40c6fd7ff17fce853b4e04e9a724d1ad1f63b19372f42b571dbfc466f4e88cb1d7f5420e65813af37af21c12054176831725af977288695cc6b6391cf77862fe3f4eae988f0757bd2a481d122d14b9ec03d328f62543daf992d302fe16dfd58833b23efba1dbe3b7d33d0d6fe8ed46e049d90915187b94a3fbece9dcc8178721ba33963046b2f17a2375eaa1104c2317e7419ac2c6e1fe8dd8b1caf69eec0c6e711109ad69bb75bb10b6f6a89f255369fb874fc1e8821aee7fdfcb8c8ea000be52d2c910f9084e165d08371062b6dd4c4abdf0526d3346bbbcc2b5fbdbc33cf96ce2d0a7a837c9415b6044a722c8495b25419198ff5155552a8a16b784fe17843d34a62fe099922d8ee7e24734e9622388224c6a5f622e965304331c4a82d1a735187c4faaff8381ee80eeb524ed66d6ab59f6fd377ad5d1b248d4b602cb10c48b1a7e58b7a45b53787293ce980e3649f69afa56a3577af437633fdfe9d77a979e3423f34df38a714ec12fc70e61f5ec81a047b45cd3a27910a66355df8bef506e0cdc405cbedc185cf218838d15aa98a249bfb71f90dd91bfcedb75ca4a1b81757c6e6a49757c462e0826660a9ee013354685eaff31264c6d9dacf6e8dd4ccf030a9f21137a7fb3439a67e1827851f337a50e931ef731fbdc3a30a39ff10ad0561d3eb82bc192dc00b1c653f09fdfeb22f72bb6fb368352f1185c3b39ef2a308cd65c44dac28cfbd7a802b3a8ed9ebb2cf25ed25bfbae15b3a0c08e127515b455d84601db614f92f80f8a7e631d0a0e86e378e65f7c1b9099232157b7c2597b2cb2e0de532d29a69ca37da03d6d7b53a6646824e1e99b4520618a1c2e1e16ed78e7d469f5494af3c847e1b20603d0f11918cc45041f5b8f8d8cdef6ff40723c1c4c4861f24b61ea72d6a3015c6c4ff2265bc3906188b5516a41e97a16e2c5727dd52e6a0742e46597a40f73fc11048695b51fec90febb3839bbbfc5c41449cb2b3e041f9dc5c4388e610d6b542b2731e4fa81d5371400957c940fc6f281d7df2cad36fa856521be97bd1de466f8d513ac69e636f28cb658270f2387b2db648aed904ee88ffb7e831cc48c8dbd46fe3ff373b6cb53bbf76f7073ebefeb068ce1a1f0df5476a67e13b79915fb2fb64abc49bad97052b0a4065eef5bde402adc8d7ec1098c465234738bfaef27b3154edf00844f3f2ea11f2a7bfa67a696046f18429d67629a3418c58b5234fb4158c34c72308fb1e8ddd1b3a2793900fa622ec22cf69b6ead35145935fd10af7bbc3f189b2e48a61790a0bcd48b651f6e0f953a0af06d030d3c5c06349c6716e246f311294709f0b2ca74fc36953216958feafac988f5ad2e9d822141660fbd58132514df5ddd2b009643db64a2a789d0bca8513b14a014a2752416f35e16c4b1fde166a34b83d050e7f7634157b7e62d8eea36dcf45439d128fa03d6f6aabd6f1920419af97de40ea6183fc2e0b3e6ac56bf2031a27f2401e634c69c65fd9cba42595b2200d0ed46a4bed4b41eef836fc41e36deecfbf4ac0b75a78160891b54c41f1c79c9381331e1859e80ce1ce6657198dc6c1e8bc78b79dd6f6543d0b34d06af5820eaf26db1f4e6649577084f43217bbe9473cd67365fe0527e5a99f82b22df29052ffbc3b1bb8f7f20f2ced0f1882ad39e5675ebb58229a936f487f50952490eda73d7917a5500d599a2cf528ad5a1b6f138ce824e3f9b9105679c5d8ab5fe28e13b9a7360ad4464e205e8bc03027b445e520fdc99039e43781a5c4454e23d3f07fbd52c657684d76660fa45b3f6ce998c6fbcfa344638d633f8155b3b539b97423185c3f2cfad8a4ac2e2f90f1856add747c3e33937fe4024e251ab086f6add12c157e318bbd9d1f7937ad2ff88e8f7df4d3047147147a863043b4c3607c26d27cc797eb263ad9f0d55c14caa39d9100c56f65c22cd96c47dd4c9528b1be2076dc50cdcb96c25af727f709d0a0539b2aca72c1151fc41d4156e5f9b9e2a7c2ca1621f6a14e25e142ca77990e233ceb038e0a9b7b09b09e025cce653b8ea0a18fc81028a0d453b1cf2e363cc905ae96ac215c1d5181dc00b50edd88bf0ed7efa0b242c85efd73ed90527e7b56169718bdc1afff1355ae1c82531863fb76dafb7c82bc2b2454eba909a3125252bd96930e5fe6c70f4337294e9a45f1f9135fd524885c06f3b7101144b034fa06de66d6d4427942cf46520bcf06718af796bd13b86c31545b608c228a8128599c4a97eba9ee90de2b3c65ea470933177af51a93e3218cd028fefdedd08cecc6664a12e28f8e03fd345d4fe8bbc0874b96e88e69f807233f0837d00ee76d3dc2136badaefb10f48205a96e98a6582ac1a63f73bc1f3647c84c6a315d1f037c4233745b7b33f4c927a499efa0ce4092dea93c289d21f4a1341e185be760d1fdd3c79e0addb6b9736b076b672ff46cd91c3606895b889375ade3801fa17498f2d9eb1c8f6148f762ff76c32cdd908fef95c0b3806f6f91c9f3100fd47e970034664727f95fe6df67928bbe099cdf7a83f02ab7ef2787fdf83957db0f6f8434fb509fdefc90bcca54b4c85b5572892ee0de6ebe37edba58f99866815092bc674695ac81cd70b30c1524eea380acaa79a5fbb8e9821fdc3b650c0e0e5a5b1b6264a061732891bc44dd9960d2ab9307ff5dd62586071ac4dc0bef788e74d7b291ff970ebb51ca528a1fb6815d65322196c9f3fd6c541ff0c106f0970c234cd99b3fdd7cdb05e4c19c9be43252a4330a1782a2c10cc8d3322c14fb36eb2a001ee771c08e00aa482bfbf84cad92e4a056fd9b3a3f8484171c9d50d478d6ab51801e6f34cc680f54aa858815346001d1c504456f31f56aa2fb94e4dab06a5b3c2ddf9965921ca90841b836aec5fc6b42b2da8a821bc998d064889e385b81524deee803b024721ab6de067d6bb77f02cf47d9d52aaacf4febcc6bfd2c1d647778aa2e592be66355e6e92a6cfb9bfe60b0e8ba3f7854177abc3aa5d6ab6dbbc33fbbf3026e8c2ddfd4d864770122ad806f170a1535caf38a946b846f2ee54f827e3268b7a156ea4cbefeb8330319a2d477dbbe8c2fee3c965b7fc050a596448b8ae6e3f8f7694e7134c888fb97829d3c7e5947c55399eaf0a652b01bc2e2ac203b2bac54cec5d1abaef53ba8a844fb8f6cfd0086ab2e5340e059a0cebe673cefdb0cc010e4e29ac42a76dd34a645213b9b57fa7c2a0bcf9680203028e605bc1d091c5a301d3e790608201d0c84017ec5743c41ec76fb4223cd385afe7e9411481ec349fbda470249e928f0ac443efb60587642f9f48ec01d1b2604b66510d83aa834af3ad85fc714404ec9cb94b8fd1b035d2d92db7e81635cbba7bf4014b4fd6d7cce7e2e1654d3c2977e2c24fda52b7ab98ee7ab4ca873a044d05e5b629fc834353ef603e6c991087854840f5efc0f5c619d0b3eef3c99da76ad2497806b50793857ddef3cc0186ff64140f758ac08a5c1b56042618d2c7afecbdec1da5eeb165cfca765fb972d3bd48591991bfbf9cdc09455868b5a4a4e364870c189bbd3a653d6d69321339bab4ff240bf3843cafdc578280074ae81ceb5529422257bbf300c0900adefc3bd78f4d82fde9de9f451c29280091aff5b3840b3feb2c1cf0dadfea2cde4d812885b9d9f113ea14089454e0c56c71a603c4037d237034ac2f7be8a848036cb6b639119dba43b3ff028d64bb194e036efe5eb0f53d857b4b8461e11c001e3af44513feae5f9e6db9c99b1ac9e0f912332edfb9503c9c03d1728cd3a91be1b975046453aff4915af9406944bd361b50de6acf943b47e82df3fc779d942711ba9e00acad40788d1aa9f3a91a02a8fa6c765d82464a076247ddc6ff611c15271cd751b407bb6d8b0638401b241251c5c6acd4e90ab3d7eac3571158b8baf5d64c95cbb229ce5bb8a6658396d921bc5340ab20edda7aa7e8ae538b152996c0712be3d108d8b6b75f365b1c1018d983f0d365164ac2922a462207e19ee3b2dad25b296a87f36375cfae6de17421632dbcd16e91ddcbabd2da5caf1ee1fb9444e53a04791941c68f76e8cff3bb145d8388507eba697b8feba246d72fa0993dee0419f90b83ea6cc0421bab5f1a84691767ba1622710fc3033c05c0aedfd2f09b7911110e9caee9ba158688c23046892c94dbc9936313f75b0f169e95eeda7a684a8f82c3d9b71bfc28c1c93c00b1bc935ab3145373f4d70ab1efdc418051e7cf6257f4a0c868aa891e75c589ca463a760e389a7d8e7c4cd4fc8a2df948a89352060fd6c2d3739ce0af6d78eb133b0217a8afc9e391ecd540b42d40e6e3410571467fec4e1c07493fcedfc95a22220ea5bc7a0bb6b55dbb9161fe20e238773990dada3ba9efe21fcfdb393149c3caa678afff6486770b2334bf99036803b1e02784642e5c230a83325af3f14773d254291ce2ce00541dc55b5006fff0ea302a7cd3e13cd77ccc7fdcb357adff563a32f53cac4dfa3ad90bc1c878a9338a99d07d2b90da336e24c7e28ba31572871f33e99611004e569333c8f0886c4d61dbf68ff2eb31b3225275816fc83805f920b9566fe839deabcf3209c7223a65e223ca7efc597f28bb9610fafc4e3cad047547ea320676ee551d799fbf4b7c7d85b3807746a58ea8408dfe23957aa5a8ecbd896b4f050a06dff817a846ce02abcba146d6a674fde056d31cf17317df4f04d7d4e9b1fed97134905916dbcda0bccfa4af93581be26dc41e0ea475f750420dc17ee81ba3c831eadb1f093a1e11411afcb731c6f4408f0e04a8165d1437f12c7030add929f4f92f219297be57702fe21308a551079e658f1a9f3ad0090165b7e33c7af618df81215a61745041b55fc53537ab2a056f4d22c1785dd2dbe3b8df9c39cce6ff085094fc9b999ecb5e662fc643b83ea337103e26cbb58ba4686459b145a5e23eea722e6ebb4000677ea487a64a8da6d8c3f53b90c9cdcf2e3d523227066a997d18901d3206a72872e9d58d755a64f73fbc026d267a18fdb5917d89604dc287f85c3701df49039b22c49195c913dddc15f2677242b79f5ea14eef5789188bf5ee20fcf896372eb908ccfd9e09ec6306795dac3c009b9f798dafa36e0364a5806f78207a6ea455d7d48c0f10478bed4bb4d3d039d794a3b4ed2253ef0a05b5e769a6c57dec94dccee61ca1177300d5bc809572c4902cd04445b78cf9427d082c43fad45f3430df19c69010829e749c86ddd6b9040887b3e5d31922308b2ac4dd7d60c8eab1e7b7ba77ca45687fef4edeb7a7715147b07efc03c989b3cd90ac94fa6317f3ede0207263d58fbe0e083e2124819f82dfa1e5359cb9c07bbb58b980ade609e178276b0e676d41d82e1b134dd58f3916623b242e577d42957745ac58e439d12838239044238e5d018057dc6ea51e1dc7bdaec6c6bb84d346f1163f90b2325dc1e51761a2a5289dd88b4188d3bd1aee2bf732dfa0a76b7e2ffaf37178f532615fb9b5e8f63f2fea544777a24d8e282c8cb39191c36874c00e3c0e405d6e75e91bb420db63c41bd1e2380d9908b4d44f258e77a141e751da31b0ef27137589a49365d97fdf3ca17f05f194a56d76a76861ac7ba577ca9c4851f43551bfc34c5378cf18232558c5959bfee12eaf312763b8144df972f939ad7c9a90eb46ed1d8ee376cab2ea94647e59ef0c1815b808525b9bbf5dfc74587069478221c304fe0ef3383a7a5a68c40838ec7255b619fc338224cea998b4e0d44ad734aa6a8ebd2b76f2ed2edaef8044df7d53e552ffce6ff3888801dfdbb17a3233acb1aaed980092ac3cdd96f97acb8f5636d9e9d36ecf1cd4114906f9e102f59cc7bfaa0e26e7217ce463777cf5d6d4b4806bcb00ae916aa634d1b2737eeeed296252bad86ca870ceb34c8ae1216318efef6ec49228df117784974eeb68fd78af128a2f4e013190e6691ab6bcb0d00fd60e29adb67fa9823e140959a73f2946025e01e7e6890cce514e6303f0e500c21d1d8a14472be939e1eb307db761a9422a6de8b65fba3ec29df34e2a0454f8f466e58997b705398a8e3b0f0cd7522f716d950baabccfc99d4e0f07ce7a70d1e908b5b8eb32f6de561ae91fa678227f3f1bfd447717918cdad8c5c44b4dfd7a597026c9428af379fa875ce0b81ebd937071c7d0032ac7870b8ae780cc79114801584dd808431f92fa60a41efb739e0a3b5108e16393f69341a287fc8ce7bba59c74e33c34f46004a000be8493d9b3e0f08c88bbd92e0e81ecac4d3c526054a2037391e1ad16c9cf43ca724e065a0f8a153d520d7588990fa7811129dec8ab6154ce8d2f98740cf1960aba38f0211a8490eb5bbd7f37d7586971d7f5fb409040403a8692d6a7f5941984a309d120d3952bc5b50557481091fe3ed723140c7549f778b50ae9806e0ee7041095f5a5c11572571e9293f8684737b89295b51795edf6d5309cf2a20cf36668e1525c76ef8fa9a586fba64b65b4ef43a4dc4de476197baf5110aaf38b327365688a6809ceb3034665d9b4519fe37b727ff167aaf5f393716675458507517ee4cdb7424aa8606d0971188bcef782c339c4ec42d1f6cffb4becf3d9ba33c219aabd9c4d52ba9ff1d128f4a9ce03e39e47a6a163c421bcb1fce723f49a0ff909cb7bb133cd174b72009283fd9ec34fe78e26fa2ee02a47baad8c294fc5f5f8d3de4cbc627c444cd193dc5eb76f0ae1a56b22a4f5c0a7e7dc19b6ca2adc5d87f4bc954efbe5c4e5aeb075a9242e2119dd00a891d0e2429a46d9f3d8591c2f7308789b66af21f8987141be1d5613ae9382a43f0a95c91e4ae46c5e6bd7f36c1fac8fe858581f3669d1ca821c4e4cb2ee88dddcc14175476ef84df3cf1f387c6c87ff8ae3775a9ddb41411783e20b5fc5c3f34aee1f219b2192590235a46b5fe99834ec8cc07dd3701990db0662875298c8269976baa07644d44a5c8d165099fe402a8c1cecf8a9049f0c8da6286b892f350774b98bbb46ce33e88d9e239cd1e60524a0b4e632d9eb0c7815c7881a4ec78d46202cb8f89ef21c8cc9f7c338d7638fe1b85a7d83693ef5731dd627227747745260bd5350f70fe750399d95847b959c7f50702904668a10974ed97bebfe60a11c4371261e65062b29d4afbb9734227552ffe24ddb08eee5a9951fc55b6ed62448c209625d41f31863b73c809fc2cb95f3b4426e189d88ef18a926ab5ee367ea07b223c7e81932151623c4c28a768ad0c450045615cd1bb828d51406a71e5bbd480666b5a0580e4fd64b76c68c8df4f57ae882c451f6e3f88a84bb4b112ed50efa0f042c13ebd3146737b27d8d10c328e150479c6edf8ccdc0f8f432b857d97757d0faa69f4581e22e41ecd2159e302b576ddd58d5a1e6527a3a67aac22d913844f9451fc7b1e9ae95efc568edb3e61271d5163426adaaf603e5e135a912d4127c9703f2a782bed6be39c8a9d5022351075565c6799293aa996536d310e58d549ba993383348412d22d6f7018ec635c7ef09d24f54c1a1f4e84d048dc7437ea5b80d42c89cd6a024a946b2d29e4fcba70c63e9cde4a8b8e514830667c7774cf3ab4718b85646511c39c45f0b8dd3a149dec7f2d19ce0fe0c199ccc99a9d0e7fd7ad7db331c5f0bc13b88f6e8c2c9cd3a3e0fa2733a9d8369dca7f672d5d7c0c265e1293dc54d49e825956863d02bb7ed288c0222117ad2471425324605b815154b8b24a15149eff9e4ade5f819ebec9423cbfc0ce079f0e2b2122aef2d14ac73a6f8b2c65516bfe9ea74f8b8a4c7405618baadcb6f8fb5c867368172a725cada15cd78f9b3bbc546700b2a7d5c4f98007a2c4bf80d926e993fec82afe883f5ccb980194716fa4351f9b17109208d45ddbc35f97cd8c45d87f70beb1a8f3520d2ee6c4c91508c07c7f209574e0c6390a0e7b00815a34559eae173c8601f47bdea6ee6197f1dc67d93a8eb77930f6e9cc03f622ca2d3b5888f2c3f1d35836493b27e80c550752a4ef408671bd3876de706f9ac628a24e4a1c3c5ef47637c855572dc9485427c0b91b736e292495bf9a7a135e57b373e43afd2728497eab597d5d0420a41e798b3686032258dd1a9d69e56c5a9251567a5836caa8098e6af942009f87e61896dc188642267739c42166395288437b81aeb0776ed6f69db332c8effa8a1f92ad7a5930ce5255ccaaaa191ae4b9749db231582fc33244a77cc84689c19f44b22e07b7778791f00186127eaac1866cc0a6ce433f9705512a1f8edeee1c01a9788fa596f86194b2ab7563278c3e1eb676f05d831515daf5e71253e13fc4ce80aa9c2b51a274e264127a6dfdd0ccd488cdcb088ad2905e51381f4b99c9d4a9c72bd36903a93687eaeb0205ee577f3acc66064a343b7412a5f7ad5e1439e563fd673940028ae432948bc4a9c4299a2f1e7fd94845f378baec33e0f3a7366b2bc0c0e9d0f0fd74f63c1eec79e5917a7c8aacca4808339929bde8e6b149047f9fbd6df0efd9438b362344b368bf35541fddbdc6050d3bf0fb97213fe5339c85a2e1ec6b049a3de2dafdc473d4bbf302347738c3b07510edb292755b3dae539684982a52f18573193756fa013562a358c910068316a1c2fb5c1c8cb0e4943614b6ff9da4dbb5d0d77d9893d37e80ebb3d3799b3136906653935a5a96defe0b6c4957d343ae3a438333c91535acf14f88ba7e99cae43958c0ff2f343d70f81c97c71b5bfcfa058e3c3f3760d6e913db5dd05989ed2f571a8c427c72fd473992018ef2416dadecfa73c739a26f75865c37e67a0f6cbc2848f49bd53989da1fcfdc90e9d8a28e5ed16a7f7cd416b8a461f89930e34c7a0d8264e89c4bcd6dd8adfb62e2b531b0673e659189099ba354740495d4d99220e462d2cb182ed3f502a9d64187fb7fcd954b9239240f25d95898c6a7e01a0cdaa3169b0fafb0c657d13e7586057b77a6c02c344b2566b31242ffd604748f6c4cad43fa54bc03712255025e54193f2b82cb02edd9766d2ef1fe0faaefdf46996d8183c45bc8740e8e7a747d0fbfce1bc8cdd176e75caee5640b38e373b7471df59c953dd11f4ce9c2e75be8fd5d7ad586221464128c811f272e0420d293e399e0c75017e586f499b7c85b96f98391411fa4bef82be5b93de0a08001e0de344d09abc5102197a360f03aaad5ee83b673d37012ba72a47192281f1270d6d8005f14682c3b2856df32b5552485adf7c3e64974911d28c241c1e5e166c888eae4595d417a287bc6893ed78b7aa35207e8e4f826b74171586a1739454fb75a9b224e8858ceb98e34814f0ccf8c6f270658c03d328b77e39a4faf1ed1eb65b06cf1b7ce76c346f82a115de7207dbb43042ac1dbc7f15a61f083cf6c3a368f5c2288b29171911bf2c02996f402ace3a18adc2acf2912bd52aa3b5a318a03fde7878f1d30e4b97714bd8f3f966f5410bef0102eeb6d943ea69f8aeede9fecb2100146b870ddd59b0c5bb9d3c8eee4dc695e7498e2b7684871e84ebbdcc36cccbc3ee70ed6865bbad06668a22bb658ef37d89e73b584b3a16eff521db3cc252b6603d9a519647c0d1e56adcf7ea562e386186dfc4b3e9621d45417e641109b101c23b088e0a93a96431a1e30a771452de2efb97ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
