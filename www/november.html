<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a69d806691065c002ff212bff901110f51948688c7a00ea4fd8a8d72c1bd9af734dc4fd519207d306bec917f704b240f68e414d56e39cf88a012cc2af4c641ba6a57b94d1569ffee53c1e0959ab7b7fdb29f9a593fe3707449b7800db0a4dce4088bd300e57feb057ffc663926469a2b53c79c3e902a173bb43e74f4b934006ad9a5d92b0b0b0f68a2fbfc380c9e72747af4160c5fe4964cb101188e2a9fa193662d5431bfe026eb9c0d83fa550654d24140cfe2878241fe8759ac1ac0bb1a6926f06ce11d3b74d50d0e2c3d6315b26a856c4a48a4cc2b85927b8b72a513715a8cbc7d7036f26a99296833e79636145b2d789872fb37ea3509361b8efcfdf7811f4fae0d31753ce5d428883a19c60d1214683064269c8a72948b1b84cfc3a5e27c64f6013dde58a60f0ce345edcd19c380009650a166d2b4b28f9f7b16a2fb665b3e439b9d881439e062e5838fcc2ae422ed6d3f990cabae3b0aee24dae2ac63674e274b979197e03c12eff065b7493413e06260706b03baf4f981dc88e47920bafd9ded5b064fba51622541f1a101a973f740ad9ddec2434d3fec79b058ad49af02234f99be4e2efa29b9cc95eef744315ba60a9d38587bf0a1cc3bc4c7642b4fc9907b1a7c940f060bcbf2648b8514f3963d4c5cbccc3b7269ce140c1ae8d438cc2b779d8969085fcf3148ae4417026d53c8431f73c1062d49e82a149b07cb22ae395f10d475f1b9d17fc6354a8b8de39e87f64c94ca049d8c72b1bc1560752fa6eaead44b8faad0015311507502a41831f91dc2dc487c00919983651087f07d37d8165327129233397dc8ba23b48de94c19d49db6ca99fd8e160b252a0c9480c5e3c997febee9bec1dd6b462ac5d8597cb91054cdb2acf72478204da07684095c05569adb41dd3e5d40a7168c157ad16723c60f9c96f4965c61bb21f104f5061eba2cea4fb531479040355a2d0bff3cfcf0e5b2cb74590a7b866ec59b0647759602919becdc0031092b702c2b806d3bca8236935dc98f2fbc2977bc7b04bc2d56b51372ae83785af196cb68ffdf7b81a5b9749fe7f4139ab62b99b967a22209327cce536f5b3b9425bd90c1d45c4e6f999b9595ad73e940981189d19ed6c255ddefa1424ac580d226cfd915a6d67538fe40a6ffa28136639da50a796953961bcc30b444e8aec8e7864788d2a56f2e45065905d269f954c583d531f256c2f94bccc0c59cb63fcba519314007ac4767101ca80259fc24942426b0c9152ae233501a2dd361123bf1e29e0834d28dfed4015f0dabf203646358ae902beb2b48e99128093b23a9d81644b053044dfa7f82e90dad005d33204a2e9c606c98a2cf0f61eb909bcff606c198dcc72d6d8c53075f26ef5643bfc582de1fb49daa8918e532027f97ccbec9696bc8485a761984860a78fe2c175d61522d41f9542e8fb630f593e36e9edb1c24454c4203ab0c7106bab774a0f8b44d027c61632f0c575cacbfb0f88d97df51c41ef487a52bd7f29c57669473b362cd258288f78287eab870e6ad953f7eb7010890d9b2f85186ad2885e4787861e04e4a24e4dca3754b5225a313a479c262bb42fde3039fd1679f3e24822c29897885b4d083db96868f751c42ffd272348c6b778e5b791d1ecadc1786d1d6f656857a75736bbb80e0278eb8a1bc90e03ab3b9b2400824ca17b0af2953517e59daebebaa6973776523edbe31c6ae18fc105a08b764a39be6cf2f6e629ce58e756c2ef3d1ca79c90a5dd3d53f40940efec757d28909b32afa3e43602cc428ebcf8589aea5ae3b890cf564c7c19173e532c0cc7ea8eef9f7fcf66dba33a44f5b00ad8fe8bf4bc46eb4b14404fb2708b238af4817d7eb3f017cb0c5f8f1d39c3fcede6ee6bbd3d2d7b3b1b1d8ecb76ec298125bbe76b1f3b5e23e9fce4e8f59ea03169c96b87de7a31db4b12a09d3b23287ffcc8f0ba8d66a13fee9c33af28652119f8e6619fea4d01bd7fb6e5e5007bb79ca16873b519d194ba51767956fcdd0300d12b2b634fa2387ab333373a55fee4424dc6ab7caa65de6c91cb2a7cc3a737edf6422b4e1a610eb60ccb69e23258a06a124646737dc2f584e292bfb483c108baaea8f38453d6d71f8d19c95f0063c8e3df0bd2d7957a4c355eb9e8ef848a4e639ce9ed642809fd326eefe2c61424c5f6bb018ec946f606dce17f0fa01f7943b548a3139a49eabc5dd77f7f90f2e35ec1a258f0b7129b8836972b5f6176fed7c9d87304d937ce6504c3020a741d5fe38886c2e82f5bd25312d612e1c0d63840fa2a4f605b0fe44dd763d645b6dce3084f1c79645be0f39a8bd259f1660a219377a792ce56d3eda4dfb71f2a1ddfacc8f6d3777a1187de1050541f5487a839885093d0919a74b8e92a6df1111dcdcc3ffbedfa3da26cf72ecd0e8615113e6b1ae4ed81d6ede679daaca6bdb20f15b425347b21c2664b12d6c5ed80077b52f229a026cdce6a25d0e20fbb8f7f3fc45c3e767f3b5773a36677c203f01edc136dd8ab80a9f6fb28696db7f30c9a21abfd76e2808a9d43132dd3b59e432025d1d21b123c169ad896c1523bd7d39f444d582063da8f5373f78b1992078b0b97972bad66d12e87637e4c18dd5d5b7362d9ab3b140a41218deffeea1b575fd28636ae25bde27c2e77510c66ce424719b4a09d8eb32d09357c4a5217e4a64c99371d208be7fb7b859b5b922b85978f7a24a6484ddcb28c2715b18fc4bb3aeb37597d9f916c6d691f58832d95bb5143e93cd935892e0d61eee9f9239105d2a7e253e902c5a7227dd3ea5aa7e6933c90a0cf82edfd335d2dde5837e975501fc0a736937774d27613928faff683a25437ea023393b576a25750a91d046ac0e8e7a5939a792539f704f1e7cd1ac5362bf6d40486de34ffda715eba88a41b1d40f78e58f93ed2c9dc9872d34f228d4abe516b564fd4dda1ce91083207be1c0e619a6b3534867d942df7de2ea041ae037eef98b54b43fbc3a2d7dd121b51acb66f96e851307e207d1ebb5d1bad2b6f5f61b726b39ad044bfb0a55d45b22e9aa318d64e837c42f4a617fe26fb0bb1b8d4165f7a4dde293ed5be921c93cd8c279c058405a0d75b144a88fdd744bf84e560d2d216abb7c8dc8a60681e63f838ce8729b2f47dc15a11a24ec022b66ff8968aacc980e16fb3dc08845fd88683d36dd87c07aebaca4234f3871e0bfc97d199d6af9f9f0d875d50c2b4e925b76f32960471d37f84e35631237e094e608142e9ea048d95fd56c5b9e23fd930440e7e6eaf5129f20e6f85f72f04c06bb8e5ab9f143505229e1c4220708ba40e31ead02b7212c75678aafb89e2b11fd30960f85489b0bf421ea77b33dfd8d2c3ab246611ccba16625c08518752b6de2f2a18e878f4760fe4b5881972d5af9bcb9236539c8c599e9755d8e77ae2557e8b72328f9be9abedc66a7ab0205d7cdc10a30830305c4440538611bb025f9e0b2b7583ce2ef300ba853c656eaccaac1a82712e0945653ab020fe520369f668dfbc14a2b621776146c0b54c2c58d9fc6438de5be849840ac79389c8605903962783f7647d0a5df14836767342ed4c41a583fa7206e22164da35b5ed0c775ba4387bcb8c6870b20a20a800500d7fa49e1324c538518c72f6291d710fc88f8d3e75f1e5f4079e781f5e3f704bbbbb4dce6881d5e18aba3ea081f08ab45100c10c03dd724040eaaa035f5db67fe0eab04bb223f266561cf4fa9335fa320e2c07671ad0a6a63633a56db75f0b28e79eac0ff39fcdf8b4268be53eede00d92a597524a42a0a2fc2594c43e521d53de39e931f7e7fb9ab84faeb66b65ad96c7f21faa02c3d41afffa2656baa2b64b9a9439e570483cf0ea1bc57e5e8ea1d261dd18131815c6bdd5eb1e2539f4672cdce1dc162e8f2b4813e40c6303701100e5ebc008fbbe6ced06dd9bc8f599177af4e87142d5261ba8c83b1b877ce7e67e416c760872daa5dd4f959738974f2c719ef321c7196655deda27fe0ee17db38b806cf12d6a52290dc209caa15c7bf9aa886dbb5871bb6604702b395ae9d398daa9b175600a26bae71aabc16fe41b5f38e02029e07e5186bd877e06b53c06ac567f51dd719c43bad105cc711cf52a15af6e2375021a2cdf5027c4492caa8ccc3d31d8c1e66d32ce8a3c73d331185049e24d77457a9facdc67bb22dbcea887dcc433e09b005cfe04e46fd4f249845e8463a673ae70d3d2a3d9ecd2de9cece1e16a6fb3b263c848006e58af7f86ab55da08abdfcca7c96ba96e7e50ae162c3f4cdf9f332d49b5f7dbbaa05e88f81803d85b540a902a650547c1c719571de6fc1aa9a827ea445cd9057ce08bc77beda461b7839b7e95c45f3111fdc3ef5dff7826c78e1ab6b7ccc3e8885abb0ae8ba33d4047d4da897e3b7c1e4362cc85476fa048a231d95f40750132218597e07cb9e274d9e88c11d558da497bff0ad9283a9edb4cefe3516115ba8d1ccdd72458e19984fef394b44acecc4e56c464f21ed92572034492dc3bab0f4dce9fed38a96bb307579a85ee40a54c6c2bd41a015fd34c183ccb86ee023484e93cbb793772eb681eb10383fdf54df151f4ac0f5fa4a3616bfb5ae6f6862f23085a2667a9c8854a2a3238db083b8711b2dd5da4edba2e33057ea63ebbc90de5d1dc3e96e3b38e37c0144e082ecd6b056d23e59b2eba2830e37189a0ef763082e5e729d00df268c4d69c3fc1135189e20a0ad881675876c130d7e49dd149ea3b5efb21988e9b5541267aa63da5ec0837ff830ae37a10dae48d1716edcce7a7989bda487fbbc699e5f6f8eb41c12e495a0fc344b3365a10de1927a71b513bf658d8fe90c1b2e6fd2835ae78599034aa8a5b69f95058e6db86b11c523d510e94c98de0f020ac28905d19d0cf89a46b7beab98afdd1feeff6d95b2621cb91ae4c7f35daed311f8552b533184e0fee13d0f0bee916fbc906f95f26966ffaba7335c1474fbaaad865c251677e2d9b83b76d741e1661e624054ea3ad8110c00523bd4f3a1a23cfbb55fb54083a5b3dbde44480cd007a4cbd1ad52ce8ad24d77f70151db67a470777e29e11caf2ca7f3b8c7aeafefce820188d40b527af135e659b7ccce6387854c2dbe66f337f2e1079d968ec3a4bf4949fd3dd46f6939cdd7323afe49df93a0620b166cbfe5aa1cd3387806dc679ef8d86c17b03a659581a84be66a40ef9fa62b15400e2224a3a1574c05fc583817ad08397b3d43e78ed76824eaac92a332873207ec6b3fbba8f7c30aa7619bcf63a83fef0e8a10175cbc6c07719ae57f4a0d0ddcbccb846398c2154868067ec67c5dbb1f9fbc192d82c3aeb365418f1b709911d29b41e40c309faf2e43471e8fa25e38d7ea41149306726c381325a5a94d57738097897dfb42ee5d7effd4bf2d84124cc23d636908e0f88838fa9313f952b7870556450e265d9cc1bce56cea82eecdf642fcbc42860fd98ecaa3644fdc54731341f519c1fde939cdbf9063acac49207e54c92c747fb81a5ad7b152e089624bcb42e149df9989ec2b1ef35d27f88e00fe4159676ed23e24483b26b722c396834dac2f3c6f73b685def2b89816ecacc833cec901c3d768962c580959751538e65f4f277c337938818309a740bcd0aabcf6d50f8f695321b6ff7c977b387fb0c8568e87cb036b595187ae3a351a1bd71ed6b80868612b56c50d1fccd904f4e942f06ca51a0436013ae1b90dd8d7c4e8ed99a192783e848cb4c47a29010f2733f9fe5b1ab202059ed7eae05f94b47fc7791d3186604e1d4eecfe201f7d9e781051b06475ec2df8a051276994a9ce7f6ab9db1c2e63e2b0ed7e31554dd66bbb6a87b59fc2111405dcf370bed8dd909b27ed0d6ae02705c1c615eab15485b3575adc9fa014e56f87adf0da08ade8dcc8d4f80db75eb06fc1e98b5e1176857e5e6b61f78ebbef8c92b132dbe07e13c5f311201ab846677d043bc17179d5d2a5fe51d1e36ab4d75786de1b7dc828716bf18b125ae51e6bed0abadbc5a131cabfc3638a10c03270f6e09fe560e7ecb0d12a6eb503e4ce1d6d6c4eb226bebd71769dba4b10df695510e4de3727654213ad0ca04cf6eed484e4fbbb66e0ad0529d62debd5d4e4723383ce2cbd72d94bee42ce3fc1835890190565b1498d674e1f455d263365d822183a96058d117b53f242ce84df3311ef421610e9f970a0aa44f69a0001ac1d6983397f9d3d21eb4f975d2f3d4554e05b7add56bb206de707a8d3a15a531371458133926c1899e8d698afa5ee9d2b6bec6d5271bab1b6498a0805ba2e1918f7840299d4939d924978adc7af274bb0df92ee0b5ae6a59d17c32b519a01040407120066b5a3ea6283df5b9de81145c55162fd799327b414fa1e3c5fe5029159b7b0ca6b88b7b9db6693e54ae7186a4de1dfeb8623cef741caec5a0d1aaaf73f7fed6f450aabc199231a8e8c6a26ba9a88f708a911b0b8f07c088b63795e59589345904d635de5812da507669c993fa45ff8440cb83a27dd53808439a8d47516233c1f648f921a33891cd36be3497e43aeb7b84eee04ecd6ad9ed1b4b66a998dc9aba1dedd278d557506b7c684c4f149369be3613f0dfede3f30b3bcb1c10301e15816d09ebca55e9427a69a5556c33bdd03010095592a16f1f195649ca91696a150613d87f3d217033ae6ff7f762e2cc736245b0ff8a3b539a34f7a7cd7cc0439634e5290eb600426ea462293cf6e41dd190b299e400aa0de54d94c58729e1908f32618808f0eb1d0c28605da6a241cdda99e9687328529d79151bff4e20f47004b89fcf114460def78e5a7ecf5b524e73d3fa9eefd5033eb1feb12272934833faae6a93647aeeea58dea1aad10d4ba66a4fea1532999c29997a9975a01b8c366af628d14c8328d3516f8311e14534028d319d161fa4748557d7099c1bf5160a37148d96c9d5c6be7e2345fb8c1f54de3b18c47f6d2b2f0693ac921868cb577f8440c6e5a85ead233049dc3637b232e2dafa6ee171f324b18ab6380247b27d7157cbeb1040d0904a80730f5113740356b02f1384cebdd33d0b349f12833e1ffa84b5231f18cb5404360253d92f87fe228f6f0d0df0ca27a4f1f687776469463cbf3920a0a130ef68966375e3d4c0bdb65589179a6d6be39f4f7117b44da8d2c0d966fdd1a4feae413fce282f6d68ba429a094ec5b035d4103e8a1ca417ab662a404e37629ddb81262dfa57d690689b752aa36fa4aeec1042a50f75b1c2b56cc0e71e1972a26730b56707cca929dfbd919b34fbd131ebc8a5973846e227738dab2ae467d6a871e89e72e371e7270cf6dfeee59073f914f8d18f408c0969d4c50066389a261cd7f7ce4e145b3161726a5db3c9744294f7fdfdfbd929dd9ebdca1f05b78834dd0889b8e3877ed55d30b7c420ad91f6e6470c83aa7ed1151b2bdffb02d05e68a8dcfe9752a170d0bbc5595a458a130af30bcae8d64cd1046441b11da590a67bd19f7ed87da06227836e334298fba72129e20ea549c005039ee68d4af43f2598218869953c124b7b88e4294a8f85fd17932d343bcb15d51afa618f4a3cf49b71445373a6f6192b35014a07318ce819109b0bdc00a8dffa4cb47829d82c24819723c9fd65c5888ec293a258d2a459f4cb2c0b1bfcee298ec65f090491a15948a236f30fde724043b7e36dd1a498e58f72358e1a1f744db88e8b206ec3bfc85cbdb6ff99a2b14fc875a3f2efacad0f04003b68904ff6b2fdd65c04030171e2da96b5b0b235ebb0e6043c3ccf749da84ceb0616c8895d79b2e53b3c992054dcdd917787335bd2a3971c786b763f1f2c084bd8d3690c066ad4821a99e21d49a7562cfd04f1e0fa370fc16f0f29b09691e2270bf9659d50b90fbf41d392f4a66335bc53ef3e4ed0da123400843bc1aefe0f8ba8099c22e85b080e2d3d65db2e964865d95c275824a9090d290a1e8ff15f5cb641cfc6283959d39cdd92657a1df5dc98e79e25e0ad30c6e42e910b1f02bff1c1a6ea94836c2da208436936c2b89d2fade5bbcea321959281a53e693ef93e260f113a9ce601e8f7e25dbf5336c64c96832f470984cbd73b321fa8146442171516d7e01c4ac535e01adb409620935deeaf040658bb39aa990484f71af1ceccdb497a154140e108f65a714922c1f8b77a6c17e4fda07c47caf5347b725ebc3086503c46f5106402d91ae7acd3c6c5319053e3ea919a9d36c6bd9c89b3701b5d7f08b3f8622c5f8d8086110af17f0c1a4ffc7e9c9eedb6c2f618c7dbd69366ceda289bf4884db77c97c4abcadefc73b89156f57b4adb7f5c9412b06886d192670ea778f0eebc5f352a2657147f1a5d917e068a62fdd9b0d81383ed3e7180780620927935d1f2c2f347df41d451091caedcbf7a57024e548b474f859cfcd258f996bdedc3a19da859e2550a523682652b11936ec3a2dbac136472db4dc57771f217a088399b9777f96e81cda8861cfb3d8a6a92225aaebb128fabf06d9d914c3d4b5d3e29db38788b33c4752dd21d6cc38bf1dfa3178746abf46446a7cc1e574cd81140fea9001ffe4e98f6e67ea35c644eee1d61daab0bc0b685981f0030e897ba0011ecf933dfb87e919d1cc3af884a1c0ed60fee012fa279252f9a47844a4511cab922e6c2db355ba2c0c4253db7d3257573bbb0d3d94fc9008766905843bc25750659c166dca1b2ac9b2f25907dbb73fe673874c15039340401e0bc8653bbd1ee0bda5e50a377812f9f48180c1048c18262c42042457ba53e2c7bd7b017e2269d8d97ee944174ea0cf36948111205741c02181ac08e1f064790e81cdb9c5fe4e2402be662ca1b28ac5f9a0d9537508bda6b6f5cffa6c1df519a7a62248ce50cffe1338fdc39c0294833ceaa2e812b03b02b62807aa8d9c5a236059a5dc1981ff64c46ebf599cecf1cc4c48a1ca1542d9cfecb8fe3424b4dedc13a4e387868ac55da75a320428909e8302b218973e7671eeee14086f6c05e3ec980d34e762532f28c97d75cecfb34e783cf93b88cc6eb9046dbe245a5178c36c1658600307768ed4ed2b8666af3d6877c4eb039149f7e7574889dcab4946e1dfd397bb0b9c48970e669fbf9ec28d76b54ef662172ca72a0f7ea798c208a1174e1e3d3fd5d30a4aa263cb1b1ff30128dbe3cd1ad0c206eb32e391879a894144f9ec359deba33907902b1264c9402d1159306f399530cc6e2b2dea170f9bd73a3d7bf4b135d6f36979c3934c4e1b59f3ae0b4efe2721f027ad19b65d87b28fa2034395921516798d7b020571b940bec0d0638d9a9a5fa65377145e60978dd2f31e99698f321db8ea5ed8953ffe16fd9a2884a9ce7189ba6df78c3616a58d0df37802aecc134554655db8209a77d35d7fe7b23bc9d50d745903afdc84f528014a8479688d3960733ce428d54237724ca8708884c997721ee44eabc756c6e091a61bcdd00f0b67307414a300664696009ed25b788a771114ed0d486d233f852cef52996c088e11f9b574e72b1a61cb87b46aefeb1ec37df1b102118f536b6375d673fcfde1ac64c7820abd1e22476169401927d7f516047d95bf96f1adfb6efd31680d1b2368ac03b911f7fd67fb33069574fc8b317e2a29ff5e4ee3ee6fbbd3125447420db40c1784f39455d96303421bdffae570e148437795cef63f45363c5b7ab6967b2945d7fa229bdeef3d1e50eaf3471f2de9cc96b31b2ed5521fb47ca0ff0800fa9708078836e8e52bd1ffdca381102c27db0b7b2276bd5403f5679a228f3793db0a9e31398511a208775c46770dbb008c70c863c7bc0ae61192b1ae2a74a9c0a06143cbf8ba3b0d5475dfe67f99eca4654d3dfe35dbeb996e44ae3e8b067c0e2e4f185bf71680b2d54ad2af7c080f28d8294240c1d2b472ce27129b9c5bb1fd1956c3c9ed5b7c74f642b6c394a287882c7fd6cad2b2dabd74c67e15224206879626d1e95b0f91d3ce9fc1cd9f3bb1d0d166dfabd869e8e02d069ec5b6af0a2dc124bc17a8ebd0ee3e5691719825d82afb7e6220a245b1e49a23e5ea5e43920af2a440f1f56592e4be00c236e36e88bbf09b779c5849589058aa60e9ed056e7dad94b35cab066d1e0c680869ca15d384703959c425175cdeeae678b3a51062ee3d196f2ad0ebec6527bc3bfb3adcf2c28c846d12b6b46893a255a1513c16cd6f77d32f7930e36a3639153e83daff0c484bb9052a4846503cc6854b1b44ab45e048ea5823854b94bd127ac36577f8176d0b6e18af58a818105242836b5dcc2c5fafab4b162901c21b069ed959df10e4a6ad95c2a65c47852ba14111e3370e1ab880c0f0c9680a4ad1a1e45d5c7cad1f21ac5ed4ddc8dcca32a27506f2dc5f4653b0250890211182e58061d96a6131324b7afdeb3549b7d6ae9fa7a76d9a88f6e0dac6f485baa048c93441e538ab0d6904cbee0a151104cfdf1da45d59fca183ce8242ad9ea43975d6cd0ebc20c1d6f470ec8d108f58d87c386cd5fb6aadeb9426015717fa58a9940153ec4f4c1b512140755d387289b7eb2fd9654f4f579c1bf56f5011b4add8d968b2b5f5764470901262ce39b6fba76a6e07d0bc1d73b445c91192097445e9cca55ed9710d9733905171c678b652bdc20d8c705872e20fa156e87a6cc263dcc459fa36b205d69c1abf9c62e4d99afa4890995bb2d20024f1347df0fc29c9313786c0f8f912c78374c4521864e2782a7a2ca14124b89e2374fb81ec29d1a53b8474fcd5ace8d07c3339195dd2d8d03c3cb8c08b8565852d384e0496b85c860255724aca8a4866de82bc7de91ddcea1c9a02773f0398af83ea1aac248591ff4264eb3d955dadc2a891c03e93ed9cefd5512c66852c4d6c46c26688b268a588145bff94db19445efc8671ea45d05c970e7b58f1aeb3b8c3622ff9961fc28f88c219cd29a765e8c309392938d38155f75fa4c3bd0d5888e6151c1044e4003fafce746b9754fb952033fd983ca5a7213c1c4af3454b76950cd2f4aa6f376961d0e13b117e594867df440b2a641120223deb2fcf8c997642d55751817f9e40ae47d4b16605ca756726ff5a8ae932926a06283c5b32907094096b1ad4ffd96ff8a22991380f48a357d80dfdbe06284362fd9dad8bd8829167e147dfc17aa82ae969ef72431cf15ec6904a426d36e96d4a4edecb0e896ddc29e2b150eb174479075c35ad530a1bcc9a544ec54c07d85db2e858f1c3dc6f1188caf09af2fef43891fd072a9b290330d876a627d3809fda5107f4cf96adbb9f93bdcf281abc93433751131c0574f8265628de3548f6f7d53f64df6f9b1f694d72b2b606f41b5a6b942bf36cfd72f06369d12a71ab58d845ef71f6d663307365a994a1f8bb9402192bc7871ce9597d7dee923e81b37259e2b7d2f5bde8466d80365ae5d743b1e7ac73d5ac52f8c95af760aac0adbd519b756b8f7e304ebdb6bc06817d9080817a6e5c8dbfa8589f262713e8507d963f5e38de917269a487ff8f3299940d132b1198401be8e58e19d0e810030b97ef3cec734745cd421a4ae4efe11479331603a349a9c6a9c0faa2ef6918dc31dbcc5777e0c8f3b18a542cfaba78ba7446268900c04c8f4e2cd7f3ee8e93f0f86913ba6dd5217dd35cc1a40434f900039cdc984c71d19b68364da1b84cc1f11e0562f11c8e9d5bcbb1a2c331473915492d5cabb9d1d2ad0a12ff595aa7b3faf6779a32173b2e87a234f1f90a921ff8cea07d2d83d009cbcd9c95584a4ae5232b0b42519193d739f4e75d802bdaaabf1c81ab2f96d963c0a71f1e0ff6d881a73623abd9a4aef7e4f0af5ff8cc1487234d64450a2ec17ad2cb8f22a5f854ad7e0d4f036e6861114e8491654989d7f1230d1094ef74bddeb0e091959bc17bee3b916fa52c20a37a841d3a9c48eef145cab5688f772c5f6166c66ad39195a5770aac39e11d217b815239e19f98d0805a027d5b73bb97584bb3baf7061cad10d83fb3a08106576a927ff7097880d414dee73de93dd0ff17751b1e9c18b90ce00babb0ed2c7ab925cc8e6df716a9867fc3a97557d15a09fa2007228109800882f7bfb6309132e32897bd64210be67de9372ff752e6e5063975a467db8c5c72dcfb7ac4521576ff5bfc5af5b6566ffc40ca7f34921dda9201bb919e46f006c9c76216a66ed61f29c77a91e62c959d63df0b56d4dc286f626d96308dd6cbfc09ddf87fa6359c59cd0e1ead25e8dbac2712c9b18f7a1d5bab71d72b64f68ce718196ce159ee19de2a0b1df910f4c4e51c74edc316f007db58cfcc3b742ea38c0ff56c5a5bc0e2886ffe397a1cde29e5bf86be5108d69e098bccb64ffdc662230014c76f752865d78c39aec441a86233210aefa4ae733cf557351646af25c4ec01d042c209e9e58f2e36001b4148aad3d09595c329c253068aeb74a7b308d8602a838821ca4b3e39ca341716a33a12d54c97896c09369c96e6518a4662213677b6a1502f3a15cc98aaa0687e6a9921d909c9f183a10e4e923a119ac8ecd522407def70a0db9ca3f34523faa3ddc0a2dc09ef318b1ebccb3aea76d6be80757e0b9e966117d00d937c1aae01656f19f0962817ddeb52fa56b01ed488ac22d1cbe384aeb177fdb7b18f8ceaf1a90b478b45fefaf7fdc1a00bf7109fffb04929962f8128ea1f9ab391c0c265e45399fbb1c7eec0ce476d84809756ed3fd916b444e116dff32006e08c282d4dcff81ccff571c16d896b8632555c1b6ec642dfdd507c83f9784563821c76d9c001d4726eb348cabecf86e77759105f2cf5830bb2a6fbeeaefcb99b656b6b31643463709ebde10c0bb77e122cb9e81b9d78f715fad3e0a455d25f295d1a868f0442d1beb1fed531033de177f741cb6effaa074c171fabba201cb6523e16a894a544450b1b9c25ec93ae4630a55867965b2a2b4c278c320508060a0e7a6d93e8eb00119a3fe35f860ca01ea8f6b79672751a0c722152a37ef52adbd5713b5c435229181c0c7ab2de8642b5b9ebce2071d260cea547482b7a3c30286cb4675f7890bc40a6fcef54dea5691c5546ad078477d0b5e2d1a7481e6f1fa3ea4581fba6ffbb5c5a60ba149210c7c8cf8e6809bb8af971279a2d4f65397cb9e4ca443ae13b1eabe58b19578363940c05230c22db89c719cf09ce17416566bc591fc098719ce57fa882053c97d26fabf377c3a4548391d38cbb2cf4ebc9b14ddf88883f41545b841cdfe9bdfe5a233804fda19b3c1e2e962ec19dbe85ff6ca649bffc753d9cab0bc8431729df893cd5838aa589f1a8578ea5e0b60eea4f11a1d09b0a1aa15e63601b683930283e5e74eb55cf5c910118642ed0c72ed6e4b6c86c50ceea1e8a111b687f0026a0e1d4588ee7cfda6b4283076ed689b12a54bffc3fce706e257d9b1cf3b7dd3ef84def42e847c7a5aa530e060a94483fdf17a7295b582be3e726aa28f0d80c9cef49952416a4108834613024c98b6516e1de479db5e28135c437a71eef7725b4f416873987ab93d966330a2d8c0876954b2777cc13773c8bae305d899ed9c1a9082e6d06a7b74ecffbc9fb46005b79d05e7a5271e1c33857db1c9046c56689243236613f00274648e0112fcac93a33397cb8605640065438c4f630ec95ffee46425e62e595a4d7879c32b5117add4a38952effda56202c85b04c2571fb1a41682d84248f1a59cbad61b0dc09b0b5356184a742779e03630b5d39263a745752d1ddfe3e2b8875b4568badf889b18b78cbc6b431ca393eb3c575f121e0ac5d482c3092d7a412f8733c6d86771b75e2b906df1cc2ff3240ef99d0051eba0d56d70e88bc5fe75199e80c778db7b39299365269c0a8e2bd2d45b7667e4c735a74cee48904b9019721e5bf103a6c3f93cfe6975dc1e6e924ec01dab33627cc83e6de0119681430523fd61848683d99bf8a9b36a4f30300265628f2c46458103fd56927f5f325e489bff87fd8a4d8c3b86a6decf4bd8a9bca1fd25756d9e435dcd68c31f596a747a259afd08b74506aa5913a99e06c0304ed2c69f419c64c4e648c4859e4877cc6a6ec1b7f70b7ba4eae41f69270a21e197e886d07970fc4f5a5d06cb00fb55d19301ee202a8603b4697e6bb05ca887faeabc759d657fc8df0973bdae8c3d3a412407cd491b561deb8d6ab2bb08ec214ba8931d11bdc393cf00fd98eb14c8f16f49708bd3bcddf383b51cf9c876ecda89afe05bef8d0741c34299cc9462a67485a33564072d7cfd2c0d0e40688e173c7cb6c58d9f5402cbb25590435eeea4ad7f90113faac276a4667a8b5ee395bc43dedf85b6e5689df083cda36e6401b4a033bc4ea0e4bb54fd3a546351d65337690e28dd642a5ee80c389d6bed325b0cdb831d35f81736d00bb820fd42a4ea7f4dfcb1105de25840ea2dfc1406521211a85acf377c1601086a631525801d50c7bdf98803a45f6e3f74d0701980c7610cfe4fca038bdf38cc966b82894c81e01ab8e2ed17a76add478125ca63f41f24ecda11ea88349e39be81499bb6a6d552eb7b2a389df4b1c14c23a4050ac3025801911fddc4f7b84e1615c3d9b2d6ececb94f3aaf58cfa3931d72ee9d31d74f511e4e7e3aa403e284c9ef325a7e86a5a0ca008b12b382a12088d0ed87cb8ab28467e10364d082e20f06751cd7bb14ece086f064c7baee02103bd7843fb32c56234bf04ce9d14005dd2320d9c13279da2b2aa2f6957b05a73b799ae8cb08bb4953f78fca01946072ccdca12dc05d77021da2a2c2dea8ed0405aecd53c204660a89df078bfe0a3a40a87c07cb207322766c22e0283f53bf094556a08edf6c968ffbefb5c44365d37780086feccb0f2eb4d0d315661b070eb08da10d79a2769d7d236b084b1764996524c3c3d62ca0ae355e4d2dd0d4a132da4d3dea61c2ec0dd5c970656c6fdda655e80b5b6602daf331011d997ed606a627a8f1a52a2487bb3e40102f1e78566cf7a531b3d79b1e091fff2153313ce8c946839d5a032f9d3c0444522c88a8ff6af25a09d50656ce4b12e33db58bdc13debc84fb6fcc91248555b3d93787150b805fad7d935ce7ded717044b298d2091e8b81c5cb8e9bba210ccc8971c5fc2b054d4aaff4feac9d0f9313704e2f85a30cb00c65c10f66213b3ec85459fdc6e6a61108de222efe2d752e1257d25ffa5f73ebd091b78e84a68f996085e9e881631fac5fea859c5a47960dd933fb9c99202d9d51a6f2a81cea0892ac3a97e613f10d7e5cd864ba3bb70c122fbd2b512c6053540417d3e13e2c25257ac718fd8ba2c26f5b7cece1ded808f5dabc9ade82007b97ffcd39b63ba2394b6db0a0c6468fb5bc3cdd31c00c29168ab72684aaca831eae2a0b59d665b9b23bc3e7ccadc1237eb37777c5d46155f3d265a3c7e01eafe75c0e1cb9811cb2a17e014aabdfcaa0b66b3033bd64d4303351d6ca43b83b14d1805b438c8a9c3475c7c92b397633b3e5b48599846ff512b5c37153779e0d23da140869dc2235d8998c50a2484d2eaeed0be8b0436982e58955160ffe0f62353c12512e20c9ccf40085ca70dfd5f4dfd956c0aa877dd8bef3f9cb09947c4222b88bdedda579533acc21e8b693ecd78f52d6c3bbbd44f92cf3c181c03fbba9943f17441d00d44ec8116ecef9857eda745b27eea0b27652f86dc216dcd256201b6e81028453b5281146cefcbc8174a2fe82c4353712dc36e20914d7460eb681a6f7c8ac63419ac0072f66ff5ad539df6c394e0f71990b2e491b0d5f131ef9590c3f43051c81e5ac3177215f850335664d780d7bb16907e80cd66f9e3bbb556a1ca2a490e0be610c877226a73e9b36904d3dad6e974937f761926b2a4f843a59acd27f36a1102c084ed3f7709900fded2a35bf26aae20b9d3361b0b7987505daf32cfc3fecacd92323151ab1f15cf9c8f818fe70f0d5e4c3e3b2575ca3594dea11fefbd440752318e46507c5ad716bfc2aa528acf0e3e1ccb9120a3d7e4e2de5328c5d18e6a76251dfe27d8e63fb4a64cb1b27e0ed407b477bf3a53f41f449e4d3fcba5112376f157d5d1da381f52448589d3635d4cd1d77b33953d13e2d400226ecf182c5691eafe3c8a32786a51c4e5995d66914bdaeb09396312bb487517ca7081d98baa2dea4f0608a8e7223d659209228bd6896cfffab86d26d57a0319ba5455087b21db14484f82f5902d884f9f50801b84869648b7392f6aaf69bb1dd6ac342655e2185c57467d692a8302d001eaecb5be4b5d8363eb87532ddc0d5b63254b07a780addea605ffff4438c4cd7dee995727c41d9a4bbcc3f5ec37d871190d9be063e106dcbfddc0d41d5e619ad15948f4b2945d598c081e3eff900c2649e9653590bb27db7337586f999fa7c3a8ea74e2b655d0c76e09336b985c9e71311f90fd645d7ad2c98290deac655c27e17d19f005ff7dc5f4d5bc745554d5e91429420630a4ac66f37273286909ae99ca37182b70c0e59d0a8e7fd3037411e3be28d357c770f9595b82c6f5998fa3faff414752921811c49b92b3446fc0ee7eb2fa7f0ad0024b176feaf2ed85008d9b3e425cae1c078f360cb8fb9bca4c3b2ef978ada0378ddf5be9cb5e9bdcee5ba77d4509a582a126ad95ab5e8d0295a108793ea38949d3323ed643dc9a96620bf05e2a1a697f416373f577448ab8164516211c578f4ca3dcee5886b03b53196b17969b7154fb45dcaff7a5b29c85c13533e60c7173f3a5b2f6ca778228f618b2a7a51fbff389347ba8102a3bfcdd2e932077294578399c9c4e50b8d5e5875ff0d1939bdf7c00b1a90b547b4d0d7c76de30aed062f1f6ddcb6c9bdcad077e2fecbba072fa1a00e1c74f4ab05612c6863296aaa369b8e900c83c228872797567fd7cb6e4a2b1f08b229c95a276cececb153ab4bd42bbe896faa1e408d34d4732c1dc014538f4cc36bc990ff4625bc266a91a0a4386c152e96d0950651c4f53b1fb34828e3adac13bbd2c689d00bf3da2497ccbe4b2d8c12a371d3040530584673c7b5651137790a9a62ac5ad9574f85beaab147cb4449b17469f8fc3efcba8a6fb9f31aebdb23fa2adfaa2a0c179a7850f78f0cfbafaa7234f087d7248de055ea042be6e536c16d4dbd8cc39d75d892bf6e6dab172c6ef3b72700ce61dc365015b978a21e4dc572be3a5cbc23e9c2d70b8a6fb50ed3a74dc421e9b75dce27de07ae17e4b1a265df4ebb122324fbf4dda9c80d40dab667d3068df76396e3a9650c13ffec2b70bb293642ddb2830dda86b3f6583170414bd5ebfaf827d6d1ba6c621587f3f44406dff21077a78c0dd4609b9e434802ec470b53f43de501b20abe7b5fe403162725cab8407b5db66052b8bea43a33430aaac45144833c9be5b766d95e47e86064cf8921d6da8750148c8c5e1bf059f6ccaf86c9dd5bea749f8cd54d2a848b76a58887a27174a1c84eaebe0ee5620b025199a28a106abc55ff33b2b722bb171e62bf89e945b9f7daef23e39446d3fd016badd9e80473ba23ecce9a4af5f5f3bb3bb3e58cefcbb62cdfeb848639afd69c54fec3800a15b3ef64b8c33ff909896c05a2896aad0e1dc926fb1f9a75a6c8ef2096fc08d37e8b99d158f70a0610ea78863bba1bf8fb99fd4a415fca8a85eb657e605450cce2f0dc5443f75960a7206cb8cb661c8b4f59e6b349136d00e8f54123527eb7cd754a6bb583d1a854ae85024a7b4b16c5a32aa0cc0fd614a6bc959f54747189dc44a4b8751963cf11394a013d1b06bc2b3f379b4711cae9627e45134b54b79a8ea2e58f64ce7f6cadcf9f966ad6e9d81b36c1b38f767bf18554b728867781e65d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
