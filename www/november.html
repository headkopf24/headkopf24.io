<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3cd6fa91cc3b11f93c1b429a4e73a2c698d05dba18bb5479b570db3cad6ae9cac994530023ec4f42f010395c288059f2bb2b15129497b628fb262f6837bbd84b5b08d5d9373753dd4f7ab33b87e72d7baa8a98f6aeed97ccfc42c23876d5258ba53f39517c75f39a30b3497e7e6f3d3d45df78e033fe340cb85327ff49c07e47afd6df8676e83120ba531b4f2d1171f24ee45ca07899d96760f11b5cec98df412023f8bea5f9989c1dabf97f697a1d01cdbaadf9e655bf74f54d3e693f99cd42b167ff97768b0e9f61868acb253fc5d864cb0a71ad993be75782c6339cebc2095c67dccb05b12211e2c3fd4be2d009bad762e719c3d4239f665be675c837b7aa2474635690840689abfc7c7ac58840e33aa7e629650687a55a1c5836f668e23fbf6f18a82c1ef38c35d9c488ab4b9c637890e9d129cebb92cbf91398cd9ba7ada77c561222169b5065ed7b846dfc9c0658bdf060e316ef0f4fdd78466c07a9a54252d737c453c5b28a47fa2bfed458f6fd193cea10dc2caca6aa187c51a815f785d7d7610ced897749ad972ca3d891090500a5391952cbe811dd15d76e2e2c48582378449dccf4275533a034df1be7a6bf4b4ef2ba5a6687911d531c1ef2da70888a234bd5249b1c04870353cc044b0042f69edc75f32ee5a9b26a66ae4c32175ad8998f13f742690a2fb4d01f237a63dc4431d829344b0d45b1de000b29228c02673df3f9ae2edec4b7637380efb699bfddc7106a8287d8f1ef29248d785807aea2e15c61f79ec6d791000695be67227b5264815daade53c12cdeb031916a6dcc30814168f875f8080ff4d59ff63765ea6195656bb0d9b27eb7bd718e4a444055c4c84ff04c047d0bcdfbd41ea6798ce6fa3c022c04026f30ea47971db35b5d9ac006a92a09f8774f8a254972618f8eb99625aa58d1bc2702a532e3257133d1d4adb6e2f686903eec47501395d5baa25dab404ae6b28176d78a8506316c62b595f1e5241ef9cac183c079f0c01b8a5df1d929ca5714b57d69ca31f9979a780719ba06db2c3b1c92fe9deec0984e158af21dd6a214c19929003ebc02968c097d8ec356fe6c33808146c2edf98b3760d1c1aec376a38a23126d7ea4bf43e0aa48f6e19150b9082c1c5de8b72093d0333e26a34cb8c1ec895aef1e78434db76115975bae3d01aa2c249e0239de67ab678cc83abf7c3bf6a78541bbf3fbeb7037dfd9e86cf1c21ee92a1f00c80848fa23ba8cd2d776432454801811af7f379a23c4c058406625416f9bdb49bc6b09f7333c596062f0952660ca43b94684b826e7e187d7e8ea241c386217c3d948188cefd1cf8717a0c9422ccb98210ccd8b701bb82ac2264495768ffd0c8c4244ec346cb1d714a590f209eb241016e42b00b001a03772d985654c6ce922e566daf07b303a825fb85971704c8adcbc48655828202fbc6b7e1451463b5d905010f7aa9de03d19b36398a2aff79a0192921d870fca9c6cc5bc90170870749b7b0980e53dad5d36a63d20b652ab7f651fdc57da605422869ac8865902661217a793711a98f1f5ca2be0d7e46c0847759fb5f13e0d86d2e7513b853de089d17272c096e548efac16e32cb8ec530f681126e889829246e90c579706905df72bdbe883a521cf1f5bb211f6736b08eccd773f42d2a46ff4bfe41a7f5ab15b0e3aea7302fd9d0d84f68c5699f20ca0f62ed406146f3c7b61695ce4dc02f22c4d427bb67436accde14c2106c5ee4d4a5e9b197939c1c6e124f00888f3181114a36caa60bfe725ff655e4eede11eca4b888f409d78775c8e47fa3f53f5ae367d58e39fc2168e2dee1fa7d9ac47c1c7cb897c396662ae7107e893fb1650910f1520d807e5d2b3ee499db1165d921844232325740fca9b0f04486760af98b821a2eed2fc0088bab691be0f36657fe2f9c38fc01a619e78bc84437072972cf79d1867cc4ac264d4c8d7e5b08d2995a59eec2a470cee56109880aaa4926a735e7030b6d746449d15dd17be4bad85ee4cf8aa33dd3e32279ff7cd2d84d68c2f8b105cf56629e217617d6586f93e60c078041c91785aa9ca205f33e1a8cc3a84c678ffa636b936c6448d7303b76830306c38cf782fd50c9658de56d02c32728bb32c0360d5dc2146259b8cfe89a64962d6fb8f1d147fd45cc9309ff6defd6554101a2cdae323deb3b96bd6be510cf73c342c6491f53bcf5bbd0568e33a7a5907c8877c94ba63b380cbb8b31318efe99c77ddaf4bcc3d8c59fb6ad58a7a7058a0b855f95b2c8dc6b4d3cfbfe2a62c5cf460125fe3666fa3f83846539bd5fe1a5987c8ae0b1c7c4d27081efc65b8beaac01eb367abe8a408f3f878b21c032a5fbc819187ba8370421479f56383e8a9c1f01f8422f7fb7752aadbd9a260a9a9192771202e0f06634a344d7c07c3ff02d8dc8f7c2c35966810296f4f100ca5c48f3fbcbcdcd333b607aca0bd7f604a0098a9840338028762b572dde1355373d5c00bef72fd0c5d5c4799a8785ddc7a2cd8e16c87252f1bd04918023236696cc94ae40ee3a278bc29f9cbb659ebe889ddd92c80da39f5891f0805dc791ebc1c59eafd17b5066b4ab3933791039e4e9e54c5cebcc7225448244dceaa6abf4435624ecaa2680733d881f81786ed6154a8f4b687d2b59845f10b270ea52b0a27bd1769a57efe19d1a64eac5bf37072bba63a8a00539066b3d42ac01285455027f707802e7667d054bce7b4e9c598357efb2a4a5243b1e35799ff1d98e30cca89b50052a546cf62350550f30c74afb46adf7619ff57a7d6ccec03f206703580300516d28546bc5cad9c26cc91c4578502ccfdc66daca5e0dab44b0fa752aef48059591f031555fe8d0a4fda672751094da33183d1432177a00db2b78dcc4225442cb59ab79a6a6ce2952cff303b3c03ce2c110b133836a528cb308fac8909f934510b5fa79848aa80b44a4d2a769c4aab4746b3646433c9f5fe4d0bf8f3c68989339717c218b1de9ed6e69d0cabca492bc684f6665bcaa8a4f2c58050118ab495c78e6cbdcd58cb70df5ad2ac7e343972b66928627c107b4e4c24fd69f48a65968d522c2e0b2879c01e4ab6734823727ee0e3048aa40053bf2207247a40abbb1146a51f3ab49a98dcf2edb16620cd85d1e870d330819bbe658c7af5b2f769bc72267ac2852d4890ed0c47663b6d408f0ad5455696f9a4bbbeadb741f7cdf8f3a78c75fa8ce970355330ac0d1021798a1321f03888a065952eb80054eeaf555e8831c8aac2006c1ec8c7e6b16ca652d71fcd969e6b779f4aaff7bacfd8ed273a86281dad8bbf6310f30ec3ec70f6887a24d91ef93cec1ecc86fdc0fe17cd15c4317e21a1fc3041449bad965ab75de8289db872ab0f96b73de80d145a1c668d624e9aef36e286ca39b4814a101c73a682d2f7d4aeda030e399090d8ef06a9a872d19fdd598b01ab25aa024a5acf7a06d82475ec707e43a125065465299881324e8842666e932166c4be8f1252d3010a900d3ec644769124eb95181fac32bb6a4d6ef86ad4f7a78c8fab306e51ee1ca0c17b83eb69ad1c94dd940a08d766f2cb1947386e70d6232f133e7136473a1dbc5924fe15381822bd3eecb553355df239f58a579fd1932ae37acffe1153f348e2fe0a5a222916a292a32960419efd931667cd5ae1ba2223c217aa3a0fffe8a78b3df8d66a135c3d06d153c2356d1c93ca7b0c0a4827ea6a0ba4e6b3ac4dd423bef1c101e05f699e8f450ef5cb1b4ba206fa5b55b93c3698f6c87934fbd198aecba55ab422ce827b8335ba49d69445aa8a119faab5842c95c0c246a15f1a45c86a57a5d71b6a0c7cb24a0987b29bcdfe3ab912f15cbc491a9e4213af3c5e71ff6bb6ff3c769f9bc0d6b71a65ad70fbe2c133fee1a162c8b1e28fadeb2e46b87e20f6ae09e7cdf89e49fc852153aa8fa3caf579ccc8c9d835ef7db72c4c5ddb892a4675c99740c5a2fb7d66ea0e44e4e957521223a73b42c524abe32f7a0b27953392487ca29a589435416607864ce637ff77dab44d2147a107f37e860f6a2c8a5bc59d21342994cc8eb89a97babea640209f4f1d68b6d217cc23efe558fe27d4f49a71364946dae0e1103f5360daa7cab232f0f52ad619d77361a5ac7f5f00d00bd728b074a11c1fec8b3102bf13aa067a3967c55d3def086103f8d35e6ad568fbafe0cf7bd5558ca4809dc1ebbfe0cfa11e1d9388f321fabf5bed1c5b0b7f5dcf2b92978090523b67df99d64b2969562de2ce9590400f2a79cbdd1312d389d5ef946256f18dfbde52ce0ac8294601a352bc7914d0633fb40a9c88ba6235ef48fe929adf344b44fc1a3ce635c9438e6612cec17898773568c5f5f963bc0737ad39ea4e8de2e4b5fb21118165a00c7f2bba541b97116ce29665feed8ff81acdbd8e6669244f997043821a44ddeb3bd8dc8ad1e1d0f94f56dfc480bef5e749ad010082ff53f78ea6d5fcfdd9a8b1d4583b61c1af4aef868329d65abf2a63b4dc8805dbeb082bd99c9f95da2e4e49b378c505e666c274bca1edae2572f11cd1135c87151a44e9790a3d656e0715e8b3008240b3b71088f978b7bacf8595fbd1340b344c64cb380e7a8185f0628585e2919d6f74aaf02231d9166cfa4ff1400cb247371d28a3fcbc3b35983e635e1d4a462605bba71074269f50b77cf28ecfda4a2dac19acdac3e2c25c281d3774077d52e525290be615e09c586757b28b679621a0b6725a68a4d6d8a222517110b32014499864752374309bd4e163c3ed4e20f29d91fcd10be481862d2af4e79a8a2199216a9554f4cc4cf071f22c633fc88579858b884968ee527b2a525ce5bf7e2fa94fab7bc3e88eab3f95db67ed801acc0ee368c8785831b637eadfb3fced5e155af6e0a0aecb10387d70736b1a023eced80c6f4d34283ab234a5997e6b25dc172012e4e612ca0b76d9920ec765ec7fb76638aaa90374caf1df0234407538b7130368490ec510efee887297fbd30c87fa38a7ef4cca22fc89724179b95c952f1d9f3ae373969cd80eae95d8549d3372f953f57f91098041a801f0ecc0e7181d5a34c42ea18527cd3bcc569cdd40a8e021df4ebd8e34d10b2eafd045c0fcc0415f3de47fd741191729bbba059c59c2ac4b7656a88ce46f17c8f2e55092c6f18c3d0f29eea910c4bbaa8a667046aa9feac2ca5f1e243d592c30fc2325add2473bde32294f903a2ad92921447767aefcebffab3a612d8cea6c3084667ff3d6e40de198f4a7e71cc6f3bb653b7277451219648512b6263a0892f31e9471dcac704d38de53630bad65cac1cfc8693b06eb199869f910700afa3db01deebee976c9876fd3a29770a1f70d9537fdd486c7bc20e93a0a1d9c0180ea91c6601cf3a21356ec257d1c27ff878dc660d65bc4e74518dff31f04de514a0014ec5a2eac39243e6911826ca4ccfd7f9049b4cc5962fefa2da699d3b308959dae1053eeb075a1cb37729358c36862b3b3555973880ff871a2e5120dd79b6a9d3d0b2a13ef6339b883a1d279c6e2852a4c2d80656fdb2267498ec8a0f80ba7d0b27c56ad46968c7605de156eda1fd2038a8d921562afa57204410cf14bc0d021fcd19b838c238f4c1892ee9a7cc6975b0a009ae2b42d0860dacbe3b912f1eb67a3629b5b91d4784ae8df38910cf54f9ccd48343050b9fa1add6791443f8391e84f42a3ee8642e87b7cc482539ab83b817185a433cd53e12e0a6f703c9b13d319eb82cedea1194e435139c6177203c492cb4372e8dd9355f67b39f5115a2f90f1ce9b5bdcc0b0d3eed534fb069093382c4f0576a7e7d00a948504cf2129c923200e40a1c3b3717441cfa6e375fe3373791f088bf0a9eb4d3c597e3584d87e6ba6bfb54188bc3addef9507ab1b345a3b006a2c18b474d8ba0519cac4ee5029adc6d9f6f1e543b75defa1cf59ca650b3d5824d8010bdf66ca10b8bb2f07404cca45c04ca90dc986ad6c586bc0258476f9ddeb19c40b06235826e4c69cee9265173a1d85686d8ad8fe98d093491fc2c9615a3b14e30bd7be5308257628246a4c54b2a433ba21ee73d700e5aa0ca31f430507dbe3ddc146cb5d179390563605450013255ae965df9bc12b48c9630c1ddfcd027c11c1cf9fba01c344553c63d2437e5c5eb6bfdeef91c2261dbbfde0a339af012073c8bf8e6dc7692675548a7ff5fecbcdb5c747ffcfc69991366772f724ecc373a342441481af628a8c0bf82f2501c89748d8971d6ce3052cdc65dfc842fa56487f4869952d0081a4d1aca48d4fa3902b03e506c2ddeec95aed892eb4287f045b9959df53ef8d83723c34bfd2ebb66910069ec8401332d3bea7b53434b76766ddd32c54a10e99a1abcc824fc5dec3dacf93645e59b509b349cba573444ab664f6a6564c1d7dd8761fac620802a6b656918b295056043af1fe557dbe650087da2b3082b27641856818ec844422d0e87ac853c5952401962b510f50b128d4e95fdccf2d9f9b2f58e5c92153322931109bae0d9c6e74e9deca12685846da4a13cf109439147fd51f2a5acbb7ceb923dc84adb34cb5f4231a2dee8e12162f6d5fa8c297727d51cb4c63a77ea9a4c72be955e986140b605b237a59f43b0450eca90bbdc9a4792d52784ab394fc311b7af243edcc4d3cafbdae6517e8d822e09bfcfb7739a59c23546ae06e69e2a5803c7c8876da77990ebab33344e9eb01c66fc1f555168c0d9f1668c3326c2f2c6f7815e405852884920e3531dcee256f8dcdf763efca3d09bca6560a5457cc735ae9b489b264e5b1c5125913fa532b4956f29955d3b93468000ae5420e9b9ac61fbca616e54f8db954510c9da6c119d90d15f42fbc882b822ec93c8d798302d254350de556a91f2bb828955a229d4b44bd33faba980b8ce74643161a845c15f99b5dc0fee036a9550f66c170bb61c776917d0a46a43a35c924e8dbdd1ef4510a279368a46bcac9f750be07fdb7aafa81dbe2c809104b87d617caedd7f7273e5bd0897ad3d19a39fba5bc46342699b02d76b5a4504f3eee7c1cda7322b1578d785d4f0dffc4202ff5ad95ee168f9b100b18a10fdce128d218fce5adabf22161e9a3c6efd7fd419ac24ed8ee59ff8f00bd9ae6fe90226dae3ca002cbbd7a73c75b8a523ae3030f18cd6b4e4edeaa9712c90f1cbaba96b98cd04c93393e4f5efcba0dbddd53b1fc69c79479597404065e32e54c90e797c5992a6f55b2e9f1312907d0b77ae9f34e1cdaa8b944595351693528c77e9a1cacedf21efc6ee3767a1d2f3ab7a313e15e81cbe19be0429e75fd40034929ebd9b2000f917ca1b83cd8843ea689ff841eee091504c56d0ed8fc412cf30684d13b9468d054fccd1073a2e9fd2c7c25f2ccf8476c124a5e9d4414656de13f4ee70d4edd6ba53ce092f9e095cb55c6f698bf1cca2cea107f4df2029e6a4c78ce4167957a8fb3403e2c074cf5d7f4f2eb031daff52089619027018f92b38ab5de7daa0faecbfb3d7ff4df3404c359fcc840a0c3d616d3d486a0b7a64ad5c94364e658dfbe1661ad1db9b995daa23f3d8627c7a5cd80e23151f2bb64e02549ed7dda92681f23795f30dc7db941060400aed6ccfc57cb8f7902081b4b086d7ae12043d07ff2b17273b9c721f9bffdcb1562f2fd90650d397a55d46d75092d26b09c0e2af689eeaeffa6a70933c90a5d1345efd8eb3bf758b71a9783f1b620579c115bd01433c055deb0f12e4624e93c67719c232e0d50a4a2850f2a4c2c88d32a156029ada2131972eeec2689daa3f733bdb0311733ea257f489ced1c74c153a5616b4d53bcaae706bbb79b94d8a5d9d44da0f3b723a5d446cd20fe7dffec220ac1b2cebcc11b7b138acbf06ac81d25bd312c3cd980ed1350cf327c5af727c9a3f9de846594e7b841b4f8f87982a644571a72f7df92a711a73b8e7b27191e125a0cc6f8b66f7021cf1f838b7c8fc449070e462c26cd607151e08c04fabf9ef73864af64eb61972d8b3ca9c8d30415d82553184e957bb1c296e15d70e0d3fa80b690a43cfc17d852be7e7d93021b739b6f0b6c88eb676bac3acadc8ab3b0b0a526324fb6326cdbed1258a091681e71b4e174d49648f2c0878a9c26f9af6ebdbb1bb49673fc72c0d92714f01207211d46ad6044c9e7e93258b41d3733dc4642e22ae4d737719e12645d870f3f49363a63ad7abc709ff60d2f82d18269f768d9ea196ebe37845c7a7e78b2b2186c02af315b75b1cff22921beafc0a9b8b740aa201bf8cc1151f4bc0ddbb3cc7bc85d6ba9be8e37babcec854c63a0fa8539a8136a4901eadd7058674e0f95ef51432c51e19a13a1c65e19bae0735cb4b80fb51a9c17375d6f8ef39799e79866ca36b2693cacc530219f59d9db28a00321faf5a2e63dcde1c7dae1765a612b674a78df9bce35143a4f4953ee2b6b853d0fd010f2d4d9f79cc9a89c2451c43e0efff439b88a0316669b763ffdb42925186a69bc1e0396107c3f2db68a96cd9687511bda9c7d0e1fd981075bbf69f0358e89440198ea150fb3bdb21b5dc93e89d60e0e2e9184e6f419449860f86133ef88e5ff3b8f21aea3e6e8190af26fba00f80c37a853857388085c61e293fa7a0cc65f605a19842fb8cef958a7dab2cc56c8e9feaf52162cde705ab40d6a4587186ea4057030e3a479a0f92e5f57aa7d6bf6e69fc1ffa7ffd335ef6748a5036480cc7f3014b9fcfddfd1bb22bb383eacbeec33ebde2696288ce0323c9520de246d9a56249de2a15f75d8899ee5a833f0737ed10de16ecae0da66e0ec3cf9fd29c1dbf1056c212f72235f35c8e974ecdc64b87fb615a709be53faf8d9bbb9a0064359109e55603613b52be27c96609e45b1148701d188a1e5b9a54f3d0d9390dc4c3440c13bb714275d12208bd35afac1b21788d4739fb40ea303cb6dbbc4f3a3bb438fb40db7cc1c616cd04fe3892b1f033eddbc7e7d032d055362f0d8972af80d8aece776ffec1afa71f0198c6cbf0f4d6adf24e173390237883fe65ebc942421a0ca3f137f05aba13cd0ac06cf95eefdc5d56c69a1d818aa1d8aaf7d5d432e62214cbc3086bc575f59f07cede78e94878537e79f0701d5ecd1ad4a1075a16b9016cc8ee859586b5b406e702101fbdf97dd90ebf026786c5134ecc353bacc8df027970cfcbd3baa5643375cbb268f3dfb17f38d6fa0f3967c322cb57bd477cc294d2bfaab8bf9e2a974651dbf549690c12c9b7cf072a148426f834419693b6c91963d0abfa962b2fecb781048e3064d5ee44ef067544611e8584573913d624cb3fb72b3d9a3e18b3e00d45308777028ad60d1f893f34f5ce59e7eb4ccb22639e0b54790e12d70224e38df755b4b64bbebec7383035337a066f35fe1f13578f8561f6d0c26bbbe5bcc3ef7d5bb92a167a8ef660165ff504a6b094822de2b885ea3714bd151263894f5cdfc759e26a0310304ee404c45cb8df3d6c0396dc0aae02bf683d2a1120f03f734642c4e9ddb339b94072789b3568d05ecf3b04b1d728c65d19206ef27cf463ed1894e978da1d879378a04dc2cd0dce70bd4a1cb61af1393393f3d6750494c10ca8c044d5620874732f64634639fd553e1e845e68cfadc762b4c8cc2c162a32f38ed005dc008775b8590c7be636a4c5a9a6851f220f5cda9016e2ce664fa9931d404ca6099551b9f45cf78375140ddc2c3632c03b285706efd08e78e6a9b6db48c27de03ca6742f7a843e007529dd8d5f3a91a357485f1f038b94eada1d7c4f93854a393cb209e505c9f50543d0d6e9b517bfa1ea5d463f4bf337c428009ad75ff6353647876c5710ef22b415851e3e6124b6de28a3665d15c826bbda0b536a7a6c71c2bfd4442b3d87c104111a87ad23714021c0a43f903022a19cf7aa822a6d3b93bbd41b765d7bcc5cd193cbdc87e45e3c68c3e705e0b68dbe83243f8e15f5dddc92cc48be284184aad87e67169cbe4aa0f71bcb0b651d82b24054eeff4d46c60292a3837fbd79191f723f07ceeba7f682eab3f6e3da6b17582cb3870e732cacce42df5496fd1d211e40c45613e5fcef34deb382c943b5525daf85e6d5b32327d59af5abae9a0443c1c41fca4de8f7d799698da3749e07ad8c9c440648c7fe45cc3de8abd71867b0b401b9960a6ff76e694c9ee74a8f5dad7242d74b36189151a1d578de50c9c0f9ab92a805fb9cf2e5a0a3f834652fefc0dc3eaee71465fb7c669d78d33ddd54df0d273efbad361b3e45b68f680a98a200b0209e10e982a82a8eacc630d4d12c7317fb12b26d6f66f127243fffe26b05e7d3e4e889feb46b6a6f37a73e78c3aaaf83b4958b27bd1b764b8706f3c477477185484246bc4904eaaaa8edd38b62a254ddc60bb2673a41047b6798f94b94af779a6847f3bdb7b21d5fc9df43bbaffeb574cd81d6d795d644c56809579a9c88c6ab9e37cd608931a9d2fb9b0f9c8a0d5ffbead809f55b24f557c307fb265007b25de6d3fe088a3b70a28eb4d0097f56136e649eb5b9cec379cb1a68f6ea17d231130c6845f5c4192ca6abc7b5976d32e259555e1c769be2c5ecbed8ccd646eca3ef85665e2d31dcc766f61b40236273dc14890a40fd7254eacb84d7e6d955c44bad49bbfbbc0edcea4ecdea3d70420582a1946c6cb0727965a23c57d3c9e31c8bae1915eeb52b37c7297308bab792c7495189d9708ab19614586822dd94115549290cd62750d56cf41abcd4644c27437e0878d057f01319549a3608554ca5aea65e4d40cf516e576d29cb082ad45faa82cfddfa5e42593fea569ac076725b3ffcd7dce5766b85e559c49ad8b9cad8ce58e71f880a1d5a1b43daba0650e66202f4fe1218196c43cd0c1cb0c8ebbe50815c4a4d8780112c4688a4f7ee061e1012a84749f71a117bc11f46f58507468bb9cf0c1c4f0ed62c8fb2439ea4e397d5ac2c77d6ab8d224d341e3f76f153654f8d7cfb119fbf9713efb7c43474973f7ab551f30f14cbed378f4bcbc98406479d1ef3f8fe8e5067a46eb4d9a09a9d98b3698b894b5ff11bdb18e385cbacec49fb1f954132529c37b989ecc24f49500d5e56bd1d3b3c09257cb237bb38904c7f85d50a8683d76983000f7303c5dcf03db417f2268e74fffc3322e4ee1dce5a29e661117172ca0a242c01a810999a69c9bfff931d74544e985c05b20b059c521c692cd4cef3f2e8c8ffaa2b4775ec22e7bf5bfdf70df7180fcdafbf6a115c022be58952412683ec6518507e9652aed263f0c2914990b11a11a01ef7ce40392c82c58aec3b409c78d9f08b0355d5961488ec137dbd69faa43f62e0850b2ff870e3bfc9cd7807b9ed913133f8a38ae0d67dbadc3194381e44e5671af310c6936f541b33577e9e17ad806f088c52c5ca8be98d094ff1675aa9ec4229da00e894f6d40bf11a9526b173b822b0b25c87a2dd54715a9ad88e427a5cca6b7f286e83c425b6b2e116371c30de7ec0367f5951d66616d49e1e5950469462accff9ec5958aaff528c08d9601a2f195d23cbdf5e60b74691ebe005b1148cc5624acc81919009aa204f117d67e6f2993c67ddf4f099eb888514b3c34be116924a8cf10be37ae2b30edad9c795ffc547a5ecfbf5704929553a4a395c29f769cf5501eddd3d9561b2fac416e6c9110f41fa998e7ffa6d47b153ce54b540e652beb35b21f3dbca29f45fecd310c8ad31959cc1266541439ef6400479659eaa3e7b75d0daf7b9f23eead3ff13f7a023e99eee44a58d36187e7ce195a3bf8bb60b38a9c115932fbfdd5cb3b40ab51d66d33a2a45ddc3a33bfd259f4f7374687a36efe5e29611ebee9bd252e7544cf9920e33f2c86584c9d46807b1a286fe6345b6556f4973247a7841aee33711dfd5be39d37a2a69f94b0753b0ed0a99a0441cc9601749f9e49f10ab815998a43d6b04e3d7b06016f58ebaa000ec99b6057b0cd635e509d5aa6411ef1bdde087b1623c17f85ffbe05f857fc0cf3d7e7fc932b1636f57ba5ceef9b3cf79e28cdc8d180b583f7ec446ca803bc95544cb476c01a551412200a3b8e59701cf744e6865e02eeee5a057a3ca46b0e488d0e571b1dde19a30482331e83e72098ac0f0ba7e47f281d5996223a6bebf9136766046bb3b8736b93c5cb5bb948de2d2a3222ec21c87e2665128ab1b4b9c6482c92d07b1c0e8effd77df764c6db4b48223e7bb3bb31183133c7056e2e6ce50fb31f542a440b96dd1c059cf83292da957df8bdb0259e6eb8c1ce31cc4c8c1aa2d742535ba5c864837f366d9d7fa716c9489b892c1aeec49755bfae197755d99127fbe943c9d597139962c381bce34c367ef89582049faa59ecd1cead613e517c5519aee84616e685c301a50fb88885e415c36ddef9c3f2e99d24e97baecd7c26bda5f9edd44587db1177b041194db2611b45971a37aaeb373db1564e6845cea092dd74b22353bbd2b08e1235ba8e2c1315ef94248956f7fa0ea7dfdd0159619af1e21328293cdd6c995f764bc986290d628bb2b343a8616a5714f939498468569b40ddf40cee668f9e31deed9f5ac5f93359dc1e0dc5b0b2eb0af0aa50eca97df69d1b5c1bb9140935625dbb5444f0b805cd980dcea524f748c94fd1a7dfd48fa268378762475e0301449639add162b668213dd12a0749c0eeb68cf6780d48596ce93b4e0af90ca587ee6b2e50bcd299719127e95a92aac6210a33f2caa16f5d7e5a659cb02fe2e557e9527f0775c6e3cc4794520fded3bfe98994664ad9d8fe60d08dcfba250d34c989f1496b50f111c3f257529b8db4a92f1d5ad92e7107881a81e9a3fcbc028fbf3f9ec9c35f44807d25263b2c9d4e1ee327c04bd2bc15fa6e62668808982b247229d631a893ad8c060196f6cfbbebcc1eefa8c060907f650603519444f68af62e4fee6cd0642078aed5084980d2097bb76a8cfac9c391882446a8d5be1da772ba5c6294eded49e41ce7eb741235a4a1d2a5ae1ab24226b3bae75e741b7bb2ffee560a2857286ed599aa27ae575336fdc50db403baba9808d1e4385281be6c616c81a9035165128af0320b91597d7f08660b6c299b9c6e224a546cd488035008a7054d82f486ca7607690705ba9ebbfd13fa45e5a9d769bb0cb5cf5e9d6b927bdbaee672082a1a341c45af3781d39131f504363a18a2055f046eba2c02afcce81b1910b452b6837accf62d4d2d27caf4966042aa27ad56113b19737e4dc8bf51ed48c363bdf8dda828a40c68ae553bc49ce0fc6817aa09c20255710cf25282d24383d6f9fa8d19c1a0fea874f6f63d60c70c9c3bcd604562478f69bc55a91dcfd51425b8058cab3361267e55a20c31f0a1b83dfeaefce63da2cf59c0e1456ef8028e2c8859fdf8d921a369b7082cbfb71e8fb21e3acd0e87b43d6c2406603a4fe5712f5eeb7b991462c79b4a082d1fc5fc87862b725582b378046194938b2d91e305a0b7327406a094c1a66fbc87f9d31ea903a78c0e1fd598c4286ba0923f666419e12d28132c5c3aba08f53564e05f15a75d7c27e66a3ec8644c46f3de5278ea15d1fcff277e16fe701de852474f4f377884f25f1755a6c23d0ce797188d4e88e876b405e2c937aac6ec5e5d8d0619426dc288a9d1e0b0f9d3338a76bf8c28d5704c03b878431798d1436b227edc7ff9eb5ade90556e5f9e6e807246ba86290414604b85a3dff4a361d6c7120d6a8d7d2e02f82e739556f18fec9c7abf78749b3f841b3c5813f4112ad1c125c8cb24fefb2ebc206900a3d93f1e8556eb8660c9e7f8fc51282401f0b11c37ac2edc0257fea2461329b3daef360396e0c0cceac7d5a261273533924c8dd81990f5130cbdd5e65e1cef3e5c9f8f462705adbc236bf53386efbbafdef5c0c6647b6fb277994deff6e55e6244caef42a15695bb719031ba34ea32ddbce022d8da08250e93e380e8f63ac4cfbe3b4a2325d4d030e289d814b89919dcfb3fd70904581648ef69bbc4c0bc38652d39401708b23aedb089421c4c81455cbe877563b7f7a64a2ca9227c4892618ab30799cd438c69d79543943c8dcd841d3abb81a9d03249eb14cf5ad2220535047a389658a1a24d0642439cd42e02374c82c5358323c5c3bfd02ef914e2a833c14dc8992035a14965b9e36db6e162e0cdc0f841cb6a420901886ecefd8ecc51b62fe09a7aa1ff54783c311f3171822866147078c43536a9ad3726b8f9c61513f8ecaa7bffdc6c72234f0ff374d57ec00ba36a0e782474efdfe0b595e93ad8fca1a282c274ee4538fb9dc6d0d0f3fbc9833012d5ed75e2489ac1ffc7a1f7b73ed7de0cfc506577aba0207c9152cf498a2b88ce2cb1b0047c2109e22eaf6f3753ca599151cfd5d1cae8a043a9988ca1c7072c491a6283f764c02a849ae1f37ef2de64e930a3afff0737bc9025bbcfda49fbc03f2b5f3183ed677c3bd0508b1b9bdff02ed05acefd37f56e1084fa76cd903481fc289620f2229b975946a93ea62d56e8469b9d2136bd55ae1f6485443eb74e280a4cdad44e9376701bc6a31d2a52519ce975bfdb3577a1884a329b9284d5ca00c54a3247bd4338876280858ec05b49a1b85a08f9e956e3d4129e158bbd988598000bf2daaa5f22f4a93bac5098459bd591b03025df8af99bc717cc31359f5ef5690da6cb9ef37fd060d58736d1b6282672a10c76c3412131c8cb29fada36d583b4056540fd9d24851efb0c6b1ee60f29b7f0c952b14e3e54c57c9435d4c5edccadb27ac02ce2fd913fb866e6fb1b2ae61959219b7a2bbb8439f8f3d1ee695a66ec7d6db0be1847a1ace46a3e3cb9daa760e44ce8f3fa5801572e364660eaa4e04803e91a316fd3d44bc16578395789eedffc3608ca479c6e358035e9c249b141942110c8dd1696ea90329035798ac09fa73eb7e601eeed6b8a99023300adb4e78365e0e36b58a7ef5be3d8537b2098c58e60dda285421fb8bba565df7d800571a2d7349ef786d1bcf2cfe9cbb8868f62d23079299983aa4adbe752e4945edb4d96c6608f1588374e6d46f809187661a7c774d871078cdb770302409487e268b309fbe40447347cb6e17d7ad0f172a8e8a56289eab69f274870c947d647c0bf35fdf5d4359e3eb40038b60f5cc66818cc196fdd770adb69f94e86521e36c4cda1c96b42d154ca50775e908a17f1963b49f9f5a58e68599825f11f5d636024f10ffef066155c5af8dc3e7832e554a5f9de8b42e3ef970567f4a2a54c4c4dbd001531b1423c45c6b155d695296ad982062806e753b5fbbf2c30093eb379adb94c74da64999db2007c1b0e00b26717da2313a3f43f88cdca90acfe77e003d067ae50227f8850eccf0c53c451f5934e12065e79baa0957514041684d5760814d01decacbc7c7c5b5eacf15fb2cb239f164ecafffd0ccca2c20ba825c50ea66bb74bb3f3fc10a43bf3bdc170a65ff604a7c2e61a208135fa1d40e9a8c4d5e2c281aa35e89dd51e982b59e0a6d1b39434432b0380f9be6e7485717d36a693395cb7ff62152a66b774f0564a2c3b2a10b3521838a2deb6ec47a06eca94b5e62b23beaf2eee31076183a2ba33eb47a9d22cde6a868037b4e4fdd6b4eb7032c856ebc4ac6426c9390fb6bac85f357f86d9e67cd75c9a31b12152b3d7323d546ce1d3777fbd3128a46666beec1f8588185513ad461d4e10ea9a3220f9abe07b326085f262c3a245b25fda7f8a48e55068a294425adba9775f0dc62ac0150540d2870fd7e46d2e555b07c3fb946197764276429f6c75f57b391b09bec6bcc27eccbb59bca1b5995b496c5ae7e9130ddc85b7e85abfce858fcc45ebfbd7ce5e6644f0f3a4b5426c87d254bc6bc58f2bd789e6f2c429192a44c9b148a3a7c88515fa8b84f08b06da71965ae36884dd42904c586438cfc9235071df133271cf67a296114d13bd05a9a8ca0cdfd74b92b9ed486a227cdfad29914091448b3875d20c224a4073e6834cf56ec473f0ad5decdacfd55f95144cd28bb5e560ae6ceff9883adfdecde095dde123a8697a3df86970673c06476b24f3352618e1703b86ac35dee18e6e348e237da879d8c936dbedf86df83fffe0e4f7200c2e968bf1149a5998965658e17a6fec4e8ad6d1aa14c93444bf45f6194f82858d020e16b626e8bad0fa5574b9762a89c3fa8a87f85a402f91d4f8fb2bb1790890e2f8dbe29bf2cd3595a16155fc88da9557d7f8c72503da06c23781750c39c0d56b8ee348e787abffbaf19a3390921c7b9a2adeda598e6304e83c72129c889908a9b842ce091d5421405d8fb70b3a934d7a8ceb5733111c9b5e24e1dcf309ef7012b5761f6bb5ad1a3624db52dffcc5d23fbc4e5d751b5c3fc2f5561ae45c907bd73624f57618373f10c7c693242c588c2f31b4e4a2aa8a92bb65222f439623cd3403783a3f2a11a3838bbaf041e77a54bec25526d98afef40142cccc53af79ed3dbeaf779a0fad65780d40981c0d427d883b8d18311bf7dedd661c7d171afe7c7342015f0b00ad9b435e3e6a930708df90a0dbc061b01a7220db5e66294cbb9ecf09e43c189683c466d21d37a5e249ee297720925c798b2ddd2048e6cfdd579d7c2b1e133c0079d112c1eb65954bd569a0ef762837badf2b75d6e7c052377a6e0a5831140dde541cecef81a9d1e8c23161bef6a88a318af71246323ef9504f4805b7f477a2b698ef56f3ef7f451e13772323b61b34de8be88c637b6e1e5caed738684c305e655235065828a687faa9479ff89d69118ecff79082ce5ad1079854bcdf58d1450ff1ca5ab5dfc95feefdcab6503d23d4ebf6e0854f67bc7e281add0e1bfb0f9f4f1077ff2a8a2d81a127e2de42a421e237fdddc8e09396366171be01a446963b8ec93b7eaf9c3e33f1e983fbafc2422d29eed7ea5b37105f5509c5e664a870a1eaca78046b435919fb7bced575ae87ea12890de7c20dd0b5b648277fbaa6a25a0abdc1a095871ecaa2b6a9bcec8d3268ce88bdac1ef3b2a908aa0fa4040de71c25583217bd3904c54c6bf56522abbbc4bae791678ca8607854506ed17b35ac76c383912086835724976ebccf1368a9b8a2668802f783792fd5209748b232cbb31b9311b042544bc575c78e11bff8cb04129661ec4a046d2ce4de12f61c687672f37d1c2da393a061339db240d150935b1eb31ced05e8abfc17fb947959b62114b8356edeaabbd0054bcc915f3ed0562f175bea123260676ba2de0c98275bf30dc656735f5b3e554f1b8023f29682fb856a76a3e104dec0847ab3f76fd6c8902db7a8c4968345bcc8abc40ef7085d97b8ca7d7ad32f994fe34d9688a9b3e0a46fa9d86dc8666614520e8a56360f0172f74958a21d5233207d82cdd23e9a5b809d2db280bdb2672d7a30d4910191b13916573debc3f61bf3f9caacfc986027a9dc9c052158d06a7076287a854ea5b59c7024c3c5c77f01f635cf1a9381e0629dfc0c0f47556acf4b8f95b30c31b429cc8d7b5d5702f1679a86bf48087d0cfa878d1cd0f956bd040f4066f81e0accd1f230084ef979142f67ea2d0add3ef44ee8990de6c2e39d497aa12a306a124781cf259a0c571989e73b7c89ec203a01e7c5cf7ffab0a963a4b60844501ce82ae69e7a85228732d7e4da2e4aae77068a55eaa726462484aacd5c24d173a50785bbfa377843fa221dc3a742d8b2be5424f939a8248919a0d749db4afe9b69d45a0950cecead27b5b97531599472deb5f33dcf1393f5353534dbe7fdea8f45712614d2618ff249227dc79292d84da43c28b80c6efbf04829dfb43a95cd0cc86f6bf748c6a66a3139d7b2684d56c2e5dfdf4f4d3e1a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
