<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"458c9f0553315e786ac0820fa595ca5c9ea457192f589f07fafea155ceb46d457ae9981616320cc31d1b1a3b3f29e84091caedfcf18b2f47604046e1cc938ee4e8ee8bdb5448c72c55a2b0739df34d80053dcbbb79ca195ac9bd236c889e3b43ea5a1ccf3210ba1561005ff6e0ebd32ed97746a0f973eedb9a73a9feb79998bb20f8582086f7d1909e5179699ac7280690e7af50fb2befe8477c843d75aba35b29d0b18cb432fa93ebdaa7bf2bb9459439bdd0262eb812beac4645fb0d6e017277d5680355b55cb33fe96b3441cc4929e90cc9ca32125ce09e36bb3935bc98267801b87d89cb64be5d76570a3195b911d8bea7436c8e6307001bbe08c23fd0d1c3ef3bd298154dae3815b7aad9a2ef10393523be0978b904314d7c1f39076a621d15bf5634f7f31d8d188a11bcfc58881f241540d675160122055f17c9d3e52e29038ce759228b1351da48973b63043db4bb98f6277e757bf9af25155af8ec548a19cb8f19c0d6d5d5e77eeb475bffd9a5b4f182aff680465b2ce878730ef7f97c0275a4cef399d137cb961aebdbce8866eea143241a2fe37c9039ae3783a500d7555e0d0125ed970dae6db926522fe30f8111a65999d5da065a6487880cef044ee4655f5409c46c5af9d3308ff607e97d52346c622ff8de1591accdf26ddd8b7574793d02c08ed63cb0a1165b798729bdc7519f48cd94715bc2c8e405a94c92ae112996610f3111b030cab7e34c89805a1d979708d662fa3f761cc9170a0f34b5ebddb8ed9b149a558b7138bdc8c13540ee302f2c69368fbbca7cfc8bb0458f9c2f486ec9b2d45c77bb05df20ac1878150ffe5cf423f565822718485a66ea3b581d0533f68a5dc2eb274f857c93bd1ba3978af1132f83bf2a13d3031937cb064f6f635089a0c6e4e610584abb1b4a7e1250b02d04dc2f26463816a7d3b27c8e0705245be386ae39a90a809e9b6168a38237aa9c615ba1ffb851c4c914ae9de4134c8c8fdacfe94ed15e20b980cf6b609d64f7e98fe7aaabc5ca111eca549bfe51564fe5b4c24cae35648592a1f386388b264960689e352b5f0e77f65c84e4afef8cec894aa22458d024cb8fefa1d3732eb17e001e45ed2c4a3dd11b83ce75431da531b53bde4777df6b5f89ff488912b98656ea80562fbaf6c71d2a580be4091810c9caf995a59fd4406e41e32729fb0779a6ff80bc849b1d5b26709640169a792421ed8d925349da639767d2603daabd812d8bfa189b77a9bb94e910d8a0a91d54c1503da82ebf50eba54005428123d2179a86fb77b54c1ff58a2fa25eba6804c0e63131fbad5ca6869a3346f8231a868a8c575161f448d729485b9bad3d5d9d445d051bf015c434045835d22cbd5812be91251b1542198d6bf50a4139b04a78e1af6948e97cdd430d0be459b39edfb77838c71844730a40ceba5f9659903a1a94131cd6d8dc4a26335df2316c873b1368da2981cdae0c03a8ae50728ca78005b1d6788f1d98f065101ccecbdc2d997d516fd9135ada3324340f4e618be854b13c38426ea6aa8e206285e81caa4cbac2ba42f8d92c03107f4f0f716ca079efb13dbb7d1e344980512a9320b35405384eb1ac3f8e4a83b2563d6b217d1ccfc7adc7d867e26d622717dfcd2c073b6d422daed916e02aec2c244d42dc57b9f42421f748ba4d9b8be3eca7594d393118e7f0a0f2ced66837f162891a432d8c9f848a7da13cca81d3e5c2ccc7705a02170d2c4a7b2765c78ef37906174818870a15ece314d7e3a3e236860c51bda9552651e8a96f1c3f15b868d730edb476531d624a9015e07dd485863cd4d245bbccccc17c57d2748ac88dc80473884671cb11a6a2d3aecda9f6e257f96c1db36570c999cf17ad01e538feeabb012910850d5850a64d9ed13c85ed857ad88d7a9a71c4d58f3db77648aa00eaeeb9c429513503669fccca5762c66e6416b2e02d6695306eefbd634589eda97bf80a5b635442364c82ce43e296d58d8fcb86e1a44b33ac08e979e474e771f3771b89bbb688594dae97db03b7491620e914fcf66b9125ca6f7ad222e1cd28ee60d8452879abc137e3927fa6ec669ff3f84a3119d15a40f5bf61f5e4b0c659d62ece3472547f2e0e311f2227c565d92285ab4825fec8c9697e4e9a16e88b51d5e7568cbe758514f8af8277613b4aac30a6f4ab839683de6756423380ecdad9c7782b306e88b003c26e3b6716a585885820f8aeebce00bb781a6f441ed465fe5d6a41b91b761dd60794a2ca219fd38be628830137f42d75ea30ba438c21ee1445d5dacca5eaab7113eb6f00ea73914bb8e8419547054434ca91f75e34affd9b9b0aeb75eea197747f8a3a84f03b3a8b862fb4e7e968633ce2b83f5c1defda0954f3cb6b744f307f8737928fcd31f80b36ce878bb76131f7afba91bbc231e4d98dd24d002908a34997ebbaeca9f8d0bc3febf338a84581c011fb65918d614bde158cad657f7263d9b992cdf650253b98800a81f8d00d71495d3a4e8487349ed72c86650ff598771a5bf8352c929bd90adb367be60718a4b9a7d0a836ae04a1a257df89f481cfe2fd11d3aaefb34724ccbbc3875e16b7e4746d02c81d3886d605f0abf40bfc6c8779a41b96ec29774e6f72488ac6b8f264b3e111ac15bb0f04f24b5b4a80a0dd262d30c47d52cdbc9e13275fc3f48cdaac8c69e59c9973c176d51babbaf7bb732746b1784535f07e197397fd66a766c083dcb2a4601c502c765473cde0c987498c4b561f239d89829fe7aeab9b07fa6cfc52188b9f146b204791cffeaba6baab4831b6e258babbb228d5f8a3367c9e8aa59ffe4a222cef610c82d4d091b5244502808d54e7965efba1d121fedaacb0e90cbd6d526f024f356a7d7c443c2414a3c5ce50d23c33c6c4b8078dfcaca4cb70c9cb58598cec10319a0b40e8d6529764101c6942306c2c67a5b1165938793ac44b887dd4d9336cc0070fe819eea0c66b0316648c1a3736fbc678c30687f7ff8d0917f3faaba29e0ee1a61437ba001ffa032963a172060867df43e7353b0281ef86ec29a5d208b00226f8a8f512d0d0af48888e6ab625b8996306b35306fbc5720045ca18290dc0f7808e5aaec1533669f6150ee077e05a330bb32f20bf865a22cb24211b9d0d476d25e91af66d9de3e188019bbf655950c2c454321f8cb7e264d25881e1ec8f509bcb9f5575c05fcfa899d2867e0d7a7e623256c968c5e4e7b5646af5ef5cf5dc7e19c93198df4b106d1973c27d61c312d1be3b6b97de90f8d364e0380145601c4fdd491a5e7b944c288150a3b258a26387d8cfa7dad17d4bf060f32e3b38cb863380b678a1747070a1d86a3b838a369b3a1159bcebb8ff50a18d6f52956e5e5983f02f5244b183dee9dc91c821df2f27656391d93be008481b5191707e3f2596fa410a3d09cc3c72ac6970e2a26a8ea08a73ba2891bae92fd1a097802f0b1e03989042d9f4bb90aa73d52dc1b66b45fce200e11055c5af29a025a6979cc3826d0a2c054b3d96dc35ad40771535754555a60fe98bd5270861427fa9f59e14f29e9828f06d7b0153df2028d7d7ec277bad43de23b8e7c01f79d52b196e53e43c910d7c130b3413b4083f24555ddc460f6c604fe2794aa2cccef5afc5703e02d9690d9802312d05203e077a26c34b64f1836b433764c5f4fe24c3ac38add63ee8fa7025b5e5543f8b0e4bc1848899f161a1c0b46c4cebc15e9d664b1c256dd35ca02de073f47b4faffae7bf6406bb1d93ef0658b3494b6665e30cfff3eb6d8a47c291b7bec847d73072bfdb1c19da05a5b45df0b10bac8ce43fc376e2688b380c72f3b0ce3b4bcd9b1fd944bf798521a26c67b1c26be4ef2330cb5fea89bccc1c8d58af655c25da7d35b4111c583276fd0932d48446b655153670b846c272f454518e7d221df4b50e82fc7752c64cb94c86304e3cc15ea6f7904325ebc40163a08d7c54420d56511a2b0d2e9773d006f4acafbac2f046b22dee95c36cf7399f01bf817c259a1f06ff00752a330559987f64db77d71c831fdc560b6ca71f116ff57ca301c41d4f5762cb298ccd15c8c608c0abf4354d79aa7e050c6effa91d12f8972f92dcb68f18cc9f23ac615e46d556a180f02a6d050f7f72e5fe1fa1166635c109493ce98a8cd7c0688da417679ae1e1a5fff3b39206840fdeaa58f710d3b5673c3c25ea757e345cbc0514d2027277528443dbf71f76a397221d5a22b2fab03920ad0190aef9011f7500348608292249860d11edc8b031fbfec7a981f13a182594c991463e9236b17f4e50dea627228c397f2d9d180a695dd4a6b199b2e456ae68334c6be0f315291a1cbfa6d058055e114586d7e21a7685a873a7e6fc480dee955de7714d7a8ebdea57bb093ea7bcf0e96b10dec65e248b0766a8fb5a813c6969d897ce59e2ae8ba526fd42a0531a13cc86ba115af7aaf659cbc378c7eb174e3c339dfba7ae51d3ad982d637967a3f05374afe99e89b434aeb1946ce89674e68580f83f396b221f1c7770b76be9aea64387c5be2aa7ca9d39047bed280f0eb023373a3162a95c6a32295dcdc69ee7521ce953897e96503369b84ba2dbb0a42584550e79d0e227d8edab21bd3ae64be93fa2a7bb666b27ab89849016fc05b3507cb410822ad20e863647846b578e699cf295b8a99c189b0af2afaf7cd84be08144147380cb51e4c19c13470972a50643c90dcdcfe7bbef72dba946ccdd6d2001e2830685bde1cd30bd4d6e95c78110e9ecff8dd92c39e3800accdbb223c7e2035fbb4efe542a03c4242e3ad6de655ec11a60ac763856f5dda312e31e75ca755db81a0dfd97d519cba345bd36ab81b761816ac6475df6e17758b87dd5af255002b449b34c68306c5a8a4a6c3df1f4051286c7f5358ac4f08c5a90670a12994279746f824619b9ee39d2537b0cd5f2fda3a8b3100ae2390ed9afda2b9ec00648cfa819b18d66ce5e8bc34c1ef7db8e7bac962c7aef1e6dd7693201e596b6e740627332b430c4d75a40a4d4ab5577dad092f7f0ac1557f72b5202aac6ca73229fa1a9011cf13f8567dc4acd0db405624e8867fb9a78de68fe52a7a465b57607581bee6850447dc45d10b05829e647100f35eb0402e57dd08a4dfc0c265e4546795db4e32332afb5f7e786f3f569c182f7afe7f443c5ec5878f1b4e66c7103bf3b3df6f53665c70c9bd81ad85fca4cdfcab6ee2ee7ae59320dd7013cda4d1755b60595845e7ba24f3a382cc201bb3aee1c7cd4ff107543df890f7ce3578ed654b8d2123bbbe26ed260a5f00995ab6730bab4d404472198e829cd7ce34b9b20ef4b4fdcfb9e7cf8391568aadbcb7e3d0f6cd99360f1f43cabe5a5fe22d117fe2892275d4c5b134aa603edf8be3d35f7cb20a6eb9486836afbc816c835123f4e614f4159c66de5eaba1a011bcddac287f83b1faaf09675247e11f977ddbf18e5620154aefeb441cca35ffe215d3f86316e7048ba24549a13ba9fb0ae6dec7c59ff5894dd48462ee6ee1ef5ac33b52a65a6ae526c2e3f70e64de577af3436ffeec8e0f5d017ef89c3c9f20a1cd79e0ff3bcbf3b0a1453c47744986ed2a82040505fea284e31c1ecd9e8f9ab3c0347592928bad0a467b40450d02f3f7d842db2d530f07bc4adf38363ac3f316604628cb4978836f5d05540fcb10d2a0a1fe08d6bf81b46c4af04053667405d64fec560fefe25a56ebe8b6ec3ca1a8184dc91ebef30e41c62adf2c8a293477b0d20c6166f28742965816700297f3412d15b4adb3c6286fb6a8b07028b0905effeaf863092da0f7cc82e6220a205f8884f75f12fb81d09fd1b8ac4b67deafb446efefd901c133b738b28de1bf03a3dc04a2aeba3c45728cd8495c0ac33f1026e991e74af7e134be754f0d6b6935dd800330a4112a5ad025845dea16c266c3e21a6135d49fade1da83b32b06ab3ae7418a477fb67284177086e59c0c312b8c0cf436dd432b235661edbd418bf283bd684b5937a716bd8d15703c3f1b43f88fdb3e05386d1b9eaa7484c3d07f2f007a9d0ac3cf1e884f0dceaf1507da261223d6ef561dc464f43da58832a04191d2e1ce26f614d20d9929bc6c1ec372689dbfe9bbee9fbf352fbb16f1bcc7e487fbedbd538da2280db1373caea1a6e63f9ed7737caba57498cabe713ce2bd3e95105df9f6391ae7e4339b7ac0a7932bac0fa5fc188ac97feea426f1761bf282894e1a1cf6ec12cd9e1285b8b87f801ab73c1416cbfadd2fa525506ea5a6941e10ea8216784206e8778ff06eee9b792078de7928207ecc61faa2e5e3fc7b920b804d42bcbd2b8481a5c6c0c879c156b6c5f98403218b68ee55c7591ffde47481f9e2e9fe16650c115c833fb6477f389414abdd40fe4893767fb811d4507271fb3cf036d5175bd949f697937851d401b10d04cb59d3c67fea01286d3d9fe6d938e5dbe73dfdd762679429b124aaf74febccebc936eb10f7ad41e98338383afe00355f7f3f67114fb2d8380aa738aa831f4427a6348ec972b74481d3aa90aaf116469e5d24a57d3415061bad1f4bc2fe978b1828de8a80b251b7d3b4dca24f1e8482ea6b2584c4261d6964bae1d7f7355976e05307d7b23720cac31a445a469d627e1aeff8f00499a87af460c55520e6f0b2388f0b7f0c9c71fd8ed6ff5705b1604c964bc6bf2258564ea2d4b97645521fe6f30b06de8a4e67506ef9ca35d0ca97af652172aaecbec018159663594c3bb858ab30d790e3b2da355f3b337e85d468b3adcb5982cd6e68606c402526e6a46aca9a7087681a2305291ffbd1dc040384905b59f7f7a9b11c2414162de11785417c7ab0d2cfcb277f31970f659c801899cc66bcf1116a118bb45b8ed7d30b445b156ca0c14786f6b00fef73530d37c19e113df9e6963edad5ceee265d5201fee604786b9724d0c9f2d421944240d10cf61ca1940163d360d6aff0a5ce24605714dcdd5a9e781d0b799e3b8ae532c2bf7acc1ca1fd646ca8b45326e33fda81ce89868f7f3a1677fd63bcfd28cebec2e0e55173aa0f3acbbeb60693307d758cee7815e87a5703aea6a87207e4d52299ba839f44063d5af1eebb7adca036123729c9410c2b39f96a1fabcf612b44d9a6dbe65198890d886bc42c2bca502cd6278eef76cf383a9f9cf9b8a155e3acf4de66f6bb82a4c18c6e5070ef80136b0e1982e9e2c6e898a849e13eb751627d9edf089e51f6a1f7ddd1d420b7a0d55c7930d25d9d2576d64f5db1de26014f5f68c59efdf5773a0bf399f5755cdef6596fd7add6f4d14906969b17b8162028f33586d0bcd04a6d22800551d2efa666fbe558ba0f287da77b726c0ea525b9cf246eca0ef771897b4d40794af41abe8b2483e7bca66bcc92f4bb4be8f62c93d5e045cae991bcdc0338b2c06b746520bf84f40cee0f505483b5a32095e08b6f95184b7817d9ea204e7e32d02a1c8f60613639292c2765e39b41752dcfb96dcb92ed0370c4a1e453f43dcb8aeba3b013fe3eae258f35be37873f0b9d5893775e464c6e8cdbe8e2b8a5deb662568be49484deb2f22c0cd896ef394ceb38b37f25052aa7381e1ef405a24fea602055572f25ad885733237d8c89f8c27e759035d350ba700f24c1ccd09d6022e066cd1c3f27d24b9e404e4931410d0b5d3130b8552d7e661d18c7063c2e44236d7a3c0b13ae512517fee684206e1fab81d29a521b7312ccfcb48a93dbbbbd464eb0091c061672d3763f343464cd305057ef5ca46967afe49c0eaef92b501bd416268099c527425df7495e96de067746727b36dc681cd6497486f01fdb26659cdb4c2075e9600a8e1dc180db901a8432c5884b66f47c59635a836ea66e3afc56d78030ab8f4493e136eb4ec2b68108e904098ce700b1c1893395a99b318b36285207aba23fba7403dc42a5e5d6e291804cc95a38e7848497d7d0a1df8577a55b0e0b03d43a37e0abfc596afd76ef7208e9721303ed4ad82cd4d273ae26e0744db143d660e73d302ebeade4c32ecfdc98c25b3c1dadba742b1e0b25eac531a459c569a7181cb4c48fadc1338dc4258bc0e15df3bba75d54bd0f51366aa835d46595c59151bb6e993db5f6e8fd1f6726c5c963674f5447337dc986b31bde655a38d812f13af17a99fa07621a526ebf69f305ebad66700ba2e008c2f381b0b739e39728eb04fea1f8c389dcb3c4e8e356aea805feddf4de40cf3af29f0383699591994fc7b987059e2aff001724a37a42e348c3da1321a398a7da06e3b1e3a872de023200bb7cf61fc147ad27048011a7112b1109c38408e3c58031ca5c1d599ac74a30555306e55ce249513804af4b0d90cae6d815d3cd6992942a3c6fb5d51093a2dd92a393d58571b93993183cc2500fa54f9932a3f9d261e7631545415036e00b85842507bdf206e11d41642da9739c7e63e853341ed5c185e33956da7269d0fc614de861c0e6c957608384ab3c6a325ee8618a70d15f750257997655d088f4036f63ea20f91639200f4f4e2a197412705117cc5176560e939a968fb6a4dc1560bd4eb19c08c071b722bb5cb227d8cd57b9a0d486f38bee8149e67a2ba57f4f2bc8225149cc0827e57e82fa97d62730baa9d32c85c03ab57c5533cd24daaff3d7333b450ad4e94967ff229a7b96465ce08ed62070fc983c70fcfd18564cc689834ca1aff8b91e31162f2b611f6925002d86162a61bce6636f872012915dd141b738356082c3da8ad35898feb5bfd44db0894840c39f09dfdc862a57c9887aef9105228b267db79dda514d63089404b0d83e44f8a7948ba831018eb4af642d1c1e99bd701ed44e8db198dddbba389e8b530d3982567e97d224f76ebe29d95f714797dae4454b35415bc3b3590318869bb2365f710a19df5d94c37b34e85fa27468201183e7c6446b6c06609664416ad0ddaf717ce8e0d52ea724ad96f70ca2caf2af45f33c2a5d65aecc57c3663a1e73d209dd2dda3ae79a01b3465aa4073ed24f57364d826990f0978e035dd10f19b79e59ce983f2fb73c45338f666e851c54078ad465cab30adcb723ac12f2c5b2968c5b5ec966dc15db1b11d697b1323848f6b69a04716e22fc039aa6fbbb87262be2e0925272ddc5f0061ded0733351a1111983a1d8e4b06ec1f50c23b7ac8f0fbce347b223b7f41eb380b51839f6d165e70c77bb6a62ef79dedd78262b4a5aa18c0c956b098c10d61c1cdcebeb48f0c4e5fb1e7fb6719022166f78d6c51084c9c1d2d2ad9dfc14e2a31f9231f1e9da3724cfa49468f0ef99c7993600366af6140fd6393d283454ce11f5413235877f8765344c7a8811e038a9be974427265ae848d3fb348b6f3024676558b590a6b949ce3f791c37c7d6537512083b46bbdf23659589179e76ac6e037665e2fe8fda82ce7f7e28095c086971f8bfbee334a4b3d3154bb10afafd805617bde43fafff8a42a0e6948de2f2ea360eee416b81b787e899b945259d177cb7f7bd7930b0fb2c34b655cabb00e250a3588604b1a9f6b5288e3874163ca31c15f104d1b548d8fa845ae3e5829970f86d5fc2ddad77b115d6342470b5e74e24ddbe9176955d2409eb4f57fa239b194b990409d0020baed154097c6707172434e48ca70900a4ca8a91f2f048f8febb342a18635c536b5d4e5478165cd20eba66bae02652fcde386122eda0bc45d25822029db9c5883c1be0eae930a6bb6b4049caf945f80d8ed9072a474eed2fea73308c02651bf17d898b6161b24a75415216fc691ef83fa625b982a8bc6b2185ea81746c3925715e914a30e1f1948c381ef68fde27f47a005d54a9cb1627247c49103b5047a3d5367f3a62c70ce10fd364ced50b3226e5b34e5a02a7120355e8a6895fc483a5a22111708066f8cb12d7bda6e85075c5cf2adfd5cd92c183839042dfea91236359d04257147f39d97149446e89ab526cf2e281ac5c445578d533250b9b8b08c1226129bd2e7e50e48e8bc4927a0c1d06a42a8bd18a45e2d1c912dcd5f4f7ff2bf70350b0ab056541736b2689ae852d63755b6a0fe11f85dfeb1356de4f35cd785ac7a6abf88b86bbd935620e94ea6e2fbf8f1f134a0781389a3a69ed3bdb76d28a36a33d6d090e9a239d987b07b75c713911efd654085d5b1e49b6f1bce698914b29092782346d1dc9fffb34a340651348f7f1db15c5bb65a339386c263a2e5f5f605936d5c3b0ba7c41a2b3c062ca8ae6523389300a575d4634316ef76543f2a23251d49cd2c616bb6ea30d4845dda613d840f86a63d7876e2a274250e9847ee76d80232cd0899fe7e0899b8c5458cd2ec4eccd95a0d88f7ceff46f49812a31cb44cf0ade0e9d8212ce5a8f6651d0beb988fceb59c4c04cafd6489f650abf38926649f2ee69823b5449ec1cdb95fdcb0fe05c160c8fb9e1fcb89913ffb4b8b12dadc5420dc652c6d5fa705cd03912149a9778e1a23486062aad060a14cdc503a84a8b5175c0ae88d234037bcbd24a9c87d2b0eb0e4c6f360d0a7e41c7729b284407577062d0e815a2b6ea89ab4962a711e69869069479abd84764cd675f0ba032a219cad3d4dc40f457c6850cc362a33690dcd83ef4517828a761093dbdff095b4b4dd5543bacb7c3899ca9da19d183578463f6f08e7120a1825da5b3911b2d96c2312221c15b24b44b83c8ea4679541d03100c823a13a48a2cfee8786c07e70079fb1827d5fff033a363c911a56c1695b6cb405f2560076ecb4f9f22554977079a880a7c676d2c09cad172ab2adbd775ecad4b44e39a9f6626a981a6d3ce48147d96c89b1e88425225f3281d03000aca540cc1e8b803400d75687b2dfe354b7bb23f79373b0ff11bc8569fdf9570d81d88cb2247af38efaa31c2ecef4d7b2b673e37974e4793d3300e8f80eef5f0f94c19b3e6bae1776dfb3d385f56e74dbe024b688270f942f71f5da6ef79b1b77d67a73b7fca680292467a6bff91a8732a6127ad2a15de37446f6521ba352c7035b485b5efbad2afbe9144ae23b9861f7197feb5fbfaeb83ae45d11519e0e9ab52d9d7214f5ac70a8efaaed5e035a04a8612d27dc5b573ba1ac5b01ad47b76ef22a73ca9377760f244cc847fd3af49a9f2ef5dcae3a9b3665424b9ab0ff112e02bb438af1c2b7bf091e4603605330bd84c6c5f2df480db64fb7b2cb37f6d6e134f8b92f961e8b758a2ffa1f7ecf07d35ea47ba6362941b8eadc5ebd302767d318147f3d59fa11866fc72d3c25342e8d6259be4ef1e9d7b217391f463a025bfe7f7bb155d00f2fada54fb480087e285d2aea8a7126498d5ae9368443e9eb66231049b09bad9c1b76c95b6fa8702ebeeaf00148f4ad85833fa9ab6f70edae9ac7e7ef3166c0c979512d8115909869efdbdc49ee50a562d2205e99c736be81a795079aa6fbf832ea600267fd0ee72059722693964a9146a356ae1f54e17f0bc4329a198759cec438c878e99011abfd855e9d5f7269339c8dc1c4e426ed1789e622f3522b51b99efa830926add60facd426de6fd9582daa3ee01a094461e2fa1a4e7b42164c553cce29d0da68b99c9a75fb876662016e549aa6a08ae76b8e7c183a2e8ff626c1f17db2844f7fb99ebcf0ae6d54d26b7b49091439e1e4f471adaea4eeda57beb0f6242bbb8b312b536d0b02ced61f8ff9b69bb81fe7ef6e3c6a0ac9469f2887fed68675e462db8ee08f763e42c2b588d1f57b34751ac58ca5ad891914e0b6d1931395ed42741b3a2514130f69e93d5aea271a55c798e1a373d651ee5007b705f9e0840b80531130cc961e14bef8b23e63871c93633b2990f9af9f86c37af16bfed1ac7f7fd71868f3862329145171c3f74230373b7079600c062ef7eb25090339452da559f329aa14da92cb99d55e74f474d5db57a29db054c350f7fef4da4fcef89f060adeaad109499fdd13371a345609db371b17c4c5c317c5968cd9444d1cc05b38a7c600e6410dccdaf51814e26a35419085b8e10e9428263eb9b62904764e148ce25ba663ae487b09e9c3511bb458eb46437c8971170542cc233a690c68007585fa56649ce263473c2b700deffc0758fd3038735ad762471f0293acfc68f05ea691fa7aeb8fce065774c6abb7f59eaae74b714d5f04065b9e628db5b99e96a62ae99a27c9e21f5a4e60e4dbf5bd78ad939cce5a46ca4f48c970faf70dc4b8f8ffc0782f46e2595c57fd7f21b7377fe28eae3dfbe16717b9943dcc6030896713edf84154c8f37c3ad70bedaf5e1c857b6d03ca204d3ab371d7d7c2daf77d75d3fea8c4282e313cab187b132e95617aedb8a7d976f490576d9abe5c93516b856d5abef4aeb2b90d19c246dd50992f788cfecd4b23c52c9a15354e6ea2537ad829b10bad3d105169618dbfcc7ffc055d96c4cf0ac7f712db39cf4199efaad44df923e12061d1e5c102887e461ac49aff5f472cbf6d857f30b50340a310fc3b5626585c18a775c74cc33f08d63cf8514942a4cc7330461369ca7a9cb4ee506916ca8dabcfe2043f786c24d51c3342bbc107a961516e31e29fee427b737e1fda6d9965120ee702839738f9253494f1860f5e372fcfc5e3a0b74d4ac54dc090ffe9355ed115957075f2263c8d29d77178b49a132f4cacea53461a412bb058f5cfd12969183113b7bda01be077aae3cdaeae045f3477153afb41a030758ea6c6718eab93ce4b5998514bfd34d65dbc1b7527ae15f51df8d00fb5440ecc36221f8e385cb27b120603def0bce4bf02eea21dac7968b1ea105b1e2979b1a3d2e5e8e12899947e5cbfdd9a218801fdc6548d3477f298aff106bc3915706f10f1af4c185aa55ce89b2c247dd901c047a8595a382269456898ef2f12aee9a37984f1ade44cea321caf9330b4326e375dae470d7e83d783e6358f2001bf7ada75e6ded0418b20648d07f6e6d508934c9ba8c1a15e8e4c7b22036c2a05a09804473b3feb96eb90fda3b9f37cb142313015cf88e06609bb506553812140e5935eb1b71dfea11600d711134d799d633ed9f6ff9ea2c922b7dd417ed0ba8f5b10b9c261a8e3a1a415ba7f6ba57d4bbc6b698e92475f1600795037c522f07384cc645399501798c9124c88a927ca575445eab06773bdcf0c28816631c032057f89297191d3b7350c527c05594ceb2dc39a6f48130ceaa773eadecc08de8b5c2a3dd08e9f4f6697df5766eb2efe6b3647025501b9b9bc012a39da32f5b6940f175af934867442b09181be38a7726dc7de059369a982cb039eb38d8d81aa51fe2618615a379cb7792d7d166fb2b70f9fdc2be62cd40f136efbcec7878790054283949fb91a2d1522ecefbd8406ee67dc453259cdf1f24c2c7cfa3e3e0fdafe0888537b27ae2adfa13cb74a148da6a6282d60360ca0a3e0a43886a61fbd3b9b002181b889bcb1044bf7b330380456e49bc5036f377fdb6da771bdc79f5b0cf2212483f5ea93f61abcecd36c8ad75a4363fa0e9a7d47b41c9f16d164a945f6ec39f7db179f91fa9db3f2bb38f071af6935dce92d6f9c9c9c173902b8e316fb55681b2047e9fbdd9f1d901341b086172ec51e2b5a46ffd37e8dc2397aff203cd8200fb3780156972018e5cadee83229152e3bf3feffef985780b3200e1f4a5ffa1d932d9a213551f60df67af217b9fe2b40344c919a6460b3e627d9b31f72f8a9f8c6b3c6a0d8779fcac69d8f7a2264f941ae4ad83898c7c4ed93a48e9a7fdcbe96c629003f8b09417b150c18a8b769aeeb86732f12f7b67130fd10a703d5fcddb8fed9846f8cd40bec0c1594139d828b5fda71e63ec84a240147aaa87c5ae5cab8f7ad81b6c5dba46d7e308d5aeb656db8d249f2f5df6c0ea3efef6708eb4978a66c9d3b029b58d1384520b8080de64a46466fdaa9c2c05a95c282fb0b04ed38808f0ca0ceadd999fb3ec1afe8826afc4fb2c033c8a15812354fbbdf9d8691d23dd3f6c76c4c8614b70c2e734f8d6944603278048befbea59d1f77c9226f08d068f91d3aee94c4c2412eba6e0d912cf6e2ec3f80080121a8faac1de05f2f56409e5303b4bb25a37a0a69bf43a46844cef5b8b44c39182751c206944c1ac99a7c11240e6d76cc49235dfa63a5bc630e171aa90454370adfc968a39281ac6f9ff9b27ba06e45b8e9ac6535fea4cd3518e1e72c508e7b8426ccaf4030ae4b8fce5d0ada31f1e882cd7af6db68e7e8191e7b10a16428f780916ffac977c39274a639e96b635be1a7fc32a487d8568a245738dbd3d976976a707ef5d90a0179a3923197790a6cb93b6c6e3d1cceb22b5e4cd71a40e72e637d0df76972e91ff1c1254ac27192ceac8c9b9871c106888a3489f5b67075d62e76e405201853a95c88e83936c24988f9a5d108fa4e9f7e2c0b8a438ecaffff0363e3a9d20340c312555e9412414a0ad0608999f9d5f36da3a35c82ce49c3a51c99fbd76dfb58b460ab550d271dc01139428c9e0c2e12c7cc26d69ada5fb0003f87ae380428bbaf46fc4623dc566684750184337e903661113849ad5ad579d3e572ad695c95297bee87831f45a13c76b8fb8cbc25509ff7366c2ee9003c2c0924f55cd607906383f5bcba0852485d51bff190a5b97d67d4dca67afa5bcd4780ea6949f85ea8489eb20fb82b04775c924b15eeaaf4a365ffd702089c7434f41348be5cfe106475758a71adcf0e7e7694cc688db108b1108d0c8c82b23f7e50ff2fc705dba0bc616fbf462c24ced6fe0bc868fbad043e5cb40c5f4ff88fde979a51995ab263d0684522b2ecda8eb037d29adba64f4531d8c5e2613d472dd417da85b69d25e5f26ef5e7b163789b376b13bac4f2e9d463deaca3a17f1f4ff209aa14914bcd534a297fb60a1473d574a87b915e016bf2fd438a8e636f07bc51ed21140b36e96de8e7c79b48e6123f5255278f8ae16b90af7374689dfd9896ff8a94809500d900ea0bf5a58107981f2205d85c8ef9b5300c382abcad2536f33f8ce07d30c1cad3d1c7c24ac6436bdb03259f44cc4f4ce093524f43b3bcf70f757d6e156ec2e2f1f7d4d5068b828acdb0614ce0c15141ee86625fddc6019c53b252998d1edabcc28f3be43254351c93bc5e0acf0052b5f5486796e8566c75368e5f5c4b18ee7eb589869f1cc55ea656fee625ae84cc3fcb09865955f00b50dfb15b2cc83c8dd20e43d9d72224873399de5384ae196fe1fe1f7f4c82242b885bed0277f0f8136f77089a9d5b1dac960466e5a026875815854f0583a3f02b60710b89ac53d8a953a866bf72fec1bc079b5cc4d56778d8d533bcfdff52c0ca79de758b24478156a80da6a5a9b17469fe20f1b8c87a46a955163a8e742efa16d7613b0d1260e1fcebb3397529419743b817140bcac33d51735ea6baa9b8324379aa5ccd1e6f11af68c4f152129b4fcae602f41ca0b2d004830a25fa0bbf8f153128470799fe86dbce7e1f837ac3a480fa9180c045cec4e0681f2e7eff4640f571f3659ca65175c462de8c8f7ce72ab69ae33fc8893ea5c5a8e2ec2f2ff739383b4385b67ec44aa16c69e57830acdfb1f7e72c0be2d9a32998c8b10e4b7578e1474340910dc6ac9c55f5e93e21af739022eaa40e826c6cb2b7efc045bb3f44e613198c0e4a29c39e4324cd70eb88bcce87265e72352b37bd36537c3db3435ebb0fd844c79b7eba8f7fbde2661ed44b1a57017dd7a2a4ce9bb44afada335e405236f16b3e80b9177022a2a3edea9acd2cd3fded4559badb8f70a2c5ab92300d9f0a1c5a93cce2a58d15b3994ecc7c446ea36f60721a82a093b90bfb968e418123d14c449db66f251d731043fa5cd51e31710cc411a404f7b70148ba0a1bb3d4e44a8f64a2ac39ac3c2aeba3a562ee99957780a9e854ac9639444a720661698fcffdc2f2dabf95cb1a19f6ca147182ccd2dcfda2941956db21483ab364f313b16b244bade31dba94665bc09468eb07e972266deb4613978438a018fda0dfc9ca4be6212e7ec4c6e4d04e006987565a98f1283eae1256c05aad9a178df36a5db37b0f026f04c6092f6a5ea2362d4e9369bd88f9c77fac6384018bef2fed5ef26e765b9516cfa107f8d8d153ab4c825c2ba2372f09b6acb1d088b288411592f5ce4cc9308114431fdba210984397c4a50fdf26110979059e66184ff8b0d35953644a6ac17799ed4f2159769bfbb49cd48bae43d1e554db59e4b786326da6bfd397d51a8939e151e1aa4d088f432fbcd7bb17a2795fdeb66307af5fa57b028d9f8dc9d84d6dd1704309b00a1b3a5e366e6657007349eac7ebfec7d236908f2377e46c7d03a49969468d5a8805171cbd0c3c69779133fc69ae37073b4628d46595515446e030764c0faf7ab697c814ec8b67330abf193f8d6e6b3299b1c5e5272e31af77cde7dcb950621742d90b40f8b70419450f08ac4d32c0e018a2e850eccdd205bb8b6b60499cdd52d2207946e7a1a1b291ae98173b8bfd49acaa59bd686a098a40a47f95c58ddae6fb62c71131cfbb06457cc06b39548f1db94c00b13af0d90aaf344e146e711b38e435efa334a859746305aafc1996aaf7b7599df755504668e11c221c03daf8fcbfd0a585d98b614a650b1ea93733c0a1432ca4a507b2b24ea8144671eb0819a638c5bdbe2fac2499894a4cd0b4ecdb4c70f5d0f16aeac0c8871d19682f02d4dd76a5cefeb6e0c375d3bf98ab8fc896ecdcf82d5541271bc774b632206b76bb8b8dd4d0b35f47bf1cc24e24d6742a42b0f016e352b60366f1766b58499e1bcb1c3af4d0c7ecf2063310e77ebf9d2dd21cdd1f037c137d5588758366b2ce64704437ad3f0f53ac4874a1cf6a41526889567253a5602ad3d386ea86bdbef0279fce66f572a7f8a35469d7481fd11f7f2ebf4566fbdf086c1b3dcf16f322c15e7f143fbebf9f41bd10a5fd16a8f6f46c0ab20e3cf2cbb90d1c1f0ad4c782ecc7fa4b0132e39b083726ab649e85e399c2e34a98fdd8d292c3f03abe73679d7a0e7a4ecb9a5b2ca2dd10aefb0b24e851f55f2fa556b8f05883c7f4898226cbc03e299df5639759c08a2dbfa4fc509f8b9185c441c4aea73cd544b97b14e287b03528203962be94fe2e7066d525332ea308dd352df507d535a7805ff8dd1276bb6d972afd480d14cdb997989d6090ac42750dec3db7834654ca89a2e0f54e0c48670e723206461518aa18b923898a6ea88bddb94ae6dc2dca919a1595b1c468016910ab02267e4f4ae84827418f5c76ddb02c1b220a25b9f793d17c30200ebadc08645fa1f68a00e9b55cbdb233182b847fd1a0fa06beeda2aeb1c9c7499718dcd1fa7a086ce4143debcd3913624bc0863c5bcbb91ed7aec8ed49e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
