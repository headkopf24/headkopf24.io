<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37f0cd2129555ad1dd4f0a47514f184679ebe08fb816b07cf9b7eabb18398941356fa0087a2aacc3ef998704a9664999a3ee7e32f3827d59234b867be4f0d461a183afa093c086be80265c59a72c77ca1a6aa5c59c771666f02f2c0f5f75164f92665ece91a2cb54834be031a010449a4313c3e04fabe5c7f1ce048da79791615ae4db1e98be60363165fbb6121f5f08f5c215aba4984c110af6930a9fcfbb3b8bb8cf1d40028a7bbbc0c49d6a3993123b77385151900e460764a00b58ff74fdc3407b4d22e58b0668474523f7380da0f8c590664367e8e94f4ea8e13e9214777cf3ad607dc24ab6c4ca84564543857f409a26bb10debfbcd8fc8fe04f721629e86326c20c598908462a27a7c09537b17794a02f41495d0ba56627213bda81147cd935a00eeaee34dfcd989afd3df0be574c018b1a111dadd88c308ea73ebc007d413060e81f8d37094de6cbe0473e0b17995a759e86b2eda451c7a345bd17b60ecbd450331d2d5d9b5e494625a0f23b4a8d7969b33eb6009914169f9267ccdf97b98ab7ef8ace35ab14f845f87130ad679e1a6b33b3f0e3366b25558ea39ccd41c1ef8bac2157b2af61f93fd8b3be323e1cc6ce0a877fa201b96d0106ab9f334746b4100e1fb2646c82df2630fa24cd8fbaa4d0686f020e844f5d6e0d6cdcd11c1fc208823650d39b9d93fdf2930fb923ab4e7f2a27948dc23412a8dbf008ec0ec9231b0300b5d3d3388e49e4d56ed9e13e9b494af949b1637352f2743daa052789a8411e45bb3861b9283f70908ec910009fd611499953a141561032f036a6f5df6b3da00dcffbcd60f7eeb52eae2651c2cfa4098fabad6e3746ca4f10794d69d7e1cfbd304f756bfd3e20c496e9894feb2561d7e158f3b00488810ea239d059ca6cc8a12b6a847c2571af51979850f2be84118a3c50e5abb32c5dbe6c0bc2c219f6592631f11fba190173bdb028cbf9b79f377a6011c06ba9d1e6494a85981342565ebb1f06df07511e20232767b1ae5677536bfed6dada71adfb7ae307d19cae5fd87bfa53a65f4ab24182adf96826fa869c411bc96f8de48baabb45638ef050e8bbe3aa8a839f0936d6f81373ce70a41d2ac0cd9ec5a1226d6b60640b059da4780847bb19e08a120723e5aeaede40f7e802c543b86f4bcadc775fbd7da7396ba5aac060708fff93427aeb5b098cbc8b940ce16e91f8932bd8c6d1e637c25ee7da4248d556e43690a340c43a1b0a8c495a1cb8089a795f213ea26ddf24c9959ac3a5290cdf4e03b166b7ec0518ef3999890c08e9a041e9eaf888c0e6b131b2ce93bcaf39371fb2f34717307eb0c1b0db67b3701e515fb18a0608d0a73faf44dd07b7f1075b5790a840eebe1bd0edae5eec77d1d471b457522ffeb4724407d9bea78275043fbe8aa80bf23425c99f48d12e6e7159afd182feda559d5a91e445e8579d2e1b364bf019a310228adbee2155ffc0bdf56864a8d0fe0acdc1dbbe70dab87864c6212e580127fa7b1861bbc41b468dfaee2609538e2e5f3fc66bea2484e34d874a96bd89289ecd8fd278306b4d78c3a3e51f9fc3b6d3d490ca8de436a11ca26346cdf9c1fa09f44a7ec94b3270db78858192eb2704dc230c45d8015b1cd9f56f29ce3864ee8eb0efc47def261bbdba0f52f149720baf1f45dc09a2f0d99acaa1f630b75400d0f9f7e9481f484bdc597711c0225aae13a765306768e4cff17261b3f7eeba46ee03ffb5c175c26b41d4db7e5545d6af02cab1310c27227ccc8efbf0a845b2f32045a2b1dd7a5def1f6c210448a0068ffdad93ec0cdc513d7ad470006e60c1bc70cfaad3689dcb1c32b0f736f50317e06c9208b393d546ea8408d036d747f6dfc362e35a494c4b695995ae52e235ebc42207220ed709e5c40fc3d292a95f899cae6f174689420cc4afa3e46411589e2615859c8a5f4d16ad31cadceaa200deecf15a8d88ddd54772ba7968a3ef7ad3f03061ac3b64f8da9ad6b01c50c2de981cc1750fb829920d1ee84e6910174b97466491fc89727d2513541667f6455b82a31fb9086d42683eb33070c195778e2102c29a6aa780d6232a2d14a485a06f27cb72b4cbde8aa902bcdcdb87918255fc1614152a17f5ed8dca4d4aff5857b27f6c75371711c7e1313735f2caf056159188891f2530dbffa23d55e93b2e71f1a27427609a1d87f712397eca4d767045212c15d53ec3ecbe26c45b5e7d8472266631472ee9c1eaa86ef6654db743098288270050987893c8c816cd044296246a9c3d70a774cc52e404d2cb3bd3b94b093f9d9fa28c7e9c81c09d4338261b39e426c919f1324be847619c862b35af1b4d3caa1e77fd406beb670419f6bf4c688c612996ccf906dfbd727f5258cccf66f1652cf08656406918ae1061f50a2d1cd287c875daa47fdb139a37040af35fc1dc6a02dc58631640b06b094017f865b6416ad821006423ba987c30ca732c5687fad6d1d86cdbf7c6bc849eaef5a7f1909f85c516e388b928425b12278b889896ce21e6bf19ee8618c99495ad32f6a2aac818069fd42a1b5a0c8dcb615f2727932de49a25073813d3b79bbd1b92c18bd4fbaecc8297dd0c9de227d24abb690dda56071933c4252364e9efb2495568ad5aa74ab0af2e1f574699bcbae7d18df93c82ed2568ca1243f1072b132d55f43bcc00fd4cb4bcb81c5c230b349ac260bab66949c8412380443d5ca5f0128bd03974c346ecb4ad4bb430c4a9be53a584c8d92262f50e51137a914a437b0ab2d4091dba29c4a4f197cfcb42670e6cf65ef536c83f9029b102018ccd3548ffa33ad60dcbc1eff1d24557874d43a10b47ef3de1922485d548a4dd78452696df0dc54e35590911fbffc9e8b3b5de587b18a9905e9b3c6f8afb629c4fd0b71bfe6279cb47b172c021f3a7c2cc83620f37b9df5c66092c9f0faf81f9b4a448b84fb8f06ef4cdaa9e45ebe4c1836ebf122aba0ea17926482d4720a43fb8115382c7731fdfd3d11804359a3c17b7066e706f53e56f3987f39aac290737126a3124467100cfd7b8ad78596e88a93997e8587a895bb164e0b3592a393efed5d9cdbdc33dd873e0229e2aeecb0bbd11ec3002bb5e79c2abb2150cf786bdbd5243de9875a2e752824f279bb61e40065d8fcd54c52e5bdf5eddf27151c255700c54d3c8549e639b42dc5844b36642361fa9c18662d7a814e9c967407ddd93bcff176f2e2dd834d64a0edb5322401d6618ccad1be55ac314a0cd077b5499fdea37412d7c5c0d87b6aa39f88571859b1e189d50128fc8792934f56da1b79d4e12a95aaf6fc4cdd93df81b8716966043572afa090e8f5391d74dc2fc400867c4b120e703beb036d7303e4efc4a5a61215183527c0d9920b2a8b7df7ee99362799e40e91a883cee8aa1f7c61254a83b9727b8346c77dd06677df6f023cb7055950ab3fb116be725ddf169bbe6529b99afa1da56375e17edd5dbd293b6a9734bf9ce3383ca3c88b171452b968de5aa1ced8f3c14bcbc4a1cdbf258a96eb85b28eb38eb11770c3f9bcbad9afd729c83f1c00eb7eab1cc2992e2d72efe96ea086bf3ae46e317ccd8b29ef8766fa4652c0c51f94f103dff4b64a9e8e8e0ace32710801ae9096dfcbf24cda516e9ef16d98453519c31fcf7c3c1db6179909cbf49401e7790223a9b3a0f983943a1c29ab819e4cb0061cfa4abf174c7be78c50cb5b05450ab5c3957c74195309032a023b5cc0d3c3b23f972692ac279dddc5f27a0f12cbfa01291f1696437ccf37fc35a1a3714f84f3e944a5c2f967829f97882f7b57d2075e2e949144edff713de14fb0bbcdc6fd808c5b5968802ce4573b1f5fe47d4d987d57a8baa0e1a261d2c16cbbf72ebded8e79fa6e7e20586c2bd358e16905e2593abb6d319b7c41e61a597cfea2fe39cb01d78db19eaf0213b26d7a5e19f5c4a4dbd8908f87180945fbb37a743f9b003180cc7cb5b7a6e69c733f3c615dda33ee864a1e08b5a877ace9a443b822791eed0c508ea4aab08293df992792f124c148782b05324d341f0aab69a58d7b2824f427d8a0b232c00e642ff1c67b73e2c1602357c105920d661d3990d9cd03dda16841b00e477587c371b14d93c459b580c3d2d52042430daa2b01aafc241c1b3d7b30a761cf8e91c37c50a6b05b09d01c251754928d6edbf453f8c6de14971bf5c22e3c6f91983e9f6ac9689417a3900eae6ab0637b5e92d2ed1918e85ed1e9a7c1ebe08f501ec5c52c7e82b273ce8c39c60a34a0c649bf9116cbb38cbee8c8e3e1f3a17210811a60cc2f9ea776e5a4f827871a17930321fe8d0622ef90e9043453c63f9553b663309e04c6fe3114157af43f1d0e307be924e78ba097f0e884807d59e0a14717e483524798dae8af4530eb92daa0e30c8b5650c8f88bb9958bddd985793de1dbc1a53409d68734ee65390cb9bbe668215fd8ff3c48ff60563b2ea52a90f14a42f7dd03d599e2c71311747b03f668e6a19c75b8762e951b9fef1480b07aaa943e3d6f6af56fb082979f485fccc63272f013dbf404d045a068ce31c99365f95c22a16b2e20dbd46f90baed0c79993094c6c6fdb32f31159d49937d481f6a453e91ce89abaa2a7d4cf399c52bf1e28682e4e51c13cc3a4a09f102514b4f2cf2f01c11ea99d6cccf5766ea7fd7d48b401c9ae136b2aee4f1e5fb4f24275f084b495ca95f658714633e6fef9f2b120b2f413198ba59d53dd23fcef9a8e87a0beed654a290a467157a63469a8b3a681112e23d4d71fc800c87cfe8db8184ed8f813d10bacf59c5efd9fefcb49ef9025c79f9a812cee4f96d3f81cbdfde18b6a1ddc12b35c48ae83ee2102bc707d1a27fec075ac46b744a7994b238b3fecfd4dbb8a6e8f8dadcb30bbbc9d4072647101facbdaa72aa8340641edd9fc8c8125545b890638e9dd4a8f490e1c2044e1e4205ac2bb255eb2ae4e83ca30409e99062c4c68875aaecef67de48ce32ede464e137db43c5e081ed4acc88f352f35dbafce436966acb068052a9532fc5d5fd529da96e5ec856fcdc9177fe8c31e5baa062c2b84dc37b46618bf8dd9f4ae18885127d516185b2e0e725e77af63ec6218c427562c9a4b38c6f56f4d00a349a9dd7865830f3e0fa3467bf76ef702d7c7a958be3420c009d1197142846e886e25b2a0ff59582e369ac0aed9092857dcd03e7c9b8a9bfbacb2d19236e0b3c23faa3dc9939d8f6d22294d29c45c7afb4385ea50c9b7ebae84a54c89fc5375ff03bbf0a3e2c4b012735fc93ec281f42e1987d0ae335830ee49abbf0910d7e22ef9a5866d2f0e534adb0d926476d134231f37ba8f6f38f444f1a221bc966d2894a249cbe5490e9e28f5e685ab062453e845f222b004937dbb10bafba2508ce77ac1f342556a2b81bfad48fa3439b2187c3396b97ca65ca67752816691ad82ceba43632150062d211413873d380a4f4b99406b3cea10cf2e97e4bbb061764a8613d27941281b775d6a99bbb4e09616aad952bb8b4d5625b134ed4b4d58d33225ee68e2f8c21bad355a95cafb0e41e46e73d67f9a88df29969e68c476f2f26e8439b26ce1320cca86dd896b4669847c91facd4c27fa47368bf09ffd1c1c6bd459822b696d28e896cbaf52b4451625c0d4db6730f5cf22a468d367f520785f70505d5b137157a13c5ad1c4faff2b944ea1f027bfb54b3d486d38433a61f5b164d576e573729a7f1d9725edfb14357ef96939ed746e2e4bcb6f1dc1203d7f6d2f99b66cc5aa47055b803dcb528417f4a7f3a1bff4bb6eef79805253a003c9ccc53314cd1a66913a9968d15914b9850fc4adb89d60dc15cc667265862f70304921f80f4f1cabf4486a9498e5e524aac5d7e94c14fcc7900d1d76de8ec5ea2726061322e00fb579ba8fd5d3bc86436ea0406178e261122636f0ed7ec81d2ebd668ba4b41703aafc2cac687745d45fb5e6396d2f12a65b44fc5203bbb2733bac5ca475a419d098be53ac1c06ea79975836c459dabdac608df6eea60f22cd97db71c6624a78ab229b9ec4e7e221aa5aec20b58404f4b0cd42f6331c95c575ce19d1a500398b3ba9b21735f05bcd1be53de5bed308c0b437f6c763714840865809104aa475d4188cfa28f19f0f93b517ebea4afb7fbe3323507467bcef3f994a5344d36e21790fa52ff8a6fb712d26852262fd0a53412c9c5c20c815b355d2949fab1a14a4a0a982a838d93f81f693970c120cafd18e3532a96d69450d16d91cc53e182272f7a1f9d938c8d57007c2410f26a84134baf8f3c29d56e6ab5e964770e9a9c6cf4419ba6730669fa9b043298b21f9aae501e14fe74abee913b429b0d7a55c17b04f921e7176a477fcd1ea45f37d153b034be44fb1b126ca204e09f4a15df8bc6c0a765ba200fd04a28b5f467cdc3e12c5293bb25a176fcc788531a821a3925f9bb14e6bf59f6b21c6045d1a70620c5ad025e4b4028af381cf69b1a8254bb74b64561b231e3d4a6bc69be776ecbee8bf972deda26890cfe4dc2fd9e5b68d6ecf626e29c5c92f34d9370100310db2143949d25e1a9c14b13a33088e695275ba2f3c3f512dea50fc2c334898db9a8d06f5ae8eb51b0a83ce21a111668437a61eb9353cd230ca0413a91ab2edaae1f7cac92a05708c49c981dc99ac6161f0924852feec0a2dd13b2774a7e7925a143879c45197d97723cad04fa476e53df28caa027b6cb73a4b8aa30676a25fedbf3feeaf090a235c743b0a844b60cf6235b4e562a215db6ec069623c5d6ab8cd341a5a059e4eedd9bf47c332b22a51bee0e7d815512994a5232bcedaaa7dd37dfe334487de2fe4efd364882af4cbca51d4725aaaba52c6e15b424a7f295deb582153f3c88f9b0d1aea596c897b664150f3c9b908b6f93ea92a73cae4d0c316a778c7443dcc209fe751f6604cadc89e5a71df70bc6ba6aed42373722a13b1c78e1ce5e029022f085fce898d4c9d9a58a7a01d5e93ca8cd3c5ab2c39dda4fc26644f841b9511680c67b0a3e9f007fea74217543acf3b8a93a60c378cae22b3578f3288a8310ec37f01aebcd0fc7f896fa3d607e79b2281ba7c507cac94a99f0145ddcc6657db64b67a06cf07df6717958f33700cbdfece12316b2fc9ae71be29ba2f6a1caae38b3377d74ce0b5099b2802ebc2be19edfd1da5d9ed4feff37b30672919b7d88642b19c1e9b7c9f0f3f5b4b1246b1972f5dde4351f9f024b27c71552f26321bae6637d0fd2491d0254e62c50136adba626f959ab2f0912b1a563eff46d8596233f74c4d5d382f9c9def2e572e35e188c54a8000590cf57e3b0bfcdc8daa898088b7ac83c967a455a5270ee8dee509b5c75fbd81d63ba95c19b3dd6a840ee5632bc0606195ff2326c7d96058f99fd0b3d941630f01bcfef1051b185958ea00e57a3523a5fba29ca1832de9baa5c39750d57a1468255da2cb1dba1caa17f59896c30710308d688475ef31d0e48bf23f6390f21d3cb6cd96cceb72a03b0a2d34843a42f177ccb2a56564403275a07f0fb8aaafe1586454683ca49904a936d59725c76a958d7757a252192a3f6d65dcdbabafa6f9da13a8e5c4688640f0a92d2ba9136d248710681fb4bdb38decf3ac0bb9ae277b1723618f57e3be1832d99384895e792c1df44ba47fc067e59c54a11b94cd24c98b1bae8270dc286878f6671c54818500afb9249f791f48dbfd615b91b668c2c85003c42b9e86c7454b1c89ae21c369df0931024d9b8227d2b492ed4dd55cd7d5d4549467b63067385b6c912188d5c15d75cce8ee9fa32986d40fb76e0e62b439d94355663b6f0200901435f56c84cbdacdd74a9193dd34d01fba94967c74beeb0eda62c97bb5748f9dcadeca659f0b44c997bd480b1ef58d81f67a05db720bca1ffd2b2a2e75ae7f55564d3817448479c99c3ae4d5e930226fe6053d0ba0da1e806194cd0841bd0b81daa1e80dd7767fd405bbf8341a03c194c32e20340ec17e84e5ef856ed9324964df9a1888df4acdf7b9f162fed9b8fb1c19e41ac4bf8d6de58b3d4abc16f68af54589c3bb22e615124b7cb5c6c1468ab8428712d10ea82c6fe13c97ac2d7ad60cdabfa4554c089cef38bb10e5048817f11220d7b397480166da0a329a2b26dbb3ab12066492bda887ab24f76e191cd0f9eddd18895dda5faaf6ecbcdd5e3c351ed1a484d99198cafe91d4ec789efef73aafd891a813c9f31f7c8f152a410fd71effa1860445c4988d8db99d739e4dcc5eb2f7f082b2f058fbbc95b5ae8a4177454622a8c67f0593ff25fb5caf962af86b43aec68f1c1d01b21abaf41e704a5e843ef6f3a0c1d48d5ac1be9af0bc1f7cfefabc4e97e35135db54027c1ac883de3d63c5b7bd9a5fac1d15c282aa9dec6fa8fcd71b01c4b3a662e5b5241fe4afebbf3c63f62d2ae94752a142c7e05399132fe5fbb2ca84c38a3f2ed4685c8646537f6a8a0a5f4a7d042cc13503452ce5ecfe2210c60347d8b8f9969f301ecafadaf4336858bf116e8bbe8d456ba47ab1810900c6affc44e795e015e7316c6013c748c4dc956a42d4eaaccc6817fbf6265e37884506c3aa37143ddf77ea290dbca102c85456bd6558dd3d51738038ebe669d4c2cd8346d64ae0a1a828f70a2cca5d01b255522687630d67423a7c8e694d9dd161bb2479f8b4faa78f097e3ec267b0c83ccdd61cb845f4ff5c0903a24d7e4b6636731c3532b38ba75c85ce34e2f4c1955b8f9ce77114f1548b44ab6fa87971bb6a95af142d77ff43045a0fa80235a633f189902e37de5f68491e5f9e4e714ae1f375ffe80287f11d5afca2b3e20330226da322fd62c6e565b3d1cc442593f79be08101b7a0c2fd9263be49c12dadd75315d343d9bf8e61391de679781b9437d8fc349261ad463fda6d016085c12dd5d14563e41e82f82129078ce26d3b3bd47fa2cfb5fb4af2270f67afb41daa1f58dd4daada098bced1788d925e0a1b2455ae49fd75f9c4c2e334073de8aa1e1cec21441ab4cf9b2471d53913360849b226e62d0d07181eaebd7fc7fbab5a02c8ba02473f81a9501d07bdf3520472a57fba53b8a43f085083a197cb6756a4e970a1fdd1f4c6e4fef6cbbfd86c155e0af609917bfccac4d08d7efc8c5fc132a900880c5aefface52db943a22c6c1325d1dd8b70f2e6b87588ff3629c1e6e9764c82c76820cc3e9d49b94e35e7a0616eddd2de4d3a2d5ebd9e236fb92ed2787778efd5dd46328cadfadeb81873dbfc759d7c62d1647a8f27f26197047809a8dd8a9de59d29059d01bbbd4bcd8d39e15d40bf3df91c5857f3882c74e9495899be39e2d66a0c38f0538d2a11fe5fa8d6edbf5963203cdd98d5d886c3bd3412066aa8ba984d62a9a8da2e87fd3fe71f8248f305dd21791e4b56a7e7860cf5acfd0b6771d9885ee2dca5de67450e64b8ec941a37ae6a4f172554b804003878684e2dbc215b716124b070401f5b3905c87068622e48d9cb3267b662dcdd69f47ad84fced73393906efc6686c062cb8c84a15bf9d11e65c34339d6440b4022f19d8095caf5aaa5a74f8bd1dd2635e9c9ba4a3082bb62a87efeb10dccc76b29cea5604bb77d216e83d5ced85aa8ef7ea0138499c2a96e0470987389af0f40bc2e6162b0bf1ded42dbe3bf9c832d65c5fcfad2a3f5fec3920c50601e87c9dc34c2db5f8c047929350096857768160e9bed1be10a924460407dc0ae4c2641816f58332ab5e18bf8d2ade85a1676d917f9f18ee82c13f4768a9b6548e226b0be7dd43bd36460c6a764324eb1415b2034aa22060998ec033f65c3ddf40f0473851a4ac07c674605ff0d9e44b40fbf064987abe7b6aff8f489d235626256a43f4fe4348f2824a65598bfd5a462371504388e7ea0a62f4ed69cc03cc6e78235b2177eaed779d0616c0520b43668a7c71318d203f152c15f9cd9992a26288c29047df790fae75b89491bacaa0d1e3be6c4578257a7435da7ec947abb1d7b2d166d96bae36a507d75a5698098785630c6d7c3814aea072a6831fd56ac93299971e75d644140010ed18d5a0b5b86214dcb6e5be33a64fc53983bff1cc1ce06bc908aa6bb399c294b08c669b7982d87584e81145738478cb3f71c25451f4f2ef1ebbc14458e335c0a4864939870304aa34a0954cc45c52006d5c31d36773cfb163cf207aad57d4a2c5715d054cda519ceab37a911c06df943bccd9e7faa4d243f631819401306ddbd16e041e4c38f1ddccb93972eff6620657b583fd8d66cd727aca156cb41d04a6e64e0b1b87800429c6883997639bc9a54814296438edda7e9efe853382bbb6a62d1b57f86b74efe45a63808744729ec58badc5b0398223771e7456bd7906fa631a12e57d12e127adb2e52a39ca1e94b280e9d220e28897c57c1110a3bccc4f8d0616cdc734ac38e8b4be56e6031a29cf24cb67c05c4d80afbe7735bc3b1bb46c688442cc8beb1fe79cd4c5a20217f5f8769aab61d5f79464870420d7d4d6fcd54ef5cabc61b652baf141f84c5f2e118d5fef63c92fdbd0f02624c39493c430a329aa21810ea534c24158a120674edef5b26a4c5db01906c95ceec670d39f48fbdf5fd9fe3c831a7148a27e4e5ed36ecd741a1ae6f8ab0ba069aecc334d3f2067683e3b98b364008351374896f8a3abdc66d0ea1cf07056f287371f1b176e3971e61ae0b9ca750079ed0e94d980f808ef4f47466f63c88070ac0ed915d9f7bc75f28ca0b499cb2aaae2f352b3c33188526736a7c1bc1cbcb5317f8e4aeff2cbd5d50f0bfe697e30e0f811524f13ead965bf4af382c7114a96f9c1fbf4a21928d1cfd78ad61c03a99bbbcab4c0e7e3d973d693143620e5de917fc8f13c90240cf3267a05103cb3f499e4b0e47356e5dbe77e909c0fb8d38773adb79426fa146933ee9914e7d29f9983b33ae2da191e2c6ccac08225476b28968b5bc24b61d9097401f638d9c3ef145223706f2404163bbd8d7d429334346db7ba933171eb2c2fd6753859bf9036f5302c21f327599cc282e8d56acff1f1829fd7e245ea13eecf70b64f10b47e8193e26d111d9d5edc62f64868bc6b0065fa8074fd9f109cdf5a0554994b6f686ab2a4fa5ad86c32f8faca0a159d237c39dfe7a546be046552e7c72e1cfb779a46fa52843f7a71636c078e13b085a46b91b801d54998d90d03ee37f76f6ed17fe268c93b4dbc496e3d6a1a7a877a5530e9ab1b886216a3dd359a6f54c7fc1aa8f6ce17b20be25cae8c567ea1c3c7eb420b7a41149b5071b0ba2e0d4e89bf3ef1421a952b461b528eb600bec28304cf94cf96d925a50cca13a8cb4296ca54b75fd3bbef46b1835fb53e77d69ba987211264ae75983174caa9ed496ad572175b70b6bfd48d3e84f77c4f8b823090541f7b2f5e5fc264ffbd44a4d7c35a756bca1a9999dcc1d1c50bd3c5c89028506eb306b8bc63d80d13ac0126240ddb783bbbdfc9d86ed73e5fc60842b57a058aa590e63d121f85b73da87a78865f7225d803d1ce07e26e601f8ca936bcaba1aa82d54dd85293212306281bacecb0075cf2488f60314fe9c14664d8802c386debe2bcb2a822407578091f63c232850c5be9f74b47eec19e6ebc6df33a6d50747e473e5cd9582b5d8df53376da830c12db8596f8e4c64b7b7456f9b670e25543c46449898a6f18a7f5c8b4d6beec301bad3ca78a7b875272a240c2be15353812650213f0704c76ef46603fa1c83560d5e73638691d740f0741838140bc10f89b61fe17778c64d277263094259da71f02634e9a5da695f9196f7a60646ec64506172e7aa3c2dfffd609ec194f0ac8c0678faff96745bb5abe8fa8024103836a592cbc265a93d8f882759e314db6265e982a1e65543a9d5146ae21c8847c42b4ed2231f8194b6aec69aa37e5d1a9bf7c36794cbf63f8ed55a39834c6870767f84c7ec61366a7105130682edc9b8bfe7e0ff602551e8c915436793c6ab1e395c64ce3793677e7fc31bcca38e69d69d07905c7965f440cde0e18781ea2502a3bc39a5fda9d454a46ba0770dbc11a83eed5116246a028653837ad31d411b3def7c2a08a2be5b2fc1374f751ec5d1ce47a2ca9059b38fe528670e134cee4d01a98731be255324f60aebfa5b1f4f4618545ab9b761a007cf5af04ba1a1dc302d35dbc286f6a67091d8b37633a4a6e9a64a5ee77dc082c84f1008907d5ccafcf2a5fdd8ac5dff69b77c30ad90a674c00492ff5b2afd1d4eea5c1573cd3a6bfdb1149fdb10ce19aee14d675e82ef44ab85ae66dc7a1279f14a8345fa9dcc0b033f3a13096e6935e4d67b98e8e80e7111abc4b6315568b8700c0349005eb2f484eead386db53714c765d119af40817605024b6a671ba4942ec7dd78aa8c2430284104a3e2cfe4a8522356e94a45c41d5bc8f6c78e7f33d2ba1a398aab246679e0c5d2ebdae82e135704544f472c90d8f30be64865f005392ce5b8530d93787070a65e183d9d711b386e32d96b86a80721376916dc49734dacce82fcaa8a06b6ffd39c7b65d7591487e08dba57705ccda2d462bb5969522b36b17e22f29607a763e4a8f95882bb9a7fdea6a935c0051dfd5b5f262929850fdfc6c4c09a61f736077694c3d47499d9b59bf8d5418408596b1b072dcc4453395316346dce3abf19d420767f523be4355e0279a0a72b5d228435c6af0f8daa15798e338bfaf37d1a5ab5efc1b23444cd697137e9acb973d1adb3443406d8982f96513bbf549714f1a1a71119a52c014ca34f1077aa860a4e3463e7c2577239f82fc73b68ed7db6f47338dea802ab93cc59f3fd4d6e425267d0899818845d2fbbaa9970d0f5dc2552c36ea73c509d947eaa3be3d20a22c2dee6ac52eb7b3bbc0034d60cadee9e087c678fcb77e13be4bea6067179b269439e7ab0d1f91b3a316921e755a0418457401989b3fcd507cb3355be933b581c2dceaef110ce26ac60add357132e6653030ba1cedf903645ed6ffebdb8d53d6b8f7745e8a46659bb90277b25d233bf9870ec2eeaa8141c72288c3770893564348b2257946954210ad42576e6213d74af99ebe1fb8d5411f07376a7affdda593b35571fba60e959d714d3096a569d981db52d3215106cc3b47111dadda1f386c30360e96a313167787529a2dfbb6136b89bafe73b625d296472beae857a3f1b4b999b8eb4389bdd4848445d51c79ed64117345488106420ea9cf5a89a3409efe3c597b1fab42452c4893aae995974afc784613a768c1d88af659d4baebfbb7ce3b85c930562381e5aed13e9aed63799c0296dadd674a3eb33622dc1795ea9e28b8556776c865f311428a3c08bc0360a489c67da7cd8c270c9418f84d186c85e035ac99c31a16efb4aaa538073c1d1597a2f5ad13b2defe0f49fe39ba41d3d0ff0128261e528e8b2ad9750643a49b854fe57ec0cd543ded781b650c8818ebb4649d94398566ba265d83935cfe7de5422606e8ea8856929dc2cabe5d6b19ccbccc3561e3a7ce14215dd2a8eeab7bbc310ff1c12451f071e1019d6aaba513d86d4685cbeaa627a03bc12787dec27a2dfd95c9e153489149dafb93f0f754c5a9eeaba61c9939eb1aac4b65182bbffbd3257d473005ff86069f1e2223aafce7c21653cfaa7d88193c2b8e785764d58e49cee84a6b648a5d71bec6bdd308a04947ca30082fa99007beec3b9df632862ecdc8e1a94911a0dfc7acd95ff123eb20f718987f07aff31b3c00ce26b0ef27a5c443f637905f5d3b80af1ed312db3d569b80140e0e69b5fc9ee70c5baa9327e7a4644ad76d14ffc9b0bd9f9cce084c12319fe6eb611d33acb9d3cf04419ef1f0a70c32ea1471f1675bb790b4a9de8e70291b5a20bb1b4a71d2f8fe3fc55423de8de7ff601a7f35c752e7ff3e3f76752b55ab8171c53ec113f79db413e413dfa4b8e64ce35f0d0fbe7c79fecdf0a6675d8189574c826a7cf09ed4ed5d76a573e83796c497ac3545721e200aef24bd70effdda53f351f7133942df27f44ba0ac3b4d342d0b5d74355a6f051f904a8bf6e20e62981b1443f554d0a140ef167c1f92f39207880630b31bbcd0f1a101b1ac14f6a8add4665466cd0ad109036dfadb459dec52d1ef70e0fafae09520ec660da1231fa7b8235889422b5ebbe61b28bb2a353b277ec2f78070a3537151db5a84547e58ba47b1a07e48a6abf37dc04c3ebc40429b90777bf7b3e548a9ce475961a334291793cbd43b4deaf0dc9f0789a1b35cfff7163dbddc7ea7ea0dcb1827591672d3d6a1718b41892848c4abdd6aed47eb135e4210cd8c847af45f931d45b08f26464e17f2944711301a86d341c6a0db09f12de0d56bfdb80202e1b21a9ba5c91f7fca5c9fab072f76b9a6011d2273ca8461fb6f5b2ce7123849de6c1440ae267a3c0bb753997d923a6470b07c94d6e7ee761a55d13ee16be64e92fcdb42e78f768b20d8cb02294e088f4840c20d252a8dd65dda918108359c03f29752b4f9ee427b0104ffaa439852413909549c372e21d0710a542aa47f3609207f7ea62eba595465e9d889bdefc05d09ed5f5fae362086f231659fc28431c6dacffa388b1635aaed015d90c9c2c4543e2f5eaded00590c4274aa089d8dd9a529ea2eef479a643449b3a466758c27f00140fd662d89d6e6d3c07c17885e10982f92e34d84c803e639fe67f488716b05b32d9418c29e984509333fa364d8c271f21e5a2d7c4169c6f89f2856818cdbb269561f12f41c31f8f69f64c2c5907e39f0b761c732859253e2a70a5d8e6da564d5896e19d6f0e68c12a3d1ac830ad43ea3bc2d4fe5c2604f377ab52cc698043d7ed0f0b7e8bfba88eccc25721f419e02d439c19bab3aacb59c21bbb17dec1c8c473cf82634c1eff9021396eac5253eaba5fccb6839bb09aef4b50f2057fa9e5b274500af0260dcf6152bcab5b2021fc6fc127f517039f7eb9a00f53429b7f40b255416899a2a73b08c6e45df43c397b968a6e4dcf4d02776eb13ea6efb1e7d3d314a6e5bd9e631ccd7f5bb5490c39347d9a4866e5f5cef9c605caf348ca508750860d051b6e188598c71f8376c9308864a89db8ed65bd18a86c507710b67c82ab04cb437279af44826cb380b8435a73701775096e821a8db6800985d39da5db4d9d73e538ead592848c71309fd1745cf9f023ce60bcc34e1439de38dfdc5e3d5f0366c8cce2f685f297bf741f2c3dbb0673b23d4837b22e1cfb726c39d93096f9c3c8ebb395f2eeca686e0c2d175cb350febbf549747560ebf55bf03ef6fe372a2aef88087819778780822b8c25b396ec8df09ed406a18cb30324cb1e87c5bc0ae776ba56ec35a7496b1f91f4fa8a7d2a0c71b9c2261349be2e8f77fccb2fbd14ad6894ee9d94f00b0a5c5ed2cabcf17cfd0d0d78ec9b528cf6213b6df75dc2bcbfa21b886adc79d0b4d113c9cef915bc4ca6abbaa104b8f1b213f9ffb8a6b3aecec313a8eec72f463215c0bbc441aaa1d8475f805ef1b721cc14559f9a9c3c09c6ef2149a6bae49cc9b64fb3fd192b812f7f8dd7062770bf603cab20225519baaf88113bba827490a3b60d623ab87a134529aaf0b187c51384fabbb6517a4b1d99bc0d484b83cd96bb4bb43807454830fb846a251c6696a0c5428b330396b6be17d23f93b429e56397d7fd517eb3b6b3897eaf025b0ab727841ebb92f9ac86500a6d907db5b8d66bfadbf8671346926537330aec2f55593e70a73df1da826332e32ee5c915a5a3ca3f402d39cae985838a4b331965194e4dc4ea077c843d031951f35aa6a446d1e0feb34748c43988d1301c5e0f29b467d88484581ddf31223219f7c61194792f2fcf231a4db789cd8f9bbbd15189dad853f85b22e639bd8ca16607ee4a1a3589acf15a9652b565d1daaa82aa8d7594c02fca84d8bc9bbe15631d5b0b019655c725e2797d15cf84b63c851448c2a02d5b81d7eb5e4695390ca9b33e3e4b4915b42540ec97dd444de960eec9d321106a61510828c7a43f0b9d6af2fce1282a3f8f6a8ab70d097ec6a9da56175589b0e6c327dd8a1532a5b7d2417f12f2b3defb783ffe072f5e01038c716ab169238126960b5f98d0e96fcadfef26147ca3652528b23fd9dd4e6f5a7244ec6385184133fbe38016bcf54270ec856191368d1549865140cc3d0811720f2f7d1f8a86844ed5378128b77138a2943a740e331567aac2c70cab5897a770cabcec480d677f73a0f3401d7a9f1286d61a64ff3dc919cb7bd855d6498c25ff8f8cdac0fd676ad58b37ffe60ba5a796656c57911c5658c803e611c41cb3bf498790d328af0888f963dac9b474d4ec52147519e4ad6e1598c8a4b526d0cbd38e718f9a025f8c812f8afaefe27c9e3e36c696e6d32a9dbf913789c6408693a54b498a5fdbcea4efe5b79056d5d52e09c13590491b4365ec68f79bcd8db9ffa81ded22cf18f09525e3845795ef172bf9e4509adaa01ddfbf7d997118f9bca60fd3786e9c89ec050d87fa09d7a9c37186eee473f68e0d66c558662bb1fac4f4707d1493a1861bebe0b2f1608fa9f8e6469b49e97c6b94657cd1e4c37ae10adebdef11c9104b0d793f588dde304dd236fad2650aa4e9961f877c1a8d636368ada6e39f085093ba2c9df0dc3fefadb0ac2b5ac242b52f50754f41b4a5f03dec8d93a344e9a33f1057a5c61993b86c1e328d6293e9f30fde5ecec12e30c80b193f256c588f0895bc10764a4e219c37f00d55f9929c81ecd473525d87f2a52e0f476e180d52e51098af9b274d1127808cc8ba34b4dc8d7b36ebe7559fe3b98836cf0c0a21f987db8b8290de41a3a6a3a9ad6e67ae206ab9e0bfd240996e48b48386ac6f72d7159262af886ceb39ceff9b81ea50470a2c74627feb748c2a48c75d629553989d47b54441e1e997c02422debf49ef1e0898b3efad94c8b70bcbd942d6149b0109a68f9b64ae1844384ae935628e8d7473f3d35a8a883a25d7c4a120bd4e5aef2bdefd70dfddc3a61a02249db935f6ba8e6332f889be24d386c2fb9dc2d1f9b7ce11e7518cbba70132a871e4f6fdcc4c2175b25d566a6f2f8cc47c178de0a62fb38680a0fc9fd16ac6c6112764be96a3adba85a8cc4d0beef1e400a0f277184f72aab567421f575f69d7e0331c8c7b265ac339aad273734c880514f02aac5d17d38195586c81720a673e9c80723bd3ad7a25b43bb4d6e96c098739ffb1413869513732815630d025c13f7a18f5ffc33fdb428e07d181338ce8f3d5630c27e893ac9c1251dc750e1cb893bc2876a1829226bcd40d548100032d10bcf482508642271c06560eca1234b0526dc0a105d3fc950b38793815b368ab8fe6d923d5a2c74c05d9e5495b4d0433a10b7f1a9b71c3cab28f95eb426ba219c83927b0c164f88aff37f21f2bb21527a28bb51077fd681fbbb48dec41b19879449a1a10b04c76739688d154f1c53121a6dafcd9dd6dea14df48eb6cfa5e98ff0823ea985a47ab5e99aa9e82b5468b7ad4262da243894e0915171eeefc8214bbe29b08cac090117658c906fe01990f4c692f76ba99b8fae3766526141dae053b080c56439f2bbf4e25731b7bf5258a194029fe1fbe6c859ffb425004304ccd5c88272ac3347b31564cbcb46186647b57052cb2162000c42a1a2276b639b5febb35058f80257638b37f6df4a56fd2b2863d71f54123578811e19048959ea359ceac4f1a8c373d437bfd3cf4ae17518bc5ebbe0c4806cda5d155489a49f1b857b7f824095d4efe14d7dd609ae749702e05d5c281f99807a0dcc512a5e60ea39e575a5fbae6eae39298fce2de49484e7f7b3e50da9ca4149c05df62a5f3cd5785a8345668b9d987bec45f84c09073d491b69886fcd22acff884e0e20c1723f33e21f2b0adc7e15a218432ccd870d6eaff508fbf648c0c8f4bbdcec557998b74099ddd5c2cdf12007513c19e3d98c22a157bf356c1cc0af08d2ccc2f32a18bf45821afa0ba8b334481e0cec8153bdba6c94736bb63ff36ef6778a978757b0aa1c2c0981ac2baba5c591155ebe1818f6ce05e7639e09b1cd11cab8c842d270e26630a94b152f82a6690d0c467e2b5b4a3afa918455750f394b04b3900558964c721c108a5be7476d8e06149ebc12483e89b30ac13153772903c7376e5f1afaefbcaa9d5ba59d624b370f8a693d828bb586840021c09d8f4c45ca39f1c3c46525e35422e63736707b01c7deec6f3ef2680ea53efe404016f35045df8e1e2e29e10c5186326421736482c7d9fc1f22fdc805225ca0eee6b02a4cf180c00d251eaaf93492ed057f8fc5d40bd9646c6e4337887deb658e279fb2d83d1edd1ce41f8202d43bcaa1ca515316901539d815141796b6807ff6049cc81785cbb9d0036d0194af2ff5cc45779d8ea1e6bd11427e149e8011e5e262167ab773d00cebf116aec36e9e40869701f68b83a0992e42a0f3336b2e86f476a3843ac15a2439060cf068fb24f84741743966f12bc3e52cf09c9c73f5d7f901bf99a72daec15e847196c1f3786f56613b95fb294a0a99dad5691d29597e8f97f809157a70c01319a88e416f2b7924cf63f6ffccc0ee0be7d269d786b30fb482f491acd4a125928d33a45111dfa3238726b2ed4d7a4abe9643e4f9b2fa9df715552393d59414c5de59ecf7c6dc147fd72780216219e83d2a68b54d8808599f459c86a7773a17697fbb615acb22d19858182f180672a97be97ecffc7673c7a7101606c6d3f7b1d15728867ba44fc7b08a86289a62657f98a39106e375bb28296264561b9e09c555c09a02b4056120dde7f50920c6180d227bd89dec4c628c8e899a45600c9a24cc35e47c1fdd41f2d00f195302690207fc39725ebae42ef751827b763a50be07c84272493ef2e8ebe1f469c026ce09b94a80c278c8c0aaae80ef4bf4d6a9bf4b2445c66a783e2f3832e96b1a7a8ee1596e93541dfd5cb96783a8c5181b48033e24ecaa691dc409fca01b8504e88727c6eda7699437255bc497ede9c94d5f74baee46c9bfd9222a1029cbd83947e4debcbef1f4b794126571ef6b74f02f2169e6f052436c0447782c60dc872990b86fefda8ad2afb82b66a456b0113e7a630933e47bacd1662f027afd775635a9a44cdd2feef4b3e62ff762bb78aed0ae9c54673144126e4450bf1d4ae0b7e7e40bf68e820057689e25e5fa74141d0b9b3d1ba55eeb67bd5d20d86db23b983f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
