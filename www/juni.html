<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f39a338f9cf54036b04bbcd358c2c24a9dc4d7bbec4a35ee12cdb89eac12e74103c9557aae982c1bd285cfb2b9dd891d08aa45d05e50ef6408e8fd7685fe4f2fb47cd2e50c9386cdf5532c4e0746bb9d9bdf3cf3ad906d8f237d22a00a6298ca91eb113db802c62ec551785a45be6766784da3d634494690b068d4cc38447fe2f915113901084b897e3d1b8d199b106b2388d129affa41e55a65dff257844ffc3ffe347852932a8e7a7476209a74115c11c52d8542a53eb88ad7fa4e6dafc65018ebb0deb72def1cb12bff91e3b25afcbb08eb91a692d97bb8d5af626a84eff42d466246e85be6ae1451d8807a4f52d265e197f34440a6eefea54c54bd82cfe1fb7686b0deeba92d474d51e00bb7d75591fc8e5ee5f8bb28d3f7ab9890e4a6cad9a98766987572bfee720232fac07b57c3712a0d5e789d31041249440f8b4a49efba10fc368dd611b8ecc20c62853d29fd855de85fc44050a5300be42ff2d511b0ede9b22f322b8a89607c42e027c4f65b8ddd49f6f1a1f2fb20c26cf4d53b7148ef9e501279c350f42af62b573c503d6125f968f521601d23a694792f966af0ded0dec32d167f98e459887f15ba9c275f63c79cf21f9c68df436b91323beec44be60e90ee9c74f466cf7485c8a5f5cb9a7eb93e0369224089c24c012843c7235b4633a43941732072a105d1a222d2ec3fffbe7c21d0d1e29d3ae907e741fcfc90155af1a1d93cbeceb7300b2291996cbeff5fd1b6981cf03e3d6c507a14798dfda1724b8a08ac5d1ab29b74446cf288f9a92e47c712c16a13ae9e72b5fce76938d72368bb6f8c387d320dbcc96894feb65711256eb2787733ad643698a5590f727c25d502f725946c9d5d6b066b9f79c4a4f4a76fa829964e4f2736f10e7b9538f712110d3adb42e53dc0b07f2334c50721749a0bd007327675c09c32c519bbf602c963cb283ef301908bb18e65eb10aea447a9047416d80c737208dd607a8402413f6426f6cdf1c525b90b7ad39e923620b28857b19d90160298e334f6220d550896347eb013b6dfdb6df806d2298bd63a2c22658939b153922de3a0388bbb50eccfd9015641f9b68f7eb8ac8dfc23c60b7a5947e1f27afa5ec69b65b08a73dfe561c793239637a856517b15b8c3cd56f2e4f054ac611e6339be647e93011fdf23db10584023d7ba4ccc446d40fb8f2dda83d33ebc93e5e838534b636dba45efc3abd7593361f02f5bca8fa10e5a7843a110096b910f8a6c5fd13da07d5af1bf91ed1e309f8d7116b607fff9d7ba7e4e8cdf2b5f218ac57d8772401b3900b396be6dc8d0ebf50f3507d5d24d72a8f90eed372be5fb802c7e4ae03cf318d6842626d2e08403940cd17567ca7a63f73f2037e5acbb4e6bd368488373fcca11d35af76bc1916545b877741176e7053929c6cf236fb58f1f832df4f484ef0c3a9d08324362677a35a3d20560501b0d03cdc91b23368684fb00c514c29c5e579b8ae24c06a6f6c64f28d06db44bc2f1a78276c86a9c7b4d268e1ff9798cfb9ecb9bc30093f1d739d471aa3d3b091100585f81af1860e44a8e0400dcd2bec966b7f36e9aa9bdcc468d6d1ad3cf755258735bb9dabffc23b967969053062bc5cdd8efcb88085f2292b0e5f2c2c57cc21dbd3ca7affa3127976fc994fde2216fd668186cfd1af81f1803a8c285a675f1655f85405452c05a1aa350c217b1579d821f34a34c4cf26416918f7a468965b2be6e5a831f80a8acba1110088bcddeb103dc65ab38fbe1f1819f7d6a8dfc4a1280430df54ff76f94cffbbcb65128cc9b71aca0b5f3d92bd48dd514313e9b977b62b2037c21ec2cf8f82a03bf740df00338a7f356b0ad6454457ce5bb8de7dd73a042dbd0310d18c7c54bf7b8523146113318c8edf382fbe7c3902ddcdd524c3df5e30f804743de648e118e2a6e0f769219fca3d2428a6efd21baa3c43cb161cec9a24f578e26f22f787702a871f941f2a0b5db36cf59463d59b664ee8a2694587b82973d4488463f40c0dba6aec5f9a08da371aa738e449d76f38d3a9654690e42a46f43043c33122e57a652e21f7687f532f930c60eeece0719ffdbd1ad92ccb9a70af1d7d0af0d1340f944e85a7ea32e457af23ca179d4914d84f3a448b68f26563bae16bc4ed21d205cd5d498642f3fa117ea6eef1a5aa92a13781a28cff4c83f52cc3d3f416b9b978be1c354cd012d246a63bdc2e715ed75695c0478b484d0ea6c618d44a1adbabcbb597352ef28bd65d2ea55915f1984f64913416646b03e4b354faa8b89bd0491b11afa6bc17a6799bee8d2c27b255062f52c5cfcb01ec2d143361a4d1ae766594fb7a9a21fc1ada2525d36dc88deda207fec05ebb7b44c663cd5cdfb8de1c6d6ec625d59ec346a869f29feceb8df62b06f24fa2adc77c85b04b5d0328f16727d0cb3591268c31c4f7954616c9761d33c2926d713c1e347172f41141430d01e1456e70213af329d55d4390e7af2419ef29425491d3c9c2c982a15bf8273d5310e6557be8f73bbb6e69e0675060b596ab42e6e91768452ad678bdcb32b75c4502a6be5b5f6fca8d52b919c9295d5d5f5fcc2d2e1f4f6d76760165a1dafdb6948ff3d3cbf67729ef5c87802a60fcd412688be6f8fa1b3b5a195c2e79037c73e2f5d5d5ed8997554251efa9dd800f80ebd4c1313c691deeceee11a1f7890524e5c3f93bef522682ab54d5108dff2549bdc743e70609d1e379ae3d1a7400fd1b3f058ecaec63feb895b34b86ab5e9871526e023622cc987ad1c183c4a7a7a5aeaea787310de01c438324bc72e92bcbb68cbff50a07bbc6dfbcfcc5804a5720fe00f233bf1e2e22d75b6f2e35e5661fcb69fedb0380756fc6351a008dcf3ee692b47575dc5ab285fc0329b8d022f67c4049c43bbff5d921b94fd87c1d32ce3137201af581744d47a60298fb46a875af9c7a65103d5e6eade7dccca9b178f17099f850609c542ce9a9ed7644496feabb799d9c1394def007efead1606c17a0d6c2b23d39f6ab0352027571d1508cd5c518b68ca572275cf8dcabddb364f47a978fdec4efe3be73a869b69901d34b62fd1db81fe01965729b13d8882e9e04e5b2418fe6ff620e975f0340501e4d1e660fea55953bdabd101c87ed7ef609c138f2ea9861e8b4a96368b4236e9c3ab9b16ef419f53cab12c227d99deb5ba33c63be282d70ea6113a91a2bc29823c63acdfa88ad5ead5869254858ea9c928d13c8003a9b7993f7c82714bafa05afc54fd60fc4a56187e804384eae3212e23d93c85e350b0b21fe63f33b59ee0acba2b2ace48680a1b5ca52389bb4563fda4ee90e43e50b6861673d8e9695aaff3eb2a5fd6964dff02832e6c109c09ad20914e0787e5611432354d27ecf5ec0e4c89f203203d46fc9a29429641f167a3c4e57a2de7db003bd3d83d8aba9d6ce8d546a41662644bf530faeec79dc6ac2fe5268fdb695100105bf7507c39fd1318b9fc6e2a6e4c9065814231c422ae84d72258e621f1abc93ac3df54e8faa00604dbfe509e30cdd31b640f47993ff11b08d52416a9e63afc1e5f61d4877614d32dd39b2c9f8c9f54c76a1248ff7474043babce82dda6ef1cca10f10dd6f4b8072fff32b65267e8df75f1c22430b8e3ddabb6caf1bfaa5b347de44c71385743abfe383a0c80fbdec5c1a2eaa44e2fe56b9c7af11247f668e0eaa291d1836a9bca056607ebc0878b0604b37d5bb440d70c6b930d8ea3000087b352bac603453046c9a68ca7fad4015ac2e76a822ee6ccebd610387c936c7968c100feee9f52cbfec2343c6f2dc7f62df745adbc66a13a9076db453fb32747127baed10cfc3c28522ab8287cebec432a1db54059b44790036876781bcbd83803516532352b21edaf25cffe9c99946ca75928d9dd96444740205a1e14d158fd0a0339d58437ef0d5314100d6e2b9607c0cba9f1a559baf7385d30e8f7f1512b0fa7fd0e6d447d963383382277c757d30c919adca087598ecc19d33ec75b5f99651df4d2b3cbd901f1072167ff34641d8078ea0d14fc146c7bc85dd6bec94879383dfc2caf211fe01840cb09dbf6c87369cd7433a66786ae528503a31c49fbbfe1c4c0d48a5db57a40981286474e1e39e6f038f9c5d7453cd9789eb57692698e7bf1d12477b27eec583f2efe974121a58502ca5f439e707826902ffb5a166c552cbb5a8236421d2c623da61937c2a366c393c0c1a66805278e2e42490aca83acb83a4c4c297b5a6a21111b35c59bf3220130dc933aa1262a2e5d842f69f42f7f6f49e2808eb65d67eee79a27da1371123c2c3bf9183c3c6433e5423a56bd29ae521c2c0ba15813c5a82c4fe2c090e7c0abf9d4c4ae3d3587bff02593eced512f7b0334ab2501c70eacdc7392a902f7de6f2297f4175261520d51ae18b623243b6dfa7ad3cc65ac44ccf9b232bdd304f038a3ee5e297e16b2b4bedcb866528f885d5f13424bc6d559e74b701a9e23d5891496e8c100c537fcd7593712638425aefe9311a930475fae438265328bd5a942194a60ef39b3c4a832e51858378ad79a1820e09d15001586adbd6d066b05d3f183105da6e3f7fe3d64a5de4cdde5b5cc9fda7ace965103efb9ecd50e692b48ceeb9eeb6c56c41992320ddb477bb105299c327ff5321baf4c83932deb85386438afb24f1701faff1228006288f135bf9b13adb8d7b0b8f5231e0d1980935867a6dd2791c722a8e5f7c5b9de0ae3453c119456362db5efab5f28fab39f9cf244750cbab2451b6457c14a5b1923ff700510d5b105320c7fa96097115056fb8c07742ed5f7b5b0c0fc1789086d5ee9e86e6cfdb66095cdfa70b6061670f5b0331b84769612466e9140979a388fab5c2006e5b7f39bf56f5b1ccc97d847b1ab2eaecd5cee4e70569404501a1b01bdc32ef681db6b5795831dcc1e00757f423cb8b9a8f269dba2e6924bcad7b6d66d22301080edd0ec97f986bcf79614ec52d9114708c3ea2252fba4903e07ca8c2612525d2f91995453be911b1166e951d2dba5d864464b248050e5c4fa88080518f916d172853e40b455410fdc58cc28a53f01944361d2f54c783d922ed7a8da270a5ac7d5ff86e2481803541b4b4ca65069047ae746034f08fa9c2d0fb9907de1a966819e97129305abb3ff15632983b319d828d8d7a644588b4a3ead02a93511c271356d9184b96b1b3a52ef56bf31d44022a3d6689f743591b5a66e3b1f070d3445849ab83f4ecbed359c233f153ce00d2c0f57e30e81a29a04712d8749cc26cf6e0482f81029405ba9c1919b54dc60e4ca7eceb651518d20f851f2ede1dbcb8684c572be336d83038775bb58fe079cd501aa294451ea49b7d0b85b5b86f5ab866a12d8faccc7d92191ef2439b430b7c80881ecff919552deaea173a543788d3b9710e952e46c5ee93eb7418cbecc5d39d9c86e9a0a5641aad8802c7d64253189fc7d329fbeb9fee01b2f2c1fa953607087c42660e2782263a7de25a1becf34f128ca543804442916c9b73361380ccc106d82cd8df95ab30feab19bd93633bc2daf06020a7cbd97988e653381c8d0a8875e1d1ae0c404d019bd143ff88460a7d6504e644b6d99642df26c293a0e8139bc4a815d815d75f396c440edf2a1b1b7d742620fd6afadb9fb7fa15d96559c9e0c25a8b877b88614e0ec396f8eed70797cf94f91ce57ddcdfb75d10a25a424dea974218ec8cdaa51e4d722bcba783d4c3ba02ae7447c1c011053522f7706f71a7a6c40103b99844bf7207cb1fd39d3458021bcda245858cd7897a76bd85ba71b235de0396b34ffc45c4964712b7eed9561123f8c1ac558ce7307c054ef01a1461cf200bccdba78280f8dad1f718c0f96449fd80dc4388170fc12d770da3caa0dd58030782ad2b50c3e775b8884e6ab3f67c164e503fc6ac456c7bc82c166f3080bc799368867ed4392a1679550a35b0200d78204003df02363c6a9229e61d6e073578080bb05a1e7b1dcd6c78c52f433593af1389a99b6fab61da3dd427d3c2862bdcd38765a06ace835fa42141a58a09547c1c8be03d4ecd4af184d67b4402c95daee9c073c1f344dcb81bba6ea6ff86cbc8e10a3288968a9e003000d0ff6d1be399b4df26dbf8078c0b0c861ef61ea9883b72327b1e69a7795321c071f38890b69aa5ef7dabc420030776fe45d9a519750340c199b4dc464f188ffb927546b6bc1f9a2a7cd6491c324a6f8755c8e67c7b509622c5e632805bdd6b1c0ef351cf1b5701fe9b13b6c5017ded48fc6763f1b407da9e74e05a63cc48982641c57a484824170f6bca21cf70c47448048502ea1a7e6229d71de7a89764649f8243fd6ad07fe292153833a357fc7b810f4774a1ddc332f3109b3aeeab441f541a04354db4b1d8c9172aaa2e81843ab0e9601bfd41c9dbf3049e221e702d2e93b728a0e0d3cc25290bfda025a3e74aeb1ecf1bcb9666865536fd8d10c64bff4878d3159001bcc440722cbb6d094d8ab8f5c56a5e38bce5649c6257fcb94c5f1da166e7b9e57c3f591e127f7def4e7a05df6ec51abe1f2ed0410e333d541d7c9603a79f13646237840275d73896bc0eee4c0712c2cb06b5f38b47a92152b18259658f0da7aed11745026515892ef1c4149dbf4a2706539592e3bfeac6994d1310d9a456dbe3af3501b315c42d50491d7de426fd29b00d7cf6e731e2d387c1933bab58e51a598523ca130bdac909330748b1954e88c0ff374e94a568d2faea6cb9cbd0bfda6acdb7c922f6cd38e0a948a95e251dd0d222d2b49f984c31ae919d6639eb9a1eef298d421f66afb24e7cba20a0fbb62536a00a4f770249ee84a5628dce1e63d8abf972e1b048ea4b598559e793322e4629c7d75e34506c086b80b33daae1dca0b1b56b34e2f1b640f6026c5356e29c6e4b881898955adf90482909ed922d9f846a377e0b6e84a8c4bbdf42e2ae558a2b9f0d9980cbd1bac569f1f10bb2d7ee60955f2aef60707893b2ea32efd9758e958a8b8ea9e6d31619fab7eb4b9511c0451a5f7382c18debe9b3144e3504955809d28defa885cba37aea8f850624bb08b919ac77e6ea902bc2038e2f5c57071f420bd6103191190ebfc3dcb7129199a34618df473444a78d94855d8dd7ccafc8edb8e132e6938de6e0713851b671e93d654676bed3c9873384786676a6f01bd6ee573c19627cbf10916bd970516e531b706323b26b4f4b0483ef6b8c4b245a08e1cc54711a5b0a991bea235a95e5b232fe69c5cf5f2a530594501c40af987177523bead0e16e974b8344e1b0b83034f33130072a58b69e5121d99dac4141781b4f2bdb9b56f3cb3959fe9b21567304f4ef4a0d7fc1870e6fa58b5a452f580237ac7d64bd29f722d0515cd408a793603f8e489b2826e50da9d60622adacbbd721d90dd057f8dbc0ab325d7dc546c5b54307c7665ce34005422f76bc7730b4a576f259b389a67050487f1672c2d2112ee1089096ed0afeadf40cc9b17083c1fa531d4d3b7a96a996042d5bf8da5964074b45abd1c4a46e6f14ec81255e089bf097fe07bdefd819f255228a353654acc5eb45a07925184790b2db4ad0396b07f7a8e227a79ee2d4a8c5075662af9579b64bb42cc36f2edf6c211ec795090261f0d9388bdc02dbb54bac61f6c066d52ae728fa6022563cc71a819050e62a184cca02dae6df7375f541e9976622d2fb46bbf762dcd1fda8d5acf7d7cba87e3bf26e560201455723f169a4c0cd890a8c9d1bbf9a7c7a661c71834bb9e9f8566482c24859cf3ed0066b8a494c53bdf6abd812979120244db40dcfae865ea7199e0bd67a33b9fefcdc7d95653347a449b51e0eb509ca5dd6b885a4b2df9fec47adcc09aaadd916f371a21b9424a8208e620e83ddb26c1a70014ea7183d48f85b20e75ad840f44cf94d8d65f7362e1ee422e29a42110f3d6d487720fb53478a14855d7f4b0fe3727f1b4a6bb6a3320e2278d586285695cb123298878fef13ea2823bc4537f746bfd6b9c7a477af361507242c3e6d7d15ca9226afba64518aeed31c909e19499d166969c468e38f11331e14758ca82d39a4639f75ebe8fb6de84a32cf3cb5cb700d867223ed29e7afd8d9182c8ee2524eedd05c8be31ba0be7f5a1e6e8d6516dee2d6e1bd628aa44ae6d5c6bb1aabd61e099e0daa56b18060823479bfd672035b49c88043bc2a7d11bd4724b773b75429c0606962869f9eba86cef7acc29b9e70a5035eb959586c40d522165c79a311564409000272e4453257b35e268ff3969b402dc0f356c4c2f358c1989855d6ba18e28cb98ccd4a4daa6d3c0641c19aa7cef2836f57ab842280471db8865859fc46e1af10fdddb408441d1d8479fe686d444897f0daa9fb46675b539e86c36c092f2b4388d3b45351a332a02068c3ca01e02c4f8dfa58667f8fc4630a3cc1ca646ac39cfb7dbc6488431bcb74b6ef4515ea8fb73d9530bf0144ec2d48d8c6a41ba096685dfadd40f0ee363a3e6ae05d4b6e162d4fba4c42995110759701ddbdb1afa69a927c7eaa9349a9d93c417fb246e27064f84aa85c4a56c927aad43022e67e1c6accaeb4869f36f2a621572107de9872b06c5347799b0109d5e3517d7806f5147d75e510277ddfaa0361f1481faa6aec5700d3428799a109b913dea76b1a483b0f9d6828479b84cf36f5c8cfb41e9878c6cb6770b9628b3e1c0ec6bafdcf740f908a203de1f8c2d4fb2f6cfe2406a507eeb28ea4d0a21a9d91c73d21efbf6ffefff5dd8b58a25523a66b5d4a503c74bef592a42426c8ae5b232502b0ea00951375d51e7b8a2fb15aef1d4335c4d665fe0e57bfa5bf028401a6288f339a2c1eea1ac3aebcf1952612bb6a76bc4347320a48486e89503b21fced9e343ac09b62e4138eb296750ff66b7a00e438d7065c90eb2156333e798175e1f2766616ee07a9e9820ce67ccfe617845bb0b12bd7868b4001c1a5008c0dd2f88defe17b0d2063ecbb568210049ce1824f5068209016ab186f01fae742eede8b861fabbe35492b0b16bcbf1ad4f0e08e47d4ae063229243f083d59821a37f415f63f1ef97a49f57e09e80ba8e41c1c9ede2a241c6499f9f6ec83ffa716f311ab0800d48b53de94f0f99da4b9b8b118dc9b9608d3ec3360fb86d2e020ca36e4f49d37f462193b9491dee349a0dc89bd1a84c4210c26dc3cc2ee05c9ac4cc79b5bfe3ecef2109451858c8d726427635e7a98e25397c46330fb94c739007e9403df4fe9457d00caa6134bb06be14c17a1f98c5612245fb5e5a3088c6cc37f66900386752a5beb95324d81c1233686bdeba64c6484dcc2243e99ff75675bf653557c622c2c56f13aca5456f4ab0efbe386706a4cc2b00d43c4a70b724a0193da013c56b36beabcd9efe3eb533e3f9b8fa9e80e23bc1ef670bbce7fcef67bb42785dde4c083a3b237e02e7a388e79359c2f9b2a5e14bbc75e935367bc64248688b76dbd19aa53dff15026cfd891494512d8fa7a6fae43485890df3ccc00e930c7ccd09a710fdb862d5d500a276dfc050c1adf2c8cfd7bace1edbc9a2e7a35935f18b1f674dbab9bf95a8fc6c54512f3633e63aeac6294b27cd094239aab70a2bcf5457da8fa142e355d377ea270f2051c5a0e9e8b3614a1d06810c6f7b3b536a65fb6e1a32cf8d5bc38f8e7541753353f823b25d80187e0b7f64f30c9fc1eae2ff8284692b50e00d46112510ef5850252b53ccf0c0efa87dc658be54fda8b522139157524842a826ca5b9874a5eebff167ab0b688ff6b6ba96916fdf88b3174f92051cab75c66db2d54dc7704c2cf5168a2b0afdb871cfef1a750459ce59c7beee25e71a8a4c641e5385e7743290b96e52d3ec091d60814a9f711d3043a13c7c67219f8be3b376da19f35f8b72de6f71533a1d980a1354ed766a379207d2251f83e4558e1c2315aeb0bba73ca64212c68068b012434fc4881214d38117d54135aa294df7f8b884d5efd393fbfdff0cfc7c5f297f5e80d9510f5d1cd84d2c65cfd5475f16db178b0157504febe3526a7c3302bc7144eaaa0b693c311ca08ed9f24982a9b0f9278cde8c0536ecebc50f0dcb9a02381a84a85a3f64477b19085fc5876032a32a7e33d45241f50511480a0fda4c7c565a5e18e61eeba53e197a0e73b2751f576f4ee5addb58013be4d2ab02d1ff1469af6c9f09de4c9c21fcb66a8341ffceb0f3af67c9455e33d99ec03792338e4c87960b53e882d4f06cf25dd20a42cc8320826b9a707e4e515bed66dae54d0eb761cb40c3c6ddba15bb94fc90d3e514f3fa7e403bd19bdd2e0de8b3dde4f3d4c674d016e97a005ca3694f9a4d8797160e1a0d1ba51003222ef1b4b99cbfbab797d79b0fa2bc0ce17d19fef1d28d5620cfeec76a24b30af1f9c61279644720b367657b2c30c0ed4ad0e63afe08c282f1fc48836e275debc3e6f358e30c4031dc73d3c2d148fdf2db9079e1d0d2714e2ec278e2061fd8c3533eb181e21ef8c5be445866a9d78ec99bb5178c911d0e6edb1a4c482485d7f79872e2f7c24f26324c6d2651c9e51ba2b864eea5ad16313817cf9cbf2b2678b2dfbb6b9b13d6c8305af286335ee139004cbf537e2424318dc8e7389c2d9ce93e2aa43495254dc7dd12b07b75bd0ec287a9574363b463aed293cf8ac25c5a17491294728575123166a59098a75a8eaedba794ee63b9eaed0c8c5a54a9e91d1ed3da978f159d42f37d3b80d8ed2bdb89a9c1f28f2588cb2d19cd050a4b11b06a7771e8ade51ce74025e93ecf644c7cad01677e8c59303a5da9f5d200c10820890227fb91311367ab079b6d7ee0fb3eaa0e45b569c862f808a9eb248c27cfcefc26aa269564377eaa260d0a89098a3c226832ec6a1de3b7c6d990ae4e72c55554ec9737373383b33f05314af2da48523f33cdd71cd00ba432dca156d871fcfb851592567240d455a87de07c1618102811cd7fa4f29789f2dad48da583e3b8914cc247eafdf154ae64a624d0a86536f16fa5519dbf98951a6776721ac80c9aa42cc88639e9dbe1e115c620386bb5458bc992fa165aa0d68d5c7813a6d8ca018a083105e3a71bd01989cc3616302c7d357acaa4fd228e8e82b16d9cc711eb582e42cde3b444c3cceb3282a82dfdd3f4ecc8ce8593ca6c72b9624c01e625af13e6f9445c4d9b0ab87d8babb9ebb3569c9b260631fecf00fc15347f104ccd241f3cd7f5990e8079753fe1782ae9b37e8d1b50144c2ce3e85a8b1918c10116c5b3d5045f7d2603b5f18d06d342cbce5b3fd955841b56f313a906fcbeb8d24ba04cdacb3719e137b267e173db7ef91559014584ab0f5c5b8eef103fafddf469d579cf09b2f61f800e2857c4bb3959d47c37204c20d47427d6e313cbcbd67c81ea09efb4da8d68e194c69b151aa419a6169e24412532618613ea75189d58360f4f0241ac78d3fee816de4356c82be2e6dcfe2d6224dd2db5eac86a3d442d152319d5fa73b86c56b5708b0184fe4417513661f86c934512a59d271ae5a4c226f1b98187311af6b84cbb7e31f75b30b4cf033eb3056d7786c0c4065ab0e421322ba859baf27bb2227fded5073a6507fb088c1414770e0a13f5ff304576c5979966e212a52be9f2c03e95cece235f0ce28cc1d8d84065346f1713423c088dbd90427f46b12ab103e05cd58228c524b9576bbcef340bfd4436fca7137ab194a3180cd6ae19528106c40d0e2630d93e829404d70a14479baeabd4d4d618589b71668ab76f3c1703be35d052ef93853ee4eed37de4296a6b364e83ae5f81f8182a157496cbd6f069df9a83f720b500ae8e1c62ad8d29fb9684b1670c278fdb65f66b7931e2a091e74eab9a08e901297dfb2a43643c9f7776aaf6030f2be30113a7d396311f6b3636ac7f54b2de95228530638078cc2843915f8df822916c96e71c2550485e2855a5653fe513f8f08827b89492713348c982aba8445b3a48d3e8830533a629ca8d285f6b30831150de828087080d91dcc3907e76b06eb2a6b877a9d209c3ddb020edc07e3a337372997b7566b58b9b93674299808d9386737793d9087a0a5577f8bee956122400676e459a24f93e0809358b56a47349ccb8d0134079f69623684d250cf79e6a81317350410fa00bd5dfc2bbefacbbf01b92c70a00c0bee5a097538e549f57c51712a040645257710e8f5bf87bcad54470f20d821b9ff4bb51df2dc45593874b24a845230896728ad34a69dc3d7816f24d271faf28842641c5bc973f0c803fa64f66577f9cd6ca62418d00d32d5b4372c1d69bee621ea1c3c30f6f6efa38c8527b20e46cbe87c466e06a7e44468e01725154f98f27188f5cec6e054f553b46fc3be382f2f9b39e42ae51bdde1a42d2c0ccb8ad68c158b0da489bdc247e5310a1e888da7aacc9efd4c3232c79c52ecca0370fa9d4e91fe97c0dcebe8b2d47a9319ac646e9478da71fba018a9d76e82172dad159a069d08c1364eff75c423e948b21feca05ab47255649d0864192f5a06f1fc35e554e87a5dada3682a28bce910db24087f30f93fd633c46b136ab6f433e36c95c233cc1e72874220e4eda35004c8ab66bd41601ec5bb752e26e361dd960558bf697927be63e9697fffbc41e3e69dfdf8783d4e44ae3d30c97e43e0e428da06c7cd1dbdc49104f4bf035cd8c11af3c1c71cacd584fc8327337e7a8dc642cb0b2ac2d4d55721af2131f48fff85bddf0c93f26fc12369e571426c2fd7822e8fa1d78d53169d804788c41ffff5dbc77af1190e8fd28916167d0a9e8dd8846cec42e151017d0d50c8b1ca8a986403fc8bb4fe21f499caa96c9b91f85ad499729e66bcac4433819bccced88470b2b77639e48615db7425058dc875e7cc5d5c3bd73cb7572bf19705eb2f00401f953563eb8db609cd91078230eb8023bcd61043fbc58b926cb78fbaa175711138a4ccea431bce8344694925ca80148abc15d0ba9b2aa7517e443c54a98dc2861352b16f8d3290d54515177975808848339fddaae1b5556946f8516e8a9ad067cb77e3e49102cafa6da15461a0fb68f8763e6494fc8788541abaae466a495145b7aa68d65045ec566f08d125bce666876252378306b4d0e886f5dd267e4f6a7c0062937d38d06558cb8e944d6278ac49739b98a6af043265184f45c1dea48e4f8a1e1a325a07397392ec85eaff9f05f1c734a290c0bd318b87aed55e6767eeb62a6096d6959984993ea0583ee03b81f25d22a47c185d7b30af04fd20449d61e628360b07cb46a685dbd10cd71d42feaf56e4b5f8aaeb99a69fbf3fa8aedbe7000d2f67891c85e9079af8bdd0599a3851a2defe212c56b674dd7b2d45ace3d82a1f0995ff5b4cf01c79963ff43d6ddeb1181d1f777d25b50e9b7c1de8d5d3ac58dfa2f0336a93ac0158dba2bf1c45d79864819673c25a1923e4c513431aa64e8d0bbf155cecb2b9d0aac58ed11448728c00383981ab7f1e3abbdbb3ee114e0eef60fcb49a4e504cd40d5a4eacadcc5b886f0d5b877af8009bd89c1721b1a038c6736daea3ec10d088df1b53d3d496938b0aba0515ad758550f26fe5fbef5fb2a4d7e6a369c8093d59c6814ec8e4d9b370b3c25861799f54526687d8c889c2c83c39443b0d9d63f807d1c99b177aebfe6159d376e94c031a1d53b74dcab6503428d87bb321baa505d1236982a7d46926029ce0df2e5d151f3347799779a8db55e9f4fb730fcb07f91aa31ca67c95d349d059d5fa3eaab70ea9c3818bc49669edf1394e99a7330cda9df96a07d8fc3e3c6af4e907c8293b82e25e3d1b8149cbae615d79f1b5b0096654b52ae7d7fabaebddd1fd66b7d95a77fb3461de7ce84895c978c6e0de50c043552b71888b36d4b17153024240bff662a619027ccbced5a91b202aed53bb620adcccfb204cf7c3fbbec0b66101ba6f250cb3129edcf7b22319c28d567712faa09f9c906d4b33a91a8cd7d2044a89c81e541d18d01a1703ee91a5f139b470a9eec20fdd0d935a6ed09248eaefd3943d91146514465988c721cd7085064bb467223ff3da76a4451aa092c4e232b50ff67d1fe16022de31cf3086c70ef22d8404534b5d52c5681b8fd438785df214e122d65c3b243b82654cd10e572470e55f2f1b5f29b4bf4532cac50bb4b853a4d7c3ebf8eab66d5da5b4bac08be863d72d4bbcd1b2104762e099dfe8024e1ff944451a62a0d0ad49a94a7ca09fa712a76413c4826e5347ed7a2e27e5a55de231dcb92641f5153cea82c83b6d2e7d5c62d50d4819c466589f19d41583da1317e44d28949c58132f1bd1097479a165d7b03746e0afbc4bd004d69401aaf57afcd31f33fb97dcdfd076d6628a90d4b30e7c4ee59cd67ec56fb8f6c4e677b04aaa38b1e70d89d508fd9ef9ea82ec260aaf4c3557b6a2899c257ff69f8602b3f5a6d84cea52e4102b0b11001f30fb0d108d212e888408e68fa050c579a36364bd6e7361582250bb9b7f7b4bd1f87a2449ff1b133fb53be504515186313292c23b255d11a18446bd77f71feab58badf611b336e35f930b357052478f885f2e409553d6aebb031ecc8bfb780721a457e6403eb7345adfecedaa57e8ec6f358ce464d81cb1fa65c96a81d2549b49c94e09d8c9bf8474a5c217c16cb7a121057b83016edc38d67481d7c5ef922197be53bd1a6a5c2632355c7f43c1bd85c03b465da1b7f2116e122f49f2cccf1a9fffbc23039663c3de3fe9cfb5ee5b2466a8c8e165f62753d5d9ccd53d64884d4e042c0b90e17d7da78106874f2f739ac210d83dd7e689912c12a178725d29dfef5c14d12ee00d30d103fbdc9634d38bdf7976470a44d83c3f411d09e749ce3bc0feef33ac61cca3cedc56310a11b950052b6b2a81faf299cf431cc1d7ebfed0a3fa358a57e2ac0c3735d6ddc63c97cd0bc58370222246f1323d22b671c4a706e22eb869e7abb0162785a9583fd366bc352bd08570ca4260e4fb0206539150c51aa351e4ea520d07e3a0ae133d962ab067d845e5eb9f4adbe2a0619b7f0b09a7c4f2efc17ac2496bc61458bca6f1c6e792341d16dd2247d74f9cf9b4f3b5bf21ec2f45c3f062b1eb75f2c34751b4e268fd515af7e9551efbd222a15e855c8d0ed623d4caaac2b97e5d285109bc2fc357ef37c793d591e3b2a561103ab2a38cbd9d4b88624cd55a483beace33a4822f863972e673c8c57eca0d38581133d8d5325ed23e26924d89eb6a8ca532fee94d9b7d8540e2aedd1374c9f6ea8d0648d4cc5c2b6b8b10f074ac0da8b7d7063b0d780f77dee38192327337d67fe0b9bc864d43dc0ad01f7c3e72c9e49409c204e40b2f0e9002aac5ec669bc60c2303c3eb016dc79166094ae069298c4a11ccc25119a0bc93590a7dc61bf6c3fa3f50184aeed08b16095d14717f456ac4e34a72a9c3297bb7113ab894bc819ad1e8ee228998e983d6ad792cd465bedf7d4c318f94bde08d3498684d2b2343f103b85c8df864bca28d18f3f8ea53b3866cf65a73a3480412265ca088278a8f001aa5d393f9eccca687fe3522139ee01884e73e20e7352e33f694c2880455f727a6b8c8df5da7f055b7c30ef2f91798a00671cde4399d339dfc56caf0b7ad06dfafe846acb8d185eac32f6c17967e9ca9c3373bc4112523c601b5a0ffd5a597d52a695468a9b899ab2ab8ec7931df4f80befde721979774be805be3285e5f721b4fa5c7a8e3d13b9552b4a775c85482570e620ad7115a65a664f327cbfe68407224ee17876b18312dfc3512b5ba08ae4d261aa26dc984a6cfbb80d7549b381eb246597c6028db9fc55f8d115e3965b12f392ff0ffc8385d038420061e732c2281ed0cd55bab2f5d6b24440714163edbc8b89b449b9e565f03a5e5d7cc98abc9d7eebf71ce00f1abf8376c756584ef94ac584e286da29186f65c56bad2a782cf35bffa2684812e301666f670ef506084192ca001cad2580a00b47238e3b29f132894e51e8569d81726c840605544015d2cc5b753ad2c566f46a9533330d32f71a476374e09b6b84f152fa726c8910e9f1c6fd53c624f25cc9392b33e36b2567367dcf4a799711089a190602e0cabbd515d81a973b58f2574a1ab541afa3f5c8abb4d0b89fe1a47d232610754c939e03dc7fab8edd2799ce429761d72311ccf799e204886b902cbc0e607faff17056e1ea2161c5f34310f44f5fa1d0639c4b5982eab8b3b195d7cc42d41ceb540b6b41638ee7849d62c34bddfede8ead471cd0e3fd1a3311bffdc7fcace0aeaf3079129ad679da79886d85f3bbb13f6ffdfecb6f1f06b01c7d40506452a49e1a0944674b697494b7df0d1e6d50a4c308aa6f07f2d72c34ca9d4a562eff519a61aab99c3f93f4423851f7dac1d3988681a8527497d6279d4ad450d44e65c70b6b38c973f0ae317badf35f6f0190c50c433cd711c63b5f88060b61e66927f621d3945f74b67d86ef8460f3de5cd132143dde894a202320dffa8677abdf0b94cc9081ba75b2754af0a0dc864ccb3ad3dae422e221499179777821ad84a12dc17decd1a9df0db196622165845293a5221fd0f34bbba00fc77756f7b8bdbef44e25e7c2e8e109565c0b550f29bf04504121b1b37d154efc63721329e42543f9e0159bdd0009b63e4cf5ed827e700c030231bcaef5c9c967b76f900aa023829516a11a689e2c9de1f041646c0232dca36686fb21e0b1cf7c60b4791ad85183056f6767f3711935a809637c990a45afe80363837a7984fbae2b1e8929547dfb912b071ea9a219233c054a720721f898d276d4606e1cde5cd53e058f3789e5dd17da51ac8f44157922707026defd74274e6d9f1490db102c0f497e0cab34429e70a4d5ea08f0e62d994ea9072fd760b92c5fe12afac057c4b120c85b85cb13a1d9243a3a0de718aa54faacd438842404bede337c933bd759538569c3cc45ae19c1434bc4845500d98f85c3270c58c98e32e15cf44d01cda118ba606c08ba5112b6f00aba2a72a04259172ec4571a8718a25037d41b46e96b6810cc687746072135d3202eb98ea9a063f68d597a2cba12b0a1c4d4d03b3ebcf0880a22e5595be03fa20afe7cd6b77f890bf4ea80117a289e287db8652e9fd459e713cf4e14ffcc96775e7d89bc81faf991c4cb30cadc1afafeead9796e0187c62d7d51a4f65c32c9e7f9d0016456e23c86f5b579698002fe36813254300348ac05425b6b3fab3374eefbbd8f4b9b6a38838192335c029b49958d6b686be9c817223ce0cc522f8437bd04480602b4360c771b6c887d29e96ff5f08807c556baecc976815a254bcbd321c2e67327450341b829080102803f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
