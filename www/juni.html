<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a84bcc133be067686479ed39bc6d49400d662157bb2306cddde396c4adc256e3edcf687a706be823858a16b2cee548937af39343f27db27ee12729007a7b59cafbf24c4a30eebb7f2704acf8a49e7e85e3eb5db7169e88fe38f25ec117e3058b713489fb9736210a8a2fea0b846c71cd3af4f45d6ade54f7f8f55431bc1792b2b8fb4870e8456d7892a2aa10a074f61b90fc149a03b2f881a13f65d2ac77ebe7852b3ff89a93868b1cc668b178136f35caba7bf446cd7fd2aa0d09981a1f9cfe5ac7b6a383e9d1a0c030971bc316e5c12154c3ce3481d173ec84424b1faa506e4468d6fa929da971ae46d37ee2bf94741e9038aa15855dbf7f8bc026015d64779d518789800383c7906f1a1792702865580fed0a93a7e42967cb6cc442bc3820d4a101e1e66bb1473c4889ca136e6c426b16603a9bb03184f097c939f69edc21be7696f0ffc2efb9bb909ccaaf5aa3197e98c88695930acbde7cb96df77b7423a865c187d731b853de0888be481eae86e75986d626c00f8917097c2e9885bf350af86f655b610a67c4860928c3e74ac5980c0afe65807c1869203092f335785f019438aa4ff848ac0cb3a42f31cd37599c74ca3962c5ab36011528cf797645e13f38e059dfbfa049d13b674e0791033c6a37e149d2f57889ab5c827587a8f6abe6de8a0fc0a7a42b68e20c0c05d178017e8f9b34735914701c73e619d2551b393b43f08ed0b55c76b19bf29ca6745057f2a6cda22ad6d027ab02d72d23e85432a93ccf8a7624f0d4b42664f2590fc748bcb7b584212c3db115381e28e2a79341c45d900b19b664bded9db54cf715928602020a0be3473bcdf463f0256b67d67dce7d7ef0693c0220e94ec644b7272255c2620a8017a72eb74963801bfe40015c05360e992a4aa20bc965e44d36de6fabd204d5eb48159e0da90a3a297110c01eef9e1ea59e3a863c2e0004a3f2dbfe0af733dc05c4c4367e2094c221596dc0a1258777082fd2bb53bff59e6682b9d86b108187069f4f507f3c02423a78be0fd6b31eb05ce8c364a46b7530f0ee2ecd9a192001f0a07fb33a740970e1f796a54cabecee6c796f06cc4149c6af2a7cad151d23b957af399578304a2559e97e3f48241024dc31af70de6ddc7ab2f4c8cc355d75814e9647dd89837da529f67c1240bfdb2c9ffdc9bfc339db62d7ea81709e71cebc05450a52dfbf03c52914dec0428e28bc73fd07ceb47f86adf0982c52abe0574268803772a1c096cbc943d48229be9678f86db3fa6a1aedc783b75aad9c7a5e0b663096896cb24ccec303d866cb7be1c8dc21939cf946d6fa2c4f2cba77d8c766e82dd6e31247e6cdac2badaca8ac94c2f147a237bc1d8bd27302b1586a1e81c1f9898ec9623dfeed63b06ee7389243d776593b54c109173469eb9e49bd86e7aa5d2f73db271ed8fa108f5da4d3367d3bba05ac39dae6b2fd10497e3a1794d28a2290c79d94f2737562c98e8bf9bb48830e0d2cc954396e508d644a91c00285f84408eabd8afbf715808e006a261400e53e0b8b575b060a2878f1eba9ee552ddda8c2c3af891ed6f38d30a82c2ee8cc0716a101c5c4be77cb2f73c22955f8cde264305d834e4abc1f2b95d42c3fcc299b8760cf6d9e75bc788be5d421a5b38240c013be8853f2a89317f59e3c225b806359fa6468e0f3f3bfb3d4a9f4dc60fd652973b373e30fc643cb3b4725ad1292920a5dc6c90ae661b21dfe5f5491a71eb6ef3cec95b169bcd30948ed4c84d19f04eee1143b0a2d77eb482936ae675bc83a612144632d94b6ee62917ad4e135d6e8b1f39cecd708ef373a21ab3920923b8314dc69327f1fee194771d09fa412986297aa1c7942b6d334920d55092dc596759ae7601b00688b13f7756bf793e1ea223e64092ab30ef041d5c27b49bc0099c5ed60fa6860d3746ae1ee1ef6672192d6f6d3d3cfe803a2789ac604d90e05581f3f42f7546006f01aba364a106f72175f3c9dae80c6f242e429d95001a6f45d9e505160d3f07c5128f1aff650558eb2bde91bae3ed1eee0bafe62fa82a1cd252140780c39048e7657f30303e8108a6320e2eb960296cc05ee72e3e6593bab489e438712b33f83500b2681bd51e257b133b398f85b45d76cc0fbbc7e44e6754f781ff1b17b47e5a0f5acc308db7a9683aef8e134690430723c0d614743d69e46cefa339fa9cdae64a68e29b0a7c0a4dbe1bc9608332f550dd84e3754209f66c5200d5dc96b2e4582a4dbb5b472296b036d104f45c6e50652381d4cc09f7ef4f05a4f7b1b267c38e68b941392b2216ed3c32717ecbc38ddb290c2b8b4b33e81a2f9c96af3f8ec729bdbd86e67741f5b5ea1e3542442703ed395bc0cb19cb0c009ea6612237ddc8b7ed63aa00b82ce3626d0960df9ef78287783191b0b761ecb3706fa7e957c095a992aa7c00baabce5eba66231062c8e13593a5007991dade72b8a9cfe4540b26c19e5b70aee2690684f2635058449c92af7013ec901379a57746694ec79d6fe18c8bf5f02feed4c32f1b8fb762fc79b543be315ca6ed25383e6c97188208e71ec62a4f08b72e0819662b8d2de789dd257de2d73d3d82407dfee195f6c8ade40d1c5815b2bc592d829665c60a7930ee78970439cbbec4d978b5352bbe6994f67f6600ed22df61c1ddd26b9300b8501659073e9239d18f80bc0255db86a511082d2c80facf399783ebab567ffb8bac074b354fe778832cf6dd3cebb626a7eff6c60836838c09437ad84f52c0c76cf70b8dec64e0555f9a8f7229751a9cb08791b69a34684a3414b6ea59a75c2b7c56a367447bb6c2d751e12146243af0e10f5be3fc60869d2021a8a1481daa7cd440e8ded29b9d5f17470928ee874200582651ec12696082b47a7ea57d7dda8ce50ab19fc7baa25637e4cd6104b235eb74a00f0fa3c9191a3fd7898e1587d02d89b97db7c14d9f63655c198139223286a00ba5e04bcb72a8695e416603ac59ea9bb5b9d499de07e3fb5445192699e75cb20fce8aa90789ae3f4fe70cec91d7ee000cef3e41ae4b02459aad09e19f6d680426481648fdaf6f4291792c2ccdeaae2cea534e16732706cec260d420b0a9e3f27ba17553d3d04be6ec34305b990249f9fa01269f10435d95c2d6a6c4563fa5baae1e89182574f7a4b4a8a9628339cc836a2364d6df754647e0df047ce171e17a2ee4215ca3cd8a9dab0c7b9ba65144fc54ef6931465f0edc795f6633224da26b1c4d6ed4151a731e4da1d5b6b344573d756fc70fa57a1f9d770ac3f424e7c985f4d74257ba2863dd35063b633e002b9fe53ca0dc38b364e94134da176ccdd9979d1caa9397695ef49a4854e7ca9d9f9034dc6229e93d8323b5cfb7afb62060b56e6247137c8cd69b3b43de59e981605ab6bd79afa5b463b2e362875f839a5eea45ee0ac994e8fe64c52085235af045a562882e6239c0cb480b8711d7bde709f2aa66596a91e56a75c78c55096377d8034d8fe5eb4f13154b9166228704679c9fd3b7db234932954da31d37875ddabc8450a18f9dc2810569a6d2c6a3ce03a74c26e0bc0389d98cfe7ec10fcec299de5563d81325732f7e652196b9f2df1e82c686d55ef62c686d1c1700fbf8769f5dd2325a767cb93c3f9c2ab7cffd6358c2aa1027900bb113e13bc8267b9cedd7c6f9a804eebaac28943b15c93f4e844bfacd1e5979ac157a76376f603594a8d51290e9037ebeeaadf00ae1faaf46e7c363ec856f77b867f1d757418ffed31828100f0c7e0a00561dc0f3b091f687922de37efa6c9f66381920a6b86a78a0844518ff7aaf567f0f4442189a7d36eb5fc34d09e83bcfd6527a5ec021aa64fea34fcd36dcbed9307342176f6602e42b8195adbb460d9265e8c9576ee355564e795d0f0a5f94bddb1d7487dec07f01de70f1668fc221ea4c4ac648be079049c6506e534f6bdcbe96cd1c0b687ae8dc338cb519ff48d7141668bfda80a6fe4d8c81f86cfcc9d323946e9410b2f03ba2295fe697af4e0444f6687666a9a6de5c5b84d2ce2b093a289e852e6441d52b4b9531eb83f4e812d5c24ed9abb27951b1c0d49dd524f69fb4db7328545f0f6b8d5f7265afdb0a6befe5a1cdb078f99a87b69ceb3280369db10f3da0a68ddcaa094869c0ce7a1ff04c7376af639b83b3d4da25fe07f6bb4657910de5ded33895159d75f2b7c2c23c26655cbd6add0b18487037bbbadd7e8a082d142d6b93d979d2aada7544577cc60bccc2a2e44958e8dd81ee5e3469e3bdffbf963d8cd1341b0360846b00198301bf891ca541d7a3652732cdf2a76e8e397eac7c90e2ae60db6139584c643c8297abd5bf07f027dc9f6ef3cf3878308483419b0a97c25a0be3b3b5867142caa80438ec0bad8de7d368d052d6836b8891ae3b16f5f2c7cf4866c9134ee32418fb94fc1e0639663d6a11b0887b963be379f0c5114cfcd299ac3ec1f4ca79fd982e0e564fe57b0044bb5e9fcaf236221481c226ae0c7ddfee80d6b348fb127b5b0529ad76c51a3384b4a81677306a277afa7f1347f39e3929546913aaf0833d9a53847445931df50eda67c34cdedd71da4c0bf07a9e45bec26d896e059027788a71757b9a0d97771e79ae825ead608b1adc8d725d9bb47d76a9b9d269300b11a58eda9c0f41c68eacc53efa98953836d095531b4be0f7a1237ce4b1726ae0d1b8fb4e34098400f2f8dbd8338c6f217f59d8fcb822bbba5dc9b76e14200ba1eec92183d70dcb018dc54857617e31540ed333491a80d19fd9d1e084394582cd3b8d76660a04b2c6443a33e4829537b154a640f001c06fb7e7d8f20e4493f2c67f36a0ab29241ae79eb246fad2e2b438c2fece5a3a2e521871f7956611d27c32eb33a6cd4837c74405d7d48eb2a3c6259c1e916c0e7ed429db43d85e307b89d126259486668a0a61fa0422a8f038907fa3bdcca6914f117d2caf6b09bc0976d61956da0dbefb559ee324a9cfe38a2ab8d67582cc011823b0547dd482c7fa114ef50d0a1289111261e949467031de60794875ec00c45e49f8046e0a68aff1a2e3dd0f2ebade1e3ac25757b72eb3b5df53a407dca6923b485c3fb1ee679e07ccbfcfea9a04095cdaf210eb434494e5db24a85924799ed6f75ed5c2a9c5f71a947ecbfa8b6370b545b413a9235788ad4ad378b33d73765135accba12fe1a571d5df60e4dc0930869ec663c0ea4ad2d5d36ecf6ebaefe8ebfd5f614b3a91642fec45e69c16521e491c1ad95248ad18d753f365b73772fa86d2309b2d3b69eec39f3faffa6e25ca43d4b461ece6fc9f7455de5e00b7468a15b6add2a8369b1b7f627eb70b578e3b06574e2a062e592d45b1209b1c27341845501cc3ee7e004481e18b31ba06d6337002e22fec9e24c5ca890befc8bc7923d56f2a687507ae3d0cdea4cf0ddb05caa9de3c02829f8a1e816aff548ccfd91935613376b684ec2b56f850ff1f039fb4f66cdc613b87d99c34ae53a0e60b360010bd2b73ec51299143c852d5d69cd7b4ae46a05e30b445cdf2e66bc715a1b4839bf92e8f837c187784120ca36efab2622e71f11516e3c167284836523f8a5303627d45400e277e317776bcb1e02d53089a9c27e4296521a872dadd4510204b643e671b7ce6d62e274485124abf46772b861d8bcef310d9d16e0799a31c16480b79abffd4d9b24f501f77960ac0f25183f3e10c73992edbe31e5dc0cec08f3cd824428dca88e10c9b1a07e597d7f6f37e788a94c2ecd1393f17efeef786ed3014cc8ea661311aaddc99decaebb071939635f0d996fe426a63b06c625db7908bdbcc0f9936ac887999cd485137c8fdc46359288e195e63431a6ce039116c2cc15709b2f1fb98c5781eb9feb4d1aef2052ae9fc1b24f78de33a220ac1b40d910daaed55b305cbed2ab2b39d24115d3a517ca6f05036144d06468739d8c9fa310f2f31230d778f888482b3a12eb6038261c9e3bcaccb633e5952df14f7ab05e0e3c0d1ab7074a41ee3f851e326805845a3f6310ad6fbe6476daff406e8d6de126636866b4483dde295b09324666bc73d4445094b6db4c2416570656b497097b333bd645112144c6fef7ea23c955819da42f8d8c4ad97b289ff8b266b5dda5ce645b0b4fc2a35bab24377487b9e6dd734beac0a0cef5370cc8dd6cabb241dc149768ea91ca249e3f44c178adaa3d0d7cbe479c8c54a105a4a7c2bd03b43988e4e8c5c1c3b784886cdf141dab5ede74087197f339c244f1f9c89932520b14574315357b80937b62cb85caf718d0ffd9713be028827e68e2a3ce8d5d28bbcaab1a6bf6b8e3c2b874dee96932ca8874931e5dbdb4ba4cc217dde8c7183aef238a8b81e2b3a6531cb307205db1ea91be93d8b83984e660dd81e46412506e3f0025d019e20c29df77eb3bc003827d08d9389f1d37870caa66ef63c41ab85c606527af088112a93df635d27dd4e6da162b2b613df2d183d885e36906f723b2d2ef722d6660bccc0039628f05f5712a44f0790b584ddd4a4040e72d298eb9ce87c62c5e0d67620b5c2b51e6b3029cbc48463e8885cf0597c64ceba9d4b6e43eb731e381b6d4d6c390870d72482971b6ec3d6046bf337c40b408a789ba5a69dc29a16197f33e97cc61228823992a9dc786be747ee4197b42964eb55ed2a291268f0223551ffaaa95013e00c7546924f686bbfe4f6ddf6fd4906277b675e3439141bc8524d185172963337b7f4b1133b1d986d1cd5279eb349abef1773c52e693285b91d79dc6e4766e4765dd581069245b511e30e37eda129aa3c2c45045046867db93d58cbaff69db879b703cd70db8451ac1e8d832d414b067bdf2ad7dc5bb186f612b7c89dc74be746f22da841291072b7828b9fcdb4043a90bb45798e654ca1958835ea2f7eef984f813f10547f265337f01e05e969066a19a2ec4bad295d59f5c5d6fb615569739f227153575eba0a4fedd8151addb6d8e4a7ac51be1be626c3c70e499856e3f04b7038077a41811336cb905002832bed7961ffc579b3b5b90b0200116aa6b9cadd51918621cb7dde267a2f05ef81d0a905a18b1e5cf40547d00b9f427a3d17aafd0df7860d89d4f79a6c1be0aeed3a68a9b7958cf7828c6cca824877bf74f036cec806e51e9b83be05a8a6cec0d756926b2a18e6d0e2045c5aa18c17597dc48a8084ff212bf8c44c2bc922f97cc299e7fbeff5aa5e5de4ce795cee0811881a0eda8003008308fb1d6047137dec69e1acc2b9f0334588691a94a59bd8144c60bc787bc2c617b5f94b73233447890e4e3240ea58b5299939c626811b75d3e323892965203d25eeca22c740e66c7faf96dea5542c0bec72d2232fb813ebb6248e6bdda910d6f89362850f7f6fe52b49303ba5f723a7136d2a4626f7d6d146fc1cd97f5e7d83ce66c8d4c5b545961f9a3239d263129e0d96bc1cdde992cca96bb8b770cfba9586667479a4f09dec3bf86be1420aff45310ffa5b33db17c4e4dc61c26fc2c4811eef20cb4ba0256956a7f05a43d9d2880208bd92e0d664a4538b1259282f3179413e1d4c184acced757512663e0053ef90556a98d8960eae4b92b5413d278f62e2e1d767d7ef89e77f1610778494f2cfc25a7e2118adc3d2f7ff89c00c8e42c63bacb10221d4c9c7931188d98ae09d37bc4eb0bf705925f363af06870d9732ec73767a89ee81787c2bc57066661c6c7231f959cbc7cb820c9b2f665b5043f7a8c42730e25fe38ae002cabc077d5d6dc6328a7c1f2025cc54a4e7fd8f1737be8683808240314a6b22400592e6a7e1db1325efbf171f4e10c835a6a5a2638fdc53222e30a9f81f3a6a767ecaf36702b929fe8198d4e62b392377fe59327121caff6e92464d4f52c2f640f32af19ef00b342bee56e81fc99a79b9c62a7e4782623519d4e0aeaa42565419e0dc9f5c9d8254f2ac4fa00b55554f66e2eaa650d2af06adc431aa10ed466af2210d0420f3f029e1becdf2b3a34a1e624b5af35beb6d2c16011756ec929649a0b2ddac1c6c9e43367747151bfdee0287486a25279871c84e3f75c4da53050e6883d3819c1bd934eb8667e6c538bce0eb74e40ee6e54e88a1e67a3320ccc27c0a6ab8d865e64920f35a7f2321c31eb61e85d5118bde693e42b6c14e50b484391c1dd4019e52b88dcf80c4b7c67b846b6a7e16d279881ef65653f24db3a3d71531ab16f5c4bff437376d871866c9cc628fe4a3972a70b27c8690ee1d560e39eb366f3e04b7055b3224a7121e1a9eddb92ee236b6fe52774d2f50f41913753408f09b86cc27721e57230293ca5076f66ee1be5dd102b25c48175454a92547986967d4d4242f09b6ad493c4dee982a9678c95ab2f34280c49e72d0e0148d5a1e2f79e1d1e72dcdbb220486677406618813fe5c6e63a14535fad72707f5e87c74a9d82739ad444d8d44980d19695ff3f1e44af7be283d476dda2863bd38e84a7c9624aeb386b776f34c897adcb74b48416a6bac9bbcf92d07ac1f2c205c24602e5895a65f13144fc36ee64ca53fffb6c53675c9da069ad32191ded0bd8d1df63c24db45ca4c8eb138a0d97c6cee268fdbe7a77a9cfe0edb5adfd9d01ce47a7e1f67976786851fd997058d9211565eb29626976de212054f988b5d1923480dfe47c1ab185d766911ae2df54350a3cf48560237a010079c79c21ed82863fc5516a2fe07caf84386b5518c41de127012b229563d789bf0d2c237edbed145e8381a790a7d5e6e9eddfa61108ee8765227a6712abbc0da5ed01eb02d6e30c7af0522c2cbc6bf37193cd6c6cf88a725adba54bbadefa0d675567f59545833faa63a7580cf4e3fff0500337a830c13d20c8c2b2bc077e0ec094e385f10b3d32e38baba77eb55d099cf5fcb2cdf6ce0fa754bd38bb02ec9ce124d5565be9306795dce85fd4ba02cae05e03df2dd1be048599d3759cc2d6e4c3f76f6eab3cdc20833b15c0c1a27df1bfb66de2e78b6b7d2632f628322dc814ec7ff538243295103095324f60e7e96dc03717a99c70c1a48fbcff3331ead3602e0ba34d68ff88071928ff5fc0fa69481894c11d665d8aa6a40c1e5e2759cfb1ef03fe3dae55d0881265cf233b99ea19169d24d0d5df17d099f5bc1a03dadc23072489ba42386ab819c42e7173d00c0493b169602585c3a28b96bc2e452bbc447f9bd54e61b1b1cf0b45ba475ca3c7aeae97ca134a013484b9aa00546d1080a138e0eed1881336c5048602e55ae31f04bdd745bccf93ab4ab4b6decb8f6b5c439ff84cd4a7a9b4a8f83d502400207b021d79a3b29fbebc46df8870acde1146e16146641f759856a691661fda5e7a1e15397227485337d2ddebc22c546195725c1ae9ea7e7e4a59ec53d2075b09e04600f99516b86167f4abfabc7f6e778d9aa1a91ec8ea626501526d44788ef5cd15cb21848ac4c9047612f40a87d54b888b512bc55fb0812fef861d6805d5e8c07ff2103fbe6c72840787b137bddb5626feff1ee3599940aafe34f4d08a99738093bc184217c27690098d3dd0516daccc3958167f788e7449241ade89630a9633d8a7f154cdd69dc1ecf519245827797063ecd00430e12d329ea8904915c98eb8f29f7ef5d350b59b52a02bdf327f4ec164ef14bc243b6a04e0911c7a751eb75b5bf08c7616df9c7aa76fbe16418481a8eb5e8067254a5ab13fa0728bd86132f0b8445a46c0900f86033352852a5a29df721b6798ea6132456b712e7342c65925507207e1b3ca0221575eaaeffbbeb9d30db366da3bceafb45b6ebc1aba3d963937e884e5d44f770f1521928b0c370a113f1933b045b9e4aa32121e6f97ef4130f3d57c1cfaaa173a264af8def6ba5de107f6714345b2f70a5cb3b31e60c2f4b110bce00b1c72544dfc06c7abeadfab6d831830ef7bd16dee47c85794f67ef4627dc0fea911f75313c58ecba4a1689f92b70775dbb83eabb0b6d59789e631e2f3f6af7050999cff62787c9de7cc19825ecbda15edc7e7ae41d1e317e9c810cf79eff4098e2f5390d4f0ffd6407fd6bdcb36ed80a7cbb33abf9ffff139183d242ffb86493ce172b629b115c41bfbbc46754c98519c193ccf583edf1791902245d8c3203a1f20938708a5eca9b0415577907e02cf472f12fde2710802fdf0e5c35fa6db0f79bf53770b9a6d7d86f41aaaf4670f58da77ee5125982517f48c8b1534c6867d496dc4aa68eddec76f4dddc986391e827109d2133eb5b6af38f9c4d70a6af77610ccd23da7769c8ee176d11c202cc07321919f99a91dd5a5454d2db03f6b470b0c1e69b35e4699722ed77245e19cf87e35f154aab513ed24691aac253f32205bf6c350bd90c5ec5cc4a31a31451d5b4556f62f228263a3390ff341b515ac324e401f02b8dd42dd83333be7f4d454147f4772556310569c7d86e211eccda9d14d5a9acbb138c54a0b177b9f8049988f5fb397a9fc809bbd8100e8866b6e757e53e7180f26f2151d3b63f2ccefc3960320a7e63d4a1a75774a4ca4199be59fa33c8088b531bc236c956ee128ada8ccbae4792ee8383db8540a334438c4d5dd6bafbb9111a5093e7483d69ac40ceeef8445bf78907aea62a28026f0dde3a59254663ac675a1f4b18607d73d214083eef97ab197235bc11d3c947f91bbc2ba49ff4d223f0b089b4114d6089078b85f68c66f91cab81477f99c2e0e9f1789aa55eb0d50272c232a5ff43a8af70199fdd86c2385bce11150f9e44b40a29779a8ac01f18bf6ec6a56a72bcc39bcc0cf238e7c0aa716c452bb8f2c7f47829f18e86b649faf0ff9c81771c29a3077caf108bbef8ead4b3babb30cbe9ae494952c8974b6d8d0dc32be6df06aaa00e66172702349451f1a1b0e0d6bc6e4682c88f9f5a5e887f15dae213c216e83c13f310532a92c6efce4a98dcedc79a08f22790c1f46faba34012d0ecd41a4e53eec13e95e837cf66c854d72cad34d1fbcfb0476acce806afdd130b5b3aae5c8d2e521036407c3000c057a68b22ff9736e3fafc127d3e86fba00a02d76f3c042b07ed21c1a37fd2ce230ee7bfff9f7d1af3b675d25745898f882c80de5e344fd753ae8163415af2e9d98e334f0408326472e910716cb82ec582b11091d10f866523cfe0aad51a7753002d2e67dc14e958f0646612f486c94578452c027200a3bbd0b02c8429032b4c924b19edf3b547e4938f038ea4fb70c55f3cc81a6d542449e68e5d23dc1af6f7ed91ea5346a6423e2292d6cd4fbbbfc8f8427f10f5f313ace056ee98cd7770c6ffcf34bdb844f4ecf512fe26447876a65166c4d357c5e6e2e34eb90dc4e00196e7db7896ba8af3d5567b320235e103a6a81fd4300ad5dd95c433022d3b3263450f645f1ec91345ecd934cfba8a8193ab144aa642f24ea9ed21d8e2cea69719d1140d4fe7af942f0e6e12d49698c5474c063402c6cbbccf3216af4462f5f43e38ad7c29dfe9711e1428759b25e0b9042e2e74dc07f8c5abb798b12a07e8fff0540647e2dc36dca11cbc3d8ac4171de857261ddbf76dbcce70b3081f0b9ca390ade329a9eae2f85b6a8b5bf5d92ea02d8a4fc39e9fd3f4ee7da997bb8980caca41e043c86c11850115ddb66a4e01de410a52deb6c8a56cda4be5a129d0191fec21e219b94ef2d457d87611e684978927aa72029674f02f54ccf378bb380a4811c69c52b5b6e540678e6910049769a321a6795c4c4817253b88583ce8278e84668100fd39243455eb11568fc4e0bd4f1f62438659d4d2c3b9673c46abb273e83e97d8752041e6721f03f049b971096702c784ef4780b10ce147cca807fbdb74d77062901d61333290e8551b9e9ce54f9b4ff037ecc7096203e2b67dc640a5ecc85b490cf591e813c5c88960a9c011f3696483ab7800b83ab47396430fc4663d95aaa4a62b52672a8bd26bc5b8e38e1150d49b5e03ebe9c3e36688a679d17884da9819fad01d490f0e8feb5a24796316ad49d6bf963020de350bb6671d19eeb797c2722e8df8a0fa72dceb2ac94d0aa5827eab7537d4e4ea6440f31ad6258a8da3bb27fee847e007e1843ff59aaef521dac54df8cd1a67d2edf2679967fb338e2b4ecdbc4455d076ed3ff5b5c02bf78c626698944243f8905d79cbc1c72203549e16bb99d6f343ed10e290bc5fa330547869d16b5de029908192d591890d14ffe4851464fd86f25404a5fcf21af99ff2e138393f25bd180b97e299092c5be1a6aac816f5d3a519104306098b23964d4ea97fd8069fbb8f95acd5e469958151c8902fd1898b74269eee86bc2cc65c2511d0de8dfce97f2969d8bfe932136e27869bc73a8bc31b7c69c80ffee69c8c4144c55906ee13a79bec6c24f3e88b0d95cbb34740ba9d6f811dc8525b5fcf7f5f0e680ad004e64e77d136eb02979564a3da35d9950d52d034a67bf12696c74a2734b1d4dc0f19cec5551ed0e3782f96be9595608c98b22d304de049d5f724a053578d0697d73c93af85308aeeec6eb7aaa471a5085c763748681415a7e81ec21d3b63c46fc4cd1711b53b17f0851212b80b8ae43be56851d79929dc8b6fc03a5b595034f85cd6a2302f522aef2bff68185249cec332dda669050115e1cf0a16f129f2827af97dc3ff6e88cf413e5ab521f339606d051609e656ee74e7d98a675fe9f229a0728ceb9f5efc8e64167b5ffe0d05efee68c08ffbf582452d79ca543d92d4a54baec9b0c697c2aedc1009b2ead39ce4e2c4ddcd2f0741f6b7656d42eff11ac9220769d818f03a533ff115f0a0eee1eb1c69193340f00f821d5d10acb01468e3e76a144a646c9af4b6bf70e4a4c137cbc5bda150a7e8b4efcf9b2db93ea37511cca679c036ad94a1bc050d43850bc4941075991c0b3cfbbc323541236b243fb11f6cf2994fbc32280a5e142bfede0171eb8cee70314a52f444f8ff4514bd469c039d9e72a7283044059eb17258aee2552b1796d5e67f50504a7cd41c00a0e748c1f9f8c46161e4dc65bef7d71e14bb9924c2f304ccbc1b84a49e9552753e2d6d41fd6472b9df2c3c9941ec37df777c098d86b77d0c3ee2f0d794fec86a3e4ea90dc7e8f44909e02ba92e10151e8078bcd4ae328842956ff7a9e5ad3b9fb40a509b214e2c129eaef449866ba2a26f78f2fc55771be4a328a9697b10bbe1d1920a28b7c94e8f3a1e05e16d38694fcfc95389583e2c6473d79ab4999d7547ff438412e968ed31c5024eac38adc93917cf209698db6054692a742afb0727ec124f98062942b130962e4104b3160b30bd6d5a3382d09a99dfb931380b6834b5350978e7397e26f2af9345a8405f64a9d21f06c310fc2ad1ec7fd9f13af02fe667bb5b4e276c13012ef1cb9541368ceb1bae8e441c20b8308753da9fc8f4072dfeeb364f0e671ed283b74d85cd941b0bbd29818b04604426a041a56f8905fcc9970b590e85fa4837b94f5c20c7d6b39ca2e9cdb32d49f8f99d190c2be00e507d3844ff54fbefc3e8ba7cfad3b005fd5890c28ce283f43edc768d036f28eaa51a7111d112399217271d57cffc906df2da2b8b6e17ace4c09ddb38985ab72863060fd9d2b8a91643e42b8a9db320c17c6fb9a9f1f4a45bd48ff4b8d8591fc4d042cde44be55545ec62cf0a762d4b0d03e8a907116a8cf1a66f27eec9f192eca5f89c2dff54006b4742a7d99be1d15955fabdd7b33d91bd645a6e34474d3e30d5f1157be6ad9063e3e7e761ec6416331127700b5431f44676709ba863066557715ad5795193b1d84a1de3dcab91eb65f27cb63fe478248fcb0cc4f827adf0742ef94daa3ce16e1a36c7d4fe3561fb99534687c4f04f56c4cf270e721c1996a3894778299521327188639d38f9501fcf79e9c7137fbad85a4ad1385f6af16a7b55e5e171848c5297ef21d190aaf2f1b390eee6358e47c54d82fedbe279c1031f6265a56ede249d722a4cba2760e53c3c7c0582c8257d82110b10d5c4461a72f9033909073744d9ddd3d69e7128ff541061164d00ed186d22f36d7601ec3abdaefe5f596fcb2dd14afe99c55dea1d738e2f562d8213b23059542a37d2447c1e8a84c6bc08b7887c0ec8d28953cb76442ec0896792114dcd8c642a08d5eb5f38aceba53e45d62001d6db67559bda2b9e5fce8a046adea6770fdfe6722493493fc40c2a45e34fdca4c464c8dec039a320e89f7e0d41460c79d33fe5101a27700202df41a13f97fe9fd443d8ce7b77708dde1e7ce9563eaee9aa7e07df4e3bb421d7f68c0c3a15b810ff6238038528179eb151f71de16ca8b7849afbb47108d3a79ffb1046c2fa5fe0a547387478d8a72e24f4295b30d02b761d06fc101dde36fb42ea4c6332f79c4fc099bb0b8fb610bf815f3f0a5e407eb5d96f1af011289d11cf8019dd5f282c4e7383f50d2e685c43f6675b31b3633a78721f9c65143d7e23c897b3b4ec3c9348a4c892e85356d686aae653decf068aa296a9f3ac94d254fbe03037f77c586dc5b438288effe6017c1274b188c3d63677a58c6f4053a2523a480e2db7a954a954db36cf2fdb1e0059e9d3ee5d755c6527581ff22aefd41a23f4121b31cb0aec8f0af410cff381e3fca060aad472b9e1217f42e36eeeb617d4a972415443be7ade4546c0a20b97c0a50aad13552a46e391b0084606bd27e9e58bf4b1aa762dc7d140c647a50b32332997fc01a3a0a983e69230b25993471790a880a6fdf1c538788fc765741f326bcd6898e5c8f1bfe62522183717428a839417ce9667dca2d2c4a9a4d661693c6c2923b46cd8e7b1284b47a6d2e37f8db3e8e5e097f5c7a728ece0f3c6a42c7c169e12bef5207d7fbe197f661246bdafd678a0b89390656b664f7065040663e877b05b08f146ae6fb0006fa464d600a75da1d6e8f55572c26494daf497a37028c43f34dc5a02fd9252b37a33fb140ae007dfedf10fab8b8dc4dff2e0e6de2a9541ed350ad068caddf24b0ec61148b865e327b6c845f695f1d45b2619e88f446cd44704e0f1dad34dfcbb6394239cdf2ea670199bf97c3df822d9955402c5e6e2f3240f0488ec741cfe21a8be2d0e987a87f2d7042caa302e3c9920884072320c354e3f898c946574cbc1ae04f0779a16513cbde7e979c8b715abb24887bde6e4d7818d19294f0f0f559c7cccc5c81457e570280cd6b6f9359e3cc9d5ac36d7fe579479fa4abb6e564f405cc3b8932a348288d6a554db322d3c231dd477cde30549097695e3cfcd88c0f097e2977775870355952e2db19e085a7420d3d3eebe7eba32949bf60a35d0d0da984d66da54fc5544c0f9a3334e1dfa2d0db549293d776643d7a3bc37def5c960315ac540d13ff3e318b895c17ad2c1413a694d2eead5c31fe09dc9703f71806dc26fdec284bc2a5fc7cc4688ae8f7aefb44f2ed53e9bb883c6f4e5d71e53bb27dc19a1b6199abb90f88fe4b78a4922f6a97ca71f0f7de511ced167ea05dee97dcdd3c0411aa28b08b46884fd244dd33ec0974e95829d167b3d9038d88215c842affdb152693d4cdd6a7f756a062f823f37bc3aaf02362c080f2de5c6e9ff4802465a9eb6ffbd45a4c255b4f6fd1af62953de784614ce87b1a1b53e06c4b91f061c0d830886970397069e30b7a079c74da6f944700c308440e1ade6464db067abcfd3de5e9242370ca08587abdf7274ebbd793366c2ade4822d99f4cdb8a4d05df7e93fe09fcb2f17128563b46398eff6efb82d8d7c6222c93b007657fd4b1c20e994654e7cb805f1f8d22aee557689e2c274ce0d7080c35eb34f6e2358c05f00a2e061558762e955b90a998098c8f79fc142a13dea3e8948fde35fb230a5644db91955e8509c9900f1b4c758a82a91c8630ea17145f4b8fdad0a538d92631b11d4c843a79fec088e10731cbe5530c4d349cfaec9bc1fe200119f208953c57c8c984c9c6c8df1f9aa0c35d5e9a0c36ea0b41ea9a8645b91bb7b8e42733a61815e5b0184f39c325b5d8c1de2e3bdaa9096600eec65256b4592a81c97ca97008d4dca1bd85052c5171e1e3e66f5d81e8f9adb48823d75645b1f332182a90a33413cbd5d4936a03548e3cfcb8ad3c18e5c6dc1bacc196155751d0108c6fae7c73317d143e6d2da8e378add77d3878865d04ffc60d14e3e9d4ba72435e2c249323049ce43e5167ae62e0bbd1a2bd4445900310fc15b05cc38c18d538e237c19cdf5d624bf11a4f338d2793eb9ce206f94aa1e175071d4f77e94393864ea2f3a818cad8d17c3ab64a2ac130597c6a0852dcee7c359aebb2ce60c915c9211f0029e176ad6d7e1cebb7e3346b04fac0f4c5f1dc74e7dc8da8c1300f12383bf8e8b3a890dfc279f9b4376445a2ef631cf32501fd66dc698ad1373393af3825d44731f89da35f89e8ff7a90290838adc6a2e574221927830858d94c03ea130b31a6e49f56230df8922bf0a52d06be7299ec17a6f8674c0191444b850fc87dbc764815084cdd86b013880e56683f30c30a59fe1710bae97bffe605bb222dd60fc5a36ee72ef29dee9101729407795632c6b182e777da8b79c4ef6f7761062417e394907d1c639490352c31e61468a1049cee765658f34466fbfc93535d1f7c7c162fe805fc32e4d8862f16725aa98053b5c051cdd5343f0fa0e36d82bbcfddff31d2a35ea6edac3ce0fec76d7d6b2a117e9ad03b4158e5e289710afefc9c20ec99fc0787da13c2dec3a417a4a3e2827f870dbef5ff952ca93ac3a9bd02f401b9ab955241f5d112e29decab9966a33afbd5c2877588d2c27612ad40f12332f17063ad7877c9788ab57fbed67ac40b87008be4bba2122f96daf2e0bfdd91ae85836202c0f1d495ae3d8848c63cc7cab8176f216d9b7a8ef04d4b1bfa528201aefbf6b7f15087848d55f1cb5f5be2137bfb4820b90bfef18969f76a0b2785c3c5d9d140b440fe58ef16d2709538e4bf35046b95883b6b93596e00140d8dc5843487d9d57ada16f6ca3f0ac3e688ee33fed92d3fba0f9708820e16576212615cea9381fe8c1b3c7a519af6db0e3ddfeef8cf376f98af9eee0f14e7255e11571da0b7568b8a38d22d0b2e2c7c375dfca45d6cb014cf679210f77f6ca7576e26bc7b0f475eeccdec1b94f2841713c3f27710956c49927d8dfb7b06917ef8998c4db4f8b637ca38231b0f16af2b7eefb57b55fb1811a1f42eec5a751b0f3e0e5a505e9a7bfde9aa9ce2c7d32110b33f1fa5b5b5c4552f6931f7ef6fecbf663e212d3f3e281a75af7b8738d61e16c351caabb54b94eac666c9730bf377e0bb07b2befb33f511987a8485f5e8d8c41749164b2fa238071a47ac6e9c6905ae4ae116bb261f74a9779bf3df8555856fe12b911befd9e543ddd35d1c1aac44249f418a42a2e26ea32a9e3882809119b4e4c610affb05c87ed1b03ff09c3ba50892bdaaf1f90017381a82bc0fc94ee3d702dc12be6d2d0061eb1e452b1737b21cbd63e8315c0a859c500b08814c863e50d15cc90e9702d64f8c48614f075e5b89a4663581ca04ee67e3104fb04e7f1ba4be54030f171549b19200d60bcad672f811b933d0318d8a18645ee207e2f73da8a796b710f3f0ad3d5ffb5ba374dc80ba37115d34b81e56e45fd0a204b6dae341930f36cbabd2d76c10e0d60753ecf900c3e7ab081345514d30b8dc2447aa6005cc8c00ad98ecc241453f3e5691563fb62a55f1cb42441cc94e32a9cb6f5c348a378730719f3a2e181a86b1986b7d5bb6c4c8294f07fbed7e7e877788e8c47d658269138963a34c2175392c984b79ed8e65c54472d9e6730ca4a5373d3f54ba67a2445b9688638c0678f97be48b5f55bb1c84b2d43458aa7f8d7d778ec07c89113df041aa2df18d7ee134e866aa537537be059ae528cddd5c87405ab0c706303348415c982dbaecbf6775d5a8a52d1248cbb74ee39b3c0b54e892b41020ea690f922a0e63fc1587d5a9aeedcede5744656b12d5431656b7a22c808e0ebd209d4e386af0595131598b8f5c37d2c4e0edacbd9473b592eec53de7a01f2cd1e8c824389f96caede1056fc1ab72e0576e53ce0df8d1f71fbcd12c4c0d05a8c72a55beb6f9d2c958b619a165647df0d394dda57ef291342759b809fcd811c9a9d8c8453a61d225c871b5a00c59a8e43bc90e05d2f5daf71089f6ea7841bc13296f071377cc90c0bb9a2d46fb2a0464b35a4babc37997ca828bbf6983ef5ad153cfc2b0d914dd9b92d6c91c05feda4f59054679de2ac04b7be0249ed160b5768e773129545aa213304978f86def006aa31cf74db5522c4a6562c4d1d6f14f167fac4c797d8c8d7afd7f5d42dbb44d055185740e160a6a50d092685edc0a93008b2e20834562288a5d0ff39c666075dd465b57c362ad7789c9a6950854153ac871b561ee30b8f6f4d9a4113766b6bfc2e298be2eb5edd73b10ccb3cdec827c42a3a3d5db8f13d93cb2b27e0ce0410099ce4ec8566f994fd1cf1327ecec9232524e9d3246cfe1b400bd3572457ab2cc205fbcdac8886ec467dc2bd69fb74faf3b2b08fcd92e77f1114108ad82bd34fb4b705fa48ceb9031b67abd61221f92d0a3b5374d7fcc826c9dcb54b74fcd1cc5c3895b953d7e0ef8658da6b3d6379669b761b5772a4d155c1453ae554b90dd83f7bdc9f050d1e22933ebf5e26b86b096daaf97a669cf5164039184d3b36ef14eb85a721f644b478ce00e20998e1a1cf1f28cfa8b3318da31199d07970d53ef20ecd88e2507208547894d843b6b58834e74201e6d88c592b36699a44e7ab89299bbdb989c4b785e96e565c46c23056f7147d9cf024148fe336ea1633698188cb68851bacaa1ecb8d0c16a155c8a34b4856a574df82e90e0909a1e80d3c6b70cbecfbb150c2e31d71b2b18e60aabf6f7c0d32739b231ba8c8cf99d045abefe3c25664ec7d7376eb62d3b4af9827a19811b211f4d7c603095d9870b7cb625dfd4ddc0d9f0857c161cb0a9c3584ca33b6bc6c5df52c31ba6f220a79bb0a6082103dcb7ea90fc3717c962b1f6641d696a33a6ce24c5c1ae764573d49b3c447aef4c75c8c805f20d7538d2b9a701c93c851490ae1377be887c916c42952bf5cff51f15debcdeccc51c41f2b324bde80645f9dfd810d05faae04de5330014043093c0d1e2e48895f40ff749cfbce101045e68fc8058c8d1d6ee06f7c218401cc1fddf8f15f2c8c99c97ae4a158b4b0daf1646be1b6f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
