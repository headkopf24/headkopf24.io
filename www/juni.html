<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0d03fd61b765deca19a8a103cdd8d68419be99db9c5e69026b0b16400dd8a025320169c5ac13b8b7d6ff93614bd6207873ace7066cfc909a83e92d8af986cb1411dc3dcc7f20a1b854117396eeab23dae1737974217edb425b6d2ae6fb3baa9077f586cde4cbb0d066023ae88986ee7d5c602a394f729a1001f464ef40c76d67e5af994d1e2b29cbdeb4303fd53293dad5fa31269e9d558522d2397af6fb17bb09a3e73640f5af912516622b2b636d7ea67d87b1247682314d9e48b5a410effbbcaa48d744f0b6668848e80dba3bfe595c8d3eb96b416cf2662253e59317cf49b2b510b4072ce98d0b2201a53a9fce8a0c73b35aa6189d5dd4a96537cf5cb8df69ce1078d83f04d34e28049af9aba09d4da731158ba2b293a636a1103597bea1b560235b19f1090607eb43436cf07cb29376685661cb613aa2e0c1f136ccf7841bc0fd7978ee10cbc2a261e7090c25affcdad182dbf8d96d99a01fe7f79416ffbb6a8d5fef0474f6c8fcd748ef8e7f152589b0dfe2b6feda47f7f416e6666b43a6e3561946d08c39834e59113215a31d94a9fe80b2c48d519e1ebe780de918cc354bd88b9c695c0178de4cd70ba79f397ebca2a855532c4576db8c0539b36f45e5a11625f94ce9eb6b5724e070738d0ec36474f6f30f00962c447ee663a803fa3c6504291b119ff918d127de946da5f787b8886e440a1d8b5ee805abc48a37c09acbb8ba658b67fb39fe2cff7d3797e984cf3927647b78fa05094b52f0a6082345d5085bb5f58ea9eb4164d6212025319cc8d305240264ac22a2f20d089f6207c92f278f065ca185e1bb3678113a8cdc7fa1a59286cdff11b853bc112bbc6dccc6bb186c1c701c97e52679dfe3db4eb67879c02075960dc21c2fcd211dbf07ac8e40e46869a9f53fb8c4148153deb992bf41c3e6b76aaeafe726ca6a9d4275501d1a8c3b6b9f11ff9e16b5cc1cff2f1e43c2fb9b426f1dc3e003c6239a82362ae35f019f32ff327ba444e8ff2be30528c5f3ad7cddc4781052982999815acbb8127e9e071d9409d403b42bf778e21bbfe7ae1838efb67b1aebbfce56f9736417c325ef43934ac608cf4fea34ced3971750fcdddea30becf29095b96f874392a2ea0e066cad03ccd3a50da97065f8ba6318087e72ba438bb463e9c7b02ec9d0e3818f22a65e379cc19806e7ff9fdd8e09b22c72f929649396e9dee4d6367f60bcb71d7f113501ca22294c343f223d24ee6b8053c24663ab9382437f9df8640620248f4b26f3febe0806d7d82b0779ed764d392bff823e88305ddd050301cc836240f09ce71e97d3bbc853343e85165dc4b735d6f433d33ae3bff10579c689ea95d53f3dfe8838cc579439f7775fd9a1a34321600549853f17d96149530e49d37ec8e29c80ba378d76dd92c26986bada0538297fd00fec457a653df4f38676f61a338713149665d81a26d5b36cf387c173838beccee86dc18dfed4e35c07c769205eeca81eca60415d579829567596b50629bc7b2f5d187954d68d41e969bbc5e346f99e9efe49efb0cdfd1a15abbf9e8b4551db3e70311a0be98469c842c896722191d955bed75d630355d2da1bb1ceb4ca2f135b2dce1bd40f96810b06e338dca0367e137c560a19d87b6907457b282abcfc7eb4e3e110e60997cf0a487e51dfdb4f001e4834703a5e3d304b7779d70113d52d13331b032c913fece0785d95a198f6ccfd5676929d33c7c6ca787095146a37b66ba37c36ea2f79b0170e2102d2510f08bb7656385f96e119955f232087f0d4fbf3412b0f511d907d3ab0fe80ef51e48159b971a3170c3dfa7cb885619fc7b1f36407de6fc24fb036a993c4a70edfa0d0324e29b351d1290a4e46e0dd6e2e5b26e0d5a3f48485a01cb48b33cea8a06a03e928b47c62b0e9bcb45aabb27837ba713bdd1a980d8788e4b5509e3f84e247e343eeff35fe18dd2db4d6e6d2242ea0011d92c06bc7c280677dd6e278fc07d46dc1399351f319533196e6f8984122d7c970e81e4bc7ec9529591162a70fc2c5b2ebf19f9f09ab1ffca5def56da1e59f0daf34ba94bbdb9bc67b6f7c483c7e94066c5f92fd4138fcb8fb2f4763835fe88c742ac0e78902b9202eb47252da276ca22f2875c0a35ce1c83d505adf115a2be7a79dafd2fb8c03b431d6e5a788dd609f32bff93a5365903ae2440012a60cf388155ecccd16c545e132d8ee203dd08c6d02c6ce83eb7443dbe91e9abfc9b0680eb098fdab58f1d29c564c4bef54281b5a3b93000c06054060eaac222f932f55e2968ff5ebdc1bbc0729f1fef6ed4fe09a002b9416b58be50cf049d4c41994d89180c8d729077c53c627905294b584701654d77595c7854fdcedebe23c5616a7f7a4eb8b4527477f05bebf0ee0e59dac4dd54fb2890bf9764e3a440f1ff193f1ef38187280f9fbe67b11bdffe9d6949b52abc247892a3ef68c6c12593e310f6df1d30efb2cced0623a52835ced42091e7748c1c0b2cdc772c229a288c8da90a37fa9ea1beace22a0d29efc5a5a68cfdb2f1975a099f3143a60fdd7c9f8a6f2dfc0db3200c128bb5adc05f6ed945f400b17186de9d69f031c837dba42e869242d84e871b39739274ad498db345c5f0c8751ca4e4e02855f1af8c2afdd4b810468079fa476598c42c628202fbe8eac2468f8c6ccb28b80faa15c69e296391ad773f5115c6808a6b3b30d04371422cb3d8aadfbd646353e22c583403758761de9f90f857fac356781d7425ffe34663ab5b772c9a410313918d330f52e6696a9c5d466a49e3968df8d10eb7446ec29686390214ba685d9b327c13f5257c173f6ecb9ab662a8ebe7b73bb2c0ab41e0d8e320aa6110f793065d05721bdcf0ab51045974837ae5d1b719f54345e1a90196fcf5af4152991bce59180c2bf99dd65bb003e7dfd7ed78382db036f5749458d9aadfe9692d5295231c750ab5b732f92e7ecaa05984778740a917a0cb6fd91f79a2a39c177fd21c9b6e1cfa57378b9285d3cfc21875ae4630d1a2f09c6eb072090d5089b67259241a8cc744eecd6bd508c305b800d07d5b78379a6195089d257fe0ce80169308eceb52d50760e78e4fa9de23e08e2c19e53bfb220b9600928a45df861a3ef73156ed469e04279cfe5458fe6892a3c11031763504fccb53d475f2cf2d5db763e02f0c6191855c471d204242e445581c927a22e831aad4ce16de94601b22ecc0b538f0357903e346f880c1dd0e4104aaf92ce92944bd0ac8931d11a62fb52fd31f02a016d918ede637cc87b84569f76d1c19306c3f6f0a7ba75b105cf7a200ce2ced6c1ef697b4c657b1afa7ede44ac6ac5d8a3a91525c1efe614ad72f90b5874736e909609f58ee5d6fc8922268a6d466e967bacf7a6f76e62ecb3b560e14e9050d8283a709f3e94393091ac95f83bbcdd86ba4a882f31af23749ca22e202b79a6aaec7d53606033b57b1ffa52bbabce6886e9695979c795e615ee393377b07ad8e77ef76923d654c33e1ccf377526be98d33752616e4f9eff81c8e1eeae6bed5f052e56a766664a95093fa735985942e289602931ed1e82a70439eb14c64749f0d54226fa027486537917921ee80713ff8103cd066f3ac62519b902b5446fd9c2df488adcedf295b3d717b0afcb6d1f2161084f0d292c44098d49147b6e06f33bc9042aac843eda279e4f960f60cb3a33c3e17d0f462d946560add646edd44ec67df8490ae43dccd13fcdc658dbfc6e6bcd98bf7692c9999e8a4c3722590efc8672e254531d74335da9e197d030b0f51c84fb428503237990893c3571c0e3de8dcb84b2025f06dc8a17a17a4f064e0eebbc5a14eda1a081f103892d761266bc16539f6d41a93dbb907db632e201cc55d5de78e33bf86eca4b9855ba4f167a3a0c2400acf8cbad3ecfaf4a94c61389a199a8d01466a9a4464036712c64cbd48c2d8371d2a25d0ccd193a63d0af2986446c58b10ae85ac62f7b23697e00759000971a994357d2ef8831784fee165bd72086256403b1a0b6993524d639f7ec749cd012ac3e529d7f2c10e2cac35213be8d748587e98c9116473cad8bc60103893ce80b6d3a91b2cf5397c6617812a6046a6460d982611482820869695c4f4923251fb04a9a49ee780d948f184574a8da88cdd7b899093f3fc4dc4ccdc2b6e8b08ff48d0f67cd7cafc0b642169a71a46f98dace82b45975f90e142bb9e739cb02405ef1bac412111228533f541cf7c6f44b9619b27a5278065b66f722b36554fd32de7d7dea5bda6a253231df47ed8ab2e255984fddca1dca0b0dcce85db771b45d400a8cf29795c2330ea0ee2d56835d7cc6237941605d7246fe6ad54122f7ba79b036f078718dd5fd00ae4f447e841add1050454dcc346de6bf9dd3889a6c86ec0acef15041769355b00adf0a2092e3e2bb52173c5955bfa69c1b81ebd1be057f6a65db7538b401d7df824c0125359b7bd24890c2cf6b4137688a24b756be4fb1f19da05f7ff9356084027486bc25e5190be1e0078120e8ee03ec40d4c0cb4830d9e84fc612682dc7fe75ec51ff3edf3ef35eedfb2b65d92e4bd21715453b5d55e83262a30c92ae6961e12032262f9724832056ac2b1b15cb0b042e75abaa29b67b96db9b21ae48af012032f207a569e0b920e4fb0390f863b958eb39daf00e1855a443f03f3e07c7cbdc7ad4433e2d885a18bd63435454fc667456d1996fe3fc8c5992dd127cc1d167f3c904d11957c04ddcac8ab5de2759d87d49ad227f47b4d3fd42724b71c9181d11628774773fb038444aee6cdc8b980d8870b224ae0f20cfbc74b3b80f6b4bcb14fc33c323ff2efa5be38b2d2974c3ad7405ba56446769823a696e3f3637b7b970cb7b73a514877e23897d97d7e77438aef87a73dd62f40ffb17d56a8097ad1e40708df4fad8c215ff299b039ed36491040816a90075cfdddb905e2e3fad4f35347350f890b3c8c0e318d993af0eb522014cd99f5e665ddda4c50269eaeb9fe63f9ebdf25be4aa171f08e4230f92d13d094008b2a14aa3cd6b7b6adb19a1300aa4279fa99199f42e492f869069119a5b99995eaa1a4d5ba441e4453b60dec20f3a4b078e2f36b243bfc03a1bd47b506fd7a85e01d471479641c8bed7b3cc540babcce51fc46bcd6fd9c4954910e220f9e2c640374f0c958f40fde1e01f79721c42001bfaec5aafb0de11ccfe2cf8ce583a530e1908b738bfeac9c77ca84a963b82088168dd26f07204f769789903fee472af52469173ab7231e04b6c158e21ab6fcc83cde7630e848aa50f6de57e1248d74eb8f31e4e6e2cc422088cbc77b29ef742ad0fc269002a85aee9ee96c20ada8f44b8cd02285361abb0ee1d28c9791407da6f7aca0bd6ddfe041bd3b49a9bbe303fe0dc4c0099f0380c5342835699c68ef64823f82bac98714edc442d51532f1f77ab7adcaee579bf52d95fb728feb78173fa12a14b406dc151ba4c39bd5a60ef1f737fa072c1e81845f196a41b75b850ae1947b5bf8316a5359ba048cc9c02076dcaa175ae60e366089ea6e8f52a78ee743cfde9d3f535ba79fe5f9468d24951e7194e1ad94cf1f974028ed07175a5dcf565fb6e4c2fdb97d1b76f433ba36475c42c2f45e882a9d00872c6af18ee633184a7a6c58304c180600532d38481a5308472d637e020507a4a2843c8cb5db6426b13eb6b48650aa01f24c835c5f1093a442eeba677a3600601bca432669e20154130c57f7aa8b7457a40538ca65e04d17254561b226bea27214f8250561325c9ca46589b8038868415e70c42c614045f17cd8bf8a219e79812424e2c1808049aa39eea650d0b8f4ea2416d86c6335991da661bc095337c102bb39ee66041ba14c85b55665f38f9af179386bd9790d0a65ee3f96da1c9bb709eefd4eb495d788adb689171df08e5fb0d11561f3aafe677d87a571ccda91594d4202c76d295b33c75ea5a471ba8d5e76f6dcc3c559929566df7416235ee96868ca801708f6a195f9dde0410c2a9538b89051b3659cda30de2fe6fff0807fb27128b4ad5d44e12af4f56ab1edc63a5fd0d9abc62f7accccf484c0b4b91e14628c3e1d87be243b6d2edc5a54c76927f7eafec4b1bc2d7365816df1f29116e03ae85e8ecce2f4c90b7f516d385c87c84d004411ce859bfae8c46f41d3aa97b13ae24eda6d74d0722cc0374d9a2af3c8458e9a29cc805b2bca904ec51c6a6d0837b9f86932b93a61e31d4eec9c14804d3e942abc6f158b610b10349141f39bb75843e32b284d14a73286447b1720e0e0f74fe53782b240c998642a44dbc7aa04266f4fcfc90e366d922856c2fe5ac7f938b8f586e24f56d6cac04db6d1b7434e65a05af6439aa22f2ef9adefe8745a77058728a51dcac5f354b144258d4f11c9e35322a72996e061d3090f93976cfaf889a00023830bbb234e4e88476607661b54d8d2c1957837f6cc36371578352cd7ffaaa1ee75f9976421f971771ff502f26d68652ee37b8d46affd61f8b40dbd50990e520080c506e153e0bebea1a76ff0048b3ff9140ae08bd4978c8e613f991ef2a74e0bdd4f27dcc00b2581ee8aedec8279f804496d7a07169809a24846003b9d9880946b11aefae42384293e3f0c1d94f7ff0d99b941431d59e5efdce8b5ba9550486718dd5d734e7afb094c57cf36099f47e2d25e5d2dee9314dee0e0235c2f92ca51048b1c54300b78dba22efdeaa9368279ab6e76ed2b6e2d0f8451560231a2fa57ce2aba89fa4ec7c73d8532d284032c973314a4d7fa90f108fc286a2a3bbef576208ddca7be5431ad484d90c13b350b5a45cfda28172de19663705caafe94673b6a16306101027e936f0ce1818a02676d3e072044a51d314b2005323d2b9c11d8503ef4d206dcd353fd2b68ccb93dfad4d493467c36f4ec28f82932034534e66c50bd4e266e9b15342de8e13f6ac26f82a834a8ddc6641b231c47eb97525c8e63fa7b98d7c010dc736f7a3f43d8e9fc55d7c78ac7c3ab68af4aea648952d2185167dbbc53ce52ed207dd46593c425a096d05f876c5c5da7d7ded75a625b5ad0b80cf30c2fc242b87e54d0e9b90040c357a3edba68c0d0f0c1a0bf8236d91a89cacc592217d014b19a4ec84391de02af3294d32a6d7459d86b6248cc3d35cc010d3feac1527eb81345827047ba152a62d65fcd196cb5db8218458ee3a91b11740d53e5ae8617df343d8e9711be1faf0850a2d0568d76054a4b34e05404b6e9f4ac68418bfaaddf2f5802fb80a86f658c0769d30d4ff5615b8cca5ce03e9b44d0865f7a4a76d8a204cf27dd330c32e2d9d66ddad6c3c80032de16d235493b94ef7aa530648a579e5ca4e4bf03afb9c4acae02a4a835e43084cfce2dc721708278f9a96b4f62dbfb68c458e6f00f648343d26be6afe877a2fa9502f9443df9389ecf5e578ac32121b96d06fb8576b5405b8db4d75ab682bd5f79bb2ffd07696c63d8c518ca7d204e170b9e58087b209645d23bf00eb5db9ea2a38ff3aaecd80ed01d87169cf020de46f83cbbbb3d1ac1cfdea176ee34e7885b3fe1edd32cf79d6e40d8b6c5d88185483efbc5c9fe7164a5257a58b9fe2b37e0988e73577c93907abab8fb7fbdc0ab0aa2d0ec6e92ff8f4a2a986b1e14b7084e3e6c284ed5ec640deb705f8a607c3160be61118ea10f2aed9f02d15f6eefb69fcef9f8e183cfb5c175bab4eb60e9ca085e4af93d0ddad752f8d777dc58e6b9ec6ef0e709143b7245eaa16eb87943f703ddef28a3245d8a08236d14ac5ec5c58156d492111c87707cca0803c6754f1aa19f319be9319edd09732c7942fcf78e964606c4fdffbc4d99b7a2c612d0a208724c05bba80689f3be29a84a10aab199de4c540765ef4523c794c04e3cbbaee8168cb1d3b35a8466b1fd8dae80d246f51947139db46593ac286d37b38714dbcea324b17cca92580720a99d857b1d9522ee1e04591ea4f880266192b254ced4ea4f4c4102bd3b0c374799bb07310baf9494615dfe1d569d6c5ca1130866ec8d0099d90ec9cde5154d5dd4d98272a1e1c90140fe7fbcd3028cd37731b45810214be58894e3350b5a24b7ea14c54e211157f31ecdd68550bcdfe49d2ce03cac7fc3bd092d7bcc95f01b1c808a74eb87de4bcbf6ff26fc0d91b82f398a7b3b0bbb48cba7b3723231b99a942a409f8e17a2fa0c0d40e8db598f30b49fe9c5b466bc935a67952391fc219a3a222f22f01036b82f4a33a0f51392d32cf49c1f8cfd65f3c1e1b8dd7d7e26b8f6be5b321da15b3e861d1e526eb6c8be2b3a3d96f912d5511590672f6f024d0e9e6252dfac9c26b87dedbe0822aebc96e67bd8ac20d05c1c1476039dd7d310e2b4733b2cd984e7533322dac0f816a92245ce680253157c0debd6488e1935ba0033e9aa277701b99a3e1596ee381f84d389a7003cb11c1b2764bed93308c471cfcdd3f37de1b95dd094417a974a8141fef4badc5f48a2896c0abb347595919ce4742674adff1cc0fe0618787e275959a400dbba303a06b5630b74c8b2ebd6060df1055ce3f9cd056beeaa105bad4c2d738a88413efcd59a566a59b7d1d6d21210aa8700c8b9de6e5567de2caefd6341f94fbb2402c89ae3d01034e284a69d18ceaa480047efff201080ea6e34df292d31e3178a0780e59e5cda373719293e2c89112972052cc5df2bff64f950125c6a89d06876e9dbf20d34211d4e7817043425302bec2c83d125a39ca7eef3965ff554409bbb74ba29d10af7e15ae3fcb0c6473b25d0aef1e52d98e6abf372856c08816908fa4ca9d0e15452940dcb944fec1d3a92b0f18dfb1b632b113fa37edf2f41bef4949572208accacd1a1d26ad0a727c3d0acb5b2297b399a1a36ef111855261ab0cb5be65a34f9b8e4d25c2d238fe6dad607094fa9d14566bc3fcdb226e609df9d5f7df92710371fce28cd1b718f1620dd559f42fb4c26618bdcb2459e78c417a420cfe5ee64deef4749fbbc1fc1d027ae8e829855f1f65f7d15771bcf28aa30887428720d26bd97e5ce199e3dac7388283948343a161f99a068507c2086d27f8870871f0c9c443b95a32fd58a389fec9b902b291da1a4109f5dd9e5530ab3ecbaeb96ad9de69ab228df028e255f22f29e0d7b6fdc89498ec2565756c7b5dae9d413888a7911b3cb13ce89fe0e20c2c671153ed7856d9fdccf40cac71b813509884e08129b6cc182b5189046d5cbc29fbdb98e4511165537e32dc6fb17cf0081480edd14c727558aab9371cec3ec7178bb78787600c84dc0ecf4eb2e208622d2a13d77a0be4ebf5484ac409b3f97f105c4eff1b8eca4a9fd96a8ce7305a5d1b7fb523fe93bd31c62b254d409fe684c82037a87824669ea9e86aca608a35871aa444ae6f6e6f4ff8d21f418c19f0e89101ca6b95397a8eb01a8038fd61a6471e26e313e5a3ba941c21d35c604b76100ac59e84041e65f790bcb9dddbae0b4d66377860d8d579a2de56006248da157e36991048300f929d214d3862b41e9b28f87f3ef95ee26eafd486c16d9a6ee28e682b107adf4b9a6b8e13fd09eb831efd56c06d34808440ed307fb3b0f1059db06569bfb56cfe500bdad29f88266ddc697832fa0eaa66a17e31dfb136fbc11885e7c3fd7d1d84b262419b65fcf3bcb23441ddded71066c890eb7a0d5e45c4451a6cd3da11f57a479556c710b0e82de470d208395683f7dc50fb3d38add2b4540054218c9913e5d9d95f42c6d51453cf846f1e7bf7569f5d1aa2b3464383405eab006353a67f89759d496bf392ba8a5bc0ff8229f0cccb3ab088fbb4b956f45bea422cac10f1c9cf2c18cc03416304961d4dff7f09ffd349c3c54786bbebc391cc44b951573287d9bc3b11a23b589c8e022d0fe0489b185a8247051e4e97174c209ce60980ffae58aef3798763256c7876e000f2c565c0889d8f77e667e72e9bf5221efc1026de8243e0225a487ec51398466bc6fd69dd6480387d03d657e8e4a8a1a64109c84a5f088c19ac85354054e5e0bee46963ef27d539dc39d5372ad51dc324b0306907d1074fee5a1915ae0e532d588e7d5da6bf4104a9112647cc2713cde7ebef303a518b462b95bcefb774ccfe6dacade42b0e562ed8ca5c786804e68802d598b0353903eae6770872e93a56fc41aadf62087048fb6b4da1d05fecd043bd0b340dc7f9351ab665262df22914dcdfdf180670e3e0346d4e520fb17793d64efddb6ec6d124996ec0339a77c1840c5da7647a579ea97d2d558e4047a5f03be6bb7ed87439afe5cebd8e3bf52a7188b42b9490e9bb4ef8ab88cd4c75622488d0d24bec165a9fcf525371f28c651365ebc3dfd5f365332dafab620ad42051f6c166eb29e650565e8ff33347a7fc6d5bd7b970351b87c8f968a87288476e5391261b91dd55222868228bafdc7761285d2cc06d9832c38fe24b5da01b5de2e90aa20a7ad3714e3209c07040cd1c535f05ca285005c720f7c6f611f20066ba7b206b34499bb275c877fdf599bd1600478ec9109921a8d1a124aabc5ff133d2cda0e76546e2c9144fd95985a546648468f38b24eeff8a60367adaa88ee8617baf229c616350e027f2217886617caf5fd5a97d83741e4e1bdcb05bf377e4ac43759a881bcdb8b5d621a81cc23fc8366de0efd95030d2a2dfb0874320b7ed305c25c80d1fc62cfc91df5ad64c4060b17601150f7d6738f2cad7261b1da458a8d45df2a27c775d92c9b20c9bb569c1f84cd22ded3338a7a579f887339002f3b34c82fd39d655a2964a511aa3f776706f6a424b9b59f74e5f08e038da753f16f6c98603a0a1b0b770500320a375218d36f0344ee01072a78d719e506b9d35cb7553bbcedd59709e0574de113211e8fbfedd4fcb84a7317db2991db9ef9042507f64c170d76eb2224d70d6aba041fbcacce2a7057a8b1b6392e35bccbbdc9b0108784a81fbea2e75bb666a94962ccb786bc2d22080133914d89a5ca2ba33589ed125fd59e0583a41d9b431eea8782363712178766b80a0ecdea03f6bbc4c654d5838c44a9c77bf5dc7441186d66339229d6fa7127dd74b8ec0294f45933b91ed1a2e6116e5809ea3742f0e23197885474b711be35dcb4c202dbb16e55af791ea012f976ac6d197e8ede3211489e042e13087034362303cb24bf80fd9aeefa2e11608f5977ac1f61fca7e380554041aa898aa159f6852bb6d4b639b21ccaac432e9e261399787bf0f61ab94e5d871d5447f66c8beae7266a7e4346a3537829bb5b7e7776903166c06b7e06ce487451322eef810bfda7acad201a13412f5ce691fed39917cafafd7df5c281b7fe91583e20795ab1ff857e59c8a23d4db1dcc995fdc82a3e3ee69c0a9e710f5253f0f75c5a98d098431f60a25918c79a6e8c9ab7d9a8d6fb28011ce1112741f2ddd09e7802f2aaa1fe92709a6597479af55142fce4c05510f701d65a173f2f8889782c0f29e31c9ab0b4c5690c285f9e276edd38b0c90d50f9c642078f204762378dd5f5eebebdfbad8f01e9ca7c3afcd04305d210a27d3fa9969c72b64dcd5daeb0d5fda6c97684292a6dcb9dec62589ddfd6f0c2d71fd0579b58b4514c325f706f05d1602f6b088d50527d9cf46f1e02ad8674ba7f2458ba49cfeef581e0821bde58e1c62b1df8f16e0b7583b22ae0ec293db422a02852c89f963c959a0adedfd11e3d54565d8e3e4078dddb51cecbb892fdb3ef5796c971ae8b6670ccb2275dfa6c1e5425bece2ce5eca362b08e92fd39cc86c905b6776659e923abb2c4450356ea35c656a62ebb3e9bde03293c67f8f5a98356374362777b12811fb1f35c6e37155fdfbd532128a175ac6e82481abec591905f94b21ca7f1f05e1cb866786200f4af744e209db096d91832d0846a7fdf8b1e0220d68460307881157d17750b168e32e8169c17ffb25908c208cc8084c4bbed2f00d33ea14ec6d8563ffe8ea9b6acdc1f680417223498b7e9c3348e4a0fa66e1f4cda33f106a042a2929408fe1d923ccca7bac9016737097aaff432de7064471e4a0f9e04933898e83b5dc82496a99ef5942d5e5f8b2e39de213bffd9f3c59db27b8a94431b51c5fdf871116db102a1c2abcc67a4e13c43c6149b8e2085393591699fe14b3991d0b3deea91ddbe6eb3f5b4f66aec1138a21fa0c1298ea3ce5afa8e074a80d00cabe0e042a08585764392139af88beb7fdb460bef5bb94fda8b0255755a860171309e6648aec11f01a45acc3ce81d81b6e3433def8bcb2edbb3293841ff2b4bb3ae19ccbc9853b7a5e4d5dfd629c0fe4b03dccecc2439b27a8e2f144ea73f873c3ee61c83957a10716ac3b4e0ed49292ae59b40cc3beac53a8c13723ec0f007f7df3cce7d052caa712f4c70b1606634638f385d9936097fec6c93b6edac93e8688cc1b3e228cb27dd44288cd20784d7ef104c6a49f1344ba4b4231fcf4a9d2a299d0aa4a390c4922cae1ad3b18cbc9e5d4bf51f6e88fe3b8e9aac9c726bda10a87a540bf60e1fce9241949779f03fa2605e82b75c6a867251ec6cd783a101e0eab9031f65494bce634724d03c133592a86c4dcc9ccd2f7fbcb27c6993f8c2e2458aae49b9a25c47434025695363083618f07661f9d09779d5abcc3a8f7ea20d9abd583e095cfa3dd2585001b033123e7eeacbc56696d4516e84f5407eb8bdfc18ec686a855d9d776605ce47d73cc5d14571802b0062d1c204915c3a2aaaffd9f73486ae20ac3f3cd56c4e46b9c0a0c125cacce6bd2920f77fea8df861dd05b597a977ea6ed6ea7b695344c481f82842a9c64c584f4bf3a3786a1c90d4213be6028d331c40d24d8c2a2afe3d51909c0b4f35d27173926efacdc1d5f1e38d32aa53e13f5789ffd0495955434235b1c4ef249a312a1e9972caab02aa055972279bac4303cc0b0045e7f5c5c20226b4d4110a19dfb7ecfc0980b220fd4bd215f1e99dc544e1ac63370c4fb93db7b6b67902b147488f19667b1aa5e3b354699fb618981a9d0ed1e51331834a727e45809f6ac41cc347676887c8aa4d88023491a1043dae3e5e867d34cbf093e771a97ed57c93c311aabd1d6edbcd941f5b71f68742070da58ee593155e63ae528cd8908bbbabae0078e0f6808b8940ad6b02b9e821091ac87109f341ce403b691f9cc88fb5efec8a13faf0ad44a9f04eb4a95afd8281e92fffba8271dbf91562e4a1c14505d0745e5de7b71a5537d9890b4a10a0a1e763d25c1e519a6c07133f2f4990354504174bec51129f3dd774e2ed8e305d3a19fa2f77a34d4a472fa134ce39cabf458f9d49e24fdc4405b9e66ca6d25f88b22dcd2a57f7ba82e84a3c0d7db9f43f8312cdba17e7fa0fbb4221cb78c679ed4556a9b2e1918a64933e3e5375bb56ed353340aaeebb879d8db59d46ac24b98f92f61d66050218c663543326bd5aca2c4059804dd194469fb7e66eae2ccbc1bbdc1f02b0da297c5d45a03b33f99d6eaffc1db2b78f4266f498a33622a2cb9445551c05807b96c0697c1e4dd0112db6e3af19228a8d9c733e5471c31df122c9543f6ed71a3e7278277b40e827e29559832d76267eec0ec23844dd411fddc47a0ec3a7516c5534ad9f5826d6fdae69d44b74f23ff89e7f44ba319133a7f2cf4cbf05e218b7670b4ddfc0a72d8e44233d8c098d18a3e50c0fac2e050793cab76af75b1a544f8c1e652e80b43284f151d83eab887fe0895e9e7d0e838961e9bf7525509c9d28ea0583f4a87afe969ba00c78486c8cd5fe5a2650cf65031e134f7bdfac016339a213e23e503c65cb6f40339d355ed9da9f7aa29fb82eb0128b9ce8863332aa392968eebbede8fa55f046d0c9f83e7e10e09c8a501fecb4a0bc643c9a5ef688bc9ce20d9c2f7b8af4bd3dcbbb67bdfb9354e3018eacce7596a1d541625348a6208b5bea8213100e615f5d993f055034948b8c68363b68347d4684614c5f80daafc72525a99c040a289ed697c16670104e847e82956c60337dd9a98e369a0662ab3bf91fe8867e3d09c32318d9ff73ff34e18a85809d8261e7b695523cd5ec924d8fea369756f6d6a09fd2fcb4eb03b5846de0bff813eecd894a827a7289b0ba08b23806023caf3fc45a508a72dd0f8783da6f706c63c36e736ceeaa665be470c5397350790ffac75a946ded4f54c81e24026e34ff61ccd93643f67ebd5b6d5f241f70d96d1ba2cbcfbd3b7917f987dcf1bc0c6a159951e1e66b88b86b97a7db8b220ff93b88c3a24b0d40dd37417708598a26864c6ef5a4915a11e675184b8ec8561b3c8aa06e35634eb26e5fcaea590b718eb8a731f8db14812f07f59e13f7789c3b8de0b997af874bdb42763b0104014220e1dd6b288518a002222ed0c6dd84e8878d788975b3353d29ce7040ca771d7499dc541ed195fa18d9d15476d727367b31d8281cb0d1fe4e61aa442f995a53dc5f7557ace974b76429f8f01d30f5b435060cd3291be0c4549d43cde1a91cf0a0dd56844619e80d6cdd9618ef52a448d745a096b8fabdedb0dffad55ad1d046a501394816f301c5b5f0cd8ff36fef0780a8e745ea63f31ae9110ee7293ae7ce2aeb86d8495f6804d9aa8aa695267236e28b095c87505080078b3e1a034d45bf48807049b5b93956eaad22ccdfccbe5df4fd2c82d7bde20b180b285d41d8b733f8727817cf307b660801ffbf4bed92680a3d16c4cd857f40f6827be37faf62e4ea43a64ac8b893db29582a3f64a990d731e74c38a53433d315f17c2cd69a55ce55826109e5796e55aa82c944e431e6796cc1623bc5432457a845b74eb4be9e561ef787130aeb572d5a82419568ff11d8d211238d2fc572abd2c50f82183b14e3f6f09bdd18b48565fb2c4e4557d71ae3d87213111d22b0fd7dd4acbb21af722eb9f1d8f9aa26826322f99e7afe6334899cf463a21e33bec4e9eea15baa42e23cf67e9c1d3e227400dfbd690f1625123f55cd8eda3d0e10a3f21d98e72f93095798014822fd69a841d07f6333067363e9c7d34747b04ae2f4e30ada396512c0fc0fa0c6e8ef02bb21287fc4f9e38cef1b11009153b2d5593d5261ce3fe6a18c86be698ddced4454ae94886cd8c55402c520d1dd328d649138a742bb7fbd2b59d1809823ecc1d3474bd2edcfa54f75e9bfe8e615c6b6af11a3afe8060978b15c8f25d49b7ce4da5bca5eaf1894c0b0c960b9b7728620ab615a1c99b27cdcdf9303b804756610e9e779702fd9b4f2de1d8dd7a271f6b0c53b8ad51c16fc9293546617ed5903118a811be8f81384209114aa1c9d138dd43843fe8a70c7b3f328feecac8ad8282d8fc55d808dafce96160a6b7c258e010a63619b0cac8127cc2c9e81135d4ec5e85ea952967e5f535b4025b1b0983e326e4ea94bb0db04a33e30079d1f36948df8dec40e0e29d1bd16da544f2785a32097e8facccad2754f918c623555b63f6e55b8f53199faa4a4f408ec5523d701a03adaeb4785c7a90c60fed0ce06a95ef5402015f1c0c098ddf2780b0390e02be7fdf545dbc5d9db93980230aa7f1984bcdcaada148be2095f8af1f90ee07f4cb1555e4ba4acac38a693924ba43b842b468564b5e40f98c60fec5042f9ddb9763b2ccc822e83caacd27a3dd79af9350843002537f64fa1df62c2b85bdf7b5763ca71ac671ee67d17813a32824e1552e3a26e63e4a95c4f7d82c5171700ee6c27c391edd7381e6267107e9e0f6f014945ce91d8a5524004d8b016cab8d2fbbc399d8894e2b47ee3aa0b20343aa6520e29b3d046c1f2209b763fe42293bd1bc776cdbeeca30a889287fafcffda2190df20e7057e3bddcf8cd7e71d4ede83977634575d3af66b792013dd369c6aa2b3d8450a991381a1fadd0dd71f5b206462072ab96a9fe4f6a73c55e87559653dc7500aa13380c07704996548f2f593f9400c5c9b17510b0d5a2455c6cc515e68a8d5d32e2a49488e2e28f9a121c9193131828a284c0c5072b0fe31cf655858d7329ee94c81c36d808addd5aba15592b2d7c0b9841f7eb9c7b4aa62a2b688525feff58fed30a8dddaacd8982681e1266b8c8f3aaed18595f1c81c9693dd9eed72b6bbf8b5c4cd20645ce3597dc37fff9e59c3cfb8ab3031630e108cb3a14f4344cd5204141facf827094a771bd4f3de9269c0d8aa263276c8b43310c4becd1eda7c364f03333930aa7a4f0d88956d084c1555e6b517b9e88263fef9a711024e06981c3f8fbe985a93a759494aa88ebff0abe6b771108d4e06a90d2f18884edfd08e8a7e534d757de766affe8035a7a73c876336d24f451919913eb2a5956e67df2e564fae6d41ecb38c0711da801ebc3ffa5c71c9c9d785b6fe3340cab1a6f297c0fb18b9f488a3d8398fa83844d7ab85e3631743b7c38ed42c4919dfcd31b6a3fd166874c3c65f4b9ade3b7c8ce9c117009bbdd77eee00a120a0f4e9b8a0eee5897f92cfd337ebe90e5d1666ad1640002b61dcb562333354540be4fc4de92ed961570ca72cbd4c087574f97c8f5e6165c20c3e2261544d22b6d90500d724f24acbc034a4f2700d0f4f77cbc889e3eec8e22b97bfe9e168b46500e44c53f7037355723e810d0c55cc41cd820d48fe7606c86c170649c54cb1f7ff753531b0dcd63c6040cd75753e80fd3edc147d9267d356a36470943a852e7bf45245e8aa67e516e15aa21971f48bd0a8a47457b476e87c0ec19102b812e8aa57b46a455629530b2328294208d13b5bface33f71bffc977691a7c9a0690ebdc9e0773a515ab56f88356579248eeda567046295e5c3afea645dcdd449712c024c64b38f84c63db35ce837750d237d3932c2a93df73a4fef2b9f1744390f21253a14a25dcd8e741af20d759f70844f22094f8a2dc0875ea74051fd66954958575404e6e58147b59ae162323275ce47eb4016feda45f3f44143ace75ce34468d90766d61d04481feb81bbf8d6eeeedd2d4de03ea0a6d2657521b92afdfaa2efec6ef4db2c0f72b8620966a7d4cccfb844a8ea69514972023d841b277bd546aa2faab459c57978eb0372d9601c3d1ef67a08b4cc7c007c18e2840435c6bc72a3d6a85ac462063842771eb578118576691e06eaf8ced16b5e310cfc2e5295809c42e7b3c5ef253a9b48f21613ac9d5306815e6dc8dea3dcaf23792f071c97316e9d82fd4f12b47fcf158aae8c136232070b6d21e4ac503f481daeaeb30a4f0cf37c5b261cfa0ec4b42e7da4c9a32535776ab0ce64df91f54f8e49eecda31c6ad89d9680ba1f819627213aca069d3b14d3d1c1ff9d6875709776bb38f7cbd374096f31bd21e66ec24c979994b1707938dc8fff67dc5b73ae071b393049e8d5e63b2e30be9335badb236898dc06214b15990f110609e3da28238564bfc562d67b669690ab791691467529ab024d274857716f04193fa4ea0e13b86a935e7313669564da824bcbbbba6b970eb07697566367bee509a3154990e7bf07de35f0b17f597af26f96094bc700bfb9a0c89baf9a632a8c65dc3e3b4bad06194425a0d0782206d4d1dbab211e44df6ff61d0958d39addb4afdfbc5ba6986a93a0df5069bf2a2654674d6eede6e59747eafa05b1cfa7f9d46e1d713270797c4d7f34ebae98576c953e39f9b313816098d7888866f4d25aa9a8cb53a1fc5dead192e9d67ec3b709e351b8e7a994b53099ba80a34ebdfa2d70d29ed99338eff53fb2ac3d15557095b8810948db9ec72d7c84f715fb0363da189ba9d19af039a3acd907118cbed0a69b0061e2695398ffd75e1a75bcdfcfb697ef841566eb0f09691ecc7e77cfbf8c9cfda2d8aaa9d515054a3b0f4bbcaf922288921f0370377400fc103ae35156c136c8eda76cb4a93df05ad2d270d779a9102dc497321f870566b9333ecd58f79f792451de330715792b47ad5252a1c464ec8a6be09d936bb14292e97b4dda26ac3b3ff3f983497b3c7f5ef766564cc862a3b978d3d019037d59edd312246d87eb302d947d766a6a9e53f1b99e361dec6afc1f90bebdd93b047b5b7a0bc2f19dab48c9b7d5655a0f79aec5343f202a78c16fb0ea09b8fbf5899e1bef6bba6cc0d0415636e20e5b76d41455cd573a1d26209b35e1d0cece7098ad8ce288445dc7afda18b563c00e2f11faa52987b9af55448ae27c453c599f20668d0e10ace317502e3cd7aba9fd38c6b37e481cc1bd509c5f7321650bb828178a2e116dbb5ff23eed2459c6d2c97a4e39e63ec93a1d8ee4c468dd11ff882bbaae786901ec00a826761ccc8fc654ee3415530c80ddafe6ff028cfcbbd835a46d3da11876a4e9731a6a1bba863d5b4c1615c36d5cd9a7236c85c72369feef3c6eb0ccb0a0090104ef827d776817cf1dd148e4fc8a67bcbc9ebb97c8f1ae1c1ae7eeeb2002761b5d4d7e8e7fb0171eaad162253959b5119c51880af3aeaf3a1da5d49f1d1636768703c76b35b6c6743b17aac82a077360fe28659b8cbdbeabf96a5e6d4d817773c4c776c2decb58c11d60bf431080ffb3ec27cf33a22ec7a1a9b4474e388f79d316029026e5b4e8f86b9632a82fac9cca49528c25e45ff538ae7b9890fba21575c1d36d550a6e54c2a4718de4b78e8f845e4fd97be340e73ef815893ac7b2bfd873f627efb1085249571683588236ff2d79ce0d51dc41b155a299c72947a9fd30e479fcbde7a1372fba569388ed6b2473d4a38eaea0fb54e608cff7b1a47ba8a923a5838071878d7d83951048dd08301fddd484852c0af1fe48cfd9f6b136ec1552dd611667e0b19c5b99980fa9e1d40dd9e83c6b8d726860693dc8fc5c7b7294c3ade95ba41b7768d2cd3b637332ec7d20a06bdad296861698e8e957ac85cf9062f7624b88be04abf3ac729de93bf13a06c66830b89535e40d385403bcbcdd40e7239e984ac5556206b46d176200124e1fbccda2a39786e117f2bc2e7bb5ccc405e14991c82b1b375b9f0986f99001ce2111c9b12776c95f60d3c9f792aa1f875f4c9f7b3d18de21e872d1689e70af30bab4b6cf01d51073cfa8a130c608099308dbb645faf66228a51929298cf8fc5ab08b22f2f073112395b02b4bf5327eeea76889e014f9bc8e311ed00540a1e3560b462c1d64ff85cd9b433cf8c4e325bee3329cad7103028183f04a38e276a887637f16e23718b55351bca3ccf0baf80d171c4cd2c0764a80461981ead42cd9d69b895e355af093189f6fc5d28","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
