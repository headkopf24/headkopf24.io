<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db7b1fa9de3d5d9deb34730b530bca3c9058f6a1ea445834a26b3079e92bd72c1c2386d7bd7b24b5dbdf0fed337f0aafbd4134b71cb0be3aa002025cbd48a91318f805f9ba5f8b8bee5d4dbb9e5a45bd81990a881ea12e44e5ead8139d1aec562c136c1de70c3889dab3b8e927bfd39ca8b2ba5baf31dcecea924ec3261f38b8609ed0923cb0fc70b4bf94e66cdb16920c77eab0dad5e1c1ea0a78de5ed62f45d0ecb2052aaa1f037d9526a36138a5e6447df18633e45073da544310b976c1ee9fe4d0684ea24091db6cafc604e050b8dc8e71de85c9faef4f814d4e32bb403c31317c861cec1b17ee9d53fa0c508e471d47dd3ffebea12ce959ea480fc54a3a26f62200374b7a55849e7ac45700267fcc0a2d3bfb110165116e248cd81a2a842ed524c86b0da20657c5222c32bdd227686c8569da52f0aaf96c3ef5e6477381e320f852caad1bde14411c558fc62373dc951dcd4f34173ee456ec127cd069c0847b367cfff92b22c2c99432c4bba972db62db5ad713d8e05a2fae8218483d908ed9e1abdabe6e7fa0c64d952eabe3518e53a29631b7e7b50a36e8e1d41569ee5127f43e42d5e5b5b1d982b81ca946acec5d3356c9a76b0da001fca0974a7ff4a2c3245c09dba3d4c0b2d29d03cc24575fecaead2215dce9e0914edbe45357eb50d210002a308a2122113b53b562a3eb01fe30b221c87b1b9b03c8c9b7dd6f3ae87a672cd272e2377e545b22294ae435b7304e1094692a92cd1c8b9dc7610c453250ec4f8db9d5942ba450f422c7490c15e5c6f50c7dfc07269c40b8eff96b1ef02e9ef4a18762838195c8df2cd8ceb6f5d0e072884bb2164514c7ec595073fa35c80c1e46ea31343ae5002a1dc3a25c434252c002c85bb24e75f8605dfb93c835213b216b4e496ed5ee56363407b0c6274234e2004ade44aa74772092506399b1f18357296b94d99e80bcf6cde68ec3e27b116cf19e90d0b7d8e68900ceaaf9c1e5cc9a5587b1bc1e5b054819863173065b5f0f7e8278f1f61981bc0efdf0b8da69f4197038ffbd4878a3c3be290ff7eef4a2a5b54b2f8116acae4cf5bbf958b341b57c31200bdae00f458e659a1564f612fba437d81ec9f0acd8091e6952e04928d130a96f7f3fc66ed47f562cee3698c2d51176f9e97a87cee19f727c13bf7a69bc11e5bbe9807cbb1e980001d571e483769efedc0fdd6f2cd9a1c20890bb771a0db8fff3b754c42caa3a7a84df3d20a5497db47a12b26ac4329c257fca0037608fb3236caabce873718afa59b77671315491457d89afc07ad1ba1d53645670a99e5770479f62228352dd53aca62fd73b4b752777e1db9e364d31d453df7ad71be8d4975b4e0d95a51207720c9436cc7416fd1084fe7c56829d39ede85d6fe40c944b21f42862f7a6b6c554f94443004fc191c01fb47a4d196792de27567f8e2625de32dc126a9cd735536163860eb07084d5f78e27faee8f5e78d1dbd03bbbe7122e312e8d236653fe88ec955d725bea27b6dde13fa162c5f7fd7b26413d1ed03eff6166b03116bf4f4a9da5f19b73a8c79728a49048c024243b34d7c4d19d9aa211a61940c613fc957af5761c06a70706e1bd00f62f118f17cbc8c913cb4b352cfb184e3e84e6f03ea0b1a191484d280f7c33fd84bf73f433aac1f55fa9c1c193e5a8003a9136230c716f1db9a48284d6673f35c75f7d3f5ce3e9d15b8c6c626322a490626d3ba4a3746191e0eb1001b522e72611f6e0fbcc1f34b5dc82e46e06f5e074e6c8d1ae4722e99a161972caca626d22b139a9ddc92caa3c888bd126ab4fc8d9e4c9dea42ea1f2aaad23fda676f519913b2379bedec7e00f3f3ffd8d60d716aa5855f7293a216a14908d7270e2299c5c3d3426e60346b8b0bcfdd918677aade8e1307562de536812aabc66f072596538ddc462d4941083dfedc2717e492333b42b93d07cabe5ab15b2ec4e002a38bd0b7a65b35017f7a741fe44ccf31912b362f2aabc065ca3fadca426c9dc666b95012f5acc5a6a64331db8ea1b6e23283c2263f404e38d59e74f1df64cb3d46ed62b4a5a5fe1b433e6cb855ad0a8b504a064f79ecaf72ef123a381d7e6c53ffc31de1ac821a51189b35de95eb6512575e74ef6d6b43d4eefd18c2ed9392c3fcd1804c9e242052629c78a469676ef5e32ccb1acc816d44122886d6e475b84f8095874d7fd0be214915fb78793b9cc75c9b01d2da363473b7f32036bebd10ebd938902e8e807f04aadefab548176068156d5741208ba5a86b1c02beec935606552631383c8ab1a8349823c876f4069cd1bb6e3188113a5434bd3aa0f7232904b5285b583d0c535c60e0e3e9c93d49bf773748df31dab847e58c26cf58e83b9c839e310d0a13e75409fad7af1add6a64483c1a8655a691ebe45ab02d2e02a315943e6963d2a39484cda94f3a4040bed0bf197c7460d31d25dec20c958d35699404ae26e8ba142eb0c3bd2b98716f18adfb1428e7a6945611fc01ee7a2b6fdfe51e0511944bd939211e9496a907ec423da3dd098cd9eba523fbfe468cce4f08a099ce926eb581903639f617e3b9756a3b152fb87f236982873d650f00985657c4ba60a04d25c7890a688b5683f78ad15bd359d94246d8dedf415c9403939cbe272dfd33deccda34e5c524df3914ec03724c713a7526a8113456ac52949c641b14189f0c71617b91b707df520697456b4ed2a91da6091423108c36d740f3631f243fd9f4111f04fd3a399536203bab8c534a254a843637792d1b1c9f431d5f4b6e30d6d569418dbf0a48d009a62d51a37dc0b05b8389a591796feea831aedbe04be7f2728dda5a1ea1bc8fe174db6dfa85745831f45ef821d6791f971dba9d68b74e79bccede6bddb930f469dc22ad92c3921edb408e371d93fd30f7d3497cc1f917531cf56e77c52af9548286ba973887705340f8a5e3c55cd70243f1c09cb117fb32d9be12f09e3ac06872c688bbbc6c858f9d5641735df0325c5e129036a0d42b38329d1d6ea06f102387549783cc3d98727866111a8bb99fac5e71dcc6caa7832094b0a88917a3b88457281a688a94be817d3105292e0c863834b4e1740478beeec120dbcb9d371269daa76eb745833f2cb1792862957674be60788c84c82a28ca6b59a266a7386a261d159b14d3798c50cd1de46b7dec6d416af942628e08ebcc5ff68b8cc488e8331ea20560587af766e34444d64250f9bd5d0b8a7ad56c225b65d620ea1b5283d0f62b7dc9f1f8553ccf4f2a21e017fad0262209a34e206ad15080469795b543bd787fdbeb072828132509372af50908021a0dc2444d0f665695fb50de293b82c40b4bda8f945c1efa64f1e5a05d45c65fc69235a904552aa947c85dce05f5304c563631b28858bfac889638d9c38987764a365d460b354b7da7e6ded3705a340a8a365d136fb6d50118e5c448df9014934e722202ca76fbb946a06f932124a78d4790fb24e1ce94831dd8c9a92966c5a1554da71c94f08c79ddbcbad8bc8b640b783303e9511b6185a686f3ec2d04f86fa72ec765620c0107f49327c345ffdc3897442fd3e16b5fc5e5820daff9bce986961fdef5acc1cb3dde5eb382198ceb35aadd130697d8b00cbd5851c8db9c23349f4d81266423a30b24aacf20c61e9768338f7054946f298978d0e5ff06c3d37919977252223a03eae20037efeead76d01337f305a647cd8643bf38c92b883b24314de9d953268a70dee45586d2436b120566bac80c2e175d109e22c92575c972ed7f7e8db78c8d06ecf808e27785a4f63279f61ab21e075aff648fa233ca6dd5ca4e9e7fcd5bfeedb8f9ecea63a7e2a5af835174d2e37fe92f267e902d8bada4700d4d5d759c7601a412c1228f7f524cba9e3859b57b30238947e118b440b5a91e346601a0df39faf18ad021c1a86d34095296363f209dec584e612386ab400adae86a2fe819d772fe29eb2d3a62c0bb52cfd5e0295803d66c8a99379327b86210da86c0928a20b6fd84e5863f82d7d59b1be8d6efb590ae4a6b3d9af8789085ac11d28c4571053d10e832fe5528373a693d5f52b87d1c5ba44ff8abf0502d78b094a5a6539e94f509c7b93caf650f3cd2d8ab26c263a7e531800435d9a7ae676c1570ec5745f9c66079dd3bc48c355f3599b035cc80b07796b792892f92f4cd9c278b43a09145aab718fc699f8c30a0103b70ec8a5adc139a3b68293a64e1a82204744bbf40f63c0e232c1ab4302be4709e76096a6faf339dd2362a56d1e47a71a01321a9a4eff6d21ce96c2c24f8e2e4f3a3b65a0cbba72680d448daffe66df60750b981099c0e76124c4e62942ec737d53a7999bbcc8cd25df9bdfa3b2e995b6738577da2ca5b89f2769e2ea0daddcd137c78919206047c5a1d1617c5d4f0994930efa77054af966a46babb933dfdb36238622fba539513ff88f8e9fff98c2cfb47110d59c647735e4aa341bb6af55d6cd87acac477c321e4fe90703e15e7f1f2f1876e8d266069c7fd75cff89fe5cf74ffd692be33fe2093aeb3c4b8090dd4b1e6f083931eff6a837c2e7b2ae01ffdb828742e5844f2a791020391f67d1c314f1e1879aa212f9d11d1966545fa30caf42cbeb25c75d6c8cc6c96588aebdf34f9e8bcf0f9dccd3f39b4eb7ea5a594e31e1dd07b0bf4dd48e6548dbbcf7fa5d03c93fa9cd7e394de21caf85627249329c4b531a84a75012280e29cb1032a9c68be21ada490f80f53c743eb84fd14b71896328f073daeef9cac9537c7deffec6ed8e5c8448fddf89aef36ac191cfdfdb14f9662a26b38e7eaa055da69469ff59ed5798aef762b7ddc6f43a789766120dda96cb496e34c3eaec7172d8a4405d59fddc640553aa4fdd75d4e5fc450260da2332cd88e9c6a1655894d5cd25d0aac656c4b487e6c9449291e73bd79cc9040ba46870b0f6a1acfa116acf30151992b865c5263412549cfd403d54c58aa011bc2c6691c6d6d036e98208124c2a4713adf12304fa720303af530afcf2c67825f20e2fc4d5dae3267aaf030bf83ef30e6e0e7b2ce18d505f5c2122cb3da659bbd1c8434575eb32d31d374f0840873e246a0739f098b1d908f4d4bfee75e72788cea8feef152b1eaa8c48b50e625bdda482dbae6198c591e05fd4ad902f279cd5426ce43a527c48e7f150a72376bf8e28bf4feadd345042b2919b5039fa7ce80e5a5bf38fd77379fb40355745984888357492f69a3ec37cac2335ff5299fa433a4c827229241e09e3cf9f6d3d7dff87645da36460d620978b886e128decaa10e8987b522f5152218964a6fdc551ea699caaeb3d8d88c087ad5e3a06b7d41b2dfa30cf731fc4285775db463bb7e05738cd52e47595dd42c9a53d3f7a749cb2056a45c94b2595cd0deff585ca072a672c59952b174dc1fd3d2b0259b548cdd696620f6d6e817ad9871f1195fc3ade86ddeaf90b255a8b79b7e6fefb6f314edd098c215ca58c676a3906718bbe4cd97c26282abb7323eea4ee7b7816f33e472c12588f3fffbbb63f372b1a3c00ee2034755339a56a94b42a1e2f6e25511ed5b13f360e1512d765c1bc81b6c552f3d7531e1f1f3cdd4817cdfaabfc5d95bb8fdd91cc9e36db18eaf74a210ee936cfbcb42306e64eac4c2fe0fe6ff1d0ce6b4407f1ad04c9389a7ae8bedf295e490f734aded839fe384c10d6453cf2b2c8c05b8bf60830a132898a494109ddcb1e2bfba950b7983374901d0c8981eb2e1b65bcb8a90e904bd1285454986446aac79139b8678ee6c7abbef8163fd9cd443fc74cf4ebe6c43d0e4dff54e0a21268333c428a96b08251494634487ac966f944ee0339a4cce45d550b7c82c4ffbf9a30c2b6ba6224426bbe53f7750827e32195a9ee50574d91ce59dee9abda5c68605d523c3841b17eea4dd105360088aaf741398de36a04a8fb117ad6725692eb1856b23d3fd50d781f09c26b69ce87d2f93b1a9a98e03b1510801c44a518c7913214e0e73a304c44e5381331d4f33aba82598471fafd8e91b8a4aeaf52d26ab0c311ff2cf8ab598217cb0d3c58d0abe0b72a03f10eadc6c456e33f6184f44ceab8a32dd3d3f1ee40d0ffd2ce95b1d2c80bf8069c34a8c040b30a4349b25a75190c910a42484b19f7303ab6f5559eaecf93a58209fe892f7451afa31f35cea027ac378fa32af0e2ef41830bd30716d18b6980fe7a8c802ef66488e86d94d841d7bdfa5d13c6d950161ee900d83098dfa960593061d76c34b910c502c3ff5d1d5ab82543b6a43beac7295405f2dd52d7c42a80309ececbcc6c7dd8f05c92842c565172ed5961cc212ca01c2b1f13dc1a31c41bd7cfd0fff2e680b4760abbb6a70f13498a75a001fca3613eb2eeb62bbb8a7e702652c90b6299a333a802351e0fd7fd183d68bc9c5de194d8db2269af22df93f245bf0206e2c5399ec8f30625efe4f58e62624fec65b3a6d263819d604a59d5099d147c2f0ec11c298d4ff8b370df7f61aaf3ec76ef14bbce08afe2c50433fb573959b7682a1d73dc846cc05aac5594c6b3e533224f1136f387f222d6ad65c1334d2a3f15a6ca94f26946653cadd1dd1942407104184c63fcffd47098825c73d2a732c857f3738fe5eb27fe26107a0be1433d09d7a9b629d3b572f037ddd266807c85f367727df86dd9a757b1f4a1143a36f9286012e64f7f589cbb8e31bd7100de6c22e917bbb2939e32df20a3ef07f71e5679b428c5b59097ad85a9a37e7165b7999a9f8bb08283b193774ba58cb22a644d640d8879badf46c3c7d1e5e808a47aa931d858a4566e54371c6b425f25f2938d6abbf89d49462f4073a7c117d62663d36b1f9a72cb20d0f439e14ab9e315332bb8d270932477336fa45764ded386c9d5f611d6c214395eec807f9344aa1da520fefbf42c17ccc1f95f72f72c1c08a742e2bd82a7db9284459ba0114f09c3c6b9f7d8df50277394b11971f571d6db47f8d5f0eb5c4b9ef65715601c3bcbd2e10c2cb85cf6d9a7ea7e82460ec42fe037ef96424364f5cef3f9ca8204119eaf43f4c90b82297dc78eda77715216419f0befd5bd479f3b4bccbaab5552d8bba88ed65f6c7a5fcb016f92f19b56a723fdfaec13efe20bb2c8ea06c4c0f1e07e135c131f607d2215148f5936a2eac430f2009bf8c42aa11f952415ee7fdf7811a37fb1627829f7a7fd63e69be79f90fd7603f5530efdb445853bfcbe8876ebf52870303dfbb700ae458dedfaea67d6ddce4d93ab059fbe69ace192be1a575ef8cbafb7f1d997411e146dbb4d5b17193731fe592546d5d38ccda4306b985da263701282a589a23e3d11d8f9a5b18321e78c8e7efaa14f2923a027721778791a7a585c277cf9f061da076ef761ed39af0456ff33f3a0461b2e7ab9e3df555313a86a8e82dfd5d4ee10c11833b98d9f9f1741e9e8f31a81c8f7e5b4a2deb897d5abf66afebb036208a3c7999dce6c1a793de1c3a00b373f1e6d2b5589bd874b637b5db9cf0ac3f85ecc4fe03b9ae23f47a0e4ca5cee3bc2b9e3745afd28b1bd28c5feb3e0ffc4c3c65a5679c470a11bb7c900f7b408fb23626904f3481250bad16ed7c55254b67af82725dbb64b041914096564a83adcc496645ed89356576240aa677b00c0e4a06025d5447a76d0aaf309a69e2c4976c3c4dfec992037cced0836e2170bb244c3c4630dd84cb6d92f33a80bbf600fb58efff3e50fa25765e34cb4b614413e4764fa84f3c7a4e7397fb4243936b3013b23d73b78b3a3b70352c901e27e00da305a327f3a5846dc2499c6eb588b38e94fd25a19b05f9c52624f30e16b88bfaa3e3ff79d712477f1a7a4a5d00f87f28205db847d8a4ded34b5daaaf7873edb132511399a23c4573871641c638f94bf59f087a63638166451c18dacad0f608242a717741f6e4e48565ddfb294bd519f4abf8406887c291aff3853ecc2d921bb1b6a54c21ab1725f955fe9e3fb7372f67c0bcc2007957e13fd88037f21741b110635c1937543973997cbea97787d95800835ff3aa560c32046150f9c0343286c809501ef6bc0b248e40607f27bf6262368293fbdcca4396976b70644eea8c23f8a5ada5a6932113302d2d238f89815d85dda733eb37f8ad17547b7e18ec7aeb1c832469b1f82bbf33eee90a17ceb46ee66a01313c22043b9451b07b3b8f9a86d4c58dbda969371bd19c5433b00dffae43ad727f725196f96b63a382e8fc37e2232533e71c251ccdc1102a918c1fdbdfd713901aeb1ec7a916381ebeb3483b9bb8e4239354521abef05dedfd8c6ed6550817b4545e6925dda1be5257e28f59cfb1e22337696e8d2beeedffe5ffafbf6640b560f2a2dfa700864332d1c8507a96298925c213afa64a3b2b50675fd9984b6b14343adfb0a62a55832b212dd5b8d16a92ab3abbc49b9a4a8b31badc9629dc3f71ff93ec69cfb2237c0b3f144d9f90bc0a38f2b7e4b4a3a902c38fa46fc31e84f712a6cfeb6801b5e81cb85eba8b64ad39fc57b1c780d0ddcf71408d8f49f1f0e389a49d45af9666e66ec575701f250bc2414cefa8347e3b13d7548d54823aeab5d69c8532b77020bdb859713abd986b137114ff3ce5a31a6e7710ba13addc9426ab34d81c14eb7c2daaef6094708a8e27be2afa04bf785b51c820e381a66e733e241fe3b45ef5b3c02a77b6d9319e3d0c7f5a2f8e020ab778b348c3375f7c41df379e54142e23c4c945bcecdbec55c0a549fe7f79eceb3036c2297da66e4428a2b5f47fef2c738098c2001ac3a164a15edb4ddcc6fe694c43b0c4851d750a6227bd36f4a85c69147803c07c281ecc333e2dcfcdd2b00d844583a0e16cf7a797e7c76a9ec0b6e200a218035cfc29e56223ff740f8eb867034f3a1a524ef7f3500c062a4f8a7fe32f7d1f947586764015e950045db34a5548e1de7d06416eb4153392a5135b096a37c2025505ba5cccb50c329dadacc37f0832ae6fcf8cce5149dca0f79ab1ab5d042a66f224ce92bc80f8f24e4ab608b7bc9ab47ef0c7cefcd6ff2731860ac6353867fca345dc1e71b603a829280b5e145e2236dbca3d6b5fcde2b18841e1ae36f00f35ce65f1039afae9b475e2d063da3369feb50af58489bf0535ba77f831ac24956214929405d6c8fb48c16b1b894029ca972e67cabe1a886b24df8006e64a086fd1230f25143d08035c92cf52d4d1a246456ad1db96cc1448d85f584b9b2f1b0674b2c4c524595f6301c6214fec4cf12e6204d78005d91625abefb09bde9b6e9b194f6f0287eb4424244176f808541314069d0d1c4520931afd8901ec10aba21da0b9e6a5755116f4edeaa6f5d79d2eeb05ecc91160ef41e6b761f2dbdf9de2104282fa996e784974c774a7dbb1dbeba340de8c6d5a4aa660c28fe68fa5a91fb0496229b9d28c83349513952e642d04fc9e53f237a688d1133513f42d7bffd2015b7a8e0978c041a839f7363cf61292ca521196a0a6f821d935c34779b21dcc8962b6db19f9436578dc17c36ab518d5a53034a15b50d706c81d151312d83b5c9ed23e59e32418876a905b823c02916e2a51b33008dd7256d0c582b682437703b9a850effec52397a55c448ee7431bd9e409f940e719ed58caee08cd4e9e666fb2d75c359ba4f10ef5a9f603201c1fa26c47fcd032f5f1f584f0c5166ad6402d4cfed2d067e64a5bd31ffb109003dad5f5cf7c4893e001b1690ed85d110d49ba4008cfa3c4cf78ccc5093e6a3b8f86d2f7edba95fd9fbb14c4e67cd65f59ee072176ca043f1f6b1c19998bedba0c0a7af7a557e201cda857993f71d2032f0e372d6873fb682256f3e0a938faf91795846ba10c6353736d967b50f46bb40982849b9107c8ce7ded57c98ec2f0914610b74a6361cd06ea3e67aa2828209b1c39dfce584a7f20178c2e923e2721fc82953267c43e325e369fb17a6e63f195e1e6792d95021adbee50c6cca60eed7c84ddd5e14fa506764b0ee29a69679aa0789a2fd266216328eb1e0ae06f23f7b1baaecc66e06e91bdfd63a7f805ca3761ed35c9946628fb4e64673347f249561812cf2a741531304d82a8d08977da844b3a4ce7fdcf30123b1fc991cb3abe8456cd248ee4d9cea4b66d5af6aa095ce964aef7b50df5738c3fa54b420a444a9c9e76d9b5d717a38eac0d05dd1de3ac872a54d7a2a88fbbf5b66f931ab105c3f822be9fcb61171975279bf524c1f3c5f1e12645f17ef6018ddc82f28bd531fcf206b321d01eb38885d12dac8a1cdb0b4861721f5529b96bdbbff5313ae6de8ed1e5589bdbffac1ddddc8d05f119297c97fe6f02a9f5a7413d5f3b6b5e8e3b202868d78526a7b7077aff3ee9c8ebf761b1618fbf8753876ba8e61052f720b7b1da87937297e6fb488514b3b2054d95a7fc3a2a7f3e83118736053d2998835d26fb4f5dc7a06fb481bef6d206b53792f85a812bd5b1b58569ce562659c372b80cb7e1916f45eee81bb0df476cf030ab47d9018e6928698871d0a0293c06afd3bd92def484ed0ada408a08a1561a7480efa73be2a4522145acb05b7c9554d9ca7b4fefb82a02f67af7d725f0059af8aa0ec52dca3e9c99a72d544edada8a3e9370932a3b593338f4f8e0b99640b9b463200031b7cc6f4cf956f5c30eaf40cf996c826c97e558af76e2e9435814a8bc9d1546e12716f0f8982a967b4e0701a6c0d676c2ac61f936b2a3554c837f9fbdb791f19728a21bc0695f4260e01a20119c0d4a991de36d290bc4cb2e5c01f0cc47e620589749ce2f58510782a4e98ca825c6374431f6fc07da811fcb1c679b5fc35b76408c3bc309bb29384466963fc94ca16db409cb26a60c38aed6d530d15a7d51e0641ca256ae96139957689f6c35fca1b5a257ce3331f821cf6c799486247c2d57fbf699dcc7b0d36f3dfabecb532755219a06e26d14d4d9919fe613e79440417b3ceb79e1dc1c92fe33e6bbce97abb657cd390899077f2229096152f5159650c0cb3f7ab4e33efb8a662ec260a8c9d5e8f8ff017849773cad16ff052d11c2073d7640540f83f0bb84a225c72e7481b53b34c72ec55462481ba2b6a13f215f8e8fd06d163b429156693776fa328dc647ce79dd7b5720a9b0cb4d95a3889b3adb4f35f484dadd8654185bdfdc57e282c9afa99972b88f9dc0ae078d13a9d53c8688e78f07fae3658a0376ffb24ab5495f697bd2084bf81dd4866af10b8a56a5cdd6c65adc97c150b89fb25ee36dbaaf09ffbdd56adf7aaf0a4049a53719219b38427e6eb98cca17aa16a8134193bee292ea6a9f1cacd98b3d0395857b54ffd6e28156ce99fd457ccbdd4d94343fcb0b884f7f47fabbabec725a467831547e3005cf2c18111c1624d4c3458b2f85882cf8ce438ad5d0cb791e9234691c24d42d412b975199e32d1ce4fb3c3a776aba036b298554d9ab3be93ace1f78f97d82ece14908870d75e98179492101689b2e70b333f1878d3cd1a4e116d60fe01d3bda54163332cfd4746cc1dedcbdffb0cda5bc93043f908ba69c6ffda3d602c8606c72a597e16822bf3fdd2e2b832dd1dc34cc1234cbf271bbb69a7100cd96d9ae43fbdc6737756a58267da3315fd539d85a68d66712ca2830665b5c8d106cfd72f88091b73c6ae2ebb6269b28e8b3fa581c689b793e905cdf53448c8f5592e4cb25d41586f5c96cd17063445ad01adeffe81d72db543b5ee100d79bd6b160b9f6dc0e0b681c56cfacdd5f0377584dd649459c27324d01a3b8310f96fd83d50339867b0837d6acdd4166054e6a9f3e573a0544a845e20c33bc75bcf22ed9f59e84126185f9da905c7020120effc95669591ca3cd306db8a2bfd23a52730d4d9788adbc6e121dfd6d8ff9cb9d9f2ba5c90a5e30f0a876b3db6119e4bbb45396c62914195071ba9386f119af02a8c58a30ad02489796b435f23db36ae26172cc1be753b9f19722fb9bbcf922f252114dc4a5092c287e9d249d9e50d74c7578016328b45c40d21a65fb9a1b0c4811a9ed7ddc66bba93d47e696d9e801cd016ecea6da58b65213dfe62e306476b0dd40d935508e3f82cdad42f3ffe68d9ec78353822e66a7b965f61c070139b740fffaf3e77ef504b79776fd1c47fa2d63093e25a8be9b310d1e56cf30cce10937d2b0fc090e79104ecad0c3098b17c2250cb631b75936a67d80d2eba7de7279eb7332221016bed5113af891a10d11bae872d67e7f6dae6d1c020d53d3bb3c326088ffa698b8ac57e9fb0a797d6146aef869745bd3d1c47dd515038c280d3b36127b77c0cf5a7147029e82c1d92fc41ea2da8a8550fe09b5fca2d378c2847661bb18e5c0054db391ca253aeda08d12428a8db4718ca4c242335ef25a4e07c1121760f0c1a38c07fea476bb8343070e4f6e7600b4f86ad0990a58c7061be238b72895cf1e6cc8fe8f184fe38ea30865213d83c60af089b53d1798066a1a13ace717b17238b0822b8bd45f4f074549440f67e06ecb61f01aab1b6fe682ca554d80d60b8008041586c050103484fa79796bbac347b996abe28d76d6a03c6711f131e509b4335aac563b439c90b393c7275bcba526f493314dc917f34042ebb6371f3b3511429c7158bcc5e61dcf23a000b72e61d583ce0ed6043ecb1f83d4e2801de39efb385a1af067ba01e82118ffff51cb643ae2a6cd0b404e52bd6f7e81c21f1cf5afead1e3dbd5b8f5f844516f464d86158720082f9189e36efcfd744e1675e900340f9402db1fc96d2da948908ac78d09d667b13f0acec594bfa4fff85f2d28c5af3a498355b1e9c3f09f2737e1b4e34d1a95b426f5fe6cbf431503972c742c2e94f9c81162a3dc9475a67ac601b023f8c763c76f05bffbbfe66e740e83475cb9429729ff0d685d2b904dccdba0baa8545a6666d1ddce9834de7127fa8d1877d43074eab11d459978723a1b4be7e2364c6b9fe60e7b103d06923b7de780f3502039f1f10a76b3a7f49c97ad07e1ebe2a4d2661a1af72900477b49bdf633279746ca3f47e400d2f8fed91a7704a5ffc16412b694852c761bb973a1d4dc4a4aa56ffda7b369cf1533b09edb1e1f1e9e6218bf4f67ce2b05fb4a64add72f5a89ddf9b6f457a6956df707e058cf59e304d4ca0fbe7778c0e47c22592c9da17154855a1a99ae0f49efebd7817326004fecd0c6370edfe98748ba8fefb150a374a1717d3062293d7aadc72c33c59ec7704dcf955ec577763aa95d3e586bbbcaea5ed1883946ba0cdeb8e4d1ddc4a1351eb17108cd74e8fd5dc4ca9cdf741c3683a4821d87fdc6901bf1e6e022b7e3e1e13da4f179e6c8338b3528c0cc10fb256f78872a9111db81e2feab957353f8ca362bb8ffedbfb33788338c9e9b00230fdbd03a3408654c037ce02b29ed0b2fa7cd2c068895ff58ecadc787653205126b2c0f591b14a2e0ae35c30fec484f00b5158d9e52ebd759a063ec290b624c915f0b0cfaecd13389b51d8240a99900df196bdacb99c018ede62f80e734ac607a625175889c226fc361d18d7f9fb6c1ff1b90c2654ed470005cfd3d0408ae14b0daf8a7a0712f228372a45209a3505ebe1b1e44fba897bfed6cd4a5b2e4586b25487f7356c5aa45523e929715741788b390d5bc00706b079dbc5aff094f5146884f84fd96a598a5674b8d0f0812409fa5392809ae8f11f29b58e8f0493ac3f8eb93e563d69b248445aa55d1217a3650277c45631cd77a8444f6b2f49a94b6a608a3713b1aaad9bf57968822c2c1b34c7f93a103843e546e1245e73886aa533cd6b393297e45c33ef8325b8bcc1b62fa0093e0289385ae89d3881f57f941139d1db75fc626057a908ae249eebf58ef4841e033e03e3cbc6d88212e74406ae919567b501f937123d3e1158dbab6bf2dff02a8452328282a1312a9778b6543fc081fd45cf8325e3a39176030fcdd9a4c7900c7eff33b6db88be1ca4c187adf86b6afa6b9d660243390a51986ba7fdac60bf91d8c748252075264b73d7d8ae8adeab6a932eee8133e1e54e09cf009379caa12b445d6642102461f6656dfefff738183ca871f5c36da9ca5e50e08f56102001002b7ca73085bc209188d57c5fbb1543895599c09d32fb69d2c755c290195a2337d26f86c197add7da70cc3daa096ef5f60a3ed7302e73f79e75e7e2db11d14f2ae682cca6fa558ce77f4b7c14aa3bb254605ee125dce602a00a1abae553ecd5a00e78cab9f1a7fd49c9b0a5342a3283c9198dd2fa887af17b54862fd8c6eb8d89265f9b3f086fca580326a59115ef85b684049eae42cd9c8752382330db76734d3241368660ce0e1f7b4fa0909e974e38a7a78c3b3520f177595f8d1b124c2e93bfe7aa9d15268cbdc280a5c1e10665c7d43fe999c5254c89dd300c488e8e3dde505cd70108c3add24e6ab4adc9e9206a62f7417eb9638b425d2285a2a729e518ffa3f6db3d6d49d884e22363c8d8705c8e4282f9367f69cd71f94230ec220d5e41dfecaf277d49bcadb95fdd0b0d3e05a48f836275b7dcb4649258b7f722269d8b9f78e6b0bf4a48357fd69baadf60a7720255f7cfa3e3c32710526915974e02703b5d75203b70d58183018568969177d574768edaecf37073571ff164a06386c03a590b8f875d6f750598e3d17a1557290c187118df8f968225a6726d6b85f59555df656783543cdad152ed4208c16799cee2c4d5495c4383e6ac20b43e7774b328a1b7c109da1e727ffbb84a2a2f9173eefa1a9beef3e8e5396135d09df7db602b8a4119b6a0c799db675c0bb7874d17b0b988e0333a86f5554229ff4b12398e5b64eb85e6130e2c0eed13ebbdd25302449f0fa7134404e6d359e5e5e99bbe0f7093126c036448d9ae6591fab4446fdc346a263df96799484f8da2b8acbf530b5efe88a0d56fcb25ff5390c636aa495e44293414dc4fda3adc297b435796efefa82450f71d561e3a337b121778b1e9186bbeeb3ee4fbea9bc2ffb829c827fb53901bc5eca076d393fcc969eda82c72a874ae0080e003d3450bd02b91dc202657897cbcc1bcf709c1ea89d13dc193cdb3e20fd8b1a227fbe49021b4fbda6f505bcaabe6cc5382c6ff4eb1043cd8d878fa079a7aab23c4549a6899e99ee948d85ed192f84384384cd70221d96072d3dac30bd8096f3802da91fd63733f134cf55589e9ec752edd02de78e78035cf2f08eff65906fa205073828ec2ea04c09e21188aba90c28b1fbf1862b2d13ba583d7e2edf6013bcec061a7944cfafdf4ed8f393d910272b61b3418c8cef0a48395590b315eda007e17a41d4251710ae0c0948f08f1b38931f0a60d006898fc622da487b9cf0bf408a195f83c0b06fa0fb93bde900d1bb319457f0dfd3a15defe3eeead54cadf4b61f99a4c37172c402835edcf72d270edcc3247ab9fb81b3757ab8d418feb40ff51f49341cb1fb594a3327f52d3f4fe3aa0dd35ef6be7a38d06ba6b84c697181d6c39bf2f041e76740d42c258f20dc93c01789c86c9300c9321d6b95b46a252e7cb0f1e7561e28afd710799868d04f4655ef66e02135e655af6cd7ab762fffc025ec24af87061cc21283550a2883a70e3373d549b7bc7d32708d21cd8c4ca4e55a88b39e51d759fafbc88d848c8d7f6813ede714b56b1f0918f404c8312b1753829760c96022ec56ebb9ed3ed729b181a0326002d50872143bced036b3eb85c46e657ebbf097a83b736729aa35426ad87ecd74263903244d1ff0ffb5b3c53880f89b88063dfaafa1a4ae2e535d4e30f51f8e67ebf242ffd7731a2b6bcd96bcc2b83ad9f74434b0d135ac4dc88702dd47c36663d4aff019d83a8d96f01c4778e28ca4c0ed453f4621c9676cafc4c7addf25648a3601e4ad365c238ae3fbc2fa2bf4314ffe6e9cc44061f1b402f24d9121887f7c81d3b038b43dca79238b92a90837b54dfe542b128d3acedeba3064fdf26dd5404a444e4bb90ff18367c88740fa3209e312897aca6f459f442562d77632300b89bdcde0103275cc43df8722993c7ecf58223f9713a4b784d1c001a0095bb44bea40150087594d7950265e775247713427f4be4ebb929b3d8475652a7f887e1f5847dde84192772c1a569da30a880fd9635247085e5f845777ce67dc5a7efa2e4b97739ccc03f9c38afa4843f0076a1c8baca9d71a440d335cd5120e98820c7803c2f5cde627cbf9ecf2aba4684b0e26658547a7668784cf784fd35bd619a9366dabe5d22fbc7aed79b84676a5ad856b939e52aec9aeb7ab23cc2d9e2d86a74ac24af7d4b46d847af3ac39d93958d6ebe9822b2129ff3b0e1d0c99626f7ad672b29ab9eef568227cd4e3fd7f542d098868cb0bb33307e7a1d533a16c83ba5ec1b21d7b54488de20312340927cf0b6da15f14df86d161ef4a8218bde338ff3d34927117afeca4f309e1de1efa7a51ec47fe337a63010c0221b71387314ebf804898d87199bd934f204cfdffff9e9b01601d9470e4a8cc4774f92f8370d9b52a185bb190b5f090f6a9f30ce883f7d56d2aadb7a57d6d2e7067b942df1c549678164b6b847327426a72425364726cb99c9bd137e8ff7e0e6e6929136bf73068313426711286a8f7597e7c05be9988b7ea89cd1602af1e3f91cf02e079c63f3c8b2cb33c4d1bd5a6ed45999735e9a5eb84292fbb72e80bbf00098bf40d9e07378ad75accc21a3ac412a1cb748bb4f85c77d1ccfc8e8faacd1f9bde1ebb59d3049d2aea16d6b153e795f19d8d3802ab107f9000c96eb7ca800e48535d2f4fa4644c6a88b630f5f5a4a03fc3287936414c2662b10562b431c3017070aa5eea44ecadbe7b09b60fdb32676f25129086212fee2a4154a638577857f37527fb0d55a7924c85fa55be43f0ab46729edece46c8d1ebda4efc6dd2101e524f5047bde122f91eabef338a7326a6fe70ba1ce6eda795e0e902ef632b3988b8966e9613a8c4d15cd5b37580fdacd27714228d353769e989279287c446394c8e5f6881bc2b03e217fad744b36d6b3b9b9a70a9695e19df351ae14da460fa6f70809e8ac5939122f251196e087d3a16c3159bbc70c93fcc388bea7f5fbb20c11d35b3638aa5aeb03039c8842ad1add03ec34b452b6b15dccf9aaad6bea5be0702d34bf7c2832a8a80c64f715069e129981bebba69a34ca5cb48af321357f679e50a37d50224b6855768a025bae633649bcd5d530a9e33263c545223d2866332aac117eb233135ae5916da4263636c6bd5e7d90ba99460452cfbca12fa385fcfaa972856665f5cfb79d3029010319bbafbcb2862816da58824433a87a445f4752f4b3000a0025afe8cf696f9d496c333bf5b1ea17a2b312556f35d380b506dca3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
