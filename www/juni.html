<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69b8cb47f2835788ac0392c77649460e0c83e6c40fdde05f6b82e8721576526bc6cf76b423f27e59961ef9e3e6e2a7cfdd6500bb6215877017b930bf44edaa9cea616b791590a8b741aad8acff58be2e5a15e7c146409efe7043f5235039ca9ff9b7f75405fd7630c0375bd5e1b009809c799bc722ed004d40d208d72927282c70ef582850ef1f60a8e616f59bd487529b1443638df73bc5c44cd98f97c68fee63a283a3feafdaa2809d632a4899dfb685619b165237ac4803b1ec2fb272228e4090ce94b1ebed3952ffce4ec57355cec1958dc9053f00879dbb6cb808affa3dbd0df9b30e9843fd73c23a628bacc0a5cea8cfbe48be6f50601f0d10abba82c7078893bd91194f0edfbddc5fc3c2b522d0316447977e248b3bf702babbad0e49893a276a250841611b24e1f30ac75a960c2bcc66297d552fec6fac252d7edc4708eda2822178b5c8529c1a2141a11ef56e9f372d26e46bf9f8a99654e38982b74b61632470b554c8b30c05af54014af5eb5be26756e800b28da3e85da75ee6688b0b96a294516545bdcea27187bf4738ae7ce25055a93e242e9ccb898a5c62ca45ba3845733df25806a0662510a06261b939cc1b992cbefd7ca07f6f7bc00d80d6071e857aba427b1624f4439135b1ad18ce87e626dd7de24621e602acace98982f0b4d832c53573b317da7ae2947bc4f86e57b2f7e8ca3ed5fa140de44c4b01715f4f1eb9025c2045b01472e433a12af2547a60f70392fd0f9adae083134e70c88c6e430ebc2e5a305245e95b27182e23fda6744bef682ba36faef684d3cb7a7eb69012e9c57930b2fc685fa61b7ca495f25ebea97fa742cde03e050a4f3154d4639a89f382c71db3c8ad24491db8e1f933bd558c3c5f28c5c1f1862f587bbcba2b5aaa052b4b26d29ff0da133121e54ff85008367363e854d17dd0cf4c6b851b9ccc7426371af902d0c91e0d614957c96b95c918de6870e88dcf0f834aecc5d37df03aaf1cb6beeb47cc6f20ed804c96359c4ab94c1b373e44e84ea135d54cf74961df2af1f988e23472eccf0f2aa80f297a1af0692beb216bf2a61380dd68c380e18a2328c0b4804dec8baf92fc538c04dfe5dd7b1247a5c897fc6922fb2bb65da976906fa3396011248516d812b638dc5416d52e2ac42730e963da2d12eefca150a8c616524de8cdf7c427c30641fee3809efbe1e3639be62164b889d482cf8eeb573fe5d1042fad9d88a7c7582eceb7c11a954b07c2c36a5a02a25dedb762e26636833d1aaaa2eed3f275b2f87b8c910090ad8c3373b3b86f0a1eaad83f2a307b9c96aa73c30f96925dceac329592e7681ceb404f5d700238e0dae6e9b05cc5f394bf7b48adaf949fb135ea9ec62cd0ffe0dc5b28fea252cd2aad1a82abd6a83cb5d2104309e39cfa8819f997c4b7b3907c442b2a7f00cdff1c9a8898ed8a7d8c74d33e9aa92318ee52dbc9e80a5cd2dd11dea9326dfb83075efb04517d2dd325695a27dbdc045aa211ada809475dc2c7e7b53333a57c14c0f08ff61b7a1756b63fa9fe00e6cf6f2c57ff8cc306a912ba4b378b70dcc035ec1a02288a42d110cd307112aec2ab6080bbcb15c9f5feb26f41ab36c9bdc526ab59d98a43524ab137a2fd151655ca611c43c3efbca57f54a7518370211f3e6b8f4fb6a4b6ec078f86b9ca5739a7b64640757ab23ba38421739ab110902931b7ea64f6615b6a41764a98192d6feaa6ab41aacfe5637f818ca602e9c1760a3d983ab18cba4c4427bdc43ee83ad5907270632374899d9a0bbbbd9342069472a8c5c79cf758e251dccf0b773097a84e64f23a9a4d1c2944b5af378f3a6f47c11a8abbbaad8c6bd104c752ec78cb376892fe4723e9b8a1449934ae43f26140cdbdca0108bc9bb95ecd3b34570945aadaf9ac483cb0f606790a5e7caebeca412ea7aee29409fe3e0c3899c60c2950a375e8263ba59fad5e536d2130d5fa6d2c7a2877cf9b5032a554da8c423b158a04706e50054f5f90af72b0309e53a82cc6ba8e34cb4e045b03fa8abdb470f0b9b1ca9eddaf27250e3e26268d174258d582396991629d858e24d72908b5ebcf5affe3179cb0d83f8a65e2a2a82961668946132a4961b7621c3312946f88ab0a736a3f3b7d096a483bf2c2e603cba47019c962e7c4dc6a7b43099daf37fac26a9c0d986de2e97162c678ae4824c25c59142afd70e723f64e96dfcca85803e21324cb5fa2fed8ab64386b3bce0f271602430fdee5c3bfaf651670756ec4fdf59426be020ff588d4c6acfddbb3e2aa72293a3d02895c8799c8094fe2751bd8f149c30b008d6286fb54755ff835f5dde018d9301af858eb6320d56128ff6440c3817ca960bf12fc979aeef776a76b70be7ed6481fe33c58f6d67ac636f7dc63a331a6f22fd40ca571739b120e8f54ac8b9516b7833bac4addbd8840184af0a192eb87840b4306436facdc359ee049cede6bfeb960828fbf7af3953046039036bc17b2ce1aa6cf84f462ab2a7dd927dceccb9c82394327dc0280e67c19cdba17b7f8cb78843ae206a5afad437271db0023b5d3ce9c83051d65e322de6cc7597e69339a87ddf677729cac61cd8791e72adb5eba74bf7d1a3d2070cc8d6805bcbf9cbfb4ea748a8501ba3b29c482585dfa6fdf3555c5f45a8d8574942eb21bc6b428180e699a3ca532c8cc6b4c2ec4ef1bb9f410796bfbe7f92dae3a1a42a6ba754019819c76c4f6226ab98b48efc45309294764f2886cc940fc87a512bfdf895bb66e12689b2e2c5f167bf4aa90a1ee48911c5c11989c1485cb6d549a74a6e3e6defff5eae89b5850eae3b9e54d887507eec01c31d508d17bfafd3c4502a2e2f4f5a6bc2146b948ba1580422b86e19ebe7b7d813229fc0855af19602c201386b58bbbcbfcd9b70f4d99b0a72a86d4f019bf6430615535cb69947f655348004733efd9fbad53efa78784877e97437d174511052b0e33607b53c7e04289d24b4ba686e9e40d2ecf399681b214545803688fbe8cbd684944f1a28b5b34bbac3b5325cc62589c3384773806cffc892e6908d25316f0f4aa327ff4470289f8d2550420709aacc93f2db1d150b867f2dd2235a95ecc0fbecfc304a161f41d9e7c50200d6901439e5f5ec2d6577d04e61f80f10a48fb96f590bf81c70277cf68f618e559dc28eb5247c07075b703c6bfe94f8b0e115cb0ac53a4d7ff4433a61dee3a16b9d6d25c00f493e54f7bbc69fe055acd644b82a43af9e314d9bac7b436cb2ef88f99c5a1c14ab2793ad3f5a88a6fa6f224fd38e24ea12912ac71416da1414a13a3ff11da31a029fcd84df21696ef4854a53ab6d5155c3d4072a770ac7771636fc3ad4e67b5c8a85a1a8aa31f9cb5134fdea6471fc9c3d6e5b74a178222c0575d16287d2528f0cabc7b576f4c7f8d2e5a60d927ed1a8ba04f16040f3e522ad9c40a08cfa62a5b73b3904a0aaa637e2a737864bc2992f407e2343e25f8493807744cb296f6ccebeae0eecef56b5eca13562d9febecc4678ae973d769d8e85e2694b5f47d6361b6359ab1386a7de030d4bb964246a6e5dba24bd5eb4de03e0b60443c58294691431e288787fab58c32eedde56732a98b1a79ea7bd0948d5cf8757a86ba62fe6ffc682716d93af405db750eb5467279e573ea8bf1ee51fc173a6bffd8f39630c3c595f6402ca18c855f4f34f5002e492accfcd1d8703b85f0a620702a0744647d2da6b5ca113e1c3a021dc131e6be22d6f7001ab8ea6860ba3d3d32bd87e8f5b7ca9580ca7a8f239b21122d790100d835ebf78258e0eb202ed728ef9c11d29f9d85a7501e55ce65794d8d8f9305b743fa3dfeb151e9c6a19eab8f28381a16084b12a9e4f250f18508647f38e14e9b27fbc783b4dfda97fced86e4f26d7786006ce0f48a75e55329ab7c776f7742cbea315e7ecdd7d8de3897cd7b9105adb0effab2703b27f6fffc2d0f13809abba502c4bf9c6487bf72353a3aa692d72d7ba35dfc0f98a56e312e7b7668ca80454534ef5689b26e3643ad60bba3e764cae9bbc8a8f401df4f418e813d7e86576d359ef8ce27a78ab98fec0edd33de8f9e559971b9fd09866a2e6e3846f0e6fc48e8af4d45349cb5f6198b6a1985d23a081132c1a5d733fd90dbc8ed4d4e997143a67a2ba3f571fac370cd784c59303661b2fd5c3c403c8c7ccac850be1151e6a1578202f482c85a4f7778f86ab681b198655ef02bbddca056b372e4c385cd52657415ab5b20905b71c3db64c39b15cf3bb698286fff806f91de7f1d02f527348ec218bfbe1d11adab0a6ba58a0a59764acd4196255236161acec1474f0ec90d06f7d2178200c34f12ce2b65e637a36537365a3aa88d6b76311c5a801bc1e86d404bc87708cb1e4436fdacef8b28870f54f5c3868b86dafc6e30ec59e84f7255188845c21b6d1f2accfdd1d011927184848f8f2beefc4d5fab11f0cfdeeb6c00defa50a2331ce09dfee9e06d84b5f96a7fa34b0a8bda9efde2e158f6a50f6115bdee0728f4d541c796ad5d94a3b78a33f14407c56164e8eedf11d2d8b0cde51014adc0df442860afad3e87ecffc52073ddd739dfdce3d43312caa18e4ec143ca23a214a812af83482bd7e6bebcc19488bec1d10afde6cd486c941954354ed4a9375b95e11bf3cb810171cce02edfdbe6ddff18829673a8729eb86ef3156eb96777d8f42dd27a197587def20eaeec410177fd09cda67e20b3e8f57665a2c8b19ad6bb4f44d2371be83b18f465ed897fa64303b6589fc43b6ad4cc7f53cfce393731194edbb80e15ce8591dad2a74d90bc790453228131ced7562401563206e26916c414fdd8acad51cb87f0b51348a11e19c5ae941b84e8b101e24c55ab112df884b2ededc2c6a1b25865d3ddbdd9e7f60359003458b473fced94710cb41c596f5c6542df6b45b54fe8a69caa0c105be0adbb6fccd912cce19956cb7f14c54b4dab6f127e073d947e698d585b0b14456d1d9b98042de72154a346a5315e7db1becd210a6875ee77388bc0fdca97dedbda558a0ba29286ba3a7ac44659319ff05027574aea331f60b882f7d41520f03c8260599a35e5416d99616ff78d6fc617fdc1ae3b000d3ccb4f4cd7dc6899b41593461a59aaed774750d7ca2660895ec5e65d1c2ae13506395431deb3a85e6f0d193c8d79ec9f1de1580c4e66ca36b17771f08ba388e5dd27c10b00aeba872c03f90497ec95032eb669b82825490c82a834d1f3a4ed5e580bb7747e2bd4ccec7b63bb656b9b57593312138fd1c9c4b8d53d0d23c0a55036faf595a904901d390dccad1be053525ba6ab15cb8741073d23cb8f619ed8e954156148e3b696e9d022c063ee86203cc97efac5e6221b92c9e10557afaa9d297c16380cf7723003a355fe41d4f031efa859785809d586bfee3a7e3a5092221c686daee3449d41e621af2574619a373a3b13e89ad7fb18a501ed9b52f9b16c3306c99b825e6a48aef94152f73f452df3d0c6f3ebf15eccb3f40f2ad7a330d9956ee73131d0a680415c863772a60d9e1d546c64f1b85a93eded7f8f5df4940a3756556957e13dbfb1fc1a6cea428249415acc59e9e115769af40f959ba50490c6de7237bb83e4b39a0f5945dd99ea03a7d91fbd4f0251c97c64821041adbcb937c7494fb36e2e86ed4484021466a5ca53ed082c0fad65303018cc88dd2a88373c33b9d2614b82bf9c5b4722d49c2c86ff4a1c51e78e39c91256812f7515e6d18a3ccd83f657f0c3894bcc3c591d185e41d7754a0106b8d99fa435bcbdf223ca81af4595221e6ae9293d62dd73e10d873eaeef1a092243c6cc653be6c1ee519761679afc9ea3956e1b8059a9044334bf87152d405ec2881cbf428db088e875408d2583e0e96f86284ed3485501ac93ba49afcb2180c1f7877091c1cb6fb0099cee1448c164eaaeeff6a0fb42e75ccc2890ba22be09327c2eaf8a885dd23d458dd2767efc4dd0d84eb996328b1c330d8d775ce391477fd39b02e3ad611199a2bbefca5b593723293a25a28f7b7560673f48b1ad2dabee2861feef16f5540e89752158c495adc98623d252c4237ddc734b5d581c37b680d5d03a38ea8822c2acd46966c6a7648a3fea19b1539c9e83f75773c431756874d321119c50ada4813b5cf69bd2cd6f0d492657c380d3bb0b7d2b4d61a072c4e33b4f8a5a2a0dd46abaa2669467101139e11cf2ec6c96a8b10667001bab445085bfa6c93f6e30485aa60c03f77c26aa5760078978f93cb36441101d4e88d6e6b70ca5360f54dc2dab9ce6bb042ff9f8835c5a3642cdf8bcd86ba4ab6083bdfe456b8e77aacca462298d8c6695b6dd66405dcb9b20104e6af7846c072ee136b628e68afa9852cb2af941d56b672a9db73d33e227928d6f86de3beb78b0df2f81289f93e8c74f3616b366d812fba2dfc0dd8f5a94f1b4429407f47b85b3c6c31cff15805a54a8240aaa479b083558c77587860340ae57c55d15062eba0512d3e010a8963572add60888123a067c9bfa5037edd8281068cf3aecb6c6503f9a3dfd571e4945d79f8495ba4c58c3c4747fe1ef432e713f376934acb2ad0f99921cd3bae1bd53a3d7beff2c407b0daddcf0b87ea13e2b5f920657a86a6ba6307f4daf04f57a0b4115ecd6f7cd946d70f1760c76f3711835cf8a360b39b1b3e2588cddfac1df10de79d97b6fc969d0d520afcb8706db92b9977181d621dff6c87bc432613e465c393ee183b4ab986c6fb18b0c2b14a4844a7410feedf7d94e08a333c988e95b039bd00f1ac9600283a24a08689984d80141e1f5d5193694704b4cc7fc786d8fbed8917872870c3027889931d398e35ce490003293b16b86be7d4a1a7ce990ce3358025117666a8ba92dfdc07d88f575cec7cd1f3643f3f231c14159214de847642a10ac82769739d3965936f29f0158fcbf6a6f6d2b04e477d8ca44688527dd007b08c741b0ac075e3844e14e7998b95f998b3d2c745dbe0518b37c14c13072a5a57bb88a12f20928665a7ffb5b2c2a3180686d3432358af4c70ae6109e2c0bf3496edc72e0cfd6c804d01da5089959ac1bcc420035a7bf003e8f91fba9c401b33c9a8a2ab6798bcc90411b3a96dda2da87b305360882c8d1e3dc77fe901bad074a456ed605cc611d80635edfba2d634ebe9f84041d78719aeb1b40aa397f3423c54cf9a38f88319b8fdd7f1d429191c2466060aebf311e7ee9955872891183300dba1de489d17b45c2f6c9b571b6ce586f0b4be20e24f044b2d174daabda6b33435cf26cc27f4d05a5fc4969341ee9c5c4ac21c23de53a897d730c3762ac5460b63ade4b0d1ee9a1a61147f2988e2a1df5cbd2a54256e195e834664ada7ac74cd830cd72b8b52553f8b5fd0ac608a8ac5d1f4df723a2c3ea07f5e39b9bb93a48ec1efe1b6c50e03d42503e587dcb9e2c3487c9add01d04a0a0d3c509366936104905901fff48a707bc50116d78839d9bdc901a16a4b40e03ccdb956de31ae8b814490ce914c893eccd7b7cd230cddd699b341c17275af5d05355443df5d88ad5541b11ca700aa1ebc09231f0b7b3933baef19402a1a2493375563e0e904d39b84d898c84b81857ecfa5bed31a54f694cb0f341a2c989c75f036bb1df46362738a601d7c6ad41a80cf691cfe386ba9611bb2ed84859ed06558d792c6665a82eaae6bf0027d4c16fe2b3181da43e2b792759bf2fb854d3a4af27e7b2ce2c06deb95b67fd154abbcd29450e6d5dd31557431c1f00a2295aa2ae695990628b8cf5f1a756b184623ec7aed9c01ea9459a88ec6abab9f9673c4075516d8742baa1a77ba0040e0760fd34ef6fe91a2b7e3262c33999f85dfdac653ebcc46761bc7fb607dd6d833794154e7cd9217e92fc116599bcc8fe290171e5e1f8c3ec1f97600246678e35b71cf65ad385a3600fb045d642c296e5829fb82463ba2893e8e71bbe46c0c146e984e50bf2e2f69aed958ea493436cbc9616b3b67a7aff6ce823867e3fe4c79be5b793bfe6f5c8e91a43f28a0604cb4ee50d901f876bd11e2f0e60c67770808bb1fbad58899488cb24f9b1c6ee47234f4eaaeb193509878b9b8162dabcd045f06087f8980fcade263e4ab2af0abd56f1e17aacb8345440705d9808b217fdbdaef68a0099a9d752aaa81463b316ea33992ace1997d68394a4abed28d72144d8f98bd19ac390f11f15424caf239c0ddaff51dfca6cab32901d2a50526f58a906dd4e8323fd0f8ca18cfc7e429c5b035e33cabe562c550c76a7ac8c075016d932d0e942e5fc02cc19725d3934b55b5957b7c6b914de0072191956ff16c22e4fdf03dc27a4294dd8fd71f7bdf8eb9d60501fa67d46fa68b493f1568ed8e765ec20d4240c5ec97a6e7b693dbedb3dcd85767525e0c74fb4a2d50d160a3fff8af485994234d8598267c4b155c81843b796598feb3d5e604971ee45c1cb2c8411104bba80bfb44ceba5da6a70af82bbe6de6b7e486f1b5b2b3ec3748368662ecaed6d89c031aeae9dea85d173b709a5b114f354d7b70d79af25fddb42a1e586c23295418e55d8c0671b7a26a4bf7dc2c46667dec5876b7b6f40f2b148a69028d4574a1323fe7401e6587a50a9a858db61acc523ff8854869301ddcb63610b50c4ce6ab0e4689fcfdef540285c13aaa89548ba1f278ab4fe7bb825e97ff7a6a61636dbb5b2e7562efdd90bb80c72f30d6fa88765a10e7bdf1ac5c7b8bf8c6b28026d16e39c48c1c7a62fc54494399e19e8777f5e840aa85912fe845709427e40fac28601660ef1bd0ca8e7a251974ef097e652fddef2c59002e7b42364dd8a2535fe61b1a8dd7d04d4d7f37241104a66e94eecfb2312b732bd64cdeabbd2a1727176636b18839c52561a924c6fe6e8bbde69511f57cbd6ac090dee4438d352bb4805483c1223b56a762a171fe26a58777de9bd8c4b46a461ee08cb5c0980a6dea1ad31f089c5d46b44458d1da86a024e2711cb478ed40716356fbd8b4a7794f3e14a3780c8d91c30404d81c4bd192a560be189ef44107054b5a8fb01572a78cb27f42d44305fbfc285a0b36866f479fa70a6c557580e50c627eb3cb5076e072d855fc167962fcfb6ba2cc9aabe809a588991c01e235af9d722fe5a75cd0eeccf09a511b1d2b07b9a6d64689f3299b997979b14385f6277364350a049acdb582b2f9d6fb471ff7162e6175eb55ea3a8a44aecfe3e9c20cb221d97c42c0aa9f7c9fd7e16d042eac43c62c00de37884dbcb143d269743def347b09fa665c71d7cd295e97f1580ad712088a493610e7943952693ac409a8c791db3bc59533a88eda3ae16cf39e5f2a5f9eef7096bac226348213bd112cf095c042642868fac5a43ee4bd5f735e9982efc6fb2a6fad5260488cd3f5801877b258c5abfedcb90660c7d6e731370969ece6d46d67622c5f71274683632c2a780925045aeba6374d5403a788e4c92bfa6a5c01df06cbe032f33d129458a699422ca2de486728ea052b1fa3186fbd8d8b9f3f23a5e50d73ff5be5936fc740fc8072028be1231459d7a77520461f76a32716bbf007996a471463355fe7dfaa8c24bd0f24b316d1f83ac9087caa65ca1fed74ed8d0a370bac1a04c4b317db2f13e2650eb04b342499e56b13e60945d6795ba5fb2019be180a82c008ff213efaac2aef58fae6426b88ec9d881c27c8ec1f9c345608d3726467341d14d5d98e8ecf72c2393913553483cba8d412d7205ef7ee1c8157a5a1443f36e65d51108151cc8fe63cddfa78fb476b5b081d2f8a448fd00101a2c146ed78f18a519a9fd9092d9df4004ab5b4a7b32c65d01da72c91133c78330bb19b9a65b40c16caf32842082328e793380fed606dfce282ffb968f81b1107617f360b2ce718b36ac86b7dac92637be2391606d21050d1619295fa6f8b75c8b570ba887f882b7cb7326e28023870e2038626acbb235d8760acf8aee04567ee15820743c6a886780f9da35eac7e78cf08f1b03752ba0cf0a8d7d56553c87b98f6694154ae0e2b45a052dbe76b0621d17cf42c07033b61117fade337277e7e2895fa9d66ed0c0295880b7359d4c5b4f1436a1394dba799f0d997a6e957325377adf956511df45582fbcbf6739d187695a49b0ab8f2e25b80af755a52c3d789d098bdffddb9886452df1f5ca2bca68a191768841f25d4d11ba131c30ecdc1cda40d3af40c243850c65106d6d19dddc73426f15bef57990f3067de5749aee39e202d01b9a2fbe83d55055bd6cd51ddaa12180f86c848c62e1b535184b54c4413beb8edb151570b00e9fda64d4e3ceced31c7c89b3476b2549eae728812b1b116ef718c45e77318c3378cfc57849ff461da907c17f379d4ff316cafb00bb30b718e2d0eb3bd524caf2d00a4e2b2282b202a94d8129d50e0d60ebc9ce9c88b49e194ae252a9350a4cde28b816162760e5e0234634b43c320a000117f6f39f61fd148f4570351563b20c360b2e68c95f1403dcd0a147c10d72626f90137843c0c6ce6e7610b0cffff84aaaaea76bbd0fb7764037167ce6d6acaa74f7dd3e994625845da717e884aebcbccbb59b3401f949ce7e6067186d7be3102e29bbdc68c9844d97bae03fce4f50350156c3d3112eeacf2721c827dca4aa74e8f9902e50ffc25a2e37d4d244bf070cb237af1933f5c5e3fc4810310613b9947cc08df5baba1450d9ac98197319a0ad265d65964997857fbdc4bea457a1653cc133d66a0a635fc24e93a9d4798336766e5950ea23117ee668740b593666c11bcd623eeb1bb11c88c07e949285538f5d671b1d8d28df9171e04ad93a137269b019e8f7ce1551bf328bfd84301efd4713cfa0d0677a70e196d8d80f07a85d4639fcf6f175cb500ab49211543b1a1fff6e0297ee3ef77032d6799c704749a01528e517e74f70d2ff503d6826bdb9720aa7a59d619039629f6f973a744cff353e60e59651233613a411e9a326b234c67d84a253a00c812303745924dc8763af5195454c7e96c388dcb5b7289988efc1679944580eb332ada1f65fbca4ce5da540f63d4ead5ae82417c1d1db20fcfbc08324f235657746605d55ed1c055440146ebd9b55a8e107664968dd566277ed94d04368ec6c7ac3dc8e05a9e997db7a640d5fdb82b4280da57191e6b4c1bdfc3442925298b333a99a85a3af56a15d0c02c96ed795e46ef1df19b6358448efd759b149953cc6ad7a7263095d3ecaaa0d1e5dd9eecaa3e4dd1d91dd888cb28a655a94025756b5d2ea111d793826ef1773852c654f16dd6d2b2ae9d4288590a185b02706cff33b163c9247a4fac5b2b220d193383978e3bbfac58f34ecbb64caa2a67a1334dd395dfab0303dcc1fe5d5dc8fab8f95a52e5547cd3813196ab40abc84fc916f96aa472ebf5950870e0500594caf0acd475ce49aed542b2f977f4844ce0a736f053136e00a1b442b3bb520acf4726a71260b7df9fd2f0f970028ad4b522ea5ce63177b0dc632983ab7278d29edcf98a4046fcb27b1a7c25f37c2d01f2098eaf29708daf5f5363e8f302d357b67e70713251b55bbe1581702da3eabdfa2ce2ebc3620a766875122c8c28056bc084f31a43ce3d1755e07eed0bfd2d4f51b8fd36e067b93388676fb5f5dae233a0a184fdde9961599460597e18ae2782b664f473ae1a286882f0edbac217ca9c811121c5f2bd1ef71d4e34c6fa25755ea3902e84d68cb56326ce60b0e05dc3e3551606c557b2bf4d544c8d94a09e01c6c3c3c22723dbfd5a5aad19c9e498102c600314a30a848c64aea7b09b900188ec30a6808ecb2ef3bd8d51d7e73605ee1b8ed6ff391a296b57fdd7fd82cff8a90b606be071b24b1c1f7ed866d84e96f2d7eaca9f6f0e9ffc130adb2774bea5d50b24a7491ebecebab350e49cb8c69b243ef6236c11c4b42f85df5bba736b2b1d9cb58ed3ba2182a18718eac393ea7d81b453bc25fb0c64e785ffe80f0e91c4e967142c5f8e21d7225b923b11f257913f86c6cf818c4b988716ac6becbe9804c3f05eac287c5dd96298b0fad76a4a1ad2fe15244345d38711e207c3a4e5bfab3fa3642640075e75a891b0180b1fe330e0573af0dc389db2d465dfa7b47e75ef331a0cfb9524a1f30c8f72b850c6cee7bc94c698ac99f4a5c29cdd37c400852b84a9677776e910f4b54aefbea9d22f6f59059644e16ad43725b67fa9d964596f4e8273e62b7ddd325cfbb4a49ce633b30879b20916fd3c9a2a23bbf3ebe4204397c7c4a01e5519018813b23bfa720baafd176f2d1d82d6c4a202f8329fad0e3aa270dd47f854c84e1d1b576cb47d20fd457cef178ffc14e0e10014a85ab4cee1f9f181756f8223edb98deb77700912b352cd68854f3fc2b22bb8f8e5e8820939bc18b94af3b09eb549c48855639e2890067779ee5cddaf6ad01a081cae43504d878d65fff553b1080ba073cd21f8b98ff7abeea828fb5ce62affea6487d85b816581f412e9e7326953fc0dead01c8fc2d44ec4230372bae03f20fc2615f95733d3256f591fa96603e29fb0b23a33adf8ec08e30358320702d6823d1db380bd87f2aadff300680b260b8b8aaa2de19e956279c9c3ede04541bc9c815d9fb2869087119a1ec95145649dd377a23fe74ce2adbf9e6c847049bd037aca2b05c4db68e834628ed8c31405a2eab05f49b0ee1135c92d0d195ab867c226b761ba2b765c9711fd330febb483af370fdb505b42e55faa4960467931840bcb11de1e3cbecedb02bcb47f7383a95e3c20e363800d5b8b53e31c5e31d8f49743914618aef61199332a94a6d22d100d431c3a0bf81fb2ee3c53da69fec34807a7b7236146b875167430f40e4f893898f5c4cc3e6d84b8c1e15b096309963322781f4efae69bbf07fcee010ba10c73bba76c826dbbd1b7109a786d6b3723a306dbb3cb155e2efe4ff5997ca766e10bcb21d589aeb8e1e5b993b3c09e37fb094fe111d9daae3e226bc8783070b411517b4399e38d05163daf1150610ff4820e886496d5236ce69f4a34ec9d7abdb99ee77c7b41f97c0a68c0d1cbe1c7f73313cbd7c8b9903ab7f8b215c773129c960a828dbda6670cae060689efcde5c8dd5d3968320dd7841ce1cc04d858dd7fd3599f3608687068731afdde4bb8d1404341775398b7e60d8ecc7a21dc2d29d678d0d00b027ea719e26e239f8f14688939f09edbe3b650b42b27f19c8c3973d745416d2ae8fb682394b37fb9159932f71b40f6eb125e9a239eb700cc71694d947d67b26198af3b2e41014dbbbc46af4984d15df58e372cd7537385cf5e2e518c0eb2729c5c5b0bac0865b9b567194f11abbab9306c1d355a61525d7c097f0960b1556d647a3a539721e1b35ec8627d8615b9745cafdf4b7e52aa2d29e9fa054b119642abdce6514804e0abd599c22c0a9e1124755207beead1f9fcdbe29f29b81519b8f76239a21e5483dad1ff5332ce4086d595951b89b9970a957342cfae0a47143a285da271a69602aa1be8830233f188003dce7c0ffec140da38cb44948bc9eebf9a391a1f30796f337bb36b7205ec410ad606ae0996a3db40ed8b569eb5ef1c317b2dbe9ba656a17cfca586e879744b16a3b58729ff640d78928cf34642c99bdef4748a8cc7ad0e3c276e186aaf9ab46d3e5c2084630fc3f350b787d87f6ce1a2e48c8be519a8d9abe54ab7917cb2fe77f659e870fc138138c0b85530c3853ff4444768caf81b0fc488b72cbd4bfc23630977c06358b9048705618ebd7817754909704e21833f302bc897345b1b11999c9d8b6ed537ed2c70556ea48364024056bfeb85da4fe43b70c9db4b02d6b63f6fea94b4cfb18a7aa6c8aa42a50f87f9a8dda6ae938eb2ddee385862d292b2e15424eed93ac5ea13897d1cb6ffee97aec04ca6750a2183cc704547ab89e02fea9cac692cae867b41bdf69a4ef523117fd08aeeb644234445e54892202d58aa0d3f6bc8f8a182dfa1bfa62eb3753e57e547d12e93271e8eb4ae78ff781dfdba229e2fc60f63b830ea0e0130b2a343b2b6056fc08a250867669b86a6fb2f55873b08b93d2f497eaf83c74cc09bd2a45be323f2d1bde4e5c11d890028ad195579d6e20c5033f9b7ba20e8f3563acf528763e123e01904a336e455a2004da0a001dc80233336acc1916e8f6c30734e8a07823877eca59155f5626a64840bc0ed357e436778ff70f8694e1cd00d897942e98cf07a262418faab086291f8b831ce7bf22d9dfed9c534d2634e0d23071f8cc943740097d1bc085accfec52697ca7118b8189f632b96bdb7fc933093e0ab0b194ed1fc116801e1828e3d1b13a31c9512a5622ffc37e0f1736f29ba3adcac40b85b6aec4cf5066e58c3c3f41befd16f53f618859d9dca280d1020d31ddea3b8e53d856da59088fbfaaa789c787eccc9ebc31bddee8d922c11b23df44b0def85c20954886dd1d9836197369550c1a94bac69e1624fc8332493359aae20de9499aea467dcde0e2a41fd156cc9b496566b64c1233228d24165a4b97b2fde2cb484d2066d2b3f1abe4a5d1bfeb6c19d297ebb1611f123b9f2986041d8f0873f91834e6bccb48deedce7f4eb8c315be2041173fc2cf0623239671d72e26627b3588e40fb963f405c278bb5b91e38a31f3ff9a040fd0e201e08f148d07ed22f915aa6d54dda871bb2b0f85ed0d9793ad96d4d4f1463daf5a5b3d4bbcd69e4c1f55f683a4f3e20d35d138bc253c4ce7e13cdfff932782820eebc5c89c4659c19f4d9bb6ae7561778380d4382e99e154803c9bc47cde9e226c8e621b33cace7d924d1f4a7472e78b77841efcf41e262e5d0a4f4b501dc5cd46d841c467cdb9401a47013f4fbb755b29af84a8a08acf2d5f2511c4a93555bb07fda150ec972371b6821362ec90136141e74eb7a29c7df82405a0ad35a9615f350544486b1d9d58ed723e149214af08227fd91abd4bef2e1ac83f266427b5e79198e777a117a11c032e83ebb1431ea656edf95d72644105a3a27d4e1ff06a888a56381ecd1c348fdb558518ede279f150cbef16b177ad161074d7a5731b87fbeaf78ac45238312c76fdd97217227b1582c7ba31d74b514d44a419d74ee8db8a7ef973c6f23df4be1ea332f759385bf6d38c8311136ba33f9520f7486202c3508b3a1d88cb2d506a91ffdae35adf1f3e70975d9283aed23e13f19c113e93d9379eaf0a36c3afeea2252808efe5192d0e8c838cd77b7516134c7c7334f00bbab1df72f3c6dabb828785b5f78fcae3a3c7f29ea99dc8418d0c743e33c1cf87597546fe393f76429b44ba99361d014beb77d8bdb1b82934d63953e175b511477b897ed612582e51cc585ba201bb2a87ed0ae22702cfd1946affa4a0ae98e2054a8ccdb61bb2857cdf773d8c37a40da28faf5b3736a7f6ffea098445ba225b18eea18a3f45a2044831d3af2a2cfb5be443643c30df8fb59cb4b93ab7973034340fad1d2aaafd9c951562a21b25fb614a73ed3229c4d4908a339c675b0800028b2701f662a1c5947f240acb4cfa9efdb437df5dd0cbc2f8cd839960c48db097dfe06bb34b53d781ce77cb0b36834afe91c4677e2dd04f286774f367699b99197341b5b39193fcd72ec90242ab2121bc3a55032ae5af463593c3b0741483ec3cf1f296461cdf93f28b3f864309824c058b96c275fc7b60ed12d8ebe5fd856a0fb86bc36179363d6bd98a7fa9ab9cbb597dc0d127637183c00dc05fad3480c8b02e233b750525198981d5e738d7d8688bb388f7c444f5a1d93549a3bb9c18a45437f9454881a9ae7c75566ee0626c1f665fe422a99966b5cb76f3155874a79f607b0b06cdad8c379c1b35bf0595e75bf885c94bc5c05fdab5dd8e07730c9535ddaee35e2611fbbf0d566af23bd838adead8c4eb112210498902d2ffc73028ab13c4f69ad433ee727d2cfc867def0af8498b74000ab72a5d215876b33e0ca82dd4f017564dd1645b109b01fa9d00af87d74d4f8a16d8fbfe5c17b518973a8893b8ec0692833f0dd2c2d2c9dda2d3894d9e8c6a417bcfb31b1fc409d9299e54622f6e17eab929ed8944a1d9dafaf916bdb1b38da8960add1974c3e9de88cdfa1d8d19b1df95eda21a32f020a580004b673b5d0cc64e92184bdd343eb4e7542cacce8933c0172d874adce3fb78c00a27b44cf3c270848f7e14823eb2ff6b2c59cc8bc99a61cf57b9e112078d1dc36ab8c522511a34fb51ee0c7e59e8e01cf0671772587b42cb52c5d6b26be2a2ec48555cc449ceef402ccade4cf8cf37923394d8aaf81e3598a27486dbecdcbfa186884123537a22def63377893aa956e673f7a45fd0b2ce0b5236edfedc8446a42b49c2a9ec16241f308e6d0b78b2c22460eedbb40312a618e41bcffda26fa8923f09a821b7804aa61d5a5a9c6fbde837022683b075ba0bc1246c008970bd56996176a9859bdcdd9d26b7e112df8c2f041411930418803bc0c00f4b4fc8ee733deb26a864fc47530650e63fb0d78b7fbc6861f7f2da832bcbdbe1833b2faee9ad21c2f5fb3c018acae3e224ef48a6c3fc7c6afc434f262697d18cb879a5f9f0621f6f393cc695dd38f577fecc65c7dda117cddc173020487b1321266b68f8efcbba6eb116736c8782ddb44e422b1566b93694cbd869adc620c71ac7b9fa0c1d0e223e9a6b94f2aede0fcf6e24d5d60811634414a102dcddf525641fcbb03c662bbab6a6c8a5d4371ddc0be8b58fc5a7ae01a6c53d57e6cf13e553736f78a4bf98ef087a60d17a132907334f8843ede2f41ca8b02faa28c2b6b43c24c4b0e77889c66879eefcbbd60b5cf1b730f099777ec5dd57b9f0f16037db0bf10ad53e0bbad5649c10e90c8373b2e3912382f917501936c9cce8c80d4d8987a6b23d453a1729d074358d02b5fba185abbc4c43bf318cb86125dbcc6bf5c4bd5cadfbf8e81329b99acdb803bfa71bb464963f05bb409473a418562c077df311b371c63c1741be2b5a633637f21346703058b5a6d31cbdd76326b0daebad6874f244185d9fc24afc8a540f2190ea355718b5f371483bc9a32373670bb14c8d367a6a8d29c28f47d708e51b26eb36f305520986d84afc4db840bf510c5e1adc808f3008af0af2f9c73689d09d99683b20d403c917287941168c851acaadfce32280705cb4de7a00e27eaec6635e71163f8a5fcb9db63013f9981d9db88276dcb8a71b47c3eac290976b593198f53f0c83068a36eab2fa8d2540700da8af337c0e40407b99f4391052278e9cf0f5521cf0c07e7c14a12570225cfba3d81ea36021391727c9765d3c629a5859b1c6c0e5e0e482d13ccd23e3404ebf35486bbab4118d8be34b608e8ce5db2c1fb3c061961bd80ce0f1c24f25af0d39ab328449045f251f27a8cc3457f5042ba24cb8a136783e2b819af94a594d3a3d255d92f41904b0ce31843bd5f916e13df24ec63569ba43a2b5eb7da72d7622784f8df2194031611694b50da0ee15c420937105cb5923e5df609bd3aecb2ff9195a38043b1f4c58eaf0f5eee567311c1856c08b21b573fd23614c71094f11697cf2f6055bf8cb3e176d121478042753468be39b25f182a1f17dd101635320a7d89e72917aea3d0d609324018a4ef5336ac7785486f23ac78f0cde5e9713aa9071e55d85510586d1448738046511bb4834c11127028fc5fb8ffa854928abd730105f9ecd4eb2455a3d3503d0201a9acfb30b6dc3f97537546aa6f2010330b193b5d96710ae134634a4c0e8541f8aa42c09820d7bd6b346f8108e9519e24995561e422203d72e17699c3197c2db68babecee0b373d741b40aaad217475b6e36e3169d4c40f7ccf6078f422a417c15d8aa605bde7eb0537190cdc5a4f3660d2339b7e00b698752b977abd8c72f116718e59b423614b77abd1c5d35c92d3331d4cf8e4036daaef9a44c10095e56cb5f9db5e50004b04daf41e6c3aec132bb83c2728c7309ed78cbcd5ec012dcacba50ef154aeddd7fef606ca2917ba14113187ffed151e10fbc19a44cc32d8fa9a6763fb33776e8d86502393169f13e869d71d1fddaa7156a95cb5e3f92eb01216f96021199ea9f39cb7efa5c66554f1477877fcad3a74fe63ff23440d526e2a6c3a29f2b5973dec00d5007a1b19dd6759dfff78977c3d7bdfb7677e76d7290f7b5ae737ea054071fe6093b222aeecd64f06d72eb1a421d91e64b0c4649bbaf9543852e41a40e6a7e3a0b9339019bd8403bbd42752b7dbed0f7a6cb90cdb6baff2013f67271fb67abb21e21412d4a4df3c0ebb50fc0465c63959f586a3a54f9f825f9eeccd9688b788073ad70f4947284b5cc585d24bed0137acfab13373384abc37a7a4db7c30c7a9c298a9271c68d5fa2c1e5f346df93fdb82b6d1c099ca53637697e4d1f4329de17f3af6fee0ae6a9070781464eb8376193dafed198114a156e71bd054c514d542a9065abd108ab084acb65f2cea19079df0ac03a41ef864a7e5b884715f8c277197ec728d0535d5ef66f7fc5120f26ce092c6683267761a8ccaf3fe656653269d4bae3b48708fed8f90660feea329d6f127e05423dd950c7457e5b99df5a3cf01d0bfd96a1834c4cf1c15b6d870d0973913983b42591cbe88426544f8126091547cd60a9090100fe72fb9b83f89c709defcd7d9ca9fe932ef96b1f121a52f50ba2b67d180bea65c41baa97741b952b093ef6b32c68fd4f22650836a8e2d20afac7c8bc7fc5002e0d8031c5d36c341d2e56d4786553a7d44025f52051b273474928bbbfa697e01bbd34989ccf863fb589410e0527a8fa5d91457accd27cf238aaa0a8d8b9906afd3c0bea44d6f3733cba378a6b02c963c8f4142f719c73eb0eb4bdbd5e92e5dd5f0248d4e1ded5463893fe32f797e8946468f9111a9cd004246c2afdc1520ef87387204ca547303c989dd7c42887db9c6134b904ba5c74e1a2fe7ce52e37cbb3a38e3eda29582a2895f367170d45055cd02aac1a4ecf280fb0704ec9451e0d7802d1239011fc1b8f1141c0bd8a30cb58c9b782c9f2d2491581176bc705622e40633010848a85ce2570155c6adc90e01a62a6467a50dc434a842921e97e105dffa932645381cf0c045d528d8b97b195900989518530d85b71e62978bccbd5ea8f8978da256d5c7b3a805ecae162c543f19250f0f45a67034b79518b911a0b45c07f1c322ef19492","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
