<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64b7e074a03c2ba4a9859f47a020f3950eda0c2473f902b88df73e1d8cdad63285060f2a74780de9c89ec771eeb38303b335c9050d8e737a3568bc719ed80b3dd6dd7aa4047c0853f48b6f264c8eabb32a1c5ad259ba1511f5e3caa5d7956a390f88300a3d1a5fc1e70538c7eb67a5d87c34cde3035adc545e29c27445e44f213800f21df8b5b9a5fbeeea667908e4b1d1d6b5b69c224c013879507ec1f276495de08e3199b8417b899e40ed14f1c4059860b394e5685b93687c717437b9bfc64c7250a117f9450fc5e44b600fbb81ae31cffea9473bbfdfd4f6767875fc0b901fec8773db0932732513d92d260902f28ff4518319885c4348b28b0a822364fa8fcaec700a4308c0d78e90bea8b3f379825b339c32e001c7c24f42f89a5e96ad63ff27c0772064e931167759a90e055581862b8955e9436a5558c60737878f3c1732b3ebd26971215577a72c1a2db8ac23e53dc2844998d585b413bf359854f80c6f526a5c720303933b703525bf70126903284ef35e2a3b1a692e50c0c39276bbbc646b4e46bdce24236a70cacb4b26da2477cd06411b70448657865b2b7b0c510ef3e01d5656e9e488021b2e5007e1c555fb200bbfb109e0d79ce0c4264366bf5e1f6e4c25d47f36adea7154e7484c8ba3f1b6daa772664b001373ea5b07c900739c3ab3be58a936d999529cd3adf5b2ed8c5d2ebd12483ce5943da41fe187c43b62bd6f5e47a402c0c702244dd0456de840e997de32c8337361bb3b05d97463817d46e685fcf735fb204b4e4c1cdbc90245da00208613c2c803845e7f32924322faefed836ef14425f74d40a5b43d5557f06280c65575857587b1c65cb14ce4792ecbb535ed698073977db3a5bd245e81f618d33e3243bebaa0d55a6fc2309de97693564b2e791581cac6154561962c5b4c476553bc2aedb55237b2a5d45f1b03a45f5aaa07ddb1fd56ac06e2ba95f0a7f3cf3e4d0a7f58923adb2223cbd114a4068c60046b1145c6d769659808f3aac2e0e8435b00122430b90ffc113c0b64b27f219515c5b66c2550dfa7dff79a8651ea45e891aca66a3d7c6eb0fcecacc926ab3e55b571d5314711fb5523135c304b0b1f7da26137b4fae4638471394646a6cbba47c0693e4a1c8e702cb6eb1c335cd27bf6b0fc4aee9785acffaf8ac952e60d87054eaf311d095014c8f9e1bea6a5cefaf9a99f88196fd4f351565ceda206b769e577f5315b67e945ee0264ce5db1f30494e1fa49d115ee1592c9e84484af7ea73384f49da021114a20421b844c137c353f88404decd01ecab935611ed81d0b80a9c8701c82a7a19959c66e9cfe725e40804fd0d72373d59b08ea9a1158cfb28a1e33f2f9611ca367ce55029970a43e2e2fd432dcf400b1e68b653bd33f72f691a66147f444454df9c96a96319a378c7886fa7f519cbad99a860348e880cdada580673df5c2e0db42f771cca67d69f000e5c36c01be857ae867ab0f7309b9d7a3cdc783f7d999a980792fb707af3f0ab67d0d4bd6a660a38424c589f37ba290700d25fa55e79fc93620b958535e89e9a628bc5c7b7ece70490e770683fe5b72c9f7f3a47df582fc464e7e58f6e6fc2a6fe5fbebc5728322844fc5961b4a60b7fe7fc012eeecded144518368bb3c8d2987025ddb2626a12b9a553927437291a943dd52f6e38c4bdf2812ab8390f5c615d504d8e1d70559cc2272b1b2ce1d300f6e28733e290d410b9d3331d8b842155540df644c2f318e9cdcae2e22af0ddf57e675c72226e46b9af40db2d30521a0987626dc63270a0b4d5d0a80c2fa2b0ec55ed8b3f31a3d275a8850184527d37f830533e3f1b7cb0c35a640d49e4fe616d9b11d00cfde3b388480efc18187b5613ea953877dd0b6ae4308ade08cfe5e90a2d0b3222a35ad7b8467cb3fcb0f924e2772de82fb19994107ca0566c234cb5f8eb9218ef2325237541130a4715e5773c0479aaf31b5ce935382af8288229f17b7f815cf5ba32d729e2eb161afaecfa603de58be58fd36895650b2a14dbf4c67de7482334c239c25d754c469e194ae397e66e044f186baf2d251d95daf639df9127924e92894fbd41ebcb0ca9210ba78b0d7a787c638323d2d7c876cfd3dca0a7124eb03f39b735a2f0d54cec6d3b7f0bb8aa9d52f3e3afcaa32fd82024a9970813096c725deee249d0cd24b457b128c555617778cbcab5ba0b943e8d75a00197d1132a5f272a2c73506734aacb44e464352b24a2b0caf0cd3583cdaea999e8cf016906bff92b833ef20d6d842338a3403534e40448fa3de5b70343c5be94709b8fbf46552b2057560c2ac4cb6724092c382f1ae74eb72e27a68399aff78f73d3a61f58441b911731f711a286491634777818b92a4d589b52e9314907599b74e55babc5afef2929234f1e2bd69a66dfe3e22b62fb00b190cc5fdde7085ddefbec11871d00a4e5a44c5342031beebb3152a536a8643e955065047760b745366a94d24557b2316fcb572c6121d3fff1af23801c82f0f69bf4637b7594f348bdda00b90f961b31d43543f3e600dbc03b4641947d3b556ce7bbbf73a14ad8a601f8b62da3c0c71980c23d7d05371b406d5dfb2c5275aa9366eec438a43ee7460ad86c7ee29c86575f81a831c208868ed9603ab2fd20e0ae3c3c4d0ef669c6a66041fcc16928aa48c1284720bedcffd0c8d9d4221ff087ff4a62bd88ba0154d31a43c6becd94bb442b747f64c84004d15d208f32c1d8cef621a23a919bc7e3d93073acfcd65eb4b1be9764ca5e5e3ac6b683256507dd3b6a228dee9c5ed61631d1f5b17f428d29c672f10a795d1b863cca2cefab0bdf547217b2f876bd0341c51f9ca234f8e34c1dbc480eb39495d19ceaaf584353b1471f9b247bbd460a730eca603f7bd35232c1866c0dd61895eeb37a86cb14dc72fda0091da36df6c630b4087eb8539e53c929639877f1f4c68612eea16ce1b0be8e82f274ae36ea0bb9549caf5ce9811bbd3b405d3027bf72b0d71d174d0a4ac9012c3f05acebd944566998055d983b9cb0dc51b8d38a7e700ba03b8d0d79297f33e0de2a5810c53f7f432cff2e29893537464aae863fa20b8123f1f21719a84c4a40b2ee515466c5eb8740029692f578c2e90375b0e8ea2bcb81f568c50f9a7db9cc2b8ed4e287b9438d0b6aff8c4e0ba1749cb08c76ea856e49bf0448939b3d6c5934c1682731106b3a4c2804c04e3a4fee0ac062d131e4f731346ef4f0f89cc69e4843437b019c28c195d9cedf9c6afcaa255263bd5a1a7cd028eae55cd7ae9f140052e4bc656a1dfcae93dff37fe332d7a20647d182fb9d7eeed6cd06ddf157b6da0441d7cb60885e36d76a6574297ac935d138986c324a0d87957ba5f69b9947225e6856593cb910413eee3d2501b10bbd9e6bfd527c6dd6b10b420778f0730f31a9763c2a406f5d507b4f2e2a2498d9002daf8f4aaa355ab2e94396ace64c0455411acdee1df4584e7bbf23a033886923a5bf8d168cd8011b48314f8bd27683920230612f082503a7b70363144129363cbdabfeb3e47211228f954810a94674556a1ba91d5cc4ec92d0a87abd350e82c9fbb35919fe33a9f5e92c3d682c89ac14534c9fb79d70d47e599fa56da9c68c5e2fced4f766c6bd5bce091fde0a753993f0682284c518699b627570f40da1a1d412dc717e3632f394564d9921229dc7f2a6995a552bb80f925e86fa98256ebccab3c8fd683b0d4ed7cb4d5b63b03b5fbbdbde838906d99662235cde743f433eb4f3ff3b025f2fb6fd1cee1eae25ae94d1dd93f5e32ad7faa1f59aff5bac60e61a26e7427d061ac635a68e239a776c73780ffe99d9cdda763fa8c2a4a507c4eba807885388fdd97569e4de78fcabedcdb33c8c099f2f7450187d2c2a9e1ece407a0dc0cab46bd5cce3eaaab9fdb2fb80f636500bd825ec33a22ecd2147661e4a2ba1952837b17008e21c851d9e28b436faa7ca56bf0544bf48e36c747c7ba367005f2f20f8b1e7f28d0921a210b03d660442b48506f4bac51ab80ea78656782f6318f881211b1dfd019ba254d5cb650b5dcade696388d574ebae8bc225f7a542f9b824a4dea2422af926cec339d699ea78aaabf66fd46c8429bdef6581f1c69757fdf7d2e9c8fb53aea607cc1e70a60e825f01225dc1ec477ae62c1afcd438a2919c4c0ec8f7dfb8b9d41b1635f3b48739529ce19759dc10e2dd588b50c8725a4865590b376e3eb66c817b2099b34a0118163b45fccb5ec3cb1f33f7837338bf0f73cbef330fbd6040ce0a3d81b17d1822ad04c4f2ce2068ebc12d74757fc39baf4cee6e9456eaf7104561c14653e116fb92ba61adc6091372a3789b307f8f7e157e77c77cba99a3a5ef52573beef8fef6382b2a531bd24b849e443b28cfa47959fd9c6048b8d5ddf2f63ae59b8379de35a13cc3fba6e82a5a7c6963a62ddaf03074c9fc24086b121929d0ab078133e3e40499b60ed7e83ec2d291cb29a04ced8853f198570623ea1bacc156db4d344beac6593d4ba2c75b619e3e238b53c0a676d1d9fc34363ed579ce1811fc1b52241a2f7a21e524d969d8c5aafcc1175e1c5fe55b2c7be4173bb32dd11a15c489c9609d0098ca43f8a4b6bfd111b7525c351d0a7931c94c7dbf2bc3ee1dd323f7490c3e19cf737a3fef5cab1cc22f588862555c2187337e75377180aacb24bcaf7a10325089a65f990c4483d09aa770de2854b9b982c6b1f6efa25803ebb92577885f4e722024a5b62f3ab7ba89cb3cd290d3694fe6502809c9fae170fb147b9f18df6b56983dbeb4ba43404fb5263db0648ae10fb8ed632312d8070f216807f1dc8f8caaf51b95bdebe2923ea4461f01bc444a152fdeb3f75ad412429b33df817c2817ab2959275d4ca026099c57243a9a9dcab52adbd0cf801da7ae0d96dadf9c6a7c741b5b9cd7656cea4b5879b6f4fa831b0eb4dab3ce6088a9bc66a0398033de475ff33889f37e81b624eba78cc35b6657d68f2ee5b14baa573ecb84f37ad23c3c38cf9dc1c479a96d99ab433a39ef60f8bea20162d0ac5e7b67f567dca3f21ccf0f3db5346a9e615bd4694d06361c833c477258af2e2594807af15649d68a90f4738f73b4f952ff108809bcc3e28216d6ec031ccffe3d3de78f614a9289955198d138e4627334eb87821ec82e6671485d5dc3206c7508da1e0e652b183eca69441460b89afb579029a2c702384784bb3112ce5d957203944eea5d8e8b22153eb424659427b1e96efb5a6de7353e8c0fec73764a9968f7cb2e11396b7d380e4dd6cc3539003b8b4397be71e33c88c67d7e74456d074a678402525bf19d5f6c8a0a38085e3f786fcf5eb1959d104124f2ef08da504eec7d2bab7f3879738ec59ba8fb9b65aafe42a0cfca6e0ac15d6ce0474074ec82b246a99019909be0499bd09845e537a477593cff567bcff4f8ff4c8f8c98e7886cdb7b220964482a481780a2721f4a3a81d5a0034e77ca3a7e70d8d73e3cff981f6fa2e52267833eb8c6144997188e60c9bf7c645df960914de425d5368bdbfaeb134baf6b2d6874a3854ebd8094b57a8ce3b3078938b55fab486a15d6f012f3d15701e28b0cf330883af11a9e77c9c43084fde920badfdb56a49ab2f79ec179a3275b6dbe3cd83208558f58432d2f8cf2de9359b57091afb4b0ce671e9a20d2466806f209a50bc1ed722538c56c5648c220a528bb54af7f0edfc5d876e42fd0eb771c344966978eb40165c939b7041736077a7e6ef56fc831e49d16119c1516b663451d1cc5cfaa767bf939c0884a785373209f680dcba37b734717135cbb59536931d69ccd0877792e3efdadbd34a474c5b392ee9f7c409708e8a9e8a0fc690097d5b71efb76a2ce5e997243a896ac4578465fe2c58bb1ff1f4749e65faa722ba0b721a12019f0dbdc8953ef50c40dbcad0a71cf531e95d9c838a2a3e48144ac1621d2aeb771109d30f7aa0a3dd6680df064f66e2ce9af00ac0d8d22954fbc26ef4f7feaadcd8f517c553da4ebe44d1bbc7db1971aef7cb3c0da1ef46945ce6e8ab637c83aa98d71148408e601d51b9edc55f129e132d8b7d3a689ecd674ddb0d60a3a82a0a8e4a0636f11be96485514eb2280d727e7e33c66d70d903c179361bbde52d98d540b2b9eca081cad7cc3cd759c7602a13aa385ef1bb71aca5b498d212101cd0d62c1b8369a3605f0bfee027245ce693b72f567d75b067c2b0548f9003c586669ae416f4fc720e220ea23ef30c7880ed6cab0ec6b85fb14d902be736e74c9fa13588389d0a0c7ab660393db8e4e50fce4a0ace6ac598fb4e67617f8e4526f97b5092d70d5bf9fc478296b8c5b48cc828958c89067226de020bf91f8930b9c688e2a7cbe8b5e4b5a612dc66c2bc3a810c4ae5cf8be1b7d076d5c2fa9583c222b59cd862a8d8eed0a79c598c7c9010beb5c555d91fb3900856414c26756db28b77ddbec574b9c5f430840e4f29eafd133ff3da900c7f79a5a161f1365e455f0eecc33f510c6cfbdaa9be80373b1e9c01ffa6fb3a29a29f9c9bd9536ea970cefa9eb4d9b20f3f959cb8119b7352dd2b80fff342d794ca1713c61cbc7f6ab65bed8f546f59be8d1c89f6385e047fe64a00401e0a9a98a0b0b5608b2114f4e6b0009c02eaaf4eac85722dfcb756a4a71923c77afdf6fa4d53fea8086b4a8a295cad5558a1b875de7d9de9e54edac4c7b4921e5ff0bc5242ab8d80009ea92cfb996aff268ab3ba46883cad1ed651a650c80401a0a8f9595fb62055cd6473854baee58de2fda75d1f11297e90921174ef3510b45732074ce70c4800a9a631d5a6679c791d6106a6582319f2c3b45fc520661905b9e52a2cdd850da55da831dda67fab19158e1763db2c777a5391199c986ba8eeab4edde6dfc46209dbb3379041c34465c16cd5500a3489463ee936ea69c07d3f86c8c72f4c00e5bfcae3037458c13b65e1005a6da289cff485a65ba84c5ed0066ea0cb1104050919e84240a6bcd1cf1ee2c46875621d979d250164a2e1496172430ecc2e4482e78a976d204f7dd447f674a498187a86d7f078b2cdbf8a3237905dd06bd104f810924ffd1fa6ecffd73a80afa57b774aea552268a35aa62d2df56ae03f1e0918fc6f09669a4bef50084c508659ff60df5f697750e5111b0f7d910a13688ab167d73ab82e648bc5fa7c2f61853060a1249d2270b3d0f4a87932dd053799d3656107432e3388a50e2a9bc03c924544399d24b588f9e58a6d5112ce954a2144a94439fdffc00425e7818af5bf7eea7c3ca0604e586e79f9a840b5b1d5a4b35f491636576c7e08e9a3698bb1dab60bedcc72ffd63b3c3e9843110b293fe2e3f9d36363aeee0443403d8e812e46d52b4445863ff491b8be746cc94b16c1a64094d348b3267d33e9cc0e3914a9b796199203e76b28a7f1f3882dcd00d8d416d0f1f26aa43df13b66a2e7af138b1ca6de6c79c1347f641f762f0d457c9466f3be1e3f3767a85cc4d678cf48109c7495d2257575c0f6147a38183b511fa24a96ce96629665a04ded3bb49920ca5aff57df3c8bd546fa0ef087d3d6ef39777e54f159ed28f73da20a65a9bcda9c5dd7e5950e1082398fbca0ce0028e969347bbfbd86e142b0455342f9d3bc92d39038340757472d101297fb46adf96ddbd3482b9a18a389822da94eeb218b961dcb481ede998436b3cd7b6a9f3b1ae464ddd781378eaf11aa0421ce849da22da6243c17eeba4a41c9b2ea7e2b4166a84ee85d4bbe5882a4dc24ee1cf92825669ce921e0d34525dc920618519190319583520e4366ae495851389848d866056cb7254b151f3b51fc7ef2ff4527ea2b539a1a5ea10c53cf2f46b0b66bba0b310be95a74b0178b117fa47e8a1d35b443a82edd1e817230a9dbc2d98fa96ece4af4705d45b4aec2822f29713b4c2050aba7244fce5ae4b4a7378eebe39ab7b241df979c8e3c9985a2d6118ef7f8e2c471a4303b1c8728c5eb35adbf633841ba2abdf6aefe6ac3b2e7589f6b2a24e8ce4348e3f52900f46fc2842b9701d69dc402c31d13e9240c72f38e0ae2039b116d55df9b60b6436ec9cb77d5bb71b1c5d8f95122581dca80490ccf69b0472527f4ab4343e7ae80727960117b93e3a9f67daa85f4a4d06d69b9acf700869ef27ac6eef9352a61f4d3621e63261b8fc7f38975b79cb0df5636393eef1abbc02a92cd14289fba9352d70f0726501b84ee1b0665498d8c745e9baef39c112b6b4ce75aee1ebbc17fc61a570bd7777544607746a01d74de4757090ceb634f883e113593aa8437389f29d9e8b4bbd3372332b42a106b58314c289f5eab8b0d3945cf82f85087e72e79de5f7956a659f5fe96a78f0a17acdca444538580c3ce8c2d0a031fb46a48c4dfe4897fb677ddf543eeeed836a1113f5065a1f3c63f0658ee8ee9b5f50e6eea01e519530634995c17510c8c2008a60ef272cf0532ea36832d7eea8fff0ec68e9fe22c9c98637d72a3f4f5075b6d896147b421fda301c8bc55821ae2ba7aeaf1cc1953111c2233f27fb3c7c769c3599a56cf8f7e24e1d5c32f5b95c81d78af31ae3419cd4a49f5237b1cc318c1ce97f35a28e3314043a919545eff6163df32422dd179bd582ded1b9538627a84585e0fc4c8ad87ede1a6f37a419576f76c8ae4f39a411a7f50710235b507bd0315024f5f36cb811b236912102f0b8a1b29dadf3519994fe86f4af6ec009d0fd66d0f300524a7042a4bf47016ec68f7f9454449970660a895125848c863c1a4517bc31eec224adcf12fc51bbd36483211c91c77fa420b893af4db992c0e6aed34d27eaa2c246405201d2b47a3fe66a02e98bc0f3e661732bf85f704d991d3e8e9de2d41338880e45c4a15a51df9ad056797f5463c8bd67cbb96c8ec83434f0c4dd5e5e449d7b1aefe7887b85bef74ba18a5fca567881fb7720d8faa494d9b176b4b8fd233250975664fb002c3803ec800f4d3bd6a1363bbdc8c3da64a5d7e0ecec8967a2fb170de544963cf88944e46214cec98f06941be9ddaba028499d814af58dc9007113858c29a690320f513e42713ed8679db463b0ec82b5991cae0dd5552007b65c960cb6a9c5c371ed71c545c492700395d8c45f5ff5b37e0aecaac37bf506b96fae8f72c2369b4ab51c2e5cd547a31c101d556a645eab2fbfcfaa6aa5883da4df6b0c87a0a7874d5c4b54054de38418b4d86d5a20a30462e888fdf5dcddfcede697d8bed89938559bcfa3269f62172e332c5a800a7e4c25244abe238fd70016b3397e504d04d493690f2ef565df5b212b45052154c4e585f8379e60be17aa7bd5ca2c42432b620b514a27fabf2a6400f4223967884611d2c30a0c5f6583319364e835a83116fb243ed972c8be5ea1964ae6fe76c6b9b7dd94ea877b6331fb86f4627bc0dc9fbafa8119dee0f5543ce94d12e31e90d961bc5c999cc36363b4524d3edf651c86329339db8e5cfd87a7a32faa81d243bf078ba93b4a95a9bb104816020b0cc6564dc07859c370ec8540eacce61da8d30f455ef154066ae6b1bb7120004bf66e93a536294eb06bcebb6dc966bc913b65a5d47a21422d4115d08e1d2bc1c7826b097142a93f258457e23d9d3f89a10ba83934076d084c1720805c83a5c8d38ec21ce612cb5a596246048d24edf69074b51b00d03396770397c5dd7a1254ac9ae682634e4c5aeaf1f322c69a18d45798e4d1b0d8643ea5856ea401b8228c0c192466144911215b07e1ffc569546c33dbb61402f20b9598a68a2223e6ddb1d55c77b4b5429d519e3a8c1956ede753a284b978e224a36e647e6a1ec2bec2affb53a0dddfc033d5fa62eed596794ac47d1a1a6c9013013ee61b70259e7cdefe0daf35f8814fe5fdecacbd618633e2dfd7ea951c6beaef626497cea0949c156d41dfc8b480944b4c25b63624ddf58c0f774a78e06a7e2d52f272200254f117635e79aecd20f1124b7ed8ed2f7fad7c0b8158bb7f31d38f941d5d451382d67d183178edbfe2b498abf255269093d5f5c482fda00a3cb5ef26e1be0f4d70b1db125d563fa830d58863b7a2a0f8e7ff1aba34ce9707e39b0b29a2fa9068832f1a9775f6376fc6c46bdea59026a761f1ee154d5c37f7fcff613293c7d21cd1fd48c0c6afc32763587cf5eaac3ff9c9285b7170a72187d07b48dbb01f5e94201d659852a09ae52bdf5b309fdb23b5f16950cc024143defb88c33206137999be55ac0530981120b701c4d6c08a55752c75098f09a58a5515ca463e970f1a37bec5257148d3e133762e6374c1094b3be856d99b4792df155e1facf0c2ffa912cafa045c94f07ebe8d457070b5382035359452acf26ed64884c535ba4595a87a296a0b0ac9ea23c14550c88ac475373f76569ab9dfc70b7e9b9ce4862d6c3f1de87048e89fb1f7a865ead8eac8487008bdd59b12f0b4c4cb99216894720d949025ae531b1af3f2beed24a37f06706811fc56ea5405778861549609087097487d9a8235a692337edbfd9f7f05832ffc0a69a8bcefbb5fd7cc8eef68370f8b3ffd25568db36731762ce9c6bafbe73500c0509957e891db45b4786210bb3a65df9ed35e5f5dde43c590a284f9adb9a1c765900a394516091859ce272b42988c9a9fa6a309b5b1782220bb2d5540f10a8087b7aa07ce0710d109cb4509091d6e0f13f642ba52f1578bad4de253672c9de40d0a122b33fc8b350282bc9e33a400994910f987a8a992399bc9d9e2640dbdf04cd6719a82e8547e10094c45385f39739e3c09b0c9567f631478dd320e0bf002d6b60b82920010f0dfbb5ad9e0541c3c4ed7512c001859dcb449040c71fcb16f2ffe2c8b041bd0f62919b00bdb1e31745920ba4f424a0d50e80b3c2618ac27cf507af8c00b57105b9c475633bbf9a4bc89896a0e8be50814fe6cb81e33bda080df09bf8654cc3840c8b935e5daeabeff4589f8e31b09d1cd4877bf3818a60b6978d1eb7e2945de66cdc436a50acf36a1f116ba651e07b928738e667dc8ce4d105a21721ae5230f973469694ad667b1ee8509dc713fbdcfaf8602d19f69df7aec81923d5fff8c3e515be088b9766057e1176a7a17ae65eef0d4953e61a782ec2992b7cfd3889b4d2f99a1aba23df450020324e17dabdbac7e54ff3f22dc9a1865e58206748df97209616288298c06159a983c52dfc486eafce2e1a820be97ba817c1c4bb10374283fdab04e19e14f3e6ac1e91e7038371d5c62d8e4934a65f18c313697c662e0464693a058ba0d961dad92ce65ed2056bfb0ae6c8f16e0475add389b8c51d23a3c0a0436362b4afb327b76505cb90b3b5ac7b5100c56265bfe5efe3a3507c20c04f90a6e3d894ff8ba3cc4342342356e54befb8c56da959fcba9133ba563174a0e10fd7c5642adf3fcfd10ee13097adf6cc0cc6ed8f870c57226a62985d5e1b21927a768af68879fd7cdab815700f3c464a3feb75b163134106a50aa325421df4a165db52ffe2fdfdebc05edfc183d63c4d99b8769dcdab990787f940ea6ad13220586bbf88987163a4080d9a6124cee6443ea15cfd03c6037828f23b103b09e11c7283da259a1037aa15be6b7531b9196729ce3d385830c4722bd6e07cf4e5ce966f0c0ea3d40e7038f20cb2fd4c43c884260fbb850e42e5f4b823d4c94ab7f5655887319f023e7c554d37f7e831fd0035fc28ba9a003395c3fa0280e20219d1aeff4ace01e007e21e9ad26387c5261aa805041e2afcb639968ae064c3f780ef4a867cc93feabd6c9732046ab696fdfc9624220a74ba172eb654f258cf984798639cf01d060375274e526838c5881a460bb0965ad7a6d3697f1856705444dddcf43b2b190de0acc50ff2e12f01e6f090845fff62f7824a92c6ca5f556bd2f054defb9499a481a51517ee712f162f288919bec72afa68743f4f1265dbd56db27501556697b591cdb9653e072d0f34a76cc0b589aaebbe758b3666109ff709dcd7afc4214032d2d558fe0a4bdd4b4f0df02b92a5dc89a50ab7be0f85414d1e7a5a4d2f12a5e5e23243c1464df4d23e5742894f1013733e42dc60475f3beaab778913b8fb38cc2eeff0eca2ad50bde9feff688bcf407d2f1ee0b663c40a1d9f20626167141e7b57ab41ebdbbedfa558257a9b37d2c377f96c5590c0e1e3dd2ce659e97d0cc404fa4279fad15f556fe693c8b128758e52ec12f2c5b04f391f979325ac9a1f271ec28729a480fd586ed2344fd12e6768706bd40650bb958bb1a2e8c27c4654cdb2a110c63e5bd56ce89977b5a4c68ddd763f59bf7e6c5283a6787e967576f129288ad1c686d278d9805c59e82de28c4f45acebc7064bdb479e9e78040bad99ce99bbad7c76f5b13589f369942ce312a2835b478e9d718fb409cd81e30b3e299e132fb3e42d35ba20dc0b96ad988879af71ee51cd808aa130578e94ca857cea59e395d75539fa7c77c8968a0c4ca04b09d820cf9e9e8ea8f0571280a845cbde7c6d0af18f61448b8f6c6be74a1609fd107723799b3233c25af0c144845cbbc72cc8117ad83d31163ead455df060d181a44f41ada02d39de5b38e889c810a1f1eab9865cf1a615285945b367a23db2b9322d89ff1beec916fae1068d925ae0482d27c34124b6e0f9df32e4020d95d658ef1ab29068fd348b1cf2f1129423c398c1b8a445e6b5c3e31063fbe13c1be245e004dd2087d5ce5395cf1742076e7da516d737155d23151e48a99c14f62a44d5b74704af8927759b41e588b2a16407340527d58ed3eaca0f3e3d0b7e6c26063d48294b9cd98a62eaff9a8eea22fb9b41f31075c529d3f7f6a0592fa392360e931db649de721c80a33276adc0a559f50dbe13b0b314058602efbabe5a53a18d49d2e7c04bdf1cd43079bc5f9b7a7583fe19602285534d2e226da0a083e3af8fd0acc7d6aa5a3f585151f2ac54081451f3e2a33f974f330a61ef0bdfe834b769634d121421b8ea8a9f68a2018ab8f349917230cdb70e07184d438f3f8206ef450482695c0700e53f7449616b747816ed6dde3669fc2823e3fe2395ddc9a30afdec2815f2e3d2a187d665eea090630a9b91d005b6f0f511c07d9685e52383ac82454c30ba19537ccf7c97815bce93bb7e5da223e541abe0745dce185ce221f35ed6a7d75e88dbb6944ea10565d9681d48058db660254ac5332785fa0ed838536253f33283f4f16518e82fbfaf967e5fd11f52b4f6935ea540e5ba83b9dacb1bd4fb7bdfdfde7ba1b3582486dd0276be4d04b119ae1d173d1d77354b15813576596a0c20d3f7079f481cd2974cc60669c4fdc625998c101747d44e27287238db250daf19e638f52ac09ed123108f11c0032e79a7b95d791d5f3c2ad59fd2dbc3f983fe7fc18a76a68bca4cc40afa033e2258b6c640c643179268305270e26e58c6cb175db5f0d89034e39f79ae27908ac794f388f8dad311abcee772c152a318ea6b5e1ebafd5da35a74003c120d488dd088fd7d5a16db9b2b299706dd84fa09729a5b14a122d1d76c9ec04a543425f557173e91020ae28fba897a0ed7dd2a964f434bb68a44c0c167a091db7932f1db6a3fe123235853abe5cd7e7c627b3bd3853386b84026e97d1e9bb8efd2d7aa24d1842457bbc31c68d2d25161fa9fffeb0cdf9f2d5bf690140270c2118a7388a89d91e6198e915b0c47b5278aaf7006065c99072c2461618c8d88369cbed9f2300aafa318c885a4ea87d99fb1c00e0d26cbce33d88880ed67757e2f43fb1793912d77f9ae74284890c6679c0dc74f124594ef484419b29c98bb306b2891ccbda82031418929a55957b61f0e5e4be010b4caf5b1d2ecca64179e5b7a062a34945c0726162c3203d0e793c19c52782f0773143ced286d1ad7eacf429169f680c42f7192eaacca98a199666f07865f97c8b848701c0c6062c6d6b82c401b9c49986ef8b751dca42286e2befd446b6a328bd27f50bab1e9a1948808cb1e0d7961154ae8a71fbb464954405fe9dff0f85604ae1e1d595b702965d1dc12afaf100f5c0f066486ca40dcc5ef9f728f41fde47cdfdd3d3de28426ef8be32ed8dd6879203ee3664f6713d81d5197d0cb10ae10fd2786b7f37cee34660e9e975fa6a208d1057d8fda89c02d5ba8827e967dbf0a90efc03b67e1e42d469cad73488c85b317e0806d39e729dfdfe7c01e1e79e008cd51b483353efd443e0a2a4e7186a79ab65fc4c64bf362532483f6dca8e2dad10f211f99e81dee97d40101445608b9aac3a3d43deba9c32977eccd4673403303ce05bf04318b5bbd8b6a9a40f8a4720c8de27194b2064835d0f0eccb5241986d3333a1ce0c0bb71e2a53b57a0007110b62980a3673918fd87626e86e042eaa89ff48ef0fbe20eb6f69baf5a4d05b2a3a9650a12b08d2b710a68cfdbcfc0466569462c49559bc12cd45234528ab7a512c18ee5aea620afed63e7ea556e8c9a4c1be7c69efc850884cb38f4e28fd5fbbd5dc3f61318be1a1a2d694b7f1940abbf36e6a9db0170032b0cd4854dce7d0ab4292de403bda46edd01e492403bdbcf684039746b34de46293d4931acb7d5ce9118da0ee04830e92db34400d4a6d83ff475862cce380aa724192df919aaf2bf0609ac693adc85ab3a168e239c2f9c8e31f07e1a73de21bf3f01035662499ede1377accacaaa75a86d2a02f34011eec357994652e112ff646b6d7fa296093c59c96bcc3fc81dce6d605b4e116c5cfc89c220effc272ce712e5e08fd0972702d15bfe472d9d956414dc3c85a31ea3f412fb2738f3f240e7a8e963994779ee5ddef8591e2ff7e85b03032da877e1426fa18fba17b933d355b40326035dfc6a24c83a5f5db99ce32e7d0374f5b3ad4f9005f640e93f2c56290c6c282e7f8ebac5a119ff788d522b11c8030179a9496070780d80d0fde6d95b69e38be5908105881863a4d52f01aff55ec5c3312d3a4083f0aeb97ac81d20e021f176fa84a36a3a097a33ae90a391084600c90577a730f5028c78600d81a68042fb85a23baa635e5ab8a020529eb33e1a20abcd105da3acd26418ca48fd19a6a682672c792aac3cf95de432b70306dd3fca8947d1ed30a435149e9f06d972d9c802d0550d4f00c2eb9599025519d435483347ca4cd2c4fcb4699b75ea48b143e7ec2baef5195c37455b6b599514be5c94f7f936c140437f7c3044277c532677d9f98dd498ae54a894b2a37527639831e484a5b9d997ef75a9fee391587b756541b51afc5ea2fe3cc3070f185400699325d9b803763dfb0896a6a15a9a704833fd2408593a92d2f6634613e9855745f1b2056f82eb9d0fb611474181744524ec95dc444ae1e4326c0ed2e9823e32c9cd41d6dfb7bace7d4c90ececf4fee2ea2b4a5a07e3b879b0c152b3adebe08f79e05019c0f15415f9d76f9762d15d43b1dc204da6b7c8fa481ee047c116b58a87a2eac1f3c52f88cf5cf156040a5f4117bd8a37dcc8fe01d53391fb0943386a4d2739b64dc43f7e4c8dcc2c0558b1639a8da5b4a50f25e96f20df43b6db0b8882258e71e4da2b97b5c74db06f6f1bee9105a7c4fc68053f6686861210af85d588ba8fade5c3727b5aaad14fd9db79c062a29dc97732aa17d79616e21ee48067578145efdf1ddafa31fc1162f6a53dbd45ec5cf2fa7abf42c6167aeb25e8f92c25dc10890756a73f9576eb0e68f57c2e0473cf4198bcf70fecb5b80743c71e3dd72cbfc2ba5a6467d85fee0e3416f90e105f003dad0379464b2ef22c95c2b7cf3c31f3af60275b4a0ba20ae3acdb1e978b7195398399f83556e84688e4f4d8c664c32576b244d09ce317eb77cb61c107fb4f73263528f2d63d50ed795386744252bacefde8d06934ef168e771687aac345863a74dc927f8c0cfc040150143a3b5eec20fc286628555d8a6bb53c99be4c698909b9f98566ae02026f4a7839b1eec566bb88736d7c0e1196f00f6e93b0cb2585ac435f13e4b27233a01b809b53d131c75725074a21f2cbef8c08ae681ae97a76a122fc38db7774638bf7741d1c2a60874cf78a4f9a4cff5ea15550d1a74681a729d7cd189e934b1821bba19594e4241c3df2303c64d7a32d19cdb1b9aeacb6e9909c13f1c762b6fa39db22892439ad66d1c64a069eb078e141a5a42524ddebce93db1b281b0d2ee3926fe522c4a3a152056342bcfc8fea026c5a2feb45e65b75a6e9842013a37b66bc4c1280a29a916b7c6fa672ba5ddbee20d7214c762ee5da9f6b70df22e4722c51b0d0e3f655275f18c20f3d497f35ef6d999c87b532f0836be59412a4b00f12a589f433ece625790cc7c84251cb1bbe88287ffaccc83f9b14c3b4b1fcd6fe644f3ac17c513951f833cb12cb4989088ab95bf6da3210b4a4d1a41da6a9764f802747d53254321d9f7fb4140b4c5380b185108e7d8c5245c8997c6bdc8dae414effbb30462fa5f6552d9b8b9f7a03d4bbc6212ca412926d1d389331d9d5486402e342c4d039387ba5c8e8202f054347baa73173de94921169464f17a3914f5d1eaa4362c6caad5741cf546c51eb24210132bbcd723bd38157ff6cc19fd5b98ee010ea948e7d07808a6f7d854682939076a2081da19674157ead1e97af9e34a3f9e1321687b97366836028f61351ed2ad1672545f2113c7e8101fc934026dc7001deab8bd5bac8f42675a81dc68360bcde66472422c357fd397eb041b55bbd4789f0de2c516b6ec5c0f2ac7d0ddb4a5f8d91f11e22d2b67b5754834e947aa3491a6c0ca7b54bbe88bc40993e5633283592a58fdd268737e0348fc4383cd7798f5dcf68be404e895d2250094c935ec5fe9b7af6c9937978fc9edf6e10a286d17064bac754b0fb90eef3f4d8f750273ac790aa435333087466e9218f3c34b96afa0a5ca50b3166bc2f42052a34ba433c2bb4ab0b3495228d8ee262252dcd7f0c69b6a1395a41ccd197fba9a04fd20ad0acda71db40139354b08ccd8c8332e94310ccb29f19ef100cbeff6f0df0134eeec1d32ff5f2d01ef599540adb79b8a07f34ed957113f8ff0ae9fcbb48a1699122b77666cfb836074c912fa2a96d484b4e190354defcd6d2d9cf467069684a731021c73e237cd7c400471c25d092e94e144294a9bba570d57b1a5e70f42a5306f5649389986f52c99f781faa9eb3a827ab3f2fe02680531fc21bcb88c6657a96f12aa837e1baeb526042d48ba99552a07de575c7338bee812036935e01cd17813885d5ba6199a6cffdfabf475859451a53dda3534e19280c59a186a508eec0ca598e4d6de0b5dbce8f0e310984278c8642720e7d9c2dc807e45ba205e94adab8b0955b573c5fe50a2415ca0471e06a55833ede241678531328732ba0b17b617cd716b418e95ece42154e9d5505f48a784aa118926e1854016edb1b917b254c58c58e53fde5fa1d43fd5ae189ded86980a9e91a89a1f8fc181372ec1df0e105245b74c27ea5391ca7678190f5af0c5fdc5e0d898421d28267ed6a477f8eb1bebeaaedea21774e0cacf14d8c5ccc3fabc59bfb0331a288d7b1710f32c0dfe048af6ef71252a918d357d07f9322ab7e9f6d2427a4940569cd694c0941a1011105ac9718d68141a44714ecdb4d5918195dff698f4375e13ab52de30e89e9c986ba91abc7d3bc5b099f22ce6adc8d0f9370d9df519a10f3d67613d9cf065cc8e603c90f8ae03cbb30abbee3f251c7180a3e84b4886522291e466918fbd44818ed19a9077421b9372bbbe61565005f8e8a825a79f820131d92b3bb3c461ed194fc1fb64d385942dc5d2e8922ceabf58fa17bf761c9ec8488a46b0ab4a7202706f0078d088d9d7029c6d4d1d3abed7c05ae7da432bd57b7540f873f2eed58512cf924da3107094822e6d7c89b35143b43bac60169bdc9d94fd0ca4f6c98da27ec5764086489beb3d040bc74513156e151f688b004ae0928ca55605348dcb5665ec5b61e55c07b23f9ffc8dd44d57b4c5e3132ca89f6bb2b86d5f72581131434e844ddd14cab2cffcc4e361d54524eb178c1f66c7c88ed7cef71d495737666551bbfc3d247e508f627a12064886dd9ee34025974d0f9a9e73012608021c34251c48ccbe951838846eecfbdfc45ef1409d9bd427263891e9d0b7c44467a0adcb6b02affe6bf66901604a9be1b1e2dba8ddc443d866602f02e8b9758c021bc43206635f979d543c1da2089b3e1f91df77f3061254f7fc3e2a6be13e5896f2b92dec87d861b8dbf713d91bce7dffe9db9bb5336cdf46c9528c96191ef5af36c0de11cb49e2e8eafe1d4df555deb66219656d5f53d9da28fbec933e27f54e2676d7101b0e2df19f69e45e2dbdd73b5f232637ada83cec67d8e3541f557d4bae86ba5d5a3a0ef44bf4db0909361053649a2cde5f01cb7a0471132ccdcd5176520045b5206152a11ca955469b598375359d0355e96cc55c5564c0aa6c30b5b9e9cf220e54897ea47eb0dba893f349077e7e5e7797496f96367fec7724e17e7eb92e6fd9386137885ce95b9d5a7b3f50df53d124ce63364c78361445229fbefaa5d002b1e308dcadc203ef75179647fc46d814b682f1be19f265e92fa0935312f3c8298f193cee026cf1c190a4f9efbc5bcd6b126164828c11b8dcdc7229086b70e7b8b2fa96584d1b524a8a9379cfc0f9acbdc9be6e1a341eb5acb9116ad5deb204cdbb87fbd2472cd522ffcd86003372ed73991e528ce78ee5a61ca1ea57b5bd9c9fdb5e1f841e65707a35cb4fee3fa466eab9e6805bce0790f864428bfc076f75a5728b89d8d9115b76fb5eca0b3c205710675a6479b8addf83db249de9ae09190225f13bb21a84bc0a595c3ae50140b76df2275b88af29799d9106420da6223f27ac9a9fb4388947225910f52ef7f305854a05da416dee5d57314b3c929fcb9164085e33948ccc6a2ef332c5d5f1958131b9be45d42dc16a05f5e9c41850ee4de73cce90a312e1dda02a4762186a8dc70cca23e581ec86559a09b01ca482f6266dc26e1846d543c85d19d47bc142015ccb51b8eb8fbbfa56b35fb4e6f638ee2bf3bcea7629c3556ff311209ac3755d3337e885cc3df36499eb27c4e2a3786aab58b2968d691724db74aac7f8b138c0918844c646d814367baa963a1f675d9acee1fa22a9376f0ef32c9edc70b181ef70994eb4ccafd3ab6dab004d86d2d35f5697bc63905a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
