<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f8dbf93bc53aa91ff46a46d4877a7183f9369725c53439303b5ca6dcba681474a6757358c71979afcbfe6b833f0e000ecb6a16722df851a44783011cbacb5052bcb65ce50c932e2ac1f782645e878878b5f5e8c836bf36375effb0f5fb0261ab3e2263840bf3f24f9f3f85e3bc83f658984008a76c58feefffd86107bde5b28b7561edeeac869250a62d7417ef34f8671d6a2e36948a08c177296e20818c18c125436c82736e84ed26ef5fe4618a51ce38688ffc83fc0853561a7c52af5272887c913d8e8a83f982a30231fa5f677c168df7a16b81ecda3c6c18be5403ad338897c25ed9d576591c19530dcd6be2dcbf1940af886e6d2d1ac905d4dae03ea8c2771049f26a15d22726a2e07aa1115b6371cdb421c9b3fe117a1a0f37008a6de250c238ded5964a27671212c2571e212f83c75f8383fec14acf646cf3904732dbb50bb3724ee7d90103ad4f31323490688c2346f6bd61e493af5a56fa91d46dfc82a97cdee56ae7f67251f229bff042b4e53041b51956ce308aa9e31ff66bfd0be16e20981d6cee8d2049b8ad13b09b149560a516a196054524a0f166ca13e94a3d4bb5fd1d040df371266b551a82820a22e1772cd8871eca668ea88a96bf366158b9fae9332c9bccc774589cec8c98ebfa33610b0a7cbb110b4d5824524525178ddf49c581dec2d8616749c53a68e2b9ac15375d553595fef1460163da2812f96a7481dcd74c2379f4a80dce24033c5d9fe55a57926ea3401f9a85c75847e11c651dbfafbb8b2713f274916948b05dd2d448017c47bd6ca314c8c2524091591acd3cfc6e462471e70516253e9f4a7f112c34f3e8697e6072f1332459db11497c81b1f993158ce4fbc8b91f3bf540f82ef078b13b4bc2d12fbf1939175fc952cc7fd9d7da8361e70fb76fd3bc3f3daf54a5970076ae24afa07c13e2be5527217e149d68af40aeba6e6dea0eba12c996c3b2b883e466599d645c13a9d4920417636042ad5a1709edb5732f1bee3324484c05e70ab324c28718d618835e56757d8d9953421f3a3a6c895b14ab4666d1c1d28b3de9ef21d965e7d87c652ca0736ac621d0fc35410c7164830f953455dd6d4cc865ac507308270dc88d91c592af52a005eba11e85787eaa34f2a06e5908e3608450286430a202c28c40229f83ef8e568369d5cd64dd618194eee425437b854f21b2f602ed52d875934555567d12fb30f79a357d28499d15286f5a15f0f55aafbcfc4f12c281d94b1dc27f07c31ea5efab460b4e7000eac9c899fc7f1e92c2df492d90f20074a14d79d5ed12f93a2ca9110b114f0a4dce58bb1d19955b8ee45c8072176166f6eebd430458584a87d09d5c51e1fa0e2ca0f5b66f8ab76bf55a8b006ea53d4b07744db741541fb59a992560598836199db3760cf26e9487182ab39af855fe8dace2d7074c14810f36ca28b29d308b340bbc5989ecd850fe94a61fe6bb171ce7ec5c6e527859355f6e1df16319151c0b7012aa9b5687a85ec6a4cbbdad257f397e33f59ad3cc22951ada0d4be17821345d5e98bd841f97de100008232c2fc7ebe6b5e9dc83ddc4c2026c7fb5067a5849c11f57a0759bfee3c63a26829e0947ba435db3d2f88e5105bebd38f2b77c8f03774d46e16fe739ff966769653689363b86a2eac60727cbc48b9e4d062695d2a7909af550889f4265d5263c4a6a743cdb942dc63514c4b534eaaacf7ea2e7771b528a3d9e10679f5450d755521d6012871a2b05e6508ec97925edb94ae201d619fed87256f9ce5d77fe4d424cda602123e701e7f953dd6755ae351f8eacd8673e5924b276e3a6f7d108fa24867b2be6286cc386297946fb0fdc33dc429a199b3801684fcbeb7302245dae70863750e488232166676a23f7ba5c78864fe4c6e5ad8f72d2f7ea6cb8133674807de8872af4fe8782ff7a836ec1bac9dd51544efb3ee8e5ef559fda815127aaf6213a35558eaa6eab10529fc5b44e0c60d514e1ea03235b14337cde60a74fbad07b9051138de5215af7ebbca814d7a44c4605d627e5c33d60581b7544b2f888d897f1080dc70b82e61c8ff3efd77e2c0f0a8def8fe8341b3991bb5800fb6375651d4a9dfaf9c6f98b4e54791601559daae8f38124fe3185599206f779ba24efe88ab0fb4567f08d24e4c38281133c2dd66c93b60e31b0267ef1296c2350bd47f075a821272e17d0e8e0f087f63c43f195b701b965ddf2afa461b3beba398ed9171662a5337b1079f124942af7e5fd61dfc8f3a7b0d247641e2497329507a4159428b97162bf2be00b6f20ee30b37a975a7249eed21eb2fd00abcb488c8e6ff450720574651ccf5ed807c83ec5d0507a79b0d3e74b2ce795352b85f9e3337e78774dd76dd17cfd6248f228f3a37d7aea61e5326704102bce97e9f58621fbfb05be3611f4443a7a4b9f8f119fb177a6230b50bc1bd18e9e4e18b4b457e465d7b3160bfadf036bf3a632a54a9613601288833d118a9d43e5fe9254f7645c55dc252bb9114ef4f389314bc427a40bb2284f323146cf98416fa6276c8304ce2ee0b98cfc30015a150a7b43b0b9246ff55031752511df350120cefb2531237efd5dc6f96331463a9eff21b293784e872e20ceed9e0d40ab1dcbc2d7fd7900b1e46e182bebe38a32db07c2c5a73ec27717c1b230593277e97e676a8d1d06186775985c8b5478eefd1de5fd6461804141b2151f25dfb9d3f84a3bf4a27a5bdd3648e61def16318a03c845cdc9fd93c91f1051f20ad9761465d36598a7f9308a5cb22db59aad56927d50c85b4e03ef8ddcd3808a47fec2dc788d6787652f179010e019fc0568402db193f977b01f51c3366f2fdd2daf2300a4332c75aacb5077cf9b3838ae066a4a08b9c1be4dc3e65635328f68decf8665f5afc4304bbab41ab0cd73ccded04df9519ce2a68fc378d51cc4eee8cca7593ba991abea2d45145275f177e46c03ce7888870c66e1ba88c69d0af5ed51f96d81f0af00c7f4caf3560e42eb99719e02d44fa56d94ba698c6fcb8356ea2bf8c9d89726253e3210e1524b2d7e7193990f12ad0feed9d0e0498e9188dbb75363fa7ab539a95fdb6f9812d6264c128f24936268a49f0e0deaa073f54ab2dea7bedefc0f1de2dcb01d2aff5c11a546bc41cc540fde63942fc0fa8dad8c7eb67c9aaf03727c414631304ca63ce83a54bf1220f26a6754bfdfcacdfca5a8802a983d87b1a74a30b17ddb09ac0c5907b7f2821b791c4fdcac3151ce298233822eec6a97fc9b44e245819fd78b62f359b5f1a2ff6ab36bedb0dcebca3538954b0fac8c5f110808062980492a4257fe0ddb352b6f1661fdd2900d6f94f200aa3c2b9f768f833d0d2db5500c264cc9a1dc790da660b672bb423c2abb22fadb91ee968b1b40d226c1de00a303d824508e3038bca7c4eae854fc803684b97b1d02b5d0067111e348dc30a5386100c2ee88c9ffbcada7671aad451f8187567588bb13ee47fd3956b9e818a911c71dc4e6bbcefeff9d1a1e363635ddf891bf11d745e8acbd6eefef92b6e75fb12c6e3df5b31bc39f5639f6e4db65df4533d8b0badb600a3504982f2573342bea89ef393f431360b31895820a4c9d3f858e4c077488a9563311b4660e41b6d498adcdfc61c6f116b407ec90d0a420401ce60be904a388e3caecbee67e5b27c777a4e14517e39cad1e2d20a63f2d5b7c471178ebb6a0f784c8b5def51e8d83ce191a2f7440afdd87bd4ed8bddd731a14f638cdb63e72f98e4452c54ad6e43e2c4a0252ea1d7bd8d3a11a8dfa325183481d09b662b818ac404902f0d03963853d4ff48decade45765e79be2f2c4af4076a902656461a148a89df4647dd80e7354169f1fcfcf3419f74b1a5931262d8a3cc4007bd77a3488c96766126f58dd9b56fc861c28adba945a8937e80303f6e436db387aa5fe6bc2b4a5824d857e2acf41419f7667bba39fdca9fcaa332e2e9709991707749637ec0b57c41ea0116c9448ca7949cf96b879c9b13bd56aa265b11de43ea5446b932078717ed025db62c09e55762b18fc014f45e5c2d46ee054496542218a1d4e361198597f0e44c7c717916c28ea0b23a19e752da816efc0f073fa78bf75f086fa1f8903dee3104d435387ecb00b98894cdc871d80580757ff41b039425e06c6ae72bce2f5ad0fd32827ff60f74f19dc73695247e4d0ed1d3ccdc1d10097168dcc41418d8fb92364fbeec67d9b83d66322faad958ac93d31fdd78c872ecfe68375d7035c79f6a21ca32521c9983538f5d6ca31ad708a328cbfa17e75d0d7d84097fa07c2d4c965a58061a5dca55b7cdbea08884003d79eaf09ec9ab27dd8f3b2e599cf799d3c462ed044f843cd06e495b89cee50a9ee5aa82bab86f92ff8b0fe6138535adebb4405b1366a7099e706032009e3d231be4b83f261bdeea58aa2c3239be4a42983d020bc815f5e5be1d8c2254eaef7b7f2a7b91511f8b7a85de50251625b6c315c5d74641a7660a852906ba64793c82f6aae414ee32dab2474d7e6d470eeee8cb8aecd12879885847b3d9babede04c77a8d400a232df4111ffac83486fb2b0ae66b84c534e5da271fd7045b92d5cf0030868ace82d774b8b75637b4e58cd3455050342c90ac7ef8b30f707a61b30eb26e208e9de216905bb165fa64ecb1e8cf6d0027c6c0036b9e00600f8668407017b33e3c4ad90adc5eb126921cda49c240c8eb98a4d81d93b73c009520fc527afdef199d98c833eb8a015237823b61895cfe54efbc5447cf39e6f5527913883d12c5338dd4242c16c1c7626144e0fcca1b18ad41d17510491119ba84b4c020676b503f1bfce71ef827c71d55c51a7d741ec5503e0440d636ae2915b6dcd193f00bfa31ab709d74fec089a353d3853b923c65bb429909acd47dcae2eed3c7816f33f3ffb55a06e5b3d518c2a4f3d0b62edfd6e1e518336d7bd2cc7b1da0074449036be0aee1b48a96f654817bd489b9858f2e9099bb5ff229fa3c2c20210ffdc4f81f013967179374bdcbd91003f63255389f661f9222a5fa8e554fa769637ea315bc183d848a00b73b56026a1a00d1be8920eb4d25b58316bfb1372ebed8c1512de0c96d2c3fcb43af27116bb59eaf892f58d60702146615b854b29c069cadd46bafdccfaea169d12a496e319c403d22ec8d02ed6f33f014f114bbce024a76b93d01ae282ff9df73351542c6d630f150ec0bb7ba41c9cdc77b54e9f15aed2df587a5599503f402de6d6b5fe6a50ab7a1761dd5279752f08ddd02e8a45c9a6a1f74f9bf6509d02924965c276b055ff4ec4823965e264c47402d1aeeef93f017efc74eb37a8e75acd11e562bb4b7b9f46e8a8f3ed2ccfd2664bc7f54b3d769f30eb321984d971bd9b4ae15f182258f78bfbe75390aeedc07936147191f7d5a69b36afbd4d8b1d8de4a7087df02b419561a194aa17fbfcf4fd30f1243d68cdc69ec82dd7168262794fc7b7749eb26ef86f568d048ccb3514bbe0e34fbeeed83ecaa95a248bbb7b104156407f4b4fa9561f2cf5a7e9a3c41b79a1b233ff1aeeb2b302e767ad2555d35c8b80ceeb57d3da66c28c086fef9eaddb7c6318a4ba1101336c2fe688ab8917bcddfa3224aaeec13cee7d7f0f52ce1107bbd4236a34e841af6b6bd2e6a9ddb011d5f61d483b9e3255b6c694d4a5488f7b2eda1f7421f56d834f63218a5e05f51b0860f915f9d7294f2ace95844cce0fa557719aca7f7c93273806eff58efaa65e181149a062b0f067bfc6571060e184a702acabe2cb62288b8a23d9e31253218a71eb9b1bd134c085e5ec3875e812458dd70cce1349e699bd5e0f781cd51bd12c7dffa72b03587e1875b5fbae3d6b0cfc5f8b44b2741b54d04ffb09ff937a8469ad8f9de842411815ff49547d9bc2455c66f1abdd01c8139d6c972cfaf61f6ea1948c976fa3970a1bf3eb210473333af3e0948ad71287b0099fae2efad3cae884a6fe1363058de0fe9ff950175117aff60bc46775cd6b40e7fa61640931e499a19795448431bcbf714a24efd621c680f75388247a0c57c6b5f1bcca55bb2fd41241aa31284298781a929d98d443fbeb4fe1cee85a96074e33068d106c8ed7c78ff1dfb4c6307e77d5a27ddab116b567bfa595bc0e8767f2e7ebcf47bf4fe3d2f62b91e3ac7fe441a6275bb0452377bda54ac1a2969cbb2f0a5723916826ecab197f316908fe5606541918030f32c07835c07cc36778b10e1aee9a3fea5311ae31a5386d2de29d10d3098c655f3ed1c998de80b43845579a032c9d7c110b16e8f9790cf0f5cede4b77c8cd73784e00367bcf86db64b8b99d71dbbef2027e362e1e904cd009b7e275a013476cfd4420be20fbfe698aa0f4fb2eaf47ce36653f151dbe56b8d426c318e279cbd6e0b05c31bcd15dbc0d0eb74d9ebdb6956f7c87381e133cf398597ac8849a8f7e2d5ae4432ed48fd094e0e6651eaf6a92003fb862aaa7a0f058cc43291e40ff50b25eaae8702e4234aa27afbd3b0fe30cbc92fc846e05f3a312855da866a27915949360cfd57e9cd43fdac36b1c247938ce97648fcce1b42b857a62be68352343ee8b98c09924dde2a42adfbd2a755736a98f8e3db159f6246063d4a61e80a26423e35b7cc9b1d6e20da0c9617de214a465bbd55ba0a8839b48934b3e81e299415e17b7da6841f6cf4e21d9751efed55279926cdeedca721596a153f2b68e16dbe5b3662845ab34d340a031fd6c374e2d29136e954c73b7b13462fdd29a02b04ee7d8f24545d2f599228229a03bf97fe920a2dc67f0a7dcd3749c66945345272419ae4eafdc9c24fdddce57689be3b04c6e14deaac44e084b0a77cdf44c9538b13bb67a68629f886cdc8f5090f3396f7bd2241dbc1ab9d6486a14a0ed37a7de74f43c2ae7a7174b12eb7891264f6b7321fca49ac50e6baaac6ae610341264c25bdb9dfb1e0e0f3c37b974d458326ca9ccbc467bf5df30e29fc7a62508963bd65923a1fd79327112e178a758e552e2d433276a46637f4618e7c486a0f82dfc0d6e422215fe3bca580a934eb2c56da95a4b75cc8a5047b190aa919842247e55103714b8de5793d72d5a7a5356af6f7b9025dbba7d5c3f482c3e3f87bb38392718b03977d88064c530405c0a6975eebd1336313a0ddb29d75a315c811e758af1e5eacca423d838dd65aef2a90afce3de71fb9d804a91b2d85c7dc6989894aad102c1b88437d7485165c7ef05844333d8b5a0691e65f767375f8d879f935e1f28551b16f319ba2714c6a35edd3e846112572d218afb0ff3b13387940dfce8712c7e53feaa0228a0f041cad9fe8cf519319e9e29dc87a5781fd2862893d2f27c4ca39e2dea9e2b93e5377f11eb14f12f48158c67ad33a784161a1d05a30a7e152e44d7eadaf541baea0fafc137727a6cbdc96eac1c37f8115865e54b5ee0bf04e629f8cc98c570a9fb13f763e1a08673201dfb94f7385e6f7fae9c064fa15abd63e7d3ba28d04373aecdb113bdb803d174227e89d6d4ad0528243f09ac213ab81b7bd2577b32862b7914527166c08ca09ea8653a338f6fb5e926f678b21d62c2a04a88af4ab766998f8066da73e277b12b59bd4098a6233f4145d977703b5d52c49eae24974653256fba57b975548f2fd984d2716f47989abc819c2ca5ffc6da7187dbd3ba6d494d01273e4428cb1358b1b873d44c7aaf95072b9143a908b3919411e500cd1e54292b2fa4f5324830ec307aa611ccdd42c5610f3d360e355b2a57b42d588091d654f54a07ffa13658b32fb1fc66a5b3b4c437a4291e2a4fc6220bad66b94ccfa103b777f53b7304f6e1dff51f3eaf9bcbfaaffbed322e6e3aed27473ad4af5f3a885632f6f3e0d9defe1981df758bebc84ca5f3683db1c8a6eb5c9b9091aaf251d5f65a053d8be00b010b0a817db3b4eca42aaea7c40dc956b9bba6ac0c3d39100750cacbb4176d31d583b6a76169afe819fbfa1b5c5af200208d319ae2cd42bb1849968438290d9f70521e1cbf60a0d12b5a2cde870cb405981d1bb6b23efd8af109f2697519cb2d8bb6dfd5bf8958845496aabb4a3ce285c4c60bb0d93a772ca64a3e32195c9a9312b99fb1c86309db9f31c82751b49c7ea17e83ff39c9efb16d3db01a813a3c7904cee045bae2c17916b313a383d3ead1181057c7f1ff32790c5078c56375ee75a9f4c9249d3e40ef1124522139b1aeef35c1b14c4acf28c2a87d13f9a293b41e88849ca63b194bee04679a08ddea34d44e435b1dcfc0c5d22ffea394c67729124103acbbcac0ebe4d11ac48990946f2294caa2a464b82ff166846f4c8484ec53f075fc6dd3d9bbbd7b417e0654b2d7139d395d1c33c5868cfcf2e795d810216bcb09e028f62b91ec4b5785d4accf819347155688b62bad4c5d84703a9dfe713b0f54ad42c2ae0008bb16d41b407c6368bfaef0bdcd186e25d22a292e1cfda1a73e47706227a4064aa5c6864d933ca0b4299aafb26a7acfc6f370d76e833f336708640bc87d7666362ff3e2b43c407b1c251bdb34d76f61431373c646c677a6845c36cac08765a5744bb2f7e7c488cc5400ace706f6dc511192494844aa6e97554fe2027e930560a37bd7192e3c2169cd47d429d045bbb46fd1f12710eee193662a96de3bb1260180fac7b1cf0f70a386d7a31de52153ee717b4060f9955c230aa1c7e1a03735b2e5bf92369c6c0e429c1719a596f62ada6421c0d57705c2dab96236dcee4a443fdcba4d37475937f26c227e0ada34b0f6996d6a68736598182d92aae1a9be0bd8a334660806716973f1e364a1144cb2f071e51aecc07e7b683b8095ee4c2278d0b6205cfc3e84f0eb05d29b94b25ddf66dc71bb767503fbb142018f3b875d5771b9dee77c143c49acbe08374b8344f175e7d8e10ee375f89ecf7859eeb3ccdf980c074908a84ccb6ed7886d7f5378bd8fc7e4f590607acf6116dfbba7ac84fed654b3046d02ab989caec62c4556648fc46e8e55a3ac3009d7830a9c2985e76a31c163f66488eb23415fa4c93dbbc97756efd3b4d6061aa32024448410f22b3f0a72707fff6a472811d2e2cfd3facc6c752fe36ec4d82fd94588f7dd96322a38b51ef2daafdf63773fc4d24c97ee391884db396784059bad9313ed99095c07aa359eb254f9fac8957701c73bd583dadbddb46c3a9ff47982f260331c7377dd8ce6d11e1a193e06fa066be833fb8766049c02761f82fd9290d44bdea77d046ac30126658872b77bec7b6d4736101d86b1f6be9f680a5969c05d70d22726d05aa11ff8e8c15068bf52bcce639a5daeeccf87a3c6ced1b4fc8e9c2d160ddd42c5fe71f72608f70d8082cb4024ea35ada778b9a4db269b67a19064891dca373cd3ed77cbc89ce9ea09ee96f8f41c8a2334fa7caba13e799fe5a8e2b40eb000a310745d8241b752064e4a302afc51bb695a9d30658e8cd95fa396cc9ddfb2e9787b5776c2483f6cf267f35aae24b7698c7c10a131b7a763d3d827ecba83fd31db1730cdb431c6004a6662bdf2d0aaa95c902782eb7ba31af97a3e1a1f507c491422cd46ddeade3a6f4c9a541ece0254dcca172311736763596555c71253792be5ad0782c581db227b533f7765f5e07502234cbbe7921e561d5d82c21337c4efceebba1fa67acb4e9cf54334e86cd0e511cc21727323a461c2e517ae0bfb064fb8817b8ccb6cf3b10daa011280df7f60c7b613887c230393108728e9f497e8c09d331bf8b079a2dd9ba20a0f9985e71c5cca0987bb27f8a257cba55b1b8d59a06f5a46125c4fcd7277801bf817b1169db803a8c4f9962d68e4d4df6212141e59ba01b0ea053d952073ff9cc2409b301b57e374cee78dc1e31917a63dc03c2e25769568a8ac2165ea9ea01ea3f55088dbdbfbed675e01e2d9dbfb330bf950f12ddf8c6177502caf9225cd64c6252119d70f900897dffff12b991a12f371bb52d9ca9a4a491c074b272c53fb71aecdb15a3574adea43b80431527c51603b967506e1bf3e8b87448619863d5733ef732eb1f818ee700b6d1fc2323a37ad4b75bac72ffa7ea8e055b50820b35868a348a6d8cf00487d2b1c294b5432f3f62d851dc4124339782f6ff1fcaef6dd1082b54e38c124c688b01d2cecbedeb3676925ef928575694f0e3138d123ffc413aa7c4afe568bdf86abf7dd0220e640b14825501618d7576b1523ee0a61d641c37f267b944625333f034609972deca4956092e5f8ac3c643e78eba30b24d48b14e76962fdd182e1e074b2eb83285098c686a5fd1d93c0fff3fc7a5bf537572b1256cbde92d8763517a19b375d0831805c6e86cc0bb87fea319a63c6f30744828888e5643ca1311f6597efac9928aa192a344f83b41fa77fe04b832c2c1ddf59752cdf0dc34366994ba947a5c58c410aef1cee52ba0d215e09f619f24e4fee9d17071eff99d91d811efc58fef9d5c76b7cfe64e1c3e585da600cdcbe084779063892db488a631e055c08008027ea7eb7c31d99881015535b2c56d2f77e0fd22d80a99fea05cfaf76cd1a9ad4a407fe22b688f6c2c667a52f5b2a61a2a79db5a05568a9f0b96cee1f7585b44dccf167d8b4eeef5efce25201fc15b055fea9545f0885e91aa90d1f9eb2924c4976d9822160f14bc87715a5ae83b2d24d6f7c81993f90cf55468cd39b0deeb30535883c23570cffac23f79ec7d1322a6ecbece378569a32dea175a3fe16071948d0c0f65484be20ff99e97276e6d690a4f2686158a38e8c2922790d49500a37e7960ceda2be6a4bc34f1d8b98ab9a9d029214401b697e060097702ba0eeec75e4ab89cdf5f9cedae5b5422571d60223014d5298cb81a64c26adc217fa46191581fbae409c4d47aa22217e2c28153ef55c5387503d38784d02d00b3d2cd298eead1735eafa5802a0a98d54084c412027ad49d2947f4106bcf838afa31dc9cc0b401c19d2cde5b9c17c9cc16dccdda83f0c1d292676d8e197eddeb659397fdd321321c1965de74294b2264d0c1329913a167df83967a54492e2f1f7c0f49ddd8357f9cae6a709240c3d9937140a9144c887a1af252b6d16e085a8c367cdfb71bf76ce69a81d9bd7499de1dc0b38d0bf93da87aa512bdafdd412eb4ffa8f9275e3ebd917ef3c6108ca9f3bc43bcc25f7a89bb2535c89fe6f6bac0b5499f7a0397820c8d50d7852466ae03fb9ebe3598fcdd08138c337a83aa4cba9ea09fa7f0eb8dcba22195c6b3bca5dbbee12674ebcd4e4e176051fa857918ec3b39bcd64f3cf9c41afb5dd49a50c62d612792213406e69d95ba31b1159b0f25aea95e51055805979d245df4ac3057f011a3df22e6b1089acd01b2a93c7a5c26108e0ffe0cfc851ed2b412c82aa80c31b24d03607e7eaa795bb4f529f2b9232711f97bdc4606aa93e20e3263965807fe81b4d38d82541dc63f54524ff35586d53d0259d0b345173e14acfa85ebe190fefe899e1363268dc8f3fa992c6a0ee664b7a9134b8292b8a5313f053727dc8117c3e2b33955e17f0ab2b426d2600541f1afad35f102ae2647f2c522b65142aa016e48ecc89b4fe85a0101927f7f79c664ac5a1efc4287d1888a4dc38b4a587d1a3ee7d775430ab396666b4e0d8ba6141a85ffb16b3ee5f280fa0dc342114a040b614574a962d70fb11442726f82e46d68cbe9c79097600c1b00a367545a2a8810d15ada4458584aaef8419f4f7cd231b1f7659b5664ca5db5662177f4c4474bcf440bc5d537f0972793fd695acc7584d2cf9f9c830d6b8e9df08b7677d56a046717fdae7aa91cf1ee3805533a502265a8703736dac181912dbdbca4b7582e12718d165ba6ed01fa5e8751c710017192355ede66c0f4ab801512d622f623cf7ddadd29de98f866118c3605f706d0c1efae8064a7e64cb4d36d9badaffd600e2db48b884fd3376d86c71b5750bfbe3479f94516a0a42575cf6c90a4a6754001f56516190fa19ff1d6ef431ed232ae0e2d8d93bb3649bddb63eec5bcb98b98544b7cd011d731089060c8035d5f4b35c6968eeb966d45d2de312efd403361e64a7018d87e55598d902133ced63033452152977b4bf1a2421128f8ad83d995bf30a5dd7ffdbea3e560e7048595751e5cfaf4dc8d94283ae341895cbe9cd79aef319956aebdc36a11aa3c908619e299f031524de9fe8b3b538ee7c1f978f9f5740f3c4900a35f0677a523d3af793651aa2291c32b4f9668eacba434ff501b50085076dd4d3fcad34b80c51717645c19438ea214743bdf57a6795af1605d98d3e108627d3a83a053e622b33a485ca4244adf666c98a36ad5c5bc87d3505ee4b2fe7e0efd91ca1863183c50e64d518e316732b1154793810e0dfff5dcb0e4a3659366b9f47df4a6543f103da0355b8d122f757a77c25b324294346fe5e34b7f9129d91a0deb6f739edd00436e1d7545374a07e7fee8260ad6002bf40c8ec354098b8b62fb81b9a6ce54d7a086ec0a1a2b33a1a32bf8ec928edc2f608b18f2bfdb23d3d5e006e8f8d8d0c56d1162d61ad7cb315886c9794c3c18726d1342ab92341c3fcd965ed9f28b6dffa083f9cd5695868430d372584d577e840608c1f071d3d3cf8c6732e2c895d1e46bd6c3ef4fbbc2a69f82ef9ebc5499b5f57241c35fa4bb1fd69760d50b302bacff77f8f2ff5416c0cb9205305c05278bb4c57bb61704d5d92185dc2fe510bb82ff25cbfd6756564e938afe35c1685bf1cfab272208e74901c98c3d4ce2e06cc2815d0f8d50b9870bd58b4ab00ad43dd502fec13195f350b75dbe45af6cb34c5aaaafa4c72417c7ef902bd6d55a2983983d2a0381bacc70bb8da08255c4cad11d833e65303114436d334ef295733aa6a6da1398dce394009bf0223be52ce4977c5795de5ec23b3c5b05efb6e5e40afd0d08d40604ded2b945419316f35cbed5016c45589c38f9cb12a4a914a88c81da9927411b2bc72fad22b0c6a5c82077ee9469220a6c7578a0421c27bc2820cf7f22ef6b31952cdd953e8d259af1ac54e751f24f377a1b77e2c6a3c5541ea50ab3ea34a66f8c042f1ab9bfeeb1d2af1f62bd1349935c09962806f4aee9ce102835926de5a114d3cb5ad4a9a468a33da01fba06b6ae7f26f93c055802bcec11e1fcf768dd0ea8df208d929a829d36b7cd979672c0b878899b1ce1a5606c9b9b21f09522a7f13c27cfdf47a0ba0427885e6fe9c9ff9be3667872763b56ea8b1ae9446fcfd2f922a0182846eeb798520e43ca004efd0be699872ddcef74bc1d456544789ff5f93fe6fbad647b33654948e26a9a27f42614222cf0169f012769b99f2dded637f6b6e14f11fd922d96483e29748a458951a3f0e83f2c00115b8102462b20e69727a5a6a0c8c8363bb527c074c6f00d297ebc04713462ca8be5fda7ad088ebaae4a7257b031f3b3ad15e5fa001663fc7f9aec80d833b02ce3456389909373a37051a8725170f3b156fa4f250168e8b52d3bbf93b304af70259109bdf31372949444c5158c1fa5333f43d4172ea5a942535007c810f263b99596901a2976cfdcad3ed6f98b6b185402939c017f97abb0635db68ecd44ecc1b10cf1406e1467d3e870b9eaff5c0c94d26cd7826ce4c674d9bdf001e2094cddcb1cb9409afed0e6b6eb970897aa290a0d68e259d7ae932e5d0408ef9fd15b6f6946b414a1918d6c661477d491fd1f1878accf9392aaba80417e8a6b9ea138e5bcf329d744e9188fc639b43632153bca83b8f5b6b11d1b4dbeae2ed7ff3269a6f430b77ca6c2247e56b448c249753a3986f70de59e2f0978bea7103f188bbeaa79388e7530c6f810956e26e8518a6adaec76b312a7c202f58dd4b96800edcc7ad3eabb49f261d5535d1e436b7cadb7e2833589a880ec73d74d0486f7f5e17d53697fbaf51b125e7b2b1b8414a693b95e04406026563b01f2ee15fdf80b584a50ab051cb04370171c6c168ee25d8ddabdf18d203bad7a2475cd51dd0e4830dd8bf21100b9d75c5f71fb9f0089778bd490a99553e17e97694fca5b41fc210a67f7d2e1cb04e43260e2436057da73971aa5840155d6cb01d41894efb64bdb9753655ec7eeeca0192b0cd0bc63928c2cd01a94de9f381f06d9bd9dce4df55708343f333e3f2ecbd3bf01cf75cf8e792c844f80a95f734cef4b31d36d0f52e314a8d41023bd9cd87fdc108e25be95bef1ac226996b4ec3bb9689b53021f92be419c82705387f4ce0456b91aa2fcc656dd668948af0ebc8be0325288368019ef112629782161b22e0e7ee07bde910d959b9c58efe23c5d349a1ab265aca116b5cfe1c98ec1b98961b6b6bd7e909923a52e37c1768cd0c7c9cfb2e84f18a5a032ac89a636058945b34cd36594ad71d7f8c685d5e8b6cac911f5f0fedf3083147ab15bdeb3d5108f1ab58db2c211e34d0be647af4022b25c864c973920784b8ccbf73f5dc6d0b8254d2612afc25b44fb67bc03837d9585cf0dfb04477c6272b1ea35e6f3db2d0e31dbe3d55ad6383f5e161350d709618f90ddea8794c3a96a9501458bc3f45c236a25e16ba86dd05ff0ded9f285617b1f72f1b1690ee92eb18ac19cea9fb67686ae66d6b21da341b73fd96dad3b35992366ffac30aa7f47697901715a11359288ab1c57f16e25a3cbc2cbdd1d6a0f404a7f90048d5924339cbf80b6e10d23d402c59240ee39512b66ce614bc5af3c365da220fc2ef868d661b51a14d7f462774eb2c9e66dcc1ebc4f0f1e08ee73a3d6481ad849af5b87dbb20a27571ab4544fd4ec2c4cfd5d51e440320ea894ecf31a5be26ebd10066f91b4e4a69d0293b8f908ecfe39b0b7bdedc347a83c1d0ce53a309b6fde41e77d1cf08b990a77ec09c49c0beec5e7d9a46a4cc26bc54b80064c3e8e90abf52367280b3ee4108ee3af0a36b5e6c8d3854915509662ec8598ec1be9dfb1831e4d5fe6c211d20e6cc1e0e34b7cb825b0ec9d81b582e038c831a2de3bb242ce35ee7b2480813d8b6cb25f8f098184c5428f42e7c1b0cbec3712c196efdaa6dd1df437034d9ceec17c13b1ae7117d69b37882b61b556c9600f3a2fd91c96b321a3bb57fa7b4e1128c2bbc3748e90fe1574ab55d0c54cb5b552f4cb4882c45a402b3fc4bc991e4d1e7806ef0c9edf201cea72c7c4bf40aa05a88e0f1935c481ad8e45d61734197b6201a5d5829b2bd376a9c4c6719aef5f43a228375e7085154ef9a8d2edfe3a9fda83fbd0a1b8d7d8d87f8ab53d570b31ca7808dc0d2ee294a296dd62bd4543d3bfcf6ab71d6b2c952cd8973d26237952ecaa1ecfda2de6796999d5758a1b6432a5ef4dc3831805fe5d756cf1c714d930c6e58282c5173af201248ee67ac91d59764c1a4a0ba1f93082b11680824fb69a0cde24e77883400606833615d2687b7d6e357dcf6957fcc5e916f71d2236df68d0668e488c290622efe44fce9a2da6f727b22f5f0db55e1c69dcb11f8243f40fa6a0a33ba1fd07c084e96fbff4fb89f005a53d2176b972ea5fb864ef161c34cbf4c3d304abaa722ca0dd54501a6869607c5fb8388d59c38fc426a53fb6391af6ea44f6626138e2018dff053076546365f48ba829e87e8ac431d00f6ffc92de8b93971a185eea007240502003879f1f41a354916b61cd6916bba500962c89e947255f333d8a4c023d2a84a4ddf96c88a29500dd76db633a750de23c8905492d01534a8c0930f38b575f6b5cc0dbcd66905ee47eaa093fac99ac49736c93f21128cdf1e760c4f85c8e0bfe6b947ac8b04b3b0ca38d62002f1f86d99c739e6c317cacce1f1cda436bf77432756a8ba4a96d29c763dcce16ef62fe86fa026e0a491a71754d16683203ca0a9e1bcb27f80c3a3101bd6f1cba967707ffed68fccded2425bdfd3413c23df7b259805799f972003272fd352f6dd446ac52f5c08161523f8644ea0cf721ad0e1dac5821937ead5bbdb9506111acec92fe5c4a704480f2e7ef3da871c54affa9a66fe4cc92dad5b5f4ecf4c83c90ba05be375a0e09e4d0564e808faf18e259890dc60ae987a82daa96a9a4d5d0bb22f6af7ee1124336aaf02cd60408fc8dc19d61e87d4c8344fdab6ddfa3c6907e1500806d126d8ffcd51893f5a19b0d97156e632e8d7bf9e36d42b4d553703628b01fd078458b6a3f7da1d572b3afd47585c99df44ae1c484fb07f6d10880f1d269fa64b50f8c5505bcc2486405b320d185c707a1a92ce268f12084dbfd2851539ca9d3d24c052fa190364219a08e9566ff0c7d097ab139f93e5aa08d4536b52d2297affb9452be193bbf13f805861c48c39d6ccad6a7b0b562858fb7ace28eec47f78f4821153822d2fb8a90fa3cc87781c367221e790c7627d8a0087f1ba96354bfdbd1125ba275f3ea372c09794da7f1d7c82f1d8d051738659d4cb44d7fc4a2494d1ea5c952319a3f5249d99e874e786d1fcd49c14f59888b270f4cc598a189d2e52acfd2a1db027e9211053909a83ecb6044c39553c2ab8810845a415625aa3eebc26251209ec3dbdcdb2f670357b1c18436c36459c6a257d6f8da777fe5ed70fb6224f8583cdd9d64b14de45862bfa26d84e612d541a16fc3197afec0001409cd0a7e1e347f0a04e6797fa03b1066e45c4de5d36e2742841aa2da44f2a42e144deb77ed32200b0b12803b9c131942a436afdaf363a0282e26c5a8f280d3563bf2c121976a89f2fae4cf18cc77f7cc87da4fade61db28bb486b5e83f85d1e426f8257ef8108dfa5826ca9d1e3bf2fc205f07cea95f597c3d25fcea763ee57af4916530df0f4a3c5d68af5ad1b26ff23028a5d815b5abc697d29d178b9e09d498df460ea2657a5829fb8e105d67ea9ac260f569c9b86d99ed0a82697ce3d529bdaa56be2fc8887877a818d3d91ee0c91342b66432d99a63dbf251cf8f7822259f703f305b8c5d453e71f3ecafa80793a481971fce9cee0ed46d7d9151825ef9aa16b08f4e67031a05beba3d2bb5a6fa96d46215b0c14e4087de3bc7ab985882d1c257b9daf4878694ddc833e8379a10cfeefbdca5c524a3b2a943f1c4e868c1233119937fdba4bb78908ed2fef3106a043e6429480df1c3e26559f86df39331c57fcdf4df76ba7cff275d04af60908b3307fae0af05d0e742e92928db83d0891252d17bac567a3145fc2f5fff2816749ff7172e03132e9f2bca68204bbcb067636f8bbc60071a8e5f241961ff46de3fe306eedb91f59c0f4879de3d1d52e76279e9c153bded7d24aa442b7a4b3756560a3f75e72466e9a993901c179312ecda191decae027c1cc8692071ac1f46dad25a2fbeda909c86c1fe017ed4d8c25eecb8d4c8b55ec0375f8f76211919b902951441fc6c4c32166662ed0dbbbb7366318d3166714f0bfd0356398414a573494fe98d3e41ae98b648f911db1556ca95991b59f1d92de06de91f47d7aa0072f0c06e5928961362885b8d54901618c9f8ff7f7fb06bad38a373d0565137fbf5f3edecb1253a43521abad82d0e4aaa8c86337ed90a1e8cf8eb7817215f1d954d45f68d8c29f1ef4da0bd51ed2f5dd3eb708fd5320adecc101d4f9031a373cd2bb619861f3372aef47d3aa0570bba80104ed22db56d6792c3305ca255cb0683d0f02fcff638ea9e368c617db890c99db8dc66c9c68597f70eed660f53fa1fcdfa0598451e6a40a3a6a93187c8756e5d23cc68dabd23facad0ea43d9bc10bfc9d2b58b0952499c70e6ec81504ed36419ff348a9b685d7a4fb86787617109ea486a46902797af18787292b831c3393fb8451b3c689a15e992ca367054fb2d20d4072f76279e302259092c3e1bf2320c405fe5397b22675362128aa52a22459774e272f720f9dc682ddc9a1584f52652949260be21065acef71b780e780be9f2396f19213c726f5ac840c103a78e3508af92dd470734c5df594456341b546b6d3637ecc0225892d56771edc71221d944e047979caf9041988dbe2d0521bb5334bb8a105cd1cfe1781f7dfc45ee109d21838cf099f48596fb1bf714125b1c6c7a2a1394acb3a85ff33ce110682c29b08e646db9d9903942731e31a186d3954b5ad042708ea964b5d5200f1d2e5ef96a283c943b5304f69dcaa02340ffe97239f4d6f6a3ec047e98675ea91fd7f98c8ba53fad1d351f5a933ef9ea507431499ef99f9c120d9e5a5fdb1f56595af1ccce8dca8d6f17f87717e8fee63fb91235782e80a3a366305f58107c87b8bbe2bb6ad7bc97b9723d9fc9bd96118cd289f9085a1c653df9f984ad63675a1f36a1ab6ddf06a7ae9c8e210bfa768fec5a04d60beda2b3cf08473cdae0afafdbf7ee837a1cb6af03ec3070869f38a08ee921d4472397e5fed46dac777e32310a140f7bdb36ec7e7cf0223906d39371db8bb7a153e36eca3994cd6bc7c955ab190398e77318fb73f32a038e4e15f0920d0ba5836592f0ca3721d55a107e5fe3348aab2a26734b6ee2cf975d3aeaaa54b90da4e1c8932d15a5a362f913de433088967207f6b95857b3e93f22e93ca4bba48e79ed125f28172865330f4c2782c9bfe772882d2acac7c880e594ab7c48f7abee7d711d2aaf02a1f35f66037ba67c2c0ff0322652b67811d7dc72fc8760b2f9d17d66f9590da2878f8046d7b68ea867abbc4f8ba505261f41b6c6d9374a57e87c4bd3627b44a69569f8607314d88445599715df0d36f8cc74c7a040be6a9de70fe85cb834359570da977044f0a29b2e612b3096f5fce796e2570352d777a0d0efa248820a425baa5097c4c49ba671fc8327d2a2c1b97c0011f25c9c97d8ef83716d746dca17ea78c55dbabde2214d307454ed316efbf518f6e86f78d5ae23999fbfe95163e8f7cf9253b251f688f83d8d3fec2a0913a8ab9ca413ddc510e21ee9687ed0cb258e03f6477ec95fedda8001426b1f9a61a1e3c6500ea1ffd2f2970920ed93babe4b0d1901f42732bda815b742f9ee6e80d9f432a7b2e418f46f98f5913c47c1efab6004503b62bdf1ae7da0aafb1504c82123114705c8f56f2e317ace6a6335d8ad9f076dc9e5f3c11a00592a572c0bf538e39bf6df687b8d061c4c19407fc8139dc42d3b6c89b49508d70ecd037bd382ac314626fdd50ecbb61d887088b569fe665017128d9f3c6c9a55f66a037bac37035900b10a1e7756dda07710c767f81450cd2a4865d18a827e62066cc53c23aecefce43395c17917cf739a44dbc57b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
