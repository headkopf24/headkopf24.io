<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"589284e4fd854b9437f6567be751ad6b39753c7e8adb8d4700fcf732df66f1bbe20cb090fe1c219314f262dbb3018921fc4f339ac08d8f3d086b456fdacb7c9838bb4c84dfbaddbc1de4cbe7adafa3a767b3d5ca7961e0adaad0727c4ad86f2402b461f1735c75f92f9b611aefbb2aa908eba171138bdfe543995c4364992d86e3dc2f72d7224a01dd46e07e0dea8555f88c7a9e9db9a827122009bd9edec5271f18e6c8055573ac48c16f798d91680e0ac474918c0aecd94ceb4965d76c74248a54ac211088ab7bdf8c01a60062885eced2c6a01385a80f3ade950f9ae34d86c0ca289efc33fc5be8b3860b3a64841d509a847903103e1bcf3aeff9238c00aa4e791db7f4f17943c2de56357a54496e46eed994504477bcb96ddc78db15b02e0c7037f86edd4f036b1e33793bc630fa5be8b588f4c768cb2e69537d4ba65049d3196331a8ed8f0e414320637fb10cadac1ec2b2e1fbb6537d1b0877ff1e15f4ba2a21a2e1f40d5237657922f0f48fd62da7c1d6982f394ae871ccfbf67e496e47e802f04fdaa8a4fbf7cdb58b148d741cfcc9b2143b4fcd474757e47b1184db4acc260e4b7c223a54e661e9001037052db5530a3a4e94c8e176e2fc8d873282d7dafe7e0c17775d66bd595eb454ae624f6fbdfb639f0117f0f5bab6a6e75ae918c71f03d4874668f8f544580f99105e7e3dd84af5bef9b3ee82e752a063a9bc2f9a55bed625cecc944ff54d2a39a8971ff7f142fde20800168affe5e5e7fa1c98c0db5147b10d08ea50bd68fef481cf628252f0ea1c17a915d6bab67b061a3329678fdb0ff09c5ccc58042f47ca02a8b431bc42081dc97ccde36b8aa7a9c88dbf50424dc9065eccadd4a779c23e1024dfb378b97025dc11aeb0fd8d197a6a29dc36265aa5cc88e07b9604b1e5a6f37fb0c01086ee8e7d3fd5823f794d3d561685fee4d07e2e3b469419bbc3fa2714cbab2732c6c4210ece486401f089eea5c0f5e11108c109d1e347251bc6dfdb48aa70f1b549b44ef3cacca6c01240e14760644686643f5a73898ed047489d2c9d9464ff84d649c2151e5ff7641fae84641ceca0b0a1a6c35def8d5d5632d96b17cf86228c8e906b499fd1865a582281f150a7e212f3f2835f68bae539581019574452f20ad3609bb9bf0a96c72fb0f25ac68afce38b4354766bf1aaecca6377d7ec1a26748f25885e0a86d1996dd8259c870b3667a9456356089e1d0b053953774175b8380afce2835549f48934a574bfd7e6dd77b3681e3b857dc5e17aad76909b1325f467b517545cfbea8f29e6634caac89e87925b206dbc9963a77dc33a2045fa7435a5d5e364f772100d160df166a33e7ec026c9dc2489a432c648fe758ea7fd4f4980c1d6ba6d7bf602b56dc333cc84e1af688c5f8845a149eb841935864e5abc0683dd2b34dae8faed89c58be02ed4bae07c0dc78b3a5cd64d354b2d6c6d4213e1c72772fa4ae6fc62fe83b387a2638915334077eb280f55b5e0b31da0d4d164caf5713a5ae2a451404054a147b1b29fb9fc51b9d03c64ebb7fb46aba1505734666d67f5335b3f21312a05b351a82e0b6b8765ef41f0ea9e7b97175492d23d8106fff41d2b5af44c95b77df868f0c02b666f0520400d68eec913297c8486b1c2eb97dfea704fcdc2a09bbe1a32df80f3071f69ec3571bf08b9acb93d53437bda19b6fb254e5f35b743028d7066510ad0e5192cef4b97c67c143a3c9cdfb8026e07ddee2c2c19fa90e56ec95067fb11206b79e5b6e819fdc4a4439c1472ea177f95e85d14d677ce76d6578480c1f924079f7d290ddb6e16abf07ec68118d3602e5a83f78df6685bfd8476ea309831bd5886d021a49e305c2792321ab4b2cb17e328530841c92993d3470675e1e194b50b014d18a8b6c006c1b84e499c365f57789c4657cfbcb45439174df2f586d51144517a9f00f643a7fa5855ff255b7773b503066ed3c3e5c2dd88c972abdee3d03a81a41eb1918b2249f597d406ba3d0c97c3e8189ff67b82a96e2cf9dff8c8ebd71f4fe043234d191fe41d3b828d6475ba2c9b2376f8556c3e17210e006ff1fecf3815b452d0b15135a64a33628401bae59606c158cb13ac60b2db4c00b18cdc0bb1d6e4c383fb6c55dee5b2c7aa17ab2fe4f73e2cf3a39f675370988e9e33a062cf59e9384a63a7968e2bb04a19dfd98f680b4ef9514ac079cd24497db801ff229abeb95f89be0308bec8ea37b67db247def8e323ec46b93246e32bf6df722782fb062ed4c359edeca64b45fd1e38a3ee4d60f47ed45b9e2cb3f0d157675c1e303167b56ace5a71c50b2cc0aff96c5e5d44b24e5b98930656b4e5203b0cbabcc4604695021d38c7b5db38a5ed5f27ce3f878115aad1707fc1efe18dd5ff74a1a6b623bf67115d35b5e3cb68a46daa907efb4a201ff51f58e26282ef0bdf01740bd539d83d60ecac88e4db9affc4128246479cb73ba82aeebe70c39339b07d00f36d614d1b2a3d4bdf00fac40f696b328bbb4f154dcbe7a8b45ce39e695f5c71bc415c227574d281ac95cf01991f6c9c95a8900a03ddee59072a335ba4c9585c14b09c66b54773fcea739704b253af946707a1e9c11861cce52ac1eaeb9788816a6f8541044b79baaa42559fd634cc17228b6a4e2f7bf9d832840f067d27fe4648e7617708bd81f92dd2f0fbd99589c835eb0ee0fc8f342737dd1e910913c923194257b64872fbf2ae7358239ceff6ea3450bf849adb0b1a1ddec10d76205be7058d3d2bd0b08ad25a396a7057a7e587a33a3412f6938e39fb678175ab5c93516f11f064d78ef07c78c95ec76f02279a0a567e72c60923ffa7c22fe4dbfc927708affba947fee724b157c0fa4ff2dff1b5eeb85d7eaf5d17f83b5a8f7f4eee6b6afb2b76776d6e00d7df266c672eb3498dac6a0753a89812f752ae80a5f8d0c2d0c5a0e521f47ef2b80c50de8a435b8033a9b2f84726fcdbda4a950aff46de7cc88a515c59235db38219d9bd034aefe40e32f0f5cc86a3319c511e4d3d6f525b2833f4647655baf0a02561e1dea22af4a2ef496c4ae599e335e1474d7dd1ed697cd35a28ab30be47c739d934cd78f0ac65a75e6f0a0f1312f2f448a1b276013eb8adba70710cafacf72b7b29eece2337d09e597656a533e361de0bb8d04499ebcb963cde1ed6d9a68c2617a500162f9d4399c454b2112c8f37fb8032e2ca95bf6b9ed7206a1bcc3f3ccafd5f012cc64d349d8356aa33d40705a68b9b820f829d0609b0c61349f00e86565e6fb1505942f1e2b1cc1a55ce91d4d41b79c2981f2331b23458581db9a1e5a0634387d34e6e2fcbd04525e77aa1560fa0e1c486d1e62081a022bff959f25c4bf1e9fca7230543d92385708a54506cc4eacc604b449105749d353e352e5d1aadd9b08c69c916915fb4971a51f164c930bd41da88a28d73025eedf5ab741beba1f41d2e11cf4dbb72a63017332962ae02340babe3b432026307d4b6effe36a688cc3f45c9fb41436d09fe45d602e1a48b8010d78729bd17460784b89935a30b4ca866cb4a52bcb3bdc8ff3c6d4ea5ba8533f2f06f457697b0adbf783f3743e1d6a11f6a51e6edf94630ebc01bac54e08a3e3030b655490cf4ce051a91deadbaaa68af00eb1d71738d83556d08ff6d1383ee29379b129c23748069ff6919f1698d182bf84a32bbd96a280ed377cd2c06eb412f306aa7842b526f3bdb3f57ad3419b18d853f0c2850d32e65fdc2e5c26fa79a8ed8b8ba47973bd0a200b6ed420a9938f56df1404683416e9edbbbbdc9a268f6329eb03a2dafb88dc1f12d1879d32a394696fa86944334452c8c9d1b3964b802f27c3419c113398730fd3a4b7b942dcb98ecd7043b1bceabee2a57a9b3f18c8982e06a4a72213f546badcc756790325e30555468ba8e1541894664875b7442ddcefe0b89569ced8168e1a504a947125b28f0ba252bc9b7a631e1d92485f13b07fa03679a145aaa2fbee4bb198ca4568321823d792d12d1ed1abcc03d0b2821f6a98bd96cec5098a7c231ab102c03cabe2e2135983d0099069cb2ec8bab8142d766a07bb12a192b0652e20cf274caf47d1b7b89acfddf6857908a674ab8db0f559e0e13dea3b6f25dd692f056f130a953f060654afb6edca9402bea962af9a050633cb2977ef4e4ecf99c00151bc249800dbff1cd2ff1015993e690caa5cb2095ad35b7dea99d4e4472fe90703f8cd9ebf0e146d47e602d793420a3e6e21f5ee5789bc6f60543d67fbe45d7968d10b6c95c73c2fd22b4a088ff1c4e266d98c92e245e5bcc2eb93588a1b3c345f2710001ab098dd3bd6aa84d0bf627c46dedd4b814ee16b80b6bd2d118709917c03edb70bebb1e2d8b10c7120ad088f5c83999180389575ba7904ad90585ea41d848dbd9ee89afb7fcb83303b7fdaf66263dcb57cb8f346d908bc66bbf7d366bebef4c7a40a59b7abbb0a03aa3c3b973a517cfe982c69a8f5ba2553e3080c764f531a4aef2c613482e03c443198e9de15b19fd357522a764edc143bf559c3f66036ee7b75d90c0dbb3ec7c93118afa7f5921f9c5ebcec96ab8500ba94f57d2204cdef8eedf47ca99065395c8f98dd52a41d76ed60f217c3d24cd17ded2238640c4420b4a15d2ba888c1ab04651c919baf4e62b402f67c272094ad4a22805b53efe8da43d781616bea20b830af044addfa3921b6f3ac1ff06eaae88ad84d0b9e5ff0c90dd0b6561888dca9a3439b9c8420d22ce35fa785500843c9c5d33176ab0e66476c71e809c0db66f4e182106ad950e27b83d20d7bb2acae733e5a32de57e93b4801e62dd5701c0b9a9e7d2266b474d04f09265773745a8ea9a090a35057a35022e3d69145f090e79a4ff41ef9e2a04b78e375b40fa6565f8eac5a2bc05de52b407b3ae4b5b71e0982f2194c789a77139a65b915abf87d530ce868ee5e2afac34fcd82c371d2cfe02291e094857e7d1b232cca139123bee4612e3a08757f3f21bce491f96d32cdfa6ed216c56a3763f8ac5db69b59cc91ac68749a6df2552f27614a15ce57e7fb885ac8f5ac0fe9b35be5c119d9b875f355798236d9ba70f863b91cf3086dc8a0ee60d17f02908564a1875bb2aa3b9102899a4e56c69e6c294bec64f14bb40ccc6e2c843d80bf5d5b813f23bd7ff3c68670e77a030919fde8e48f2e42bb588615c2380d9a735e1c9d781f8ac990b4944421d5e4721ea62f69fddb8be69b14c197e20a962d6a31d3ae7770213e2dcd603f658c79faaf535dbcfe5e70004d57e7a6aaef83d96ba8f4b003dbdfd47173f171cda69604ddb8214d56388e6150e81a59a1fb332ee18b438c27e6e0bc3940d202bc5458bf461f6576d1e2b62457ceb57de69dcbaab2f66773e4bdcf5d2161bb9d07095969aece3246a980b426611cf2e1e3fa43d723888f101cfeb8aa997a219f0b3f76746621bb7eec06ca3877fea1b955e1a90a69000329fa0e4c596891a0bf53c16fb84560d402289fd444e3e19b8ad1ffb5d870077c761814594a825907c7d6ea6d4a6ee18765420d66426067034775d2f64a552ea970f0dec02d1c13e7d3784085b391e693abd15333fb48a5c4d0598986949549c9ea0cb4fb00ef8032bdfeb2e6cde8f925050a0d2edba728e1f982b9daa54e4cf91569c354979c2042e323b7fc81ecd1c1fd563754027c9e32c8eb6b51dfd1aaae265aa1610327c886a618bfe5b96aec7c651d3ce8717def3298aa87430b381845d4c50bdb327237d852a3ddd1e4643f8e25868352d0b9ec17dab04ea4ca5cb9c919e806add0bfadd03db17a209c2f5d5821cf627a96f7c0b79ebc47c6a217a3265d840bd86058553b4fa01d35b9fa4dcd9502a7eeba0d527f01e924b0f1f119f06db220bfc7a5d8ee1beb1d945c75390ecac1ee0ca229da9ecb0761e9080ce15ee887facd28770e837ef92c6a04af783d5365db7044e5f44829485171510e1a2baf82e8323ad4775be96a226fd5fbe8f8457d824a3892e596eaf72c0eb07cd9517d12179346745fa38cfcd4aee1eb7986bf18ec93dd53f3c38a2acb8966450f562f76f26ccc3d175799bce06b8c24d3e1dd49fe62cbbb011eacc4926b44adde0c3ca693c842bd54827430ddb010d1b47715e2d0e5d87142a2d7d3e77097eff42914ce51b99bea4eeb6ad920e98548667b785a3b1b69016415641aa163c4648699629e1462f781f9d23c516cf025b33e6146f1bdfb70118118c5dad81de13a5aee99c3c10aad8061c09b1b1ff47df5330da03f3ea456c54664b690a933a99b4a28de24a83f228c3e123841efacdf98f5b7f29b3ccfebed34510143f13663e69ed0b6cf06e0a8052f620a772d0cc873bc9c20d452528d777fa2555a12c45f9b0f17b6d9fc4a46fa2e7ce5ff7e77d2e64d8de5e12f2e6d97c5b5d031aeca69c7c9875947aa02991e9f67ab0a735d908136cdb6b9248eb1b9a4e2d78d1029fdacb5fd1a6ec8deebf3a27f43ceef7292871fccd76af50916289841db31b1ae6465a58428dd3eca7b03e01ee60dfb7bfe0bc3f8a5e7fc976c23d9a97862745c204554e956a8233f0a06e87be7ded0389eb91fbc5a92edd92c6f4cd76da888933dfe5ee09cd53ed1ed872a59e7e2b312af4dbedd1c2111f5a0b7d0b36732aeaa1921c0b27c7e621a37a05587bd36f0acabaa22728943dc27e51cd019fba3eec31f190252e3fb6280e76f8bcb7fa8f9731298c94290053dcbdacaf852b130196ef132c650dbebaa64270b8680c0a42753b0fd964f69a8f565bb718f06436895a147754349a9ba89b8c2a24c5d641a77c7b165263facec7ff49910481688b438f5754488de1d97009b6e89e5f14c5eb5c36adc3006635b0a66ff8ae8ad6a36196bb036c03d5452358575dc5768d2d1009cd5b2177807044408cd48f3414fc324b6cbbda08193ed5dbabf60675634cae99647423b7ee2e5816875405e8f8de74a813825bddf94b953095eb095e83d80436a970fc2d7890aa5c06c9c11e7a2ff101487d86990a9f713718c26206396b7e567198f677eecf3e8fb1557f33bc19c8d55c3b012f444f0adf6f2cc0c3ea38da06fb8f351ed7e8a4d0b2e65e4bc53299eb30cdc2eff7c03edebd8930ef7d92d9e99132e1dc0c56822d04eeae8012eebf08b9d8d9155cfe0732f4930b4c2936529a50911ff9b8c001612d433e5557e681a49df0172c48006ab0a619f834e1e2a6c8488bf6375fc5308411beb52ad22e7539d68a405364fbd2622ebf526d145e1caa075d4b403252e0a658d000fc3e7c04485fac6788800fdf55b2a71ac995f84829fe0ab3011fc4fd7b49ee9998d859bc0b6f520a48ad709b1ed25366070130b431d26d4a363b3da74d423d775f0f9f58add015b10d83c999e9770ce61ee879fb18050043b264fd531f51c36a5a92d164476f20b991019f70734fac2772d0d805c80f6084fa1c415ab5126df317957cd6a82d312219970a6748353a30da8a3e43ce24bd679609b17abc63ededd73c2be855f75a1cce2bc392d86c60dd2b306295d4f42e63f133d99476f9d86455fb6c3cb4d86dc24f5b0f0e8bfece5bf3f62c0de254e3e358daf6de08be8412dcc4d222688d5012b3fe2af20613f8ecb658cd6b10f21a131e292218a35c675b0edeefa81fc8b4f7093c5292f2e79ada4dddd43f2f57c170492cdfda3352432efe6ffd9f50bcf890bc3907a155e722b298ebd591aab38c37951d009fab730efe0ac61e0b86104107e1e74a169e4672d7a8780012b8060d519d8c485d9ff60b38c64700738d04463a98e66b216a325fbf54a6d6d8d09dc7b725e9ecee2e6d0d154e17dea0ac2236ed9bbd9736660ab916e4b7f431fac556a7999cbdb6fd1279f7e0cc175954185b8381fbdd76ad94664dd725f0fc1a1ff43f81dcb3e9ebee6e684fe18ed89501fd5e894dd5f7145ca5654f3442fdeb8603d04f8430e219d507ba25533da191d9edb3267a0cbd9a97aed52cfa48876fd0136bae2cf1e9fe4205261960c05bd1c9a33f084a765001a53b69ef268d3784b995581e05cba9da5dde8e027d82f3446f399a90b36f47b0c9cdfb80a7f9abf846434827a23cb63330b0b88071a904b57a6680162627d013c89041132a3760ba5f103d5c79b423fa0b4edeea633898eef4feaadb85f0b4e6f8c07591e97cebe7f17756a895da33c72a0f7706450518b1f6476f5212947a1da4c626933b0b7393828bcb57ed9cb91287678c592048cd0c1f8b6aff734c3a3128464b37ec1754d02a92a6bc203724ad15750ccab476af7de6055264088b1c3de8d902471a21435a9d17efad73fddc83988a5ed6bca5e68e0e573eb45de2b3b7a79070454143609458e926b4fbce0dd71c756b7d063fe063324967dbac201a1cd408fdce5d5c6bf03ba0bd37711ceb511c02433fc23ae3c2db9369010451cbe9627a9aea5f94b7f05f51a76d97d8b7621ef0ff9b44f7e6e6f83353932a1d130f7baa804987f03df268b7282ef423c708e30f20384dc02303a4c95b267842646643ca4e1e17daabd824d07c0519946772b64112adc282253c4d2ea5d596402141ad8e95ea3de792ebc486a7c7824d1380e619bf3d58fc70131ca856bbd4f1230710e10df70a3dcfb3c7a8a4709bb58a2a52335295928ba565d22a5ed223cea72bf3af51adea0df343ad4d00eb9f62091686d06b3e7cccbc6c994c64d6f6ecc6ed1e7c9b27da2aa2c0a5f0d91e74d27dd658d63c8c05828ebc23de5762a30be2c591fab2fd7c8c8008a4703fafda9597d3a2e59a23977d8a331faedefe18a0ccb0890837976d60747c21c7fd0824a3e364d91f2f0f790e166d1d0392b735aed04c463818fe051c0a87f853e053d5cd4ff7911bdfb268b53329bd0b3c8a5210e66a7b019d0b7e813d5aeb128555f7840ac55dd9a14813e6eb6ffb4e34c1608c1ab01c16f8af7d0bfba286e5f7e172c91979db8516e3be13e9851849904e0595125c153a3b944335f65ccc697c6fd3b633cc91d73b50593b64b925e164a40c8634ceebfa33eca741709b7358508d7f4ecb2a41d11017a6ea93c43966c6ab9ec2d69ea48db5c09efc623bda3bb2143c27f5dabead95f7a474c055cccc887e2a87166751f52f0da1e7a22b3b4b2c1a3a69c5b44c2ac30e634db9974b61ce9fa5b3fd086ae8230cd9cfdd2b794e10e37a5bd06b6ae356d0a0f5d40281080148c5516fa0a975875e72c7f10256ecbdd093c6cc17d643e6e8f2114bc022fb57659163cc64ffed5580702998d2c1e511b24db73b4df1b2e991b1cef07be9546f6bca8fc39a9ca421bf71411a86e89d9f8ac17ef6b51f8d97e0ba72b864a80bbdbd72eff391d1c95e29331f102a01b9e35eea5706da4ffb6bb2f6b2e4c0c1da4dd8275cbbb00b9dc016db05c3d9b76efbe319c976d578428c8e42f24665da5e9374ce67f37a986e5f6121322a68026df80d1881fe130feb8ad440611faae02794300e09487f685aac0a2823274df0cae3e2d72ee6c47c1362e9851df190a37f728315f6e23e84aff02b5d027333e7ea80cfbe49517d23b5b3f954161c20a1418078ee96cf4d591634bf57655a870b790160e76b6860cff46965ad498de390bd3a305fbcbeb2e7871c0344870d174a174b94773f79916b4092d6cfbc36cf966ccfcacc6fe78c36ea8b7a4578af75e106a16202fb98b305ce3f28e37f8aa485facf567ab27f3a58adb68f03537d96cf6ef4abe3ae54bf32bdab8995e47ad706b9d0a7d213d494afd99d722ec1a221d6540258cfd72ca59452792c7384269f5241510f95c4196255ac879a75e78f5f53c4c3d8f28c790d3c4d91ca684f08c62afc9bebbbcfc7d8cc14942a80a37cde0ef84de59627665819e05a051bafeea538fc300697c9877d681fb64ce2f805153127644c83cbc70bcf97e7a41f8e65a9af96010c2f152cff745263fc9649e6bc052b203b0f6afda39fe8337bec528b22ee881b81591264d39daacf5ca032398ea77b307ce5b0bf3219c64b656423901c3647e5bb8d17bc34d9b8cd39c2e98e376032784be888741f9f56905dfc1aac4a87a96cb506cd346eb5be183bc54147d6014181162c058bd47a6418323031f80b4d26b7fc0dae77016f1a9d3bdf4c8df7f1b0748cb0a59cc3a387d683de1e1fef338e40453d4a534595ed94e869105ae755b5ce505a7aecb18b4e043ed6b1a2dea8b5ee4ce4c5633d3aa9e4db88268c69cff8d75b306aa5c14adabe858c686670c0421ad49d00158a50ebfaa6ca464d116e5f2f0a38bad6eef5f1ab59063c43efbc1c87c28c66f1ba5341b7197b88862aab051b8925fa0679a82a92a17a045c1d633f6f956c740ec92aafa61fd87d303d14eedc3613a04ff9d758bda0f7dd3c4af8ffda76b3b4567cc8c4ba63f243a4a0687057b2ddf8d13c0f6b45a17820f290cf64ada09e61ca339aa5a707387728b4fcaad4196db5451d6602b54e8ef8094585f6c596c6adc9859b8e35f3944049a027de97f658f84aa32fd26c91d99d81ea24b69c69b4d51cc3cec8707d8ee5953a703f8817fe30e44d73cb3ed83af3c769be9ddfa125c6be5fbafb33f7fe7e470b95bf2435a0f7d80909e6a03015393e16e45fd708ea460f04b9bfdbb961159367717b8fd31b0a082372a383a7c43830bb415c07e330cbc3e9ede902e1318d001e9e1cc1fe46a98aa62ed81771550f494cff98a501e8f5221d2116a193acd467a4b5ccd11afac5d40c4c638c8ad583c5ae0b32f30329f6cfd6f9f2b1a295fa9f3b1003934cf0a476cd08b619fe439ae652384a433a3b7ecc002afb7a1609182cc9886ed20a2099fbd52aff52a87ff53cfbe32b97b0ccb988d10170a55afc6a65966f7f6943a75d721be9b6e65502469563cc47525fe28f259c46c69844fda8621a758e3fbcb1806d59f9ea1becdc67d64c822b295ba43b5fe884a195a385f4bb2d7390232bf74afc18cf65ae07cda3392119d124f0ffd6e1f4a1affb8fade39ac128b50dc9890093eb8c086a6612db90fb812c9c2e1c251f78b4e9aa00e42241f453e0e81c4aff8c2a8f7f0d290c2de2cb0f774a7931842f29cb2511e387acaef1f5c3c8a65abba0604f8ce0cc2c99593da85cb520edef207112121d9bd82b37e962b7d24e9bb3880c296d8c9932059bd4f8d46b8d39ed82255ed16657525c6a7a822e6e7cbe53c157fd468dfd05448cb4c93bdf9f8fc0f88fe5c8ff56a1cc55425d7ca5c5385b6158933184f5b36d306f256422d5dea61242a0e676e1c53a7b05c892ad8ed37106caf576b35827c1dda174302673b2618946d2fd74d16d8b42d7cceaa150ac0d27f76b0a43bb3f2c37e9088348f329ba8e9a7152721f3af6ffeb03b68eecbc847348688ac4f8ad61bb27d001771845148e46f44c55596d0feb5ff91e3056a7353c3e2a31c9f4f2a2d172476cdf0f250cf06dcbf9510fb7d6d7d25827d554bcdae0b99304a629e9c8e70eb5bf229c10e8eead91cedf84816d510fdfef2b87dc555f1bf21a345d6bdec08c98e5a2e140125bd7b61f593da8a737deb726a67759df33a3be32f078d27b48b2e056a94735cb24a678907f542725e393c7fdbda5c8e3c10e823166bef876f137c2f26b14518bbb377292dfee9a95515029e4cce1594365789b9584443300e939100d5b47b9baa974c04877298b51ebdd9c44fc39f9072382271434f57eba73e376517d20930b48121a4d602d426549d8b3705549c3c5d3a5f2f7b60f2498d341208485f2933c3b0d4c6d72897cec09658768a8a049f2fe0dd3da9b75ad717dada4e3d0c984aa7a0261dfedaa9decf51ae54400ef5970cd6cf3364ccfccb66499a2ff0b73571d14550ef0da77029e5937ac90849491554720adf3ef374db9bb14e2fb286ff06bb6dacbd1b9dfd9cdc00d593c70073ba5d98883ad280494ef393317fe6750e3e9d5303bedafcb63a20d415272e45ef97da27226dd48e9f025782fbe08b3cc551c972fcd7780206388414f0ec147921e098e88c3d24d871da2e70dc2ece230fb2955530a6fee428a6533fdc615910f63c442bf2ff337f58573c4aa5ba8d0408dcbddd6daabf1af80d6e301eaacfa3b225d61008a0ff427ff2472221a0f538593c11d2de043860c56fdf93e8bd1a99bb62b2d3dcb5c752c9ffa08042c137a8d9131565af8d71b0d0eedee3694badad53ab16132299fc7b1d6a23a5b6005597af6744f80dbb576dcb12b56ad3e750acf62ccdbef2ed9484a3435b73997eda11de510d41aca9214c07ea46344dde064d1c3b729278426158c64eb0093a62f4f37c8e371aa56df33bde602792b38d538a09352f468964ffecde452060c671a3403e86566d6d1a080d975357c17e2a4eff7c7b39a90699bd9cce7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
