<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a448f26bfc88a358b8f846cf48b79a11efb9771b99e8e8e18c0f30e91a5c4a8102466d888103bde1652e87d752ee1c4fd5cf6824a5a2e0acd1c8ebade932f91f943a16ff141f439dda67987425c5a2e6e61009ef52d31652517ff7c086f7c6d9c46552290240d3f425873e86a56faa064da7acf6059cee91caca3257ab249f795a077d0541b9c7da1c377e44ab14021d62702d40484b5fb374119c5d7837cb113ecac52e160ff316ef7c03ddc02c1241de2b621bf5c2485bebdde6ebc9e7ba8fc2887e1a72ee91f6492bb4fc95d29428a2c11a0ae414fd1aaf12cace23cd6fc9b958fdef3267296a08a4b1d65a7972636a93c3f56388116f1b8a06d5f26fd1c357d3b94ead1aac94b5f0221d63b4c3e79e874c90d3f1df5979af0c247965ba6f71d3c485cadfb88137a39ee0b9970259e015271c65ab380ddc0639d832c6dcb78a148519e2164b082ae496747c1b3ee3cf19391457436099182f6288f1a0fa0d53902fb3ef13894a3ecaba5808dacbb23c41da6d8179d4d3545b3bdde17a39a10d38738f0a9763dc904fb96479d19013b6707ccfcd5eca51914a150b1784f0683e5fb1daabdd7e0fe4b03bc908327b904813102fc2bd58c4369b166a3f504275cd037c93ec10da1c035d1c7ab5a57b9994c2eb1fe12c0b5057ebd493b0b1cee56e7b6f78b123bdd009ee70c7993fe3a9de1fc9376ffcad054b89b11f0368dbe332ee50f5f81d82ec801249d83cf584154a2109b7c7e07e08f97c3c92dd7ce099802485aaf9bbefef37865b1f4974026ca46dd017c34f648e2087cface1e98d6380f80900f5bf1328bada617569d872eb0e5e1406c26bf09c1982d090d59004ce78027c24263cc80f5531275475bdbfe8ccc6a0b34382f385395f253cf3926f5ceb4ef23adf087c5c17c4dc06d1bf7b81f77266326905e5114353ab17d6ff4b10fab4a5d7a1c0528c8e4b0f89aa96ac443e5cd9d76c0244d3867d913493abc17b114637e0b7772da7c841c45074d400d81a81bbfda2af6db58f867f7ed5e9b47174552fca5930dc14e6048075aa9b2bda805d5582bd82e5ff89c5c0ca567389c26e73a6c231c4152b8146b0c7accdf746b0d4cc57b705256076eb38d3a2f1a266bd2ef449258d35ca0d803eca7171584263763a8250e14df324d7f7741e36e702965251d92f26d7f90a3aea7f79ccc14643511574c0fd348cbfba058903a88db5d6777f865eff347793e81e987daada0d7fd013b5b80a42b408cb0a8289165064d3c9f2990c82ac1ec36ae9868c7be3a75be4bb51b2086fa8b0f94663633463102f964d0251a98ee224ea9a5d850e92230ca735397ab124d3fb8148b9f3524131e220fa1327f5f713e475deb4de8d26b2ab0d9a56eb6e8878800db766aebb5c67584bdcd57a1d68c8203561e5546c64d652a6cdc27b862dc18d286462574dd96af0b14b0195f6710d79f6a721e85e8f2b260cd582ab6024f6e3baeb6a16438c24f66e3aea04a0e476502e3f6d0f23799e47c24a31a0e89c94a50651b8c6f418d3dbb16000a8b202193866b9db81d56ff6eb88a124824bed9658b5b03be48063bd2e2c2e9dd144433cd4d74650df36729ed0bb1479940df20f0781921f1f6e3cf759868cdb469ceb2f189e2bd5846242f44622ccff54325271eb628009baf2e47d878ae3208b2a07f888e13dc2a756b99ba6e6a971e226ca381e5c4cc6656d6b4e3a98474d2278e117fa4f0af2a4c80c4c62febd9ea3ca700603198e29a7920bf07a997be4aeecb21b9e858045947f8314a5a3e09f33503ee1186af5e89a523eca786bec21b299fd9f7668d4fc8bdb697761672f216dc4afc0c9ee4794536bf6e5ca48dadca2e9ce521f06d22f45380f6eeeeb8f6f8c144fce6e72731ee9609a0ff6753449e08d87963f6b1b5c0cb494941ad06059f04c2c2bc0c6cd8ffdad15f8c701825bbbac9d9ca990b4c39d5daa5aa00a518fbf8baf12ca24a5b22c7f94b0faf15c2511ea58e754309a03bd4d4e2567098ab4cc8027bc89405c8065404382322cd3191ee4101a345fce2f1b378b6335dc0e67df893e8c6a4fbad0526af2f8c2c365e05d451be524ddf8cc90f9c0c3b6a203b38d1d07e16f422a79485e652d40c2885edbbe9336bbee907871d624c154a3d958d7e8ad8a72bc40670ed843d595c117b0809d5aa1d07e0fcfadc0ebdf1dd37c2b5a042a3a6c61c54e5bde7f8767eb09e7fddd9cb6991381aee777caf7ff645e8c8677d45516d040f1ac026c3183fe164159a047a995c29d1da3c89f14221ce946de07afec4f304437d21e8745fe8b059f12d31ec7272a19a88aea27bfd604cba08ffeae20c86525c085a42eee733408a632dd60c9f9b204126c924e8ebb3a415f789f0995ac8c7d8ff7f4a7591fce608ea6f3f3ffb69626220ac7778fff5b62a6ad0eece95df6c67ac8548a5e4c2cd072c5455ba44e9f0716db6961393b931c802b2361c4d68acbb61bada4e7d8bf371d26b7ed78b290a32c1274d913df17942fb3ec40a19adb5d212c3f0e0f8c153294c96df476c30920ede3b9873807cd0eef31ca83c85b5857698ac9802fea32ff40ad79f239ef59567db4a756d68fec3c3da5834021a05982619a2700e1a0b73e0eb57dcbee87d2cb3cf644cd3a818fbb1edab55c8fcc0646f70a3fe66e11612c188430f4c0e4f56bbe94d2acc99a613994e20cbc02fd248af8c787014467b750033d338b9aa19df56fbe6ec106282665a8526ea14abb9ba19b1e0b9eac2181980e979ce995f8eb84c960e807dd25a68476a0972db38bc3b487485ac3b1034e39672f5c5031dfded5fe9d57d1b7e863a7787dc7664a27131949b7fd88d43f3cd5e9c96bb5771a298197b52f39d80a0968b060950c86928e02b3b917a71008cc456a77d79d888ea057cd75ec3303c669bf293b27f090b065291265a986f335b9c8044041e6dc39d125f04a0a04f13436af7553f26c21492ef6e7ae86b6a69dc3631fba392adf93e8ccd70b396598e57bd525c76f700ac4aaaa47599ff96526406a32f5d1c20365cb32904d336e01032f7109e5b9437f0ac8ed334b8d9555cc20404c470902d0139005cfd04fde583edab467934a16a7ad0560e3278002cd391847c07fb462816a9495140795539308370300a3c04ab214ff4a041ab0bf9d047692688ce0af15006631e7bb26900d0744f644a531c8a72b157625e91892d4dc0ba4d031d928daa019e93ace7f4dd7d4165ea56580355c99eeb1e66e38d447e2c47bae3b3cc27bbf6a3657d08f0c88e4baa4fb21e7380fe93b443cd843f640478b6a4c424d5889cf0bc2059cd04f42def2fcf0f7cf1f53942d2f2515e740e52730f104ba6aa83b70ac595e60cf10acf1b77537a5e0d844ff1897e9872b65695f3d4aed9c1647ac593b37fc52e27fe0eed2a90480dae33108da4db7c54fcbceef6d86cd6a17414b528b2a32c4d4b532e8100f438ced3504693f3bb691cb8e88e292b2b2368dafe2a5b7af3b21a96e711d471b81d1c8718a6533c1be3706ec9e128ede8fd4a8f0da5b4742dc09d95a8f76f08420071dbae2a16ec48b4ecf87a5cc5fd41754035793440f8dec0e68c6b819474707500a8a2a08b6b8f247bab98a31335a15e5cb8273ff7f1c0c0eefc1bbc538d57169333288fb8d3ef1e1946bcbdb34cb4077b8e7e2d2c61b9d6649cd5c4d460e4f81557644f347477febe0aaedcbd02128f9072f1adff2ab97efe8349de7c76b370ec0b9c508d90e8041efe5c44575c5e7d72e19848527d13327f8408b918e650a5ef7a912454db97521c57d3ab1c5c9a4585e8d8730a58ce754cdc558a6bd677bf61fc9c93524708839cddb3ae1590e7ac0a65f91b4b4a5019f5482061708cb4c77a8d47726692e84862d0cbc551d787c209cb387825a728b8f45304af9be04efae1b1408aa976f7b5eaa65cbdac63315a6fb7f4015e7592524893b050b59e33f58d7f7ccbb750392f4c7f5e19051c697593e393d1d01a0e74509d2af4c870094d666a201e6fafbb2042d5c3f7ae04cc44f12b482ef7eb40f10cebe2dc7a9026785cc5794f25f5a1b4a49cd186f221d31bbb799a50c59f6575551dad1f3eb854a3f725e9f60fd5fe9eda6a1f26e145c9d0cb0497e21a863c714afa758e318273dfd10e5a2f45dea50358a8f90006682d3c7a7d1b636275f8b28d242c4329ee4482e40cca1d23d819b7cfd748c0dd330959d6639cde4d406c088a17aceca066d2604fe2524b1b6a28c41b894775a9b17f51584050c2de82f57a07be9412ff6112bffe21f571edfc2fdcfdd9effe9ef66df9449162e492d3266aea927f46d52f31d60a44ee7edc5e1f8533f67dc8f0547337205535247a4dd4ab93013fa3e5693f3b9311528b977326ab5b09311231dd458e353034cac5c08c1452c4b324cb4e94c70073027427e241eb2d21a694124b5631f6946db674a0e369f33ff27ac7b2ce022e41a0bf141c56633318bcaeb586d04227489b96f5679196947dc12391a8614b1d7cc9191dade5006313a76be266f157c6dfa104356221a5bb0543a1a9a3654a92bd1c375d51cf49a42fc6f3a8e36739a9f62e4a646e73a0c1aca1963cebd25ceb6cda3a9e0a9dee11f3a4774325179d70984bea9206db5aa8fb28150ef676bb1522a6193e5853410b25be4545dce59ca5e5ebcf78cfb488c64c6693e8f056116a8b960ba9709b1e1a2e2af36f36ce89587cc3ddcfd7e37a89150ef173a5cd87d31a7deef20a742f55968e78657e52b1f9bcf25169d3d268c16aaaaed5fdc9d332d315273a685479cce3b05b3ea24fe2426695b19be55566e91b5324bb3c805276372265e61cedd9a89e07b2750968587050f96578b60788eb67f7ad2ed788ccfcb43d0f7d2aff31703b51e10e2deda38400a2293986913618049eadac80cbda9c326477ae41a3d800224dd7f92868db78195bcff4334dd3d49fb443185bf6a78c89cf48a7387d44384dcdbe0ccd1d97245acf7d0d928ca8f4231089ac04f9bc10e483ad17a519330eb9a132ee66ca548cea1f359ed0eeb865017aa263e4f0f2aea7f185251655f61dba971626765f0c5fe1020ee6ed87b9da3d0735560ab3cb568f3605285c2b46d2a282697b1c648702f8901f384908cdf80c32db00667aa0686a6a9c877eacfc2a735a8117839c284ff5e79dbaefaf36167a40c05e30334c9d809773bb4ba5f362b9c887e248edc7de4842c0e87acad903c2eae333d4c490df4c9b82a7c13343b5b32c2a37854e4fa5700acf3c856eafcfff01ecfe10bc079b6986c685f56e96f089bc5097fb88ed5a356f421c8649962bcb12bef69c90f52a52c4a623a535782924203fd6d8a5a937993c69ec2c0bbd79454618fd062e8ecdf3c7543852103e53431e37edfbccd1a2b43317dca147a01ee5dd2ee80e2d54cbc229311c82f20d578cc4a459cb0ff5fb8f29530615d2c075d6e3eec2b0cf317c225830a52a409913b73985fc04177e7c25f1fed28008524fec501974e3db8b11d8b0b6272f1331f36c3904c82276e80c1411395e8d995c6959f267820688b5d00ebd00defd20ba84a26c5c08c2fde27a0cf2e6d3438a4e0ac3be4d635573052c88b8f3440ed930917e04b3aedfd01be39da41be2584eb66a5e1504449ac3956cc7a8fe036c0e493ab0c57c94c77ae75797d9c4eb0a7b934eac3cc8011359711006eedce343c898d611166eed46eae1e34a0ba6e823e99625658c1925e0a6deed0d2060e1912ce65b29f2cc39f6019f10a1b33e14625b63326d84bb5fd34a8ae8fd89af0fda568ec2ce95919756f21d8315d7056c25564b0c51a74585e1351a79d59ac19b3a84da34d94b61e1f3371e1b335014b56f57a5bf72b49565acd21b70cefb4c940b9fa84f8ac508fac66ead4b8c656c8c5b83ea71a7643cded09b13525e5d9758e9ee7245e955590677fb5a32b75e3a5707de404d55372f669da2d7e2905d34bf1c57150f75ff15efefa496e112b36cbca970c09e02120593bbb0470aa84189a035f7827f1bc8d2c09d27a0cfed30dea91eabca4cb8ebb30d573fd30046638e06d94a6208f37b598d132b5cfa6d2ec58a9c657c29bc1d59c0aec5eaf606903fbcbf1985eeb07d8e523b04651234d3d9ef622cc86855fca1df51f6404075e7c9b0e3ba793e2c578f6d3a1cc23e6dd828e6d1d53df6814980465f7d231c2461d5e0a6ffeb608783bca8f77df7da8729f9f89965a450f2bd3dfef0b9676f6f97f53f0a3f58f42b0f159d515f04e4c5707f081cc82843e100d04e70a3a8fbe20abea97fdf8b665bdbc7b3a69f2c9812e138c8c961b51c473c6f59ff02bba11de9ae72bd7e0886aa279d0d05c2a709d4d78e59ddde3e0a9cf179489d4f52c08a9831f9ac4ba0f21628528ca19b9e9f39b1b94b7d5d054faaa9934dedc298ce623ff50ba1bbfc88e1f77928f6f8ee7da6f83263d87658529adbca56e294943920b8c8408870ff70b0f04d414fd50de1926fe64423bd42b41ca943444ddb2b875de22f5d9aea1c973b24ddc7aa79b5f4f52669f0a66c18406c212f002da2a7908747a2ac85023a385ef5f3a5f9cce26ec4103b0515ac4c7bf36512f3bbae8b3ebbba4e0086049c52bb9a9c5921fdad27a977cd34cac25db20c12f4c45ee7b943f5641f463a2eab4fe0680bfe83ad60bcd627a695f1800da7492af78ed0f8e3bc0cbe82565cdfc54b54fad5eaac20ff6e30f6c7fca31889c1368ab3eef87e382df0145901a8e60209fc75be72279694428f197ee27d57afbbec4a4d210f684fa91999357ea445785c03b57ede2b4e0bfde6f1bf2078d79977337a2548fbd22dd5730e16a20a73865861507b78cdff28a93ec159f5e382ff77ab1cfe54df810452dd6c23bbd6679f65a5b5b887868d4c89df8b3c094e07a2385f20e2cf9014dd20f73886230e54486146b604788e53526d15b66effb137959c82696879a6520c23f055623417ebb6f2b7547cff56f8e883dd54e29d2904f2b4d6826ac9c5835cb0df27ab709918282e120cd21261e46721d29f120717b55fb8a227445151fd9197e8509782c3650e2f49db51fe5913bc71086f0e5f1589d5c0c9c73245243dc765708a95f6f24ff11d580b7eb8fef940227f995450a272b87f1f1c864efc8ee24c65937134627e8ba9394b8d67cfc221152d130f1d89bb47a9d11709751cbc82e0e22127adaea491a9d58e53150a23310a9f1093b1879a2a0ef9605dfd5252789a58b219a04efa3a0adfa83f0fe9a966c964e0905504fb8dfa9a12dba221f81f80a16cdb3a3950f2c46115635f233f7016f524c3264d32cc35980e7290b37577e19321a3e1f73d63c6ac761a95e95c460fe37a56beaf20bc03825c725a927f6a93d4e2b64b531a6c82b25ece9978277c276aec5dd81e052216759059bc803bf8e50dfbbd340bbe717cd027db4f8da964f6067e3841e54217a1793da8cbd7afec20367f86645695feda2abe78a95a816d05fc58ef75c62bf70c3c54c61675acd9f0a9b22e5ee5c2fa60014e34e401fcfa9dab436623bf8e73d428a33646a2b39f4031c20d764f762288b3a4da6ea45ab2d067a663b9c833a2f921b11ee00fc031ca7aac04b02066093f08a392c3947a6d9d1e1c4b7ee8320ae1c2741e985ac6febd321fea3453a08085cf8edc70b553449ef683a8e54138ec87176110e6ea229eb637becbb35f9c00fb00c42f85111791ad8380fab79b86d9522d9fc8af98bff03f10db8699f2016138e16c7f8630fb7f0ca656b3a16c3bb67d8abe54ed70d0873270b976e74bd0b479d5a5bf3bc10c4a645bfee913f1c66fefacd12e4d55719e97a9a77fd90cc03b26e294e99171f4f93ef808812f96bd5c9322b0a22b61f80e6ce87dbaf776465a6d6ab8614b61a1eaff70396c3e1e3524047885da571f5309252fc1a346509329eac9b1620e367b1024df204de1f50850ebbc0080f6a3596e1c70ceab8ef5e1f9601d7e025bba3c11592ed920c272044d43066bc8fdb8f8f59bb9c93a2b47273e043b1bb136d78a7e19de7c6d99a19dfde58503328c1074510481d7395af14f5eee7e0224215d51f163ccffdf4643a677ab011bc0d98f39c0670b61b93cd7a73393be29fa0a716267ddda0058a127117bf89d3a360b9ed9d1fbfec290efef74921a41663a4e4d4fb36202a584fbd647b6e4845ad4f4d8b953c332f5e84fcf87564eb57914837b3c47173df2ba55b46bc8e99be1a7a268ae7248a221967781e24f12abe85554ec33e123625ae5ee62fac9083ceb7db16b3ed3b08a00da62c2541ce0383caab2bad65ab41915dcc8c92012283c0eb89127ed1ae628948b74a942507a5990a1ce34f6ca0aaa845648080d2e972328bbfd07ba7565f52d3488039cf07870b5eebe486d53a5e4e6010d0bc0019ed40218110e4510738b609b39434f7b6c72644cd42f8111fd8dd62c2c10d10e0e2569cb20aec4507b544c7b646c10db96fec797a926f4a6d9e82f2aca992a2b58513d0f97d77015294d87b07f8b384790806892d5ecaef1422c4b40e40d382bf9a2683c8411346122075c7954277f7e83eaf64344de4b9b64940de6d33fa958fe85c62ef42c2f36e599cf5274297bc94c6f572596284181b7354c7dd4e6d5271e87926ccb62706d661b1073630db20a7bd9a0f80fb9a282f5855fbaf1b1e2b2e49c08d3c74f5074525655a6615be835cb44593a717886df2b92844500d6b64d6b0344f8466ceaea9b3e8856f88af50aaf892d68e7fc24804aa7997d0acba032c9bb25d317fee1f7a9270f9148426d4f8f1c419d9db683f25de20d5685076c9bc53007ce63b5a89efe68ad448ee3b3048edf3d5ed35becbbb22d0a8995601cef5da3410ddc6328f45c3c432fdc60778d15fff6c10e69404b4e96eb2b785bb730f5007dc2b60a1f986d44f221e850e3c1664ba93b1886acdab5a26f532dc033f2d8cdce1b394dcb73aa57b13c736d6d843bce76b745bf88583ba09fa455f5e875a866c2d8df064d16f3484a01c96a184ecfbf8152d21480f55f907b0bc5c25605b732bcd6f2890624eb7284653439f7715f5cdabee6556a88d7f868a40ef7ec79aebc38032fa054dbc9c4fe14ae8bcde60bee590b25f8cabd65852accd0015568bdb938dd29a40039cfe99b6a084e975de428840b1b93438fa39744a3020faff74883d26132bcf1e83216d8e18386cebfd32cdd9efb32469383cf50bc49ed669480ec2bf5027b9261797725c2ad8fce1feafa7a59d24f982e344f3c5d97b9f4f30fb0fc2f332923023c44b23125dba8122450780fa8505f52de631f5e8cee5f3e0fff360ee8a5b3bda01e660588c328b686eace0c4bb24a71055fa2d2ae9308416199673eb80ab651de482eabd8560ac1acb9276c3fcb234c85f9309395bbbcd8312490a14a51d3ce12b704c096017398a16f33f86453bf76cc6225c4f35ac44323668e4856a76d4761319100f5ea1a56e786ed47f6154af393fa0c650f50c35dab4695c6f047ccb694c72e10f13154c8a48c216e53b455ac2e173a413528c7881fcbaf7e1099d2f826d830cc947076b3e585a09f9ab3a3ce931cc0362cb754b829afcc0259aac5b99de02899faea6a2c4040c28285bbd64e043eb173bd60fdc32fca201cdb3877de2d68d88172d2cb97f75056988141fbcbbc94420d93409e17a08505d5024a3aab7e1690eaff8152c4de53909fa6e4ab5221b69a1b1efb935b2906c8d4d8d48e947ab5f9bf445e7fa961e94ad43e42a74a8f4e8090ff83300f41385f6b9d8c263310006980e49b1787b9f1cc587d3ef6060cf6621376afad52f6a6f7b948e0062da20b579957b3ce2967d0369396a4feb8ad0e93506359d43b0ad0ca8a74d40d7e456319195150194fecfbc42c72e7bf5a37e18ca9bbe85326c0c8aee22de72a2418a639718220435a709e896be374ed67ac94fe12dd0479521de95d81d3d477ab4c74ee0657073030bf374f9adbd46e2312ec0578a94cc2da390517e149bafd4ba53527264e78e0c28368e08d7917e4055b2b8e146d7ed8f68ac02476d3a79662558f0ecdb33635de86a729341d79e4e5d375a1d16063c8aac4e7d4f64753d6aedd47a2c828159869ac8d95bb8942ff1024172f3fe350faa40574753f4fde5ddbac6d727846de399434983e348816e2b5aae0d12a1aa1a9a49855f8514c8dea367163cc6838ed822744c7f8257ec68ea501f452bc36609709efa1a39225f5c2f48de90c55f6d899742a75d223b95e831b2923ee626b6c077a3f84c5717a546e16bbe3da5b4a46e136009dad8c9740647d301cd32712fd2c4ce85b7f551b0deaa03ad7cdb6d4bf1d432a84560de971254c1a43f6b4e8a95f09ef85ce85faa358a7612bfef85803c40c556b1c85a0bdfda6c8ee40b6f48eb1297ec513a7c528112143fc34f3d0085dcda6642c928ac0914cd973a846edf244ab07e506e3a86040d5e64e20ccbfce22fea720df533cb471d8239a4b5f8f7eae153d858cc7eaff41e1fbb06d76df7f942f6fe4ba439ba19abab36d2c149ce66ddaa87ad2690e36b38c9475bd51ad288fc66be5c3610a811ad2d230a904a9db19270a466546d48a55e9307caa3f90a18c0480211d04677cafa371653885cd0e16b3184f9a95245057b7b3d1d7e92b2b364e291791b9b5638578a9a628741bec4b3c1af6f5b7cddbd0f9dd88beae2cfbe6c0e462531393348c9350ba7b88f2e1218352e74f87f62dfc14ebe50ea234242c6b5bf4249a19422c77000f1ef5a3e37a46a880d208b0056c403b6c09c5ba810e51f0b9af7a512797c58cc43e059b6adf981dc8b94007b36457b2b09a28d6bccc366ddcd7afb7b48d537ba498007f66766f41a6fc2ad75dd02d7d71728ced46a8721ac182411e149ccced7a2ec674937dcbe2c428a99887debd9e5a36f61afa0207463f04b4f872b0aabc2438c466dc2d43e18b76c35115143442020e0732175fee3b76c4975153260a0828a2b30e594d58d729671858db73574f4a179b538c62cc9591d427b7058ab7dce70859f430197323d240dcda836be6a450bdcd88c6e531acbb73d1bd3c8841a8b81ddf0f6afc68c6d408b4c28592a3c63b4a57f72697ee5f12e558b90738553b20e05576ec9d20f4e8337b8907a9ed4886f4ce5a2f52a1b9b8154f89359865fd874db2ef05cc2f0b9db2a251347a6f305802731ad673a2aeeab3a0a2f228f150d83c881f2bd1bfcec1ced32c840c32ee0c0d29d874fcecb70ae82ac93b6a649973036f393057f7c08952a5f6d9423f17a916abdeb8805b1073d55d7d9150a1b8d319119817b29333ac90eb257c81a7217c47939dd9d503151519bb69cc5b6601732befd965e9a51a48dd415c9b8349fdaaee638663f874e586ebf35a1f06eac53bd3b9f4156e98b2c8d3f72d11e2a410202bb40defb2656d07c44d810945dd55648cc8fa3dbebb9773ae32bb8bd8211783422a4cd3001699ce7e4657df885f68c295282f947c846dcf0f27478e8de1f7c6b531f7fa8035270c1661aff1685dd8a8341176eabe1e56f0a9f0dad76845e2b0281e3551ea3a216b7b32de0c94f80b0875329ba68b797ba700d1b896d1cf42ecb7eb6b54964ab272dcb4b596fc97522ec212923215b024879795cac9389cf22f0745ce4ee51b64112d9b1f1f2ff0d2e1b19c98fdec82b3665509c540f8732ad630979922158354bf53a0cda33d5d6fb7fddddc16eead8de37260f88e11ce01c12f2196276c8080b945b2dfb59fbbe7316c1bfc1b38830b27ad731ac40643836baff1d76a9204d156e177eeca46263fc0d6c8239761aa3c76fedb59156a85386490135575c7b8b44769084e4c419702ee5aac6e4b5791a5c55c604b9f48d49eeef9fbae301129776e3b54b1cf9e31be8d65213746cc9cf075f54a0bb7ca6712bd3591598adcda06a6af216f28399fbf8920f6b21e8609e7e58e2158a4ae4e9ed5b5731f6e7ffc49be000399cccd5de6b6bc253572899ba5115f0887c85991e9ba0269c8b1950cc0d313a693c5ad8f1d7497d563469e6932125f16bdb725d0237e2e8aa95dabc5739e9e78c10bb939635193c58f0605cbefa834cc9881eb6a635636afba6b733b4178c271dd566db57993576b7a04eefe76a62af838ad7b71c8e4d878e7ad0b2c5bf23807e08d48b8de7d0228e0ac1cde49e4b7da106b3cb150719bc9e00fee579e53bfe9ab22c8d75bfa7e672838ad273ed0406068abc465a16cf77602979193f4f65d7367077d13907609f8f3d456c28603bae1e5eefc19120f3833b81241d20db761801e30576c7b8051c1c1e78282e1451adf80baf1b731ce9a0087e26664e9b46fd8c1ba8ad6113d3c10d54af177bdf74e33fb1fa7327cfa67b5eca1d05c1a008620707cc224212fa5bedffd8212e92bac5d26b6d3e0ea1138356479ded5a1453c75c0da574b5b242054017dd005427fc4d2ebceda2d1b39d2fc07efbcc18b67d34a23156b9c8afc78b1b943cd62e3f9f771a8ea673aed2487c983ca1aefdd29617f79502e8a4cc0f4c4d09733b1280c31138ef6879ea3065f50c1b612cf7ae41f86b2a79a0aae82bb4c0c7ad6eb997fc1a0e5416a87be092b59596593cc19706f22cef29ad40a457858eea2956deb31916ffa3d3da61511e867ea72c8620811819748fa6968d1c734be4ab15f05c0a740a9da6c5f0b61361afd46857aa45474742bf0d4046545c9455d73750ddbe5653de7a88a05f56d73e675c194c1dc36d4411ad7e85c4492f415ff5199024997d19f5e67acbe42858d364de9cec22d628c3ff43257d76606f0f04d4635bfc020b853ae464ea53a2064eb813a7d2b88756cbc0a7ff5de044be2c7d4cf1c341f361c806649d66e4fd3d95926e9edb97591e8f49300c6d9887fd214d875bb255476cf87efe4c4858e370a0a545935f1a3fbcb4eb6854731a62f0ebb11e6ea02200098358b6aaceea7af43a9ac6e85b064385cda40d57cce56db2a7358be77e25713b2c210cdf3cc3180e5f414050261a2df80c8d83cde0fcae5163225c60a9dc1566f6193282c1409502874b1ecdc4c0c9be0669cf0905ae0fa5be09b12f35dd46f33ab3ec98804741e6ed235e33f52d8337356927a80fe6a092b31a32f440740db3252b17704af2d5281309890737119ca9412384226b4331d25bee104d962b040387c1a008c2b9256b315f8c0b976676828492535f4b0f1e46c99c7ec9a4581e4a7498d0d2766bd28ff6ffb73397ef028371794cc0ae85f5bd9f1835b2a5f39cda5cd0ffa1ead03b6edb517cae96254d6a186db6c6a3442f63237cf7db249396920da7efa1232e3e6f5773458ce3139d3b65e4987d4e827efa110c2eb06cdafec09dbfcc0da833837027cda837b90cf21ba0f6853554bed81699b8e6044835944931d03414cb6fb9de4e94b1ed84db0c9963af4ca448257d7bca3b2f46276b82f1bac7bc6fd3866aacade59e72087d86de23bf3d1cd2df89428a0113020b2db8312334d7b69e46058b4694eafd2c6bf39d73ad9c1aca8f38e330543847e71d2fff70c5a32d9904a371004d4f18606b58f2ace72b971808522d0b763fe7d7630c9e5410ae9d69a0a1df9be0346ca84d92d5457529fb2b9ace3edf33ad1bf9be8f5ea803daeb50acd7b57626855128ba450337cb07133ace902529b4f8b96f0197268447dc2013d0800bdb652185dd75550b505c605f3a3b9124d3c427122d789770639fd0affbbfb15f2b06d47720b08fc5ea9f1ace2d5f6da086c8608500bede27bfebde86cc7fd848265768054053c5ab0f8c985f130e07fdb7dda8a3d147b50ca26e6345beb5f6ec731d6a6fccfcece6a191622e5a40dc3acd3649bc46242b6d4f39a209d5ec8f942fa9c7a0685c6182f15a718dfe3b6f719e4fafbbcb394c6dae6149c26bc9ad4631de6f7bdfb7f78801046a33c43d3b4b098cdaf580658152d0ad49128a815f0feaea41abdfc94ed70f3932526e6add386a0584f1bcaa65352dc95e49a33d5752ddf8471de5ea20f37e58397163fe8736b7e0087bb57c853186cdd12fe8efe0d4142524e04352727203443137acc82805eb70b88b60de810230bf829420c187db3289f91b3e79e4c6ef849c8225a809635f3d0d334db8ac368f0d87bcc55d54254038029cbfe148261d7d6596b0b36282f453d8045b2d738c6bcc058e2df812fde212b415568ac4d2f05a1bb84e176e42d9b89089c53aa6ef5dbdfe81384d9876e55328b346761956d14002405a57891a4d9209bd5b5442a3f60838d70a6d2f768c517f3393c116f7282220b4953fcae38dbc58d89ae608c7f00a35ac135b4af163f47f80de59be524979732a7b1b95dfe10df846f55e3ac8e87b5cf4868211b500898e72a25d13ccb7e987a596c112d78a9fd1b3d3a1c2aeec41720f40ee91c4a17f371df12de6eae21d49760328b045ce371d667d0f96c52f787ed80f5a4c3e4873a9868e1d00822a9a664ca4ef53987f332c820b2d9faa469abe86336802fccfb10d284b7c292b4a8d46b5c931b13bf28af98aca2441dc1b168ec10ffcc0827e97390b30f79358a7b36c8f217d76fb2fed58ea7cb3ef3c99cf2a8d123ba1eb32d54360340be9ec392318acad7db1f94017e5f5f0b67a999a8ca5a7d5989c40a5e06eccd95667c3451abece2039bc63f665d76c37255c2baed0b7f293c593d11f544c69194029be8bb56fd2898b78c6c0a7387eadf13d2d08c864c0ad0705c0698ade247e9844dca1254253fc67b2e1751109d22da2e09b091a5a66d7ef455c7c0e7c06893c1c7e8816c7910b763d34e3704c0b6d74baaef764273e5ed5e2392a175260aa29e4a2c8a94ca98e7f57e8f818eb65408085e7d97073779804de703bd9c06e144d631652290568e3c352b1764bb82af3d6ddb5e58859caa38a5e22fc936acfa552db9e4e92375398530e93a3992ed57eb3c81a9d28eaf3e7cb6cf6e6ac6b0500135cbffccf68622a1a90eceb33d57933cecc1861fb60709ab972ab539849a58fc86234ef46db29b03c3e56f6c1033e34a7a06bfa865a244e731db346693c98f4869e456a5d2d601fffa7d820fef4462c8170d7d7d4abf1acb08b0a8081d9206b66be69d95e3b9d6830bd36fbf865da5b7fbba016edb0ea4d22af6a18030aefd42aaee8c9807efbaba79c15da63557ac14ee25932ab42d82aca6b5a1ab15c52a389feabd9c1e9059bbaa7bddca424434065059a2db8996fbf4301f683c45e1e1b2d7a93d2488c4413a08635d6e4f616227cd490b08322a9ce7696fcdb889ecc95e0174b361a02495a97860c126408a1f910636dffd87b3a327d841f88bde539a852eae995901a149282f024cacd93b5fedf12465dfd9bbb87fa9bf8af8e5589cc3edb670386edc3405f0bcd83d54849001f363b515527f0442052c1afd2b1a98159def57270a59b05987ad1ef1a7c3264dd0940f62a77204b112933a69ae35bb1530e9af3a367808557a4017ead9caca91ee13e3324d9bda6c68e65d98e804ce30101725036af582116a1e58175a194cb3559ad556d9ccf7ea86e80094376c9e59dcfa513fbef58afb55de4a495826c60c681aaa7713be28ec353dad84975650c08a8c68f05bf5fa252cdf159ce2379054c2d34799519ed462889d1474ebfbbfdceb77a668c4a5c9b045b06f30be4ee517e8457b537b9481854e17248136026c067f3be11d8ce1ea83b63610ce481b89866b72f725f5d9c47fd3786d4ab55b79a26366ad9d206f196bbcb3e9145e252eb2db6cd0cf0c4a749a9978d272aa97c02e019a1ab47631207ef86f9ee023b2e0eda1ed7da104eef96ce013571145e83fc9155376463b6ef21a37b44c7defc9a9f960d33707adef57ba70d832ef1008fd6d81409cc11e83f74afdbb8d38a92d5a1117771389d1ccfe95457878e1b9789fda31147fe34161df61ec68e923ddb90ea80b30850e41b0fe76574f145138f01b2387ba6e8462a60d6a976bf1ad0c1401e28703f68561bf909fde0185f891ced4cd02deb57fffe5e6278a46d2fa24ceebf287c3fc91ae528bc626b96af8d4bdd15165510a79e4f3fdac2ceae8537e8d3f88b2197c0f816890f6dba29e63546d425b3201a7284867af23242e3c5f86ef56cff7ede3409b9bb94e11c6a4f619e3d49df294638259b81332eff2dc06fca83f177a115d2bc384ed23007456b5e3b6578d5948967e05fa524440a11dad54beb8c94c2aecfe495e75a09e443cbc73aaca1dbcb46522c298546dce5112aa4980608d63770a7aba893db94d8522f51d7ff35d34ab31179377b0fd94efb69c5a4a7f8566d261dc3dbef5e8914f0887a5218339e42f60f351b2b04f62a2df066d6665554e51a01da63e2f007e67375f01c496522f7296135b3dfc8d8abd46c34b5fc142c5516eb2ad854015cee3c7da47c9f6c9974ef59c094cf210bf926a3e49ca35dc8a10494f1584418285dbe400da9bd4669a2f7f968a69811aa4071c02cea03b02ebecd80d26f4fdcd0df29dd5270702bcfc564cb3782a6777efb3c667116a1316c9d9b75e64c54a2ad4623aa2dfa49e661f937159287fbadff94d5a7610bad6e6f7640f79cc34cb19909366393dfc02a1c9b0fb4b21b33e98fe81effe87cac820a58fda28da6b2b8ebbae437002f70d965aa6fed9fb485ff1d95ebf01cac9c8b6fb768b757591a5526042e0f9947910b1cdc9ef50dc81a754023ebd296306013dbf47f4f35d3486f738de4b166bef37cb1a3d701a125bafb8a5f376155d213cd29b260f6425f93ebf0b34e1294912dd9b9e8b869f5666460606de63a941124ba7dffb0d43ad5f40ab9c20ed5546ebb574bad850620f78a04d89c95958fa82a8d3f8f32576aba7a21cdad1f0ef4c113c6f7039a68810b6e72fe206c7750bd473ed94585e174b7a3f43b5874ff7a5687803ddb6344e840a904fabaf2839d549fc00574fcfe251d971592c57acd447fb6fd9faa1a877527e133a592f0bf7e2ca762c3056efd15c3382903487d1242f929415256db492da84e0452b06c6b5f81ea0de2350ff47d73d8542c0a2485beb79386c25beb7f4fd19946cd59d30496ac9a7b06b6c667fefd25ca161d0b28efc733f2a04706de0a4364d8b1c5d1e02d0f9997cf2f4ef47f9471964d83cbcc55e54fc50a42e58a5df05fc65a352612778c0deb3b214df4aab03f932ea6fd44aa95771a2099d9ee2956096a1aeb0f701da0d71e6d3f26dd8fc8113694d83a176a8c0aaf12ce91008857422b15d59c116ae10e28695f53ed8e15427b37cbef5f14e13b43767830ef6ce78c7ae226aeacbb9f674bc772aab763edd3d6d73c6d568c26e6b7ebb4c4199a6813bb95a3468259d9fd97c41af04c347c843790c9a6707a3f64b3186da8395be04f847cf355c152ea7545bf2b932b9ceea3ddb17c18d9f4694b02e5d8c40f921d9c874edafdb2cd2eeea3cabc4233706e7194ff3b08e200d0be8537385551ddfd433e59eea44d5eb6452c17493db67","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
