<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0dc773976d47a8f036c8bfd33f65bb5fd7874e25ed53ffb3253cb9bfe656de0b395b338e95f413f93cf0daf4b7df1713369ecf673f6198552f91f88cb0d5644d9312fc52afc7d38249e44f86407a00f3555871ef0e092a3dcb1260386b10678eab345869a5562d2b26005d07e3a04dd2b8dbb6f3558858252c2284610fba2aaa1e009e63dd6c0f0f1c4072346de58266eb16ce57768c4d1109dc05a0be5a2de95a4f5204dc6ee6db9350ef2a95cde9f8e0dd54e78f3a6a011624dcbe688a05fa0cf8460bc853d0070e377eddf74fb485e5b90144c964a841d7c3c93ca8fde43cda0e08ce42a5d61dfce39c625b6788bf6cac6f5f7447a7ba21ee6e754c2167b73212f78bffd025347229caa542994a5abcd34ece6b378622cbf7aebe524f3c882c5354fe04437e9186d34140c092590e1ce912bec64587bb49d7ed9f4f426b74727577162416404582302e1a6f4a85e01dcab5b126e5ba9dfb5c0425d7329a3adb5860bb0a957d1af2f99f5abd8a9ebb17758081dcf4cb281e68fa31af09869af8c0cffb831510912fe103452a8e06a80f41f4b5e95538b49b5225ed17058cd790fc808e68b7d27bcf50aa09ff29587bc2dab733760247d159af82ec5b0ecac5a122456624e64ea78018abb69664f6d062f5ba250fac8e583b83b1e07906c1f05090207b3093afbb2034791c52c8c1140a8f60c0f88e77757c3f20bd646bfcd000d4b94a9b55c93b576cd6c823d29d68189ac579b7d3873cebe7e81699a2aebbf17c5eb73cf62a20c2431e6eec2100f57ee32517ebf63ddebf2a628b1dc4d461310c31e9f6f554b08ce2d64c4ce970dfecf0411f5178e8ef036f1b15953d4a43f098ce52e74bfaf8ef07a1e40fb1d447f7dc0c8d13fae6669bd66c255f81b4720ecddd2ad99797e4d9a3277d7c885f835e0cf6fc7ec41152475c597a4920d9486bc742136aef0048ed515fdd1b1e4905f43a4bf244ab7db7d54fff66dfd2fe322103a8d0c3cbaa98968040b506118afa4defd2be794a1bf9dff8b86b40e16e31753ad384b9b6c9fe666103149360392248c46c387c3680074962c3f49076740f6a4fc65ef27b2e4d7b9d07c0447233c133a6697da25a8b10af6f060626f01a11b42e9b111de16e66054d1c5e512ab6ef115843fe2987caf8171ca360645480558e52d08bc80529a965588308c310b30511fe8e0b88922276ab445efd18451d16ad7090f9721deb00e4ed79bb12e1bd0b0edaeab64b1ef90be4be36c4d67676b3b3feb5b47afcb976ad5df23cd92ac3077dedcb293002786e85ca2e11a00bb7f16e39da5be5822246ed72837cbdfcf315949ba6fddaf0a621b4e331fa3cfd4b1b90b5385d2e21278e9c3330f18276914158adc1e901b7fe750594b1520e52375c714fd3608a196bf1382ffa4776d699709d2bce88783b87df7e7c491e3fbb20c6956b1903b23b95edae127f5966857f38821ea1d12145898f868eef26c638d586f71453c67fe3b6ce31e000615a03d005204962dab275583d5f21cb54e1647951ff0efc082ce3a0e53e1dadd70905857d680e07c0916c4156a47ccf51de132fd2365ffb8bc8c81355534f8bcb68abccfb367eac1a925377c7b5158b4007662e60b2db7be4ae84924748249b111daa54fffa7d0d618ddad26c605d6b39a23d869f786e71085e9a7fc26ed97760c1229fd62c2f155b184038241efd8f7c55823d9f67ffcbaf6b37ea6dbcab40c6581545244f3c07ddb3278ed6afe377d6e6f044d8d974a52c1b126aa134098910183d7a235fbd6756fa8eb95a0e426b6fe310068ef04c2a8d65d455184e7546ced5dba13c6ebacac10c9e61e278495e08b941d0ffc62461e67540b6a37c9535572a6a41bbf15631908fece96a04c6aacf50bb7c887d3c6103c481e27b702497dcc5f4045697af16110f0aa9a2416006d4c41954f4f14a99e476603b287cd8d2d1c249f98d8519bde1c0ee71a5df401e8b281238dd6386d41d8c1b46d16d08320d5739aae50073251ea7f6b954186384b7cd41d81b1257700cc1f6984488c3f48b934c6a1e83a000fd4cc054a6b007f5e33dccf9d675914c79237a1373452a95a20235b584b4972b34c2415429f79bfa92175885755994e00919da8e05d3ea1f0beffb07d24250a805424758f504cceaa0cdbaa40c22da201261e467fb709ad25fd613d895a99192b9b5d0bf22afc814271b099de795c4f19d4ad9033e7a943a75a929eea82cd354f2f05861c2b57a6465d5809b85fc06a3c0517a889cbc3d7ce5f162affb8a2d3b137ee81c02bfd8a69b956648e3ad442e3759e9c52c3c49edd71dbe366bd99859632ad7a189e79204173ecd8e5c568b2e5bf0485d4ad967c1036111ec98e2846575264d7a73c670507138c9f428446207111473da1725d7865c7311c556fe72bb38cbd0c6461711d6657fb3778f7fc5751561e9a4082470aedacc026d6ac59e47b5051b0eba2aef3c863d0f236021833ab5f06d4f90692677fd729cdb8c59fed9a63a31639fb9d8178c6a631393dc8617ba7821f4e10ee849f7a48cfd0c1290fb96ba1daa2ad1b4e1a0d54ff8bfe882e53903560a96520f91ee6d45e6cac33026ff94d8d366728ccc6c2c185ab022f3a300ce136794a6250406f7e99fe5902871683f5fc5d1a9aa7c7fd4b35af235167fa3e51ed4fe47d7fd6585714e9252163a541a27139ec48e51a70cd0cd94f55291233e154a2f12e40508a56c51fedd22d80d21565478aa789a52b17348fd178ec428a5148815e46f22b8bcbf2d7cf2ad6af433a6234405746385bad53f9ba1d2a096eaeadb6d9f89246bf96b078b24154b6c9a3fef4a136e975e942c03d027a834c5ead39feba3d512c7f4981b109c28c82c243f9132b93dbf0a55e9d3df7fe3a4d36c7a18c89d14d7cf86d6ea7dc02f804a03e322ca25202be43784002cc9db035b2c924114b66b0d04bc6245df0540dee5aafae46d6a0cbf815a9bae2ba6826f93a5bc0a0ee6451ed5eb60c8e999a4885994a71eefb3b8e9ff0959faa80b0b6665feb476804301f81ab0e652ce4d04817352b35fd2711214398cb091890e1c87c92d555643ca86003517fcd973cef31e88101bfd07001a52a3aaf70061b748d2e21d487c2b935ce44fbf7c15b978ffcb3998e265a04da17aac6e0f6f5a3d103d63eba008dbeb9a8d9d5002edc59e6acddca77387e991adc8aae973edc7478b3152cc1e278eeb32ac0f7ea14b269efbfc4e653f1988f9fd64139834c31404920701883e6430e455fe3e4e7a3baf08af22f4e70e7eb07e03b0ccc9358cf2edec4899c4446b5534913f6f67f91050ca8554caf1ce0be1c9c8e1f222ea0cd54cbc7734116061f525c10112188a31b00a7f6a2ec8fcd7ba85697d7c4d93bb81cad036b64d1b850b0337966161be138453cc2bfad27cfb4efbf745e288332958897619f2a89b357d83800d9180c4226951d234a55a2c3293ba241f244b6db1004a17668572efba9d553eca39fba891e5274f9198434277c309e081f96c23acd39057801e89d41b8898c8bf1ad70ad877a7391115517b1d4b714914e69bc7c59fa3cd0398eacd25e6d851c9c02c59ef0d97f1f0eb9bc8f2989cfb7f40a4e53d377bae209ac3e0b8f8a95c8a36cffac8348d50b8c597fd10e44899655e94c5dbd82956d04e05fb282f70b9e916120d72a9261e25627004309fd412e8252196478f3b03e7b9ce9f2c76319fecb4aa9ac94eb976ec455f9babe5293f51fa4b8a2fbaf2c536cedee22fae07845ace2bcd3616e10fd96a050e9ca127bb08fc00f28363e5c18183f2380037ff40ee4818e3e80cc3a50c7f0aef9b8afc55e7a937ed22616896470b18523953fae8c757559bd7c02eec2137d4286bd77f69375831bdcb786b17c312a0755bce7f48dff247b327e44e797070472d218db481b7b658d5ec375f0b27e34a83eab074907bfff5877b4c6275d22e1f785a234a1d9478415258bf164a3c2c49a933e53af117719b8ad2a618776565a88e042c5e2ae2e9d4ad8b910297db94ee4385980ad9b23878c0c8d8253d2c1d5e47d3f814b62e5bb6229027c7523b16e5a4731ea481adbfc6e5b48b96aae74f73a7731026aba9e8006fe17da95401b258b20d1ff6937e19d818dfccd58f9b98ac2bc9708cba7e864e78ae2fa4dc3d10a9893504b9518a17568c032c4877e0a6671fdb2bc81293386f18ffc6d4e8223e3b4563c902d493e92fc3d0041b9f1893a83b0a42433eacb79565e1fad852e9078359a6e9814ac2247f8213704c3f93d1d289fd9245b23854641106fab59c22b9adcb375b263e73cc60dd5b5399dab518d450b135aac9c9caa00e0e699d416e2ef8ddcfb89f449473b3f4954d18c5d78e04649446f632c8d333d4fc63b197ce339c292c672c522ffebad51fb0199abcc843a7c0cdf42f33db34362f387f73cf6a64367513aa050dea5ca41d98ee75d07e0b199b3ee6f37cd5fea537278113adbbddfc0fbc25af0de1c717276c9b1198af7df8ddfb5141f5ad0859ec6ac2ca6f6282245bbc85801aadcf1472d61cc2ee35255a9c0d7aedc28feeb704e95fef96aa41770a359869445beda1170634153db2a31082decf2cc936aba413c82fe679bdecf9ca03e72f0555099330e1e22635b65ee4a0997aff276999d68a1f44aa3cf56d88393e32a2ec3217b3b02d384edee2aa7412ad6f2c123b90a77283c40cc4ca3e7e35ac28d6706e35f691c90696872cf2971fa9b9fd21a78edf7f7f9ee9d6d7cbdf3832ff979d8b5d7e36bfe0c2432b4a1eae303f3363986f8fa54fa255901db2ab7cf92e55ace87d9dbe159a5e757fae166d386fe59c78691a4a88e20232c6ace413b2d0809e13557d5a7f8350be8bd2dfd6ca13e70415adcefe62214403ad98cb4d70205ac1b6a5687388357f9c3da7458c0b8eda10d1a3bb037e247d5388d94a854de1b4302691135975abce8fbc5603e18240b92305b2395af34e0d67d0c452de8116f9a601e4e10b1131a3bb024b27391692f1bbb9205adffd962750049ca74dc72aee1b850095fdb776545118895db7f6356940193b6865ad756f78252db43b808678c277e74895ff0b04abe310d41fbff4d807f18bf610aa210b79414d3b4a9be69ee084e771dc9e55dff60de5867a7c51ce9a2749d3f57dc752cb135a40e2ef403f8b6989c685fa23e0d4a8a30bae89e2e091bb07bffc436f78553639569990bf7aab712f0bdb69f0b1ba15dd439a28176014f03f086a9980eff2637ae1c30eed7e06b1b31d9ea2a596d31e4f4ffa0895fc17659cc1fadec8df27f46d67a53ebe30d798098bcc782ec64bcf49f9bfc72f03453d521e6e7ced9c260b21b11aa64433d8c2fc8ada699b35e6bd77be64df40728d33875ac0fc56791dc2ae61ca56f62a662e5d2162be105239c911a88f52116b845c9d762e06a4065e4189aeb5df9020bd0e1bc681b4c30b1fee97fd2bc89d00c1933ad0090de40995b8d02c5d1e063ad8708b387cea76769ef91c059fa3c4e81ab92f4405ebaf770e03f8f9023ee02c04806a43c862a5a785fdb12194ff836c87ae70574b9b425b58676d587683c825c7849e7e46ae2cf2142fdd6751ec7ce50e41c79e4d0463214ee72ca19a864d18aac045f18668002fc0f36d68eed89b41bf2582c0ebe0b077754e5f20f04fb460dab41485af6906e19d4b0406d7b807ae2887588451ecf9d4b5364bdf816afb946a66963796fcc2a0ff4510307095afc31e1ee42e01aef702cdea84f761c780cdf412854b1440873cab78ea221a7d243fb32f6e2168f10e03acd0e6c2b53ec2223074cbbd5a0917d7e6e34fa0975d2346f2fb9544e8285f99f14fe778e89c77fbc5138a7c7fcf23f309ff3b2e0affaaa5e8c10e60186a7c6cb61dfc41d49a39905397d18d4dc959dcb4f5617ec1d165a8c335b3812d029435267159e1feee22bff8ebc63be6f040ccb6a2aba643eb2da6885d82848d20f484d94a0531b11d7883a7c7568b60793fecceefa5494bc8cc5a7b1785d94ffae70ed0b7cd1143c407e3b5df9af99023dac4086afe893edbca02b00886d55f006649f502eddeceedd5211e504e183d7aa5e57c71b08a5cdf36381eaa756615626b2565154ccebf46b5b3a74e13eb2048d0158afdc6fea4defc3bcefcade0d01d022d3fb5703093622ca2005b0850c17e232980ee2b9e6f46a4f25f4d997f1c0a0f082c232276f4547c7d3c8abafbdfcbfcf07c7a8e733129d210843cad77d075b96c411b5d32e7a6eecc481922aef9f1df3a64653b715b4972060ce99697de8ae3e1f4465dd1544929b1d05b8f3abb998f065636dfbf12053dd02f240d54f29dde12b5d68b60d42dc11717352f44bfd1e3485caa3c980d070bd1eebf7238e414c3f4a162d08964c9b9b4d63c5a1fb31fc3cf56760ddbf1a3056dbc6ce8febbd0ebf622a60e59ced396a916c0038a6367d45b1bdb711dcc56f3020630a98ccd2244dce87e2f672e01acef456fc56d892a6a355d0c764935bd4bca544dd5b2832de8e045c81926d265a66a2b2a77cd8e751aad9aa6b6dd914d2406e26730968fc7ab2dff4c2ef45a7c8cfd193893383d51937e1d55b4ea3410883ba7a6ced9237455f16f787ee62cee3406f9e676f69743f82c0dae2dc497e108a18823f89b8b40e8782fab6a3b21f1778b3e60986658f08f6c9c387a70c46587c221ee43263363a9388a47b34517eefd6673cfdb9a15dfd5c3989d388cd9687b6f0997a555794a180728a29642059721111c1535b063583f1ebd546ad50958a7466c846840f5098a594f8fcabd30bbb668239801a2968018b7a01c4d658a2b40c1764fbb0e058dc5df70cf4451f4ef557538d2f58ef674dd8649740a130c880ccd2623101a33c3ca1ff413f64ecfa9063382d47d07c9934582f64eda605f5aa9b64f68d14195322465c7b951058be6e9169f98a2c40c6bfc9d207df3113eaade0f3878fd4aecfbc909ed33885ab55ac3077b1bed8f06aa9181e0a55c81c6bbf856b559fc44c1b4ff43573ddb32d1c6c8b2d468462816caf4da7ed1e81cea2d87e0b94d78134b7b8cf7e5a39109f74c5c9ce03288ba67e9de99d37cb8e4f84d6f62888cb078aeec4bad3b020a4913a2facc90b5f0aafbbb6505872134b5c34da621e555d92b06bd4656599ad897f9d8bf3d100cba7aca9964678dd9009be02f8355968f1179ddc98a23551b988890daf2428cb7b48e5069b125e1db5ab18de6021146759af8adec8fca221132c3f8b60820b017e15a9a1dc3c8cd2a65c09b84e54ab5bb4e6d5791c26d843c442c35f236bdecfe897287f0cc6c995f45e629010cfcd9d5444c37fb382836cc32fe4d4929b99667fe9288e5b7c8d66560aa43931168a3f50e9f9c01ae08aa9e9ab7a1194f9f12a6dcd17e5d8defb06776d43dc817864d975619efd1876a592c3dd4e5587d3b4a7d411e7e53974561d369f42164fe8f1d83b44e6c26d1d9c76700b13baa420ec66679a3c3b27b820f9199bfb2a45e0150acb419e0de436ccfd976ee37a252fedf6dd61716a54872578085c092391958b31ed2584c17057e304a5b246ec10d36e7278fa99aae3a8f1fcf7436ee926eb2ea2369deacc5082223167b7408e3898867afa1f704b04d0457e3dac2e82a1a9d6416486f26ae5f9d90dbc6a40928baa788a289f9ad979959f8bf26f3a2d71c0943b588f0b02294a26b7000af2222acd6b15ae275dc3f15b3d80aa37b23c8625667fc364d993ba5ea6cc7a20e4b74a97aa08c209643fc9e6ca9b166bb6b6d97fba1c6234f5c8bb21358c7b5cccd8dabf9667983a289d83664bef795b80306de7ab8389fb9ccd9bdafa0d971b8fc5b533375d021abf98949151cabb6e91924b7cb434ed316940c19463811ffcfa5cb6aaab454cf63fb356f3d5b8e264cbb9f790c131a054098706b959b95cbc68d14fe17a1f385fd778e3f6323d14b92fe5388cfcbec6d481349c96a5bb1b0aaae826a48eae3cf9a9b4a3a9d56ca51fe9495cc201af5c9570a2aef4868a4e36ffad7b33a7990b26e4120bf02bb5c9c199e42e7efc99540116d93a6c33cc8b1c41b73632e0b01b4b1289307795f4df8fca54e9be6d4dd61ba967733b50bf18518e79f1ab8b4d9258aebea31937a6a63d25ac7764faf334b75bc3e443c8e1be23c7fd172587fea5297739dbb552aa78a48989c786df516aed0ba21df1fb34f37e4ce2c6090f735db347b2e301e3c66559124ee25bf2ac490641ec983739c62d6a9d5052c1487ce4fd903779d582c27cbb10896936954ca63a382601f4e5d69956e619865fa17fa8f31081ae6d6ae5c4f4681ff096aa2f3f7c8173d01b9e4f3cbe76beb031f5f6be1317fd471ba1e9e272a010715c0a5b5784e9784e3cf8d6607ed19adbf69945c88d62b93ebe47f7132c7e85abfcd4729db014ad808539d1e4ab23d3c39f40d7a1df24d1b608906b9b72ed94ada271a93e5839bba247751673fd961f38a7ab05d7c6d796f2900f9d37b75edd66d5875edb5b6c91080056006a38b8ebf1270f6d45abf761774db11deb98a87db4052fa91e85d4da487f1cb968754397327d55bcf4be904be57dc432968ff5509303902565580eb599f3fa85e5031b9ea19b19ca438c46350a11abe5ecf88aafb98fd8002d3a040aebdec5740e69a78bc6bffbbf33880fbdf77f8598a84c2904ddb0f20c71d54e5ef04766f4e6c980811b4cd44f0b4f702e99a850935bed2c8d14b17f0b259d063631a2ee4f9ccf84604156f117aebfb25cbeae5e738e04a7a614c0cbb7ba8c36ea889ee50b80321c35a509f39af57ae3374b42d6637c4010a80e3bbc5465667587e3452394313ba51d7b9b94ab7233783b741063a5115780da6b37e5b32e8151ded127394206ffff6dcea628a456012524aef66ab1952b9fa74f2ec556a0708122003eac64278e60761d45146d963022b57005a4189ac0cd51e2905aeb4a8a35070eb668d4e91b00a504d57d7ca2b77c31c7afb822d6a867595b33e3de66124a68664eb99acffd2ab5baff5d5d7599b96c53748da59297aa2fd354c48714dafef85cbfe4848282e3af968082f7f2f06854c2e1f8213cec5d57100e4b7f741940be423b371a7af7dfd34c9799b4acdab6dcbe19fc69a97c298526562eb546e43ca287fe3cf55ce24b94e048720515af104c1865b7461760d079f37a5f38a906d89974643aaa3102ca0934cf61a268c01da6376687746e6e670817ce076ec11a80e55f7c4192411d8c77d9081fb11067889973a3ac659288fb0693b80e50761aba9a00fe551ee3bd47732ce205deba3b0738ce4fec4cd6800c8ab36b6aa6c34accdb31d253c0bd69de2c29dbe4ad080dbd6083fcd9e92c37d29978e6ba56fd9486d0f3186ba2d88ebc19033cbbaa79c18bf10462dc0138d943cd859e6aea6d852bfe25d359c65d3e31e178f22b4556923c90fbd1a213d527cf2c6a93d54ddd64a9552b8d3faef4aa81717b0f03bde0ae81441c29ce84049722d8c2b0afb7ffd3ac8d350f2716885aafba28d758b9278e7d27a1f5d86188d17da2c539158cbcef1736c0df3812ffb93ade68d95276f70bcc90d1e9dbad4608247ae836589defa53a7bd598360de4e93c0fe492acfc83c060d8cee39e010f3ed70513612f7b75a4bb598c473ea9780666decc3bbae668abe167c24ad3b0d13d2c5b4a1f2ffd9c8242295964676dae8f8eeead2b3d85cb25a1587085e4747502a6186e14c116efccd7af02a0109c285e80eb8ec5ffb550cab279990a7735e4d775070c2e66cac77b6b4602157f64ab23611d719d2fb139870e5143d087809aa904ab5e52f47a00a72cb6a134d112b7f6320d5dfbf283c6a95502de25f398c102c9ecdf124299b393d2076551315a102b7eee705e3516158c0cb11ba8b71e33873f906dee626a2e731ff248aa6b8d73fc19b542c96f8b1887d9ea36a999149ae5902f41b9ee1c6dfd0e75c4671278d866d55eabdacbfbb1d4803708c464e5e9f4f09d0641b97c028cfeff4e00a358f0ae26f8d363bccc37b00e3aaf23755de731b9543b3161f86d4227b66bd195104e3adbb8f6f20c9a1228367f251cbd4a3cede7aa824605586ce34a99bf195bf063be2486ed5a55db812b78c6997d121a177260e1dd9311820755fe6fda0d9c07cf541d2b3676992b2949f60a05696ec4354edb3f0c4565bfa2be58bd2e480020dd7a45f9e76a78ea77fe750f18c19aa9f50bfa9822f3cdab31c8a5e64f04af506c724a12949b141fdcb6b2fddbe9b949ceadb25dca78c89a2bb925d2e2bd7955a55f060b2c250eeb69f58ad0616b29f91755952ed8c140f79159b5c7a11fd766b1711168441644476bd92f77e1b87028cbb8a52811a1ad15cbe5e0a9ffbeb94b3ce44ef9c2e8333aa563abc6d1a582935c8f3ac501d8c41197f907d2ce5b610ff1b70a249bdb64f8faf57dd14739deea07d3ec9e00b30e2a7a186e1e105e527822969aba25b203793fb5d90e5a10114c598f379155829cec3069151e379ee8f80bdc4178beb1adc455eced18845957c96faff9827f2d5cd6fe64d2369417f530c34fb0a6640bcc4c38c880e4703afeeca9026943326fd1b28fdd79bb197776ae36bd31267a7852010bad42ce93aa2273fb6b8e3596597d36ec9da173dd0bb7daf93aed6b5ad30cfa10a95f7ee0896d35db0a2b1811b8efc64143345fee6e6ffa8f2d46f736c7f0ceb69a74c401942f4f3cbdd010cc9842f0e754a9d7c8445e2d06d247a792fdd5c18331e00ddfb2d5b50349090aeff7bbade40a9c773488e8cd9a8bf8a3303eb5c254bbb28d16648475eb7388a6b460c2fea829d996d1ed7f44655eb7a13ad98cd6daac90bacadc261af821a6a1cb8f22a0b1ed7a096eaaee15ddbade1a0e0055bdf6cec06a3b42193ee4c6f39d8485fe7f1d5676a58a0f8b900d13430dc68716ffe514ddfd0475e933726607f099f511576f111abb2be6ca5e9bd5f7936465ae27576dc515671ec53a81edfa83988790d6bc9eb831988591d99737a580695af43a1a2c096310687e81a1e36a7aaf46a26f2295835171167025240330e3277487b6e816caf48d87edb7358e0dec44c659e925f522e775a0bf3b7bf2b9af5b4600a3ecee9a1f4a2014da29b5d4572c75f7a8eae3598430214e7fbd71c97deae6d025683456a37d0039cf67b2677fc29f4242fac09bfe56eab2d5df9b93ed51bd70f2726e81c056b3d4fac3cfa51ec1495e84a50793ebb033e828c9d4a7c6307a5a0bb84e4466d4f0c48034227acd1a380042b3b3208883e99f676ab07c452f8673d3af9a324dff058b517da41189dcde61962f0518b2ee27509f2ffbca4dd929aceee793634c2bef891e1a0de2582d0f33a933ca64607082ac79a8a78210fc79b5e098aa0a713fedcc5ca37d32d302ef5cc088eb9a2497d814701500a04058deee9641c4e9120089dab86d697743042cb9d28e694a7e5bba4785970cbf6c32f5b3a66eab22306220aef7eba6d506a33cc464e8182f2e49d2d2efa9a8b5644a615ac8760b8c1e4321869251b830946a16db54a9be8efb4c63c56872dd9f94ae4a97fabd5da74d3478851195a9a8ff0cd01b7c2e28a09bffebed63509a72ba05722cd7069e6bebaf21bc420df3fe83e4a7a0e01c21e7e1d86d0489a1607240ad3f09c39cfb960a79d7ae6bc1eb3a7c125b6f1b2bb139d980ce5be12edcec7672d3b92b27c0660e72a5cd639ca79899e7db9421d794357c264add08a83f09e784896494fd5dc4674c13b96592fd985e343ed9aa7269819096be621a42939837e2155ef98760a356f49d60a6228e77b180e591108606e98004cc8b8685cc8616a6ed16c5df9a281ff7483967e734646e4cf214fd35f9087a530a0f70af22ee1e485b13f0b9d66bac9b141884c58389a0adf49cfaf35013b46b5b49ebcefb0a0fd51cf7dcc9f7b68740a103ca1f5c9890ee21a1b982824f435f34cb843ac63ee54fd52937d1d1e2aa4bae7a8edef4a299374494aa04566b0f9a1dfbc7fee4716b02bdf230ea4529f3c1a1d5f906229b5cb42878f0ecb6bbb61b326767663aefd65e6ba4799131f1878ed9dce905eb8a0ccff196dbfe1e675fa7b1a94da852b8f341ff0fe394c69fc754a2984007f7a646470147e42fa097fdeef13f6133e16541090edd9dd263bd32c83d40cd9ecdf60940df2928a3cbceabaffc0fc74df084d291e0d53a651a239d4169fb1085f564e7cc21034b95092814e9bd4fd91a680e79413e40ecce8488fbf78947701ce34fb78b54e8c0a296023aec0f413ced038d219262bfcc2c02c4ab6f12df7813518b21c013f6e2332f07dda124d39602473fb57c0e265aa2ac65ba6d6ccc37605ddda809e68ea57ef6aa66e6c9ef88eb6f0eaf02f09b38862736784c2c30a35a29ad24e80121f987b11d79a622f29eaec6c2020da1da23121feb40368ce7ffd731b0a7593524d62911fb575e9f433b2337989941996205caf5d527f0f436d58620328b386c374583d84fecaaa0a5bbeca00ce4c43d679b7abf4a1079a32d135cf3f2cd70e9a4ee440ca32dd2c03aabfee9a146939d2ed646b62a79987879c52d3192ee5d2d65aa68bce5c05c0046e3e4f9a21bf51ae09f403a7307eba91e3a0583161249e200a175811da7527853a89293162b78c000ac6e947675f0c5dbb2c9d3d3241c0569db81dea47041bdecc56b4b8e74924e58a88f98288cd491974e249c31cbe5f4c3b01c3d18e15617ca62f11af9ee54cf1938fdaedbf773f2fe487b15463d29472aff9e418a4a3beaa6997734eded00370ff936eb3f9971db1036dfb8effb930e200dfd82093f6af6e1a07393958d0d7dedde77917357a89e1191332287b9f359b3fce16e69a26fb7e21a47ddad16a649b683d2231141433874f87de9399f6f073af14f5882bf33af029b1e1d4dd5d41b435a19463fca09a0e8e1398e41816eda5a329d7b70fe84b64e77459977b6163929de9c30370da7f48def3361b6ad2190f5a63816cc52038fd720efbba80acc08440a274cbb3fb93eeee8360b92b3f61fcbefe89fff5c3273e9318e7f94f4be8f22b7b5d0a076ea3233d687e9d49f382cb8cd84d1fc18e84b6e23a7168521494cb2f9a86e9928932a638858836f5cd80769598868861f7a3217c94f3a7be9f890d40f8b3141c6ca8ec4db3a2ae7e0ee91266fdffb7e80df8b4ec152aea85637bee00c3383d0d91f48c5fa08d1a5cb4a17c05c097175eb35ab34b54b182b3b030c2a4114c91de66dfe3c26f9910aa1b27ea9deadfe096c04b1ca82596743cea1e3664f265e1b10f1abae8a9d832e6c4e91fd07e74029829258a665ab94c929e8bc92d7c9b5bc385060587d116df3f67a26b53dca70eec833c3e577ef8c2ea9d101cb3b93e2eafdccc6193cced6ac5023254e6b8eca6eef4c1eb91a483bc07b6e91ad31da1affc6df6e61d410fd7643f77bea199573213c08780d85780eeb8440c84ebe25aef3ecdb23c376ce960996bc0208ca4266e0176f4c5c7b0fff6129d16447c998db4cbfb8890f7309f378f3f9b801c56917167a4cf2a5044b2663b4cb47b201b9cc73ec7b8b311743e704a46f2ee4e7bf6cf506f38c33f909dce5683270ffbda64fba8673d438d0a6e5e687fbbaddc26f1186061a450bd640c28ee6e2a204d757dde2b9d6dcd539e3e927312a9e630f6b71566bd434605e72a99e83708ce58ff4a7b4e7ac6dec1d907dd64d3a86b50ac246a7039747191fa06131c5c7a35d0c33815c67c8e79b5de5c606a5db328e844ee5e8425f733a570b9d2d070b058e6ea55621c4b6426c63fee951ef21c05a4d7ee2f43df9085c4db1e9b76b6f1e49c3f8f174f878d0a42c4613a1c43deedb1ac6eb2b301fdc4eb5bc9624ed5d91dfd35d56ac522927e3107fa156571f3d3377c2c5fd2895af1712f07033123f41371005adceacecab449a41a90ab155583db980107be71fb7847ad5c3d50602625e05a92f9101451eca3fa2e34c0351c47e411e30b522ecf323caf0e91d8da42540bbaf8fac81b5fa1908b701d94a33f8d89368dfad361fd5fdefafb21421367715b03edb47ded41064493d8e3f26e44a053fbddac41ad5e7e393e22d1994559208a7d0017df1fcf14a06b986904d33dd7626c67d791e3ef0ae15486b7f0eac99ca941e40aecbf418a86270a0384963e1eb3e00ce1c0bdda577f2989e5d95781fc9a66cb36eb2343c066eca0446b43a39b26c71636fd6680450ca755c3b2a32533cf11b6317c5f4d18d321e22f8d16179b6a7d103e7e5df14210db9b0fd96f09e7389293438559634f74886ca60aa738005687eda76b60f0997af12ec40167934c694bb3e6a0d1730c6ad38273a600f69447c906603a60f946d17078991b3dbec52ffcf9a038b7a812f68114fc9986fbd484f29cf9ea1002ed0237706ae41db4a3d5d0c7e64d89125f64f9b01981634c6727d0677df19384c6cf43269155496c86218a089136e5d5db387ab9d50fe8bb7f8f65bd075c9621a217b9b5787696d5ab6f105b3b691e9f296872cd3aa80dd0025603766fb59d9fa1359ba0727ddc908d7fd78ccc94394a192ec9074f66558cc6144dc603d67b2daf6f5ae2dc1f0ff5bda141a05b1d4e8caa598a3d80df8ed11c22826aaf8d46c7edde470ac6b9db34ce72c6e422172a85db66a4dcd2e1a1e3e677e5dc386dc6b98c1abe89963c8800354330aa032f517ff9077695ec584c977a7f76d27b4a4ba418991ed3e1e72e2e22dec8e2ebffa6b974c98561f16c7b131c63e92b9038d983858767882269b4ff186a5da2854d60211330f8b317f73c3a99fae2de30345a0fb3d41fcd61932febfdb60be43b2893d6768deccee9c5ae95c6ac33c0abb446abd48ebcd098de13e0170406343a2f0e1605a019cc8d074e7cc6650828a46d6a37c54f9ec8d5bdb994fe1c693a045e41b748a8ffa4ca0e9ccdf9ef262880bcef9d2a810150b1e2b91e69f66d138a350775edd0b196ae802c16043882a48e26495ac031f8286566d98e10a32f961ddcd773d5b6139ddb21050fa596ef81baa9dfd32f18a6f88e5c53381a6db8167532b18e27330a6c966938cd3b8338155e8aa8b34f6c52f5efe9ce3a30de23a2b68ac747ade9a3620067af3266cd6677f2bde6d84608ead0dd93caafb2ee3f8bf57f03ef9a3162318fd2e1b0e31e5b80a373e91a8af3fac121c4e51ad32bfec1bc12948d022ff5a4b5a791dd3aafed7b9fa8fd7477d4af4bd425f41bc78d1d1e27535e647db38b0448edf4f014e70f47418fe7f4c3f93b40e6d81c35c2e45393cfb876c2970dba6372a07122a9a1a6c97cd160e754390f92ba9b758c1d7f519b3aa45f0ae037b81c4a274b0d1c7328b4b86f85caa1c1e3ef7c0e3021409589e44930393fdcbe350cc1e04eb6bf64660c10dff6b30b63384cd75120fd2d5fe4fe589d0ddd3d14bba8503df56134f3c7dbf60a801529920e3b38c9cf3868c26567f827db2a6cd362c4470639032669d0117f2b3c6b4d9c1ec36d75cd95e20684e84e149af956779f4e600560f93e29c9032b11b9e36388712f56a120ef4ad7617b6604f50766cbd918038e0563a018e7331d44f354d758260ba116ed65f47304038879ca60cedb8fb682d9909fa63883fe63f087ba5acd11ecb8bafd001e792ca6ac1a02db6e6a00b2c152daf9d3327f14826766cd0c557af7c47331314a34ea79630212d42691112ac38bec352f071355a4e2fa33f9e12d84934f51f2db810e8f9944607370c08c42026e0658cdac2268407a9e25f8a5290afb850be3cd6b4755b4821711b8baa9fa0a0d89619a1431af23444629d9ce97046334dacb8184d2ab6f311203fb8e2ec949cfe5143ccbf5ffc69889d7928bf431459148bf81a9cdb066607aa2de7387b8f8829a2dac3b92cb81733a7550eea766bde3d752bab2c2fd200b0a54cdb2afc47fb37b3fedee4bf0ed68ccdaa43685899bb3853c13c63fe322fb085616a4e3024e11a4c77eec3ef8dc44e5151f702b5ed962eacb1ec38e31e8f8628d46638d02cc2bc380e391355bae6d098253e8321727630ab722369ff78972d353a6e65b317e9700661dc737052a8daab01824f7522b4981c9388045c55ad5560984cf33414765ce82a70b476ba3a254ca3b7719a1d4fc713b156a02785b2f0e25b7ea877d05f2a79abce38b44013af0256fe1099fab39fd85dc2b8262494cb2c5d73dc766b24f235eaa6935a3d6c59bb0a4dbe42e296b8163b6869fa54113a87968852c4de4c589c701ccd4bb173352d6f6d03198434a21b7e3b840719b428db73601327e8b70b359c521d71765c96ef2beb9c03e041c4401cc19d5a185180f7f535f5f9f0fca90c51724602291f34e2d7322aa9884b2af5ed1e3eb207768f41b37ac218473cd52f21547115425865120adf8e05d00248bd30720868b86264ea9a9d117d91be705c77e7b47cdef5439e49be543767f6caeb645c4701e559082fbebdc419c708918bc506a4a94508be43b7c08fbef338aed1d3dc14b0be2324c2397f00644cfc1de278afbd8196e9f1ac6ae6491cc338555bcafeaca7cc8cb675dd5423028ed51fe613f88f84ae9b2820998c45c49513613a7e25d18384e35c0c77844c4e947db91df16e474e6f98b497392d320d8e1b23f17f055bfda27eeaa84c4984374488762a011f46825af126b5bf190c2df83b8c8c2fb7bfc38e26a315e2ec78c09c56d9b9b32861e19f28cbb8c9f02db7f19a95b66cc7e2b828b4c230e25556f9c7be979eddea3af826252e3ef1abafbe02395ab80684317ea77a6f3333ce807269c6b89cf229981794615653f5e14a33cb266f2ac309dfeb02bfa5e7593e46f9732b8867cf7b8f88bc72456f327a0b4f3ba13aef83c34921d3da193bf58a84ba366d691244ce0ffd3cd497ea40cb1502c07aea3e3fac52ed4e780510ed191921522d2201f77e49570dd1594482aca4a3ebfc3a422ad6c7b3989962f5b33bcd5a65ba82c0ca4dc58f8ccd80a412212080489c4c12f3d19261014dbac43be6db1bf88aad686d0974cc0bcfa184e86b5cd6c2cb96dae55a683d6776a4eb83d103abe4b1df3e1a5263c500f7dd33b9a93336cda7deac43d28c92bcda8ed175dcd1147a0e7eac37b1952defc3b175572301888ab1ea5609a873abef2214bf9037be0a4f5272f957b1064fdddd1230f91c6a77420f21ff57872e678ab5983769adc2f8e13d8972b5cdf12ae50d4a523893b16def6b39dd329955fb0f283129a0f6d0e9b067cd97aae28953b67c10e992fc81a66c30a59dc67e090a9747001b56791082ee792d4d5de922e9fa268a96ce6f8934173621d0aae082bf347f9c40e4a8ebcd414535e9ec811f2d368498996c5d6946a452093e07a5cf2071b45b4e2dc06af073d6885b3e2452ad5611c50e0dadd088fc9bd8b0c99febe6a89a81ba5a4427a45aec5cc5c173f2c33132fdd9141727922e402312e6417b7903791d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
