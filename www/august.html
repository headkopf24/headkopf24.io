<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"085f0bd2c245df2c5c9e5dfca7385c35d4decd58f2ca76df8ccdb2b09c4fc7f7a3c0da36bff7c8983feaa566102aa9619240ca7ae108666b1f4836d842ac172ee42314bb61aab926a2653ad5d4a82f2547562c14456ed918470705bd8d70db28d6e8225ab9f07c686a3db6daf32ccc359974a62ff857ca203eccac86453b1d4486e698b4893fb86f21ffccc7b92d39df8550105d7d09f22084fab7b39557642fb0141295efa870a21c5e0eb4783c3299fdbd54bbe5f85e87c3e6351789da8b17857e8111c416549c549944c43396ee29a95eecb34b71bc2c8f8e0358cd5cd834ce91172900e30ac391f4ef045b4e8168c1d078f20ba100c2b209902a02ef002dca4dce2b5f5d3ccf7173559cd171df123474da57e73f3e2fe3d6d384fcc9bd8211f243233a4d08404e46b50d601f0f692db8bb3754a11f5d9e41ca58df4bae1210af54a534636fbc87c94b279d530f9d2820ff3c05f850e1c7c3510fac7080566efe1326ee4e9daefca9cb55945ca4a2e371ef4dd0a3adb4a00dde9eeaa832138d57bfced82ce8ba788dc25a7873d1e36b457a33b6878f7ded865b377a1a4828bb97297ade3ce3ca91e2ff66dc30938e4426c9ef26cff491b8ec18711f2eef104f4e1b735669c7129e9946873f324c5f34c9acfab2d9870cda8df88f60916cd456b6c0e90505f818207d68c045d72d7dbd08156033ccdea12e8c26741e0098ee718639aefdd96f97414a75630c386e8e6f4b06d02bc294c327b4dda92d2044b259869923def50c6c639c7c77b2ca169a6fe7ecb37cbb7294ca5ac53873e095452eec63e5afb5fea1302d6ad55da00fdb6f5bd426217e50ab9064662a6fa7e426ac9314c996adc1b0b64b1a3d97230b124c0e8be83236ad05f6e19651e63168a3007c8953953962b388ee4cc5b0fe8079be84f920c81fc0f16c96402ac3bd9a6ec2087257ffb10beb246c32bca137b8e2b6985d0829160633c2a99eea0758b2b19f75b69c6dd38e2c5600bb60a0f003f39a077c101c1f435db0df23d1c3a87d75d8c49de4062251499295efdc996573290292a0cb1798d7ba2b74f58d8dd1e637e9c62b52cf029d34f1da7976cde097621d473f824a913be4a3afc7d24b6b4fd9cad913f31f1b6c45831f2bc79728346d0850d0c1163da7963ddf78adeaef2e8e4ee0d8a4684d6945961308b865262fe64fbb6a5021b966d47fc474fba2415d20b3ed5708f3b910854c4ee3e975e74e471828b89d59feef917b6c08897ce0822ee96fd40161de8e0b76b1b84638a8162f7c1c5c85637286cc4aa332193347fcf097927215869ac05d2b90175f700f4c7dd317068f3b0287284900376ed696ae26a81d1ac19f6941a085cb70d008467105c15ff0341c3206e676bb9cd2f687b19c092516478be070fec1e66d3a31fb60fc1a321fdb5a1380d46d13eca1b715d9c2c4022aa40112b3d0fcebeeaf7ee2f5d80060a691fbc3019278e9dc9c8cbc419c3d13385f1a2a40e7b0ed3ef13f961ee9f9c03778f812a43eb11041181631194e55dc4e3f0dc44187c1edb97de83c9f65d1c1c361dc950a931701394f87f51d35a209ab35a3b42a6c755a3361d4d3a84c9f3298d41abd35e8159526e0f10919da48e6614fca18d134258c64e2e3b49bc4e3cc616ec4ccbf03b06e6de4cf20a54172a4121a69f25da0d7b021b158393b91baadc6dd0148578adf940e21d9c3b40889cf7b6ae66b0b79c979ddfd4b699df3c20a031fce8c1359122e3d80977aed425401f11d26a044e9c34f42e743903aba7f9c3655c5aad0105ad2488810c6e317c312dcb22329e98f38fd2f2aee4917ce7f5310a69410d577153ebf1d1d03fa43f05af6feca0d74dd14cfaec3668451257510229c333cdcef65b13d06014fc3463b319434f4f4cca75ae3c042d60773994cb5ba6b0ec1f115ea6863ceabbea74103d95464c4de8f9dce8fda95184eea5d6698f6c9092977712971568f2542af1751d2dc2ccc8b5a9004a16b6bdaf858c093f19fa1249d0350add9668307695d8f9a20b42dd8634796fa0f2a7a0ca23873d2d4d2604ebbb0c787220bd55e6389a6317a208bfd0e5548561ef8cf0ec6303193b66fbc9b0af9cf394c6c4292976a8612fba0265342595f6b40e4de05ffaa4faf6e8b66047e732a268e7a9ab7a680be3d168a5064324a07f1b6371f6c3ff19b810b7ccef05b24e5abdb07cfa1e3f0adf135ba87b6c4a84ad6a8ed0f4f4962ce963c73628bd6d9ae28b2278dc056e917bb7bb4c5a5b7af9cd4e415df7b3d7efd66f9609cc109c490f5ec983fd16105c7fd1966df8da0c14bcd91f288e79d31e5637f04e085b3587f5f33d52a7e8741bae1a5cadb006790236889975281db15f85f91b29559bdbf406357e88bed72a1b83f66a36a6d311f28f63b9f56a4b03b594c48d8da8736c1d66935ca4dc0d09d08ad5bef889e97e9caedf13a106b71f157d1b2ecb3cf826908f3ccb33b003d2029ce701eaa39958bfa9af135cd635163b6c68191487921b4f9bcbf7502357f0fd47ae1e6f051863d7ab57df2c748e7be5d4d5c8e220ccf019e109949498bc58a78469db93567f4dccbc92adef04e92bfdecae225c6023875d86103dce2854463a011af1981fe9e4e19304a85acda416439cb177f6117a63da5fbb5c4dc0f0682e9480fe12d3b382e6e83c67142886753d2a7ad796238fdfe85e7eb5b9e4113c1a5765c6ab3fc1df0ed2fb0040fcddab7525a1cfcce35672a373987d13f3c70237bd5d9286991a86afcc3d00e297389d8efc41ade175599087e93445404b2081e253fb86d833da5f19be604c33110739b54dd5541419244db97b3cc6ea87c793435552aa6d7f549670d1963c4476c383b899ee47cb5bfe1d018b4c6b494c880c87501e22dad047b9e28d79ee9470551322056ecc4029c4ab9d48bfe9be8eb965a590f65d5f36f08dbde975f7ca723e5357df030969b3209385fc353c3a9af4699e9d55d4b9e5a7e8db70b177bb490df022e72b839813c145eba1fd7d4bc10beda745edd322d20b91fb32e4678c4f83a4e85188d73378ad429d43deb65b026373fce68c598bf8b9e7ce786d8f4140e3eb70c7d084d0f18d02823e48c3260b355f2a38072a078c82eacda16ff648baf84583badcfb909360f9b6b53f7f081cb0d3739d071238c6aa72b54fe4a24371cb72c7857a2d9585fa49a3ca4344d4c5eda935b3fad039c8eacd77da740d992b110ca3aa95a220ba1663731ed52b6aa9048d46c9f1713ce09b7ff391df8a51063ffa8418edfa93a4376b13edfeacf36969c4d10910546eeda39554d2e36aeeb8b7ef234325f78796c8d5ff838f758d991ac8ea8f8ef45b4443291bf972cafc86b20d3d3dec5cb3bd8126e92c2f9faf1b7cc7b2f4b169522932d00bc5e0698c73e9cb2c4c5c6e778748d91f19283197b70d4829feb86544ab432d0b9b49b50e048769c561aca3e49ca7f14133360a2b2cd9f1e412be7712d9ed3faf75e74ec7b453a08a32073944cafd43cf8589b34af10daf61bbb50fefaaf3c910da1d7fb301090b7c71a08fb5cf93fa825c957260049aff32313ea6ecb4c977ffd9e3ac078b5af6a2ff0cf216d4b60b1bd7d91a7c92621b9b03add9420ca00e29fc3ae2a2d883043298b7f1b2628b6f5b2580cf0179e7b687c5e1cad9e807f346bf09e7358e11dc998873d9bd0fe3ad4f435c7a4010e7930df6ad9e88cd10fde2dc9340532f60e9222b081a4ab8d89c6537cfadef0abb4ca916888b53c080b4ca8fdf72427f7373202c04034608d241f6128d2cec5187fd4dfc497cbd8e001bd8d73810e809a6f46676b5d347b597c62b151c19c73dec810b89c4a62daf978ec5877ab935bf0b1d057e9f3f4eaf5951c019dd9a1ce41243b3f914afae751a3349d03a12e2278a0186c53d1f336976659da3f3318597a1fc4f75fe74ba86d59287f538688ff489671a3730263130412b70f075b7a37586f5d41c7fdcbf2b6540fa736af90f47f8f31d535ce16a3f6c18aeca1c31f4b5c7e0e84dd0e34224a9868fc34757be5c251654ee63334e2f1eec970a5434d32403a387457137cf0597767ed3661d1fac5665959a0731b856ae6807a1165ec614585ca3d8977d99f8cbe8a031b841dd653d6ce722909cb05f66488ade44c3c100cdfe2e46c332c1b6ed4e848289058d66335c1e567ed242de877bb0c4e30aed21a5f1ba15429b8227c3114982a716a8e162cb10cc849e3b58bcf1891da4f401a05909a3f011cc5e76a5717905df76e470f16e2dedc9d400046b022aa0120c0fd149ee089d3d4a440efaec05653a30f9f15fcfea568d7e27cbb648398665b9fbfe05c39caf3b1efd13b86a65c63aebde708d69bc51c42ec890ab53a237f2a439b39ce7d6a8a2fb2bb64f62c16cbb5a43a12d031a31925db90079ebb058e9ae09e33a3a73e1a3cc53c584719e101c52730245567b1722872621c035ba3398776fb8c488e47a5be68188271df90150d60c8fe48e1b6033238c0abb099f52251625d718a27ef027e7599b74e1fd023cf8d1d1e2e7027ddcfe777628694bbb420cf364e2f4b9e08a579a78e457528679574a39505c90433745b6bad6734f98dc108fecdc57966329db7c30b53f9542012bda867bca145167b20636454f34b3d35c3a61d176ff353188cd6bcfae3419cf30b7d24b0e6eb9a8de8a055518b4e6d385bc4a9596ff5e7403ceaa7663884eb876d2a071f7d50e4d5090b2fc4ee1c2c112f39bddeda384152e6ad737dcc5699d58ca1b0bcefba88f539943bdc3307877e963ea2992e0948a4395f191f95c9d542563d3f6a6967a943c0dd4823dcfec23e67bc87b6e9602c0773a3cfa8e84e847cea045089dd6cd93a6f1dee28a20481daee005775c73b286854c29dcd081b67d7b158b3072537905c4eeb549360b09d491b561e5337d734000545d8ad7fdca24a17b14c4cf13439a837ded0de2c671e4ed7e16a5f96b32b0f94d5097c06ac9fbbd9d6d949c05aae9952a38f3ed0bf57785912a9b5368269fee90d2615a530502d2217e3d3f177d134963bbd158460e1a12874bbe30c5b3ea5332fdf97d7340017030383bd1bbac5561507d4e67b537fcecfefa4613d19167ccbaa12fefbcbd8dbee38690245dbd3f5167d01d5ca2d822163f7cac90aa6a9423f76f1df84c21a1c5c116f0523223f909e5f0ad97e10118204ed6c79ffc5d2dcdc9d56f4c52136ef2fea0846aaa3a0b53fdac68596797a830c2d0c2f3eb53ff62b11585ad297dd0acd309d40f972857bd1e5a52987a5c04e7d2aada4e3942760e6ad6499ecdef6053782f92aa2ac9462688e762cf5cb1ab3d4399c957a10ee4858b44eb5943866f8eb8c10e86850f4b47c30370e8f2a1fb114c85777c2b30377e433ffffaed64eb37038ca2fa9412aa7f6a3197e1ce5815c9fc8cee09c440db64f0ab81da3da9b3a5537c9102b0498c3880e022508807a7921647a93ba25eab039e108cec38d548f0a50abc9eae10e9ced44647f29c9a4e0d1e8dc17a32e87c515e847f7939aca67668bccf11a5931de0b173a4f1dae0c9e6d964150fd2112bd547acf7763a6b1e776e86f07884f11d1e7199138893cd88e5c2087f8689285fc46ce4e449bf2f66e5f25ed307eeb0e882779ae1028fe2c780add47a14daf9f4beb5e648c7658a34883a8cffb6d54f42f1cf7e60748dba4a691c8028737cada0e2d721829b82fab3c580671f5599e2aa65b6ff51f05609e556e6c4b4fa8420c5bd29d97304b33eed48df7d2135d1f4669f70327bec4533189337a9a0a6ecc76c12c89f9025f40794e58aa436ea219f41ca005a77cd2b40a57ac4ee4096f1e5fe2fb939743f8d77d28989dd6e9b8a66484ca0771c49188d25ab70abb627f9de568291195de4a83bf9c23d84e32688051191594bf08dff44878428b8119b1a191e931ac8c5652eb2c57e128fb65d9a2c8f2fd0d518a6c6c71d506f10125b56d6d2f9dab65938efee09b50332fc8b3a90942d67f0d20cfb4285bc571628ba79e52bd1769ad95e7dbfaa4ed28b89a3fbcb96d3d95124132006befb926d3d383551bb1713f8fa2f7fc23e12aefe80ddc4f6644295c2a3d11bc5706548bd5c1f74113ae924be58eff376149e33add25bfbd51f57e454fc38dda9dcbb9d9f819e42be7468fdd51dfa7b3a31b00a15af49e5bd94f488e4d661287ee7827490f7c82c0ea96634df4aa68ee317b367e6029a4ced829a8d48d1ebc7767cb1babd36dc3e714773d7864740770f68b700234c5a35d2b03ab2b5ffb001edeb2c1f0b8a794625bdc92d88118ffa62ab170633d29190a8a9faa16c9302e89af0dcfef405df4389aea8868f099e94aa5b562cc95c2f494a11a3f71cdbd500f4801701fe9ad9c4224cd51a3e9b5c8e3ad10cf050eb50ef30b000c0226015a9cb0040c608b2d857fdd8e90214186704c09360358bc12e7318a3b512b52a016aee129e8b43a0442352657c556fdef93a89464db12340df0233cf698eae484d5a79ab0bd4ee075f94efdeddac08ecfcfe70a9804825f630a4264d0b2d9c9a1411fab6475e14da2e313f5eb63822124e4f2309fb01ee50aedbacdb3f55d4fa7be058c6a151b697393c09543715cdbe749c3a465cfff3f2be1a515cdff45fb47107cddf75f33ecf8ccc0b61c63498d97812914046356591b61241db8fd237f7b93b429d225b9006a54ee65520e04e2129d36a5828061808211420053c7810006a15d1c9e96cb7395b484582911c638f843a8c30cc19b362cde31eb24d63ac7fcce87ead9037fd5b295599c1708427dd22657035edaa3ffd8c7d5610510467903d41e7fc9e5707d2929704047d4044e32cda3389fced108e3688dc9aaa7d2271cfc70e4e575d1dbe52a0f9158a170a50eccce4e851ce126d55e15d1424d17b9e07fe81978c929bfb0982350fe4fa1d0de49a5ae728496ecdf033faea93e328ba8de4c6db834c438190d131bb5f9c740eac20b58fd10a066cd0d88471c0f999752746214f7e2a0b546fd821afedfe91eb0d646b0a5e0bbc06d4bb77685a8cec081c711b98bcaa82adbbe9a23446fe107d8a3c5078e2958452b39a22b868ca51f96385e8640b94eba0b46bb38266b2f91964ac017eea0a135aa2d46b78bb9d56858eca2b65a6d85357667503b747dcfe9b3a7b40f7f58c42b5e35e96e25f4ede2501a4beb0a2e8a4420990673891d19ae0be4017ad7efa3809e7e3ebc29c8ef6251e48112bf2b579bea09030d98e70133ee1db4529e9752018fe803816bf68d2193cc7dbbf664715306420530fb60a11903c8ab3278c4eedeaa3a915371a16cb2574b1b3e3582501f65e2cfa01ee2ff86921906da6d8fe6f98bd7c0c7fba1cdaeadbae3758ed1ef9b7f742f071ba5b4aeefa2c06549d049d69650e1769338914c02a4e2d03f4438b0a926039df7376b89d54992aafe9a25bd6c20cd2e705a523a72bb52b24c596a3e8da5b4fddab944b100217d2cf2a3c9bbffb87f85f2862012913a7bc7f0b77dcab0aa41973cbc11943785e7b9b8dc3a8c44407acd1839fd91e30a6f1a94563c1288c34f5b8f1d1eef32f33fab4d6207d7806080667285a8c3f0741e2ee285f6fbefb94b03fb8c5b95acf2a4fac3765a84ff068271194ba73c0a75c0997f341c7412be08f2ad20064088b69b923c6d7a4b1adf619333ae34b6130bf03cb43dfb8072ff2468bc8cb6f41e501e7e5e89e0be00a960f07127193a16332435b24fdaf7d71f5fa2a1ff1de289d00b028a3e54a88430bab812e827a1d3ce05bf5a56617e376efc98bf6e2f22054b7f400f5e8e7c935125cca859f1b2ddf662162f78286a3933c4c40c0096e809671038e1f0df7e501ae4a933a4f4091c937f8b726de8c01fc456dc28b3143ec16e6b1eb4b3709ac3a68742dc0ae015916b50f38d84d775fb8bf8b8245fc2d159df083c925ddf2cebeb3baeef9b3256952fbd35d3ea4ebc53943235cbb48d15b2ad0ea4e09a4b59cfc7dffc4680dbdb4a9eed8d96d353861c6e99d7a5e2fffb31bfe3fbda58cb468f9274e28cc309d0342ed83eb4d861cdf24cfe27e8bbe76a1fd3c411298a2741e6193ca2ed367616d50f0a8039fce4e05ede95bb2293996bb4f68c6e79c49c0205aaae9b196d804d1b53bbea3ae55cbbf4b4c14ae03fc682a6812ee251b1144e1ae9595ee5209500b9d189d89d05412ee8a1ece1e66c68ab280ca3361e4b4056f914b49667c7cf31b0c0432ed61aa9ac69fe0d2b0a57262ca4994db9556f7ecc1c4697f7c34861104b54449aa9c076d068801f6edce3324fd60931196bf263202bb4b1d22a90dc0af071d9a1afab1f669da458234e9159d06583d2156a06b4f68ef3543172d03510ca8a808d97add7ca54909111a9b9edbc2994e58031f75f0f6a80b6075a64bdcb8e6b0a8e8c130a7ef457c892cfc132986eab157e737b6bfc2b11daa53fb59af12e136f913ccf14ebee3497f531f1e51be90bd7c138a964a6b5bc039d11779a0649e8382dbd85dc57ac9c92bc49a57a63ca9970f6d36f2b86898dcf83e1544fd78d92c9b60ff1b5a6ddfb70269dc14ddc7e3a142d0601a8640b0678d6874aff7749ae05eeeb3ab0e6323c04e50fe92e1bab6837e6aabc173b48ad34d57408958d2fadb9ca097c3eca45be97a9194214573683dbd5a222e5c22cb64b3609090784df1efdc2a849016e9a3261cb1995edd47549eb06aa03802c0e49bf6d8ded9bb3fd854ee95f7f6a0c5adbe6c78012ddbccc30a1b9fb0ba47129d7b5ef90d4c76a59c237ee279b8aeb7b1b1f3c30c2d31c43761de9518a7855faaff2bd1a0295e010f681b4f7477af008221ee53642d6559c617a96740ebd96a686c686bee17202a98fdf8e7f753ec33fe095bd14a5d71c795bf08a7efd5c96f4133d92ba6a7f4a61c6a4167fe885ec8ca74021e16ab0735e5c109da76b86f68f9afb73d5f9dd8110893d970ef34f19da00b3ab4d76080cc97e6dd968df8aeb45bcabfdb41fa210c4b7c62407b7085c0475ed70e6d72c2ec69095c867e98c78adf1266a4648a266a88df0985fb117aacc0ae8140464e22e0bf630afc44479b7551dfff2825b7b025bed1004a895ef259719b412ffa35a966b4f027b56820a9f1d62f508b04f736044522e82e52d1e84180a84b45e0ccfc48af014e69b2a4e9d67e63e5861c92337d780eda4d10e3d2ffce0c90930b1042ca6028493e449c88d817bbaebe34cc38677ad513e7b398d240bda68e229e6e3f9749d41a4e173b1fcd566ca7ae7678d371dfb79bda490edec05b1044fd63629d14106c60db29270d7c32fa371ee2a06dd0246801fa4b491d30cec587a8073bd578b02853855f4fbd7be332c62502b0665e2515e506f594a3172a4e8b61f72d387b351e3690b3be1f784a63925c9ce634da14813f124c7dd4723fb51cb73d9cf5a644f43807baccb4ddcff602fc651c3d6cfe43b92556abcdeffad1d47525ec178996bf3ca5d77143fc5cc0b425e4f73889f4e7689b81b6d36e2c848bb0c5101e4483ee3607af3fa3887f1c41c216c6ba6a28a15e1cbc438a3045848a82cf26dc38867d46b0bd734a4e520184839683de10c347bb80812879dfea92f38c3cefcf9a8684cbaaf1eaeb9389e4f8fe66ab2b877c5214790b90dfcec3a288b597135d3a8042fc030c55ff535a05f599a3cc31f3db8b033b04c2dd9938c41eea20f7f51c70d8d75dd105965620667cc18c27f5228285b2e66745293c36c6d73d1b74021dcda20bd962fa3b8034d44f595c49b738de29db47bd77bf90c5ba2af9e56fc5b77cf649117eaed59b1d7e51e3d424a36c524438ab50712d92d74e4de926a29e290f876143dc19a8fad9c4829062a72844e047875f064a506def5d1f4f37ed14128dd254c1de2f83eb70b83e8111908256dc98a48397d2a7fbd96209c26eb3c34ad75125a4b4b9ac10fbbac2f00dc3b0bda17b32598f1873450523a25636bedb6c65861afc9087e847ff486fe6e41178cac4eb638d0a293c9f3ff3f244c474e70d2d5e529d2e8174182f6914993a9c4531ad19d86b9f40e7d3eee94973358a896fd71b99985ced706565f8756a778110ce5cc40ea658a6472091a7ae24eb1f2e0d6936f1567813f086ef73e7c888d1ca14b78d6a336b22c472d4fbd55d6cbb423647c3d6b06cd97a4532b461f5990e5699db1fd3d21d49f52c8e73d1da45a128ac1396ba5cea53cf024c63073453dcb8e3a400838d7a3525d8afeb80fd29c299164e14f60fe24ed8c3170f47b60754bdb4b5b36a9a6b1540ca016c91b6696cff2911f5e4031188d1851de34da46082337eb63154a8b55f518d063659b63f28998e719bc553e51e0ac7ab4d5a7251e572c69d2b94ad277d5ef541d0d14fca6d75bbfefb7e553d5474e7bc083bbae65aef7dd4633ed604ee2458d481826184f135c3564e4263993d1c4da783b29ec74b71f69631706251c2209cd69df87c79c1bc2f4ba00037a8a2f4551e9a4385d8daae9f994530e3ff469827a13264d8e6133a5c046a356e7fb37c1e6b811d4dd58c84bd46ff41dceab2ba9df9c0461414bfcea6e897b175a04dbbbf3914fa3afa1032442d428fdecc4afa4987422627ad9887dd94d1f99d5f0c1ca57b458b001c0203b872250d4ffb10eb6862b615ea9caac9b958c4d33def1464dd5bb49f8859e043d835ecc06ef793d023f6a296575a1de9d21995758e1fd00ae59e2d7cd6451002da9fd7ce232ef933efa5cf2262ed1e416ca0acd42fdc2441d6bff5d5d1a64ae7b15c2dc7d7a9f7c5d62e2e3e37fee803769aef154d5a34ce4d40d0462083d1b8a288f808fd4f627c6859a513e8bafa07cf1b7026642c7290617d8a21b8346221956af5cc7b950e6fe9d1bf0a0e44f39665ff71975a5fba53f18c564872bbfd724d2f8236b1f4dc64f196978192dfa8dc6154d4cd4fd7bd626de4bd7dbc8d98fb70dfab59bf5c419db2c03ecc15133c36428fd9cc699b6d168adafd51891cb92977150dab0b9667a297d5d36db02334dc3a7d46766195927965b9e4af9664e4327cf5e1e245b282491daf5a539542a6a2e9508149a624fd7184f2fd1521686d93835fc2670b6fc8645aea33ee6f15eee25f52ca1701545b692c4eae8f6d7ed98fb149c6263d4a0d83c662f8e5e0ae20d36c081beb206f703e008e7a945a4bd8d001573d772df078892e2271b789de2949d9eac3536a1fee68ce7d97c010ed13fa54df5338cd3d9a03b71a7e84b57b4acd473995e2c0b67eaf807c957ae5c62ae81eae0409228fcf6d8925f57fa2dd35dbb4aca3b5d305eb366427c410378bf8c87b0312e3077615212185abdd66e34ecd7ab924c5b89cf497b24e21ff1e57ddd2f7506196079ee70184459f61b9fade456d4183b9f9491c6c972435d4a4e130f74ec8fed86f5b662d5ed73c55642379e06079f1d5119081bbfe674eed7d29224600dfcc3d982dde1f419918b32d474597d835fabc84d57688c7c65fd834eee3ac258977e88ed6b3ede4490352ee5ccff3d3b2a269420df0dee29d35f5cf307de8de0672fd4d1b12dc37f1edaf0e12e06f7762a3c99fbad535aea432f1c86949b853d0b16667e67044f5a13cec72feecd0d12f9706413db3f59d7eb35417add63346685c09d5e7cddcf8e4bc475f76e58371a2c6126268cd785d02c80aece3ae09169f088c9d65cf07c3773b2233c423862e8a7f4139c5cc4967075989f0533ebb3aecd66c681a1a66c9ee7fc81ad80bc4cc68705e5bca01a75ed931a5b5f1ad887355fa6935a70a96c268f671653709a2d582b18fb89a6377ebe3ceaba210b7c698f6fe95b03754c00c8c87526ce35ba681b232ead4b93b2624274d26cca3ee035122d8106ea6d0508dbeee96224db9817af8d2c4d7bd5e2333a57a9211dc471e4609234d9dd0d0b3b373e533884c90ed911946119b1f3e60fa3ed3655c02fbbe89ba630ea9272aae546f61c2759d412cce3019757ca9edb6b34c951f49303c12c1faa157f66253ac2333af8b278e2325710123bee7cf41cfb39c101b545044ae89a7f891f7f7a64ffe34fac5a4d6f14d4790ac1675bc321a7f73d895cb68d7717a30cd1bb0cf1d44c119ce1d07cb811882aed50337509a734c9e07a32baba76b7c95687dfb09c447d24665bf6332c984d488dd82c121c6d09db413d6b7606982a804a3c79fc5669056ceda68c3d570b65977da7df0776f8ee2effa561b9bb13170f541bf24a50fce723492cebef42165829f26e3d3e367904a407c086f0a8c7361db0bf7a60c827f82d6bf32956c908d18b9b2afc5c4b966bab682b7c0d7f2090cb3567c8284fe38fe776d668ed0d0c6dbcf6c8baef0e4592f9770595d7abfa44bbc8f7846d2324fa64d2bf2c0999a7c1a35d34cf1ad5171cf534483b0c1bfd7224c67e530bfa20caceb4fdb2c24ba222fd445a7aaf1f3405a1fb5f12b76d24f01fe76d1e155eb6d8e709e4ec2d46864753084ea05d548d268d95ab9881d8aa11a09fd7389c37f6ff438ee70b70cdbb9c923ba3f7c84e0a2590c13ee95a33aa1ede1fac045f0d98d3cf0f0a626fafe1c4539b6685050bc7a2b31b6c3141b473f6d2b4bc27fa8645323d6a26c7a1fc268e463c0fa76cfb629c4d576f606ae2abaab38d19642a20ec5c2060b17b853f2d99f36944a4fadce6c72e43b995adf601f6843815b476e8aad2bc795bb7adad125eb855cfbc1fc01a83ecf5dbd88eb2ea7c2e5657022947044285e28922d49207339a9e5f94020dde00822728a59edcc90d2a943123a0e10256c610511f6977bbb29058721d620a20d90dae13187e556314f0cd76435fcad46a6cc0d2264da6d033cf16084f8e3632ea66ce5e1d398009a5a4aea90557bb6c3892184a2eba3dedc918b55c2c289c4f481a033e3d59c4c659c5ca846960fe45cc0f76f4015f381f2c73640878acd87808fa40dbaf6042aad3ca6f5ef3cf174463693fa997a3892ee1c113614804ad7ffda3c9f02ed15de9cd9a4d6ff2774db302f97b8b24552fdcbabe69562e08f5574384897db8c2c38c4b5e8c4b54900a7f8347bba32201407593d7fa2032ef001776b53266aa4847c30685e568e11ce9e40a25b20536b63476a5362ec9ece601db3bed27f81230389ffc625838553c66242b4b2d51d3e16689daa6a7857fc4d166700dfc76156833a7b4f364c0b2bc7604b0bc421af0cc7f3d86167ca22a9dcc8cd060cbd7784de1293e721261c07e4a5d8a13af66806755abd3e916b0d53ce232fd652aa0827d2293684f643c9d14747134e92070600eb7ca67dc5515b889c3dcc96977fef192fc4785c70cd922de549c11213e1895e61516fe85a7a4e081f7d7d74742baaf8a07a9d8779f6230448d204cb1fa40938eb028ffcd813574a8e4be80588ab26546fbf8b4ba97fb3aa0a015047c9efdae9dd00b3aa100fbe6aca907c2ed926019b64976ebe3dc5bad67bfe518e365e670d62e4501c9b9cf569d74ddd2ac9e8d3e11e8b709de11cf63fb087a4107cb1d95fb37e92ce0dc90c496fa3069d957a68244b1f6a95ad9b0716b82f99db70bfa07d6e1e30e3096bbbddd2a0dd22495ae0f22e9ee69e304cca3a3759af459cc5ce25ee2af8942f5c5078521fc919884aad45e8a55a7d82b1f46240cc3da2ea98f112432f7a2183eef68401bf18265faa8f8e31f7ea3a90726a18c268717e8f28d5d2c9943fa55bb11b70c1e39c49ba6c4657173a02821b27cdd5b80d297b00063b5bef562294acae755a66eb2e73624570183793d89f67850c5e48ecde6eab44c0986942d93136028457b2a842eb678d8906e91f1c86a3a7da1b8dd188e06e9b92116885942fd4422ed577182730a336b62f93fedca77db7bf987ddbeac8a235bd0c67ea682414051a5c79226230169f67cdd5670b39e620b8a708506fddadfa7a949e4cc967cc66f9725df7dc9c51e99a95821c08b6d41bf8d3b346ea1f5a6bf1a4e3ef88769998e4856f857f7249b41f98d21892d45f62fa2050b49a2e32bec85b469871e588f1803cd7165cc4984897931f798f005ed19dd3627fe87ac34f3eaa63361f225738cb78dd7dfe0c8ac6fcdca42b11cffe84e9b87426a4778e03d97ff6e435ead8350f9422dc44aff003ece17ee44501165ab0782bb1d8af4cdcd768cdbce63a6608bd4dfe8c578e9df76fc06c012e08529d8ca0d1691627b05518a46a0b8492b118bf89a133f1b8be8328e70fdf68af3a6be41f10d900fed1285935350e99cabf3cae89410dea32659a231be13ef672e93ae029babfe99d32ec467e4d612f7097a48c680dee516683cfbb74c7527af8f4868dfeca60d06e464941d645567f44e2ea0ba0baf880ca87f5788e9ccf4af82395aef1f0aa9477358041e03693c03165567d248b1aa25ee0a24af7fd86ffa14837c12d02f422f12e8883783458848260ee1a294b53407b1b79d6507bf27c998135d18e01bfef085d748d1e87fa52c63335f94a641c998a6f1c0f6080925caba7f6bb6e17e5db94e0039764df4c3d90fa3171559b7280d205e2254ed99a4ccbf5bb4993120f084574303145cc94c29e93329992dc35c4352879b426b8000b410429020175c6ba2e1c31ef8aae3318dd550161417ecd03e11825ac079868b44c95521d74c8cffdea9b9710e316580dcbb5ce03ed0c0662a2268a0f387bf0a2c955b08e0dc887ad0ff595f3cc33326abea2e0d024607b2b8484bb6e7e2da210a7dc9d00226e8c2c5508104f29274fd35d7a339a9750127a45dc0142c5d807b7ae7791a73a6359152622876da223db735b02aa2ef9f86d3bd6e57d9a87d20fecd2654f1d8d707187840bb4299f0b51b77b39e02ce9c6d6ca8d8ff7157d094be49812879f45a985cb554b78d6afd65cc78d9ad330437642383acfceaa3781a260d935a5ef8b07725241685ac161f756eb7804d0b42969626d644f986fef073e86e446da5852664f7d0ea5974da39637f1bf303207868eaa528f8cb03d42d69e0532ea358780d60c2512425f14e511b360b7da4d2b61c465e944e660bdfb38449c628a2a0df2be5ecb7fcc27885899a4be97e96c1757a2cc8fd888d270cf19401abd923d5ca13dc011b760ce3a0091ef5ec08127c7ff9a394ee8aa07e1784e3d4698f1994e4b0b22da9b0944a2c71dca83dab36beb6ff1ff7a1ba7b3cc63ed2003462dd7006d58d698f2846756597f74535578c9538b20ac704ff8b22cf5cd9d56eff431ed54d4d61cf20f7c84d04c74652aefa91d97dbbe44efb754d809fc12a982a002935195f55865ebef819a2c40077c674f018c6c5cbd46c53305474448aa991a7ccf388e49928ab17792f9feed1609caf3b60023528abe15c15902b73c5a18e6d5bc6a61f7412da48a84b69a49e1ce46460c2f60cb86dbd0d62fe31b80780a0c9f1a94ff651e004fb655928cd0af8ee7c916c01ea6d55e21d7a0c62bef500baef17f18bce9136b60c32d2f2e4574ef50b8565b36abe82b19ab653e59c3e75a0df9b2588eb5b8e6a475ff9f055c2782139b446bfbe152112465ed7a6b2aee78e584cd28cafe32a7ecd4c367c3e59a2f6789ab10ac805a5799777e4b5f2a40d11ae58a2aa4eb9c0ce3a6207029b1a8b6906302d1e79df85214ae93d222ae309736249aa33fdc8b4987043dfc2b9b5295e49857de720e945ecdf2c9c64c7f53bc06b494430e85d3e2daa8c0118098b013dc3b48dd27bae473d96c75a8d59c1d15696db292196ed09475666e6f8884280feebbe3114ad2e2514b13b8deabad471ad58ede7ec6b92b1ab5feaa89028d2338d6cef0d402829600bcc89d6cdaa79bc0aa8d72976e44b687ad9ccd00d473cb45a25a277fda4204c40e42c50e1d5440d6d70c3ee0c4575644c9a8ae8092e4e654af9ef94a5e23825188f069673ebd9e496a163a907e4ce30e268fde464e0cfc72f2c7cee8caba4c124bf372edee59f3ba9bb9476f5cde3e92bd20e7a5d147b187bc7d7b08a04dbac8d16c1788e604b85df1750cefcbe9e53ee7926eacc22ab647dfdfd0cabb6a1825796edf7f2da27363bb9dd948e869879c7f451089ff5068bbf7e5bec2b2f52385dd6b81c97d612ccbd2ab5a1310712b37ac71a8c12e715b5e92039bef0dd1e2eae44950808d2e19d23f88cb41bd80ae3bfc39943cd4385f87385b9ab349fba7acccf7b22dcc063450eedcf280b8e9b8df0a683d6eb14a88ed40423f5b6dcfc22461ae9485fdf5587f60170dad5eb933fad60cc4b1777d5e4d6223c97ba33748aa3237076fb3c43888020ed9ea34ba48dadb9f45b9746bcde0c6f8c5597893cb211a4dc198105f76da8ad6349806e31a9287b6907fd04df062b844cf3ae62e16a0ff3a68ea1e4a893f40f064ea479effb73b46297a08e2bc4cfc22c01d607d36f9467fef5e294405528b779bccb9968d69b8478abddba3fa5c46269c249175b6a517822a2b48f5eb3f641c4fa3d784c2fee6803b99a6c57429de6b4796634c097b774df911bf0d4d71ca3730047201505d29b5a7f0afb245814cfff42d5d7e334563167c8e91fcde524c7bff822a163b6bad4f29abc01b991ec838ea1285904fb216fd8263f5e3abfc4b9a34eb48e8a87368b2bdc059ea18901ff9b36073d313f448c23bfa2ed6b8c607a7600f29bd4658f4eccf863322b77142604a4bf635cdee117fe06db239e4217b6dd2febd88afb6681273da4ff8005bd01df30de6434c4d22d6e8760aaf8802b0be296b448f12e02ba8d396d495de4d95bc27c39c937ca494a757f4881ffd8bba8d3bb90fcfa28b791084489895b67b3acd7212a8ecbd70905d3fc01087f0bcc5401b681b6d7f1844f81cbbeeebd8993c416060f86ace8f927b397c4219614ae5850616819a947b8f1dd92b47aaa605f174d2085f3454f7cc0c66b9bea788f1c43281af7c287a60c6bd2f5a97a96467e221632bd0439b91b518425ab875147c441c37ba98e1c0b88f4fc9fdbb97d04ab27407df5a8cc019e89d551b4f4512fcbf5bb94a405dffd74b5a57d4dcea96ab9c05f6b2a81a34fcfa1306145bd7971e6859e22b70fed73add1c678f766a5b6bb81caba9a9895d1f7429263ca8951b297933c1772b4fe80e31d2b6c202e78eb961ff1e855d4571d6c4398fad65e35575cd445f25415501bfd3b21d74bb4d2320657a85b812223fef1bb72274f6a6ad9303b33f6df919a4f90900cbdcc7309df1ccd9f798d226b61d309de742e98f0d3f9a69d7b9ece85ed087b2e48c716ef3687ab7fa0bd2e5bd0ef3199674646a98de0d8f97a7140b96991769c78fa683c7e375fa4f3d9f18671bc6da2c4a0ac69ba6828cd6daaa6a7db621efff5b8ab39abef9042f097e31b567cc0daa80045ab94a771d418dda245bc5f394c72dc2d70e00fffd77e836275df309217a765934fb382a791162c8506f029c3b913268797901c04cf8b2857e17c74bc238162980e44def241fd3bec8da23a54a6b24e94c1103eb8127735a12d4c34f44a7165cfb56d88c6f87430531fe6b280178d231658a1445429c60235ccf19a193f219f9ed3b5651621d44de046dff2dd276fca9df998ec6573c6d4d18c80eb2bbdca582f67306436a111988bbe60746a17e3bb1412e6bdf0e1679495315c9dc5477b9332951971770969149949c9996415f7e46b8e841d0eb8d1fb909574b6cc066af408594eb226bca910e395c72b7af048e3473efa60648057cb4d2d644a6692eb5890f92ec9be3f24cebca5c09e6d884c4585af512ce555347b585f9b6c2045a0fc3c5437e5a2a07df62bbb70d298af58e889f512c2bcc656e63fa586eefe13a7434d8854a8c7d18206404189bd72ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
