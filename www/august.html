<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b58b9070a3f80231f2726039472d5fc0e46405b5a0d7c5974f0522037a869d237fdf5f567151cda03ada7eb3221fd652084ee115296d4e9ecba5961c8222e71d95739bf54c89431741eb79ac7f8c299012fa0037268a384a7b47ac12cbacb726ab08b3b4536a35aa47ccd9341a47cdd50ec26141efc152f0dd8a2f4aa8ca2759b572232e1ef639d2fbb5390780fefb534b841f3758f2da5bb8645f07785f50674e614add20048328ae6d11a2643a40f2591b5e6939fb0f7d2f5bebfe6ad3ce00ee5bb1da8394063b9b3b00b7a0fe3f86c7f5c616ac244593085342b091ae27a705317c1f2391dd3f2d2672aaa320540c1727645f9113c9c6a25c13266f4ae5897a26dca98b57d85674f93378ac42183d4c482e212bf2bdb97f02ab36e939296c947e9cb427dd898ef6a955eaf0345e568c34b6c287f4cddfd88aa85839f9889cef1eb01f51f79968759c93befce3d49f7af2ca160bf0e69266c81d43083d3e6bceb4a20477f7789cc2c927f43ca8d080a0fb0ee506de352e44924e761b65337ddc6debb11c5c23edf9e1e0d55c6a654d9eaf135db9c9f8e5de501fcbbe677cfe0b77616f930760b3203e36e10169bc1ca4eeb166679f7fd394f82083ee5eb29dffad3226728824fff4da04793ba89bedc93f8edb134908612e943aa5357f4db666650863f9e37189214cf924700084cc73288e0258b60b7c540a802e333d83fd40989d6f85eab0d29f175adc9e7601bee94f13cfad5464563d14671f2e7916b6517255d4541ead15f20c2ab5b24a51ea1d28685a2ac3bafd5f069a956fe8fb8c3eb6186b7360c050e97404b5bc0d0499ab2379be758102c441a60ba4df2e023145ecd407a02b0b54510219d8f186b332f2d7414a13e239434322893e6e45716f8d13026888541299e6c1edc49ad75ed0193033515426d475e76fd8f46ff87fe5f867697dca82ccd6f6d73d3411737dc04738121b5442a9b6389fc550f5ca729f3124ef5aba1466c5741ed7ac7866ea6802e379442023f4c9584cfec033b2b167457a75da98fe41587d7176f3ff0aad373a25e021976fe3261ee79ebf473729a53a41eb1657ad9c78023445c1e3f94981df91bba330224c3476152f611ef6989095ffeb9f1358fcfe8b2d2f2a6efb3ace3b04dcd41cea487c6ec1b20d997bef5d582da2c3c8f78edbd9fea01248d0b9714fa1e79841100dcb003d43da21dfb3b9d4c811723485b0f6e181d98d3fc208c5a1fc10be567c6edbbda97a7782263fc98ab7078432c172c970583f8cbadaaadb9eb70be183fbb530c4239e714668e5f281b42ced93aff8ef853114b244a933cd9e18e156ee6b8e74f9feed69e4c2e945edd9308001958c2d1f56c76918b42e56ed158118fbc3b6f0a3eaf17df01b9d3aebab91092f51d5a1604839378544d26407a72f43e8ec8a5563525cbe79011a4d31c774905203ff67198e1d6c0d9762f66544343983108b49d710802e437458e6f22685015838b0ed6b0ac7fc9e306f5a093cf94b46a8cbb01b6c13089eece9a7679c80ec17decaec99d912af42fa748c3c07b8dc5620b29cd999783ad567124b80a7561306e240145dca09a6d19377fb2eb1ae2672e5afea4bbfbad8f83a2ecb1d7b3326ac6377050a01f34d7f3463155e22724678ddb8c23c6b72ad3e75570122705acebbc7f796e9155614bf9e95f256178dfdba3eeac8310a83e1f4980d85318efb29358b7f78b316a09b1b37037788355cca335ba0ab04d952b1703a179f694555e2b68ef295ca8cd7809369ac01e87790eb4bc7e666ac6cf32e58f248e434e898b35a4ba059ef6c35efc2874c9ddd28ef231623cd5fb12530194e1c107feecaaf5ddb80ea5b038088c240cc8777f2767fdb55bc3c9846b609078d16d357bfe5bd500ff9b19756a7cd3cf249c32908b2c3e26982914703aa4be9f99336dbc31a8dc1c25f953755ddc6345df9c217d421672ebd83d245f988eb196a869154f05cf019dbc3851fafcd3ae639d961d7ebb9edbabbdab47606aa1cfdd8f89d917bac6b0b78a880cf828e888d1a08f7353311d75e4d915197aedca4a62fc68a79f7d1ba981eb7d735b251bacd46c2e519564eee9b0902a02105847467ce6471f79825612d1eedd811082c718c090245cd5701e888b0697e2dba59cec4e1e79b0101085995a63a53a07830b0569e00c496859f2484f69d1feffdcddc4bc757a8bc3ff84e24f0210aae754c33bdfa143a5e30b0abb24d8fb39633f95c801cf58294f8f7bac6e8868d26a008bc2c0ff3bfdb510f863da98d68542529ca55677463f3a6e7cbafc0ad92c1c4aebd569233670609e7b1da38a7a51af22488ffa7d07631a53fe50c6a6d0ea2f371b2fd19ce7384b3f89c993f3e0e9c12dc840fdbc4af84804027ffbaf52f860a26e09ff07d355000d2a7ff5ecc42f9ef2c37974f555b5e6d2cd13a2ed82ed8e44d31283b93bc1f8d7b424a7455d086fbece101a0c22f07d9ee2495b94962e2b004924f90d349ea7810ab612187b02d7d4d6146be1f15f0965009eace62859ee2d23ba22c688def344cf83b25ddf8a1e29ac803eaa25821ce5bff0d32f56b24e9ee4bad071ef909c3b1c15b27eeb6ec822a26708eeddcc91ada44b40e4983d2297d6bad3189de565ab21c6dc8cb46089446d07b77462365ae69a623379155ff762a18fce8458e7990e5188eb9821a3418ec72225a7ba809bf65da3dc3fe143dde3fd282676a862f68306644eb822e58d4a6393fd277931b798a593b1b0004dfccaeba6530cf8d9d100b00964f3b2d97cc7cb49235c36b2015b22fada627788db65090261aab6ad644e2243152dddd63996bac50241cac70e6eb0a9098b2c059c9abdc716c90e586355e37cebdd81fad25e824802dcc1f0e0da06688738d4a639dbe4e0015ea135b20dfff6d0fcc30c29e7f75c5456555a3d914d3610937a9d9e30e789dcf9355a52bb158d5aa95b8afd487c93feb3c6e3a95135640442ed54c0ae8cdeeaca1b5fcd5e3e29491e2d1b01de18ec03a401d26f88217df877f7f2d27b82af26eb2fd8ad0559fc5e28ed75fcfbc734f00d098416a34c628b5eef1f1980bff23cdd2e9aae8646ee5a8bee76bd2748263e14a063d12ea79144cd0847891732579854d82da710d2f0c29c482ad970b4636aecd720a18fdcbe957c7fd9ad635c58f1c12c4927675bfc331803213f74a54a8ea5ad2e26e0c65c19aa334f0a215c74d35cb048f3ec19a9076fc0861f604ec86fa155fbf44c31394e89a4cda656d7d0b1de98fdf179f59d425fc60ade9ecee358c797c5f50e9d068b7ef656a2f6995f05174704b610c305e64ea8b96fe3d53c91c970aad291769c0446fe6517d317f120adfe2782a46c95b10eee6ea71295644c6b4658c1b4c0e0c251e615a5ce178f045ad139c1fc188228d670276fc56de112b98a64d5a83cdd2a1f382eb60b168bf5fd6890532eb7984c10ab743c1de75a2782fc3450e33f81224478ef00394222dee1a523fd597058639dfefc774d0f712d5718a56932f5a5f452d9e51801a511098aab3570546b2e1f24c7ed03a950454cb79bc632f780ba5fc663cee3f6daf4e19f31e9107aba6605f680d45ee8ded8f4cb6d09c458f51ca6f4ba8166a398b34b83907042a7374b5ed5dd65ff1da3f66baf4eaeceda360c4e64fedc2577ceb9edb6b4e83bf19267ff9de8994d7f1460803d8ef0139a74de756360838c82582647e729ffd626671a5384bbaa7cb1ba0edc243452f09acba8aac402d22c0132ab1888ba221ed3a904b531d83a5c121a951cf4f228446a1d536cb1e6d9ba5223caa01a5ae0c96390a8b24b45feb6f7110394e4ecd26eb1c1c7a459ec117905b573ce32259212ab6e178fd379323df535dd557917675cc8ef89e55ea4304d2e929768ab3d1888aa8f0b9a24f7c90d10ba9fbe91f76e8e6f2584769cdd31b01c2f9e37ebbedd5d7c2621b9213ed18badc1ab83bbf04dc37c1de07c463be9eb1c2008a9071876d46d2a77aa4dc96b201f496ddd7cb8825ccd43c4a856c32a560fa5684252e8b6519e51f1e9ec7dde396bdb3d684f1f232a7093545d68fa22e23301ee6e51322ec4da1d4621adfd0f700cce6a3ebab52bb2db98258542eb4bccbddd1a3679015d97014bab7dc16429db3fa6f07224d303130a6036d298368a6e889609d8dc4d42586fe6abc8b68eec39317440f577847fe73793ad02efc2ca4d591cf1e90173654d6f1536ace02f15abdfe9dd49f6c8efe742e71f71d9c93349376af2be46e8490fd3fb0464a1267ee993b29f5426679bc6bc4e111f33e0409770a535214906e2b8ad0e08f2ecf81b1583feedff97d379abdac28ad0570ab849403fee77d332aef20985a985352c13b728699f8d0a706bb979278590067f55ee4408644c7280a9acf4802c9382afc159e87edf7eb4b73d38aa4a7faab0873d719d1fa0882a2ea80f5259587e9ebdfc1f7c1e4f2ff318c1157db34c4a908ecbaabb0c1266dbbe9c9f307c6ccea87c1cc9bed7d9daaf4f90d645855a63fc79a1c854ae46f627436011fd32b4ef26dfa643e5fe06fba0a5d06bee540315a69ffd3e34b2b70ceb8cef09aef073d11262aef598622bfd474d30dee0d45f742f8daef04c40b1cddaf68be9e6d56dff8d6d30624a2d5f2d97e71c37b755491d5f71050d1c49627085b15cd2ac88346c798b53b3920ee6ab0b900b3669ec08899b48d87bc64e5d173a3937739402ddb9a23d103a1f843cceda9b0c063f68b50c10944bdd4dcc5b34f9a787ff9b5ecaa8d560d28e79ef5f75b9c6fe38be99e60572cb2bc89f563cdcf0a231ae704bbd5357ac984530afa04bd70bb3adfa6b17699b2a7bd86d2d91a932b383fa4198816cde592c1b6c60bc7c0f50547ee33d0e24439583f8782981c320c0a6d75fd9419022ee39ac671f588cd57077d523b951f78da5fd638a2460ab31afedd11f9a97e0bab7e36e9eb73582be96b1dc2935d86bcd861847361f299c89c15d568b74b48b91721810a81ce4194e6d5ef1c711abb123fd62b7367a48c53f3c089c7f51d31296023a64d80e8d0bd20a7ad097f9e0aace83515bad32955b07129dcf4a416eaf6da9f266da360c134e4b896edf2c9959207087817c6646b107e7a2714432f386d12c6a505c76c047a7c9ada44e5fe8bc23d99fb1ee42dc922137d73e29123a0b04fed4d4da40e97cd3ac262125fb27894bad83608f60decfc48115c17433989461feddf634e30882b79b77f4141be994fce6b375e2ada4a6669c2815787f2f2e119cbaa7bbb034e92b5fb12b833307bec4a1ddaa3aa21e73c6a82dadd3bdad8f0c712ef1e5e6b7ba701ad8a757c61d6ffb72a06d6fe7f5526029074470d684f50c4c2b11feee489386319475eacb31a930fd9c757dc999e1b55b0f8f682973fd2cde6f16d01bbd4cc5b652bdd305a07b312b7228dc23c31cacc05a040d271112943b3109818b18534b18a0798a2b93a2d0a7185ced803c28c93bb06becb98cde05fa127b5f9d4905f7ade9a10235edfd03ee554a640c7bb4b95d5d91fabd63b0aadcef6c9b60336247727c4c5cc49b3c7f48031b5b0bebfe84a079a6f03937f3895f4145bb4df50618af2c2174e2f6ced18ba756491659888532b393b00d0069e3e39146157c2657991398babe92f3a79b2dfcf6b95ba5c59f7b97181f314a9feb10b15d123e3f85171117382ac7cd8960a30413de2dccf6952e63a3a37ba60fccea3fc134d23777cbbe704c6355a93dc6d5768935837d5e4c8fc54f71d3b42d52193e0e600bb3fd248e85ceb0059af325d8d1a9b16936754fffea78777bfeebf6ba3d06b669f130e5ad6926ddc0e1f2cc9c4df2b97bbb040ffd8267f08f6b255c50ed3fa2b745109254d995679f668eb580d125aadbb69807889ce417bd3f8c7afaab073dc1f645fa1461f26f2c5b14920121797371d7dcdc9977c100cf5aeaa11e7ed2d2415c4691366b2730de1fd48a3ee92e86b424a2bb6fbdc501978ea9bc1fdad1da94f5bec67e7fd346bb71914b9beffaa898f823a89c9310dcc0bd296cace1bb094d366a602148db34202b1fb29c3a4a44ee5872fc84c1bde4d304bc23147c41f21347aea4f91e60acf6abdba1ae552f7c0c6770ab2b5254dac0dbf2a3044bfc1a9ec9a9f2ceed19d7f17cf62762d9128042e46a2c3446d0eb173054518d0ec18382b192c6a04ed23c2be794fcc2d3277bff443fa42f0ef0e1dffb2c7a45fe727a03fc40058102b24cc12844d40ecb34ef3915c632c9935515d6aa0cb841c919616c354a45a8ff5b4883518b0cfd427c307a6619c628c79d4d945eeb60dbbf4f5044ce33e740d943070393ec4d06aa6427428ee8d20cd4f9aa0fde476ffb013a0e07ddc796f555e7040b3a858714ae228e8c51411d2e4f7b1f6c607ad0ea9333ddac00680e22d6639271fbe563f92e9f449202b0c52369ff631745b6f57c7a44da1ba0c4ea6f2e7d6489d881ee9e3f42874b66d85f625d58e123cf7cc34b6c8419a7519440a0756646e8b6a66c53ed2a803cedac44ad090db76b01b9cbd50d5d5eb3727b3e5e429cf915056eb316ca0ef3c395009f56e89ef5341cff4142ae8896de40ab405d6ed6ae1f6673ea973a3c9b1f57916dfd78ab34b0173480be32dce713d2e93db8ad3c0f90f4e0361f7eea1ed60b8a89a1ff4be9ef4618c8358d6a1b6a22f38921b6a8add2589abadac5fae195ad15dd15a36e7bc6e95b04bb34bcc4abbe226fdb085513312f7fc15d8d4987afc1180c414e788ef805d76917e7eb175a39cbe6f20c3c244f89045fbc46c06bb00f31292f843cdf4452be466d25ab405eec39851763778d99fdd9cb7f8d94aecb3415ccfa3db70d22f4362d1d03527a2f4f1b410db14e033ad915d4f8e1629fbdee0173d0378cca4e3e79ed79c3e9c01135398db21fa173305c9206055a5e767eb41ba9028581fee57a417207c9fa4d595bd6d1954b565c58e6a033a71f99e86ccc4e71a011f74e414c47dda02428d5cc45111bbcfd9d153349909e6b69bd0259007527f5d7abacd4af124bea259600f030d752eb9436fb4f1a09b213f23a1f657978e8ffbd4c37fdcf5c8e1018e9357d65f425f227ff8db096f3380d72314f615e9d47ef25e6530e2b7f3ce7354216d9a4c82591a0aa5c7670e999c921acd3e75390b30eac230bacbb8acc4f329cf213db51003e4b140b723369d601e91c830c930aabdcffdbf3dffac88b8fb6dc660ad894bb72513a182aaadff16623d62fc2d97ed603c15e7c7b1c0d9a050965d16ca66165909d0fd4e82fa29ee61fe2d0bd618ad50a19cf388aa7d3688cecd070f21c55fedf44c33da5fe40123b9ef6fdc5fd956e038ef954dd451bcfa40de68326707c0e10ff35d0a76b13d5ba69b0d1183d8f35558dad3673093e14cb0dd1d35473898cf34f9824df4ab69b559f10ab7064e87f9923f966f3dfeced0b22a7dbaae5eaf4ce184223c066162da4e890cec3ff26e41932569e77fc7d1212933e653d49b0d8585e873b55ebc5ea39605ef720a50a52e963fd6d8397f9d902e4c5339be3458fd4ba1e1b5778635fed04c480f879b99ea7c535661e821642d9dcd31d425f12b06b04a170a3bf2f302c22d8bc677a0cc0ef45279a94638a50ec01cce419d6aa880d6983bd203d72a12c82132caccdb82344106db07b0149dec3c7c51b5c97c9399a8034d081b92fd676574876644b00ebaabecd71cce4100ff340f7c17bd13edcfa520d083ae896c2b47730c86cd26b413c791df2b7a80b99d00b70a1143bbec3201eb5175b2f2ac8d07eae909be324c01c9a5da23d8f9c455f97ae1146a532de6441947d9db92379ddcb015dd3d0253281c2b1055f440dded2008d3baae3ad443d90b3db33e648d53c5f6d1aecbb036fb752f6e6baedb9946d75a9d5cbc143362e4979f86b2fb841dafc4e4d2bcbfa853d4a87118e6df9dc0353e1db2f396b85e8581cdbb2572aba254282135a787239b59e544fb63b5884cd3287baeddeb345d82bc94141e0033b34591841b31e07fd2c90a6d17193a3d0410cdebaaa9ebc54cdcd131b0b66b463b05694065df872f123e8196f0d44548c4e1742a0f5226a804a30b8fd8510ddff50c8efd0396a8f2367bb0551ad87b6f72a7c82573170499f812140bcef251705a13f61b2e68ccfc0983c5369c68f4b74bdfa0dc26480a06ee691a0b138d386247c4825adb2093b5759c7b7b0fdb455e98341775f3225dbb4948976dffd24ffda77b54ca07543724fdd8dd760f67141c605538cf352e89746dc236dfc82705ce8b62f4aca3eaf68c9003a9dfe101ab8605d5432afd6530d083b929946dbc150198b0ab595391fffb8759c8482a00e7953e86274c93ec3f0e9e3ff9b786302eae88ba3b5857efd76c9685529d5d5f3586fa1eacb7f1efbd551e106a61ecad7b424e728196260fe25f421d989388000f50949107b669f2e41d2402fedc44c93582f94adb42520f4e2c3586884a505f3bd7e101de6218706a0ec6ce98fad47b0a878b8f753c76188207ed6eef88cf0136ebae8e559662d99ef89a7bcee28b06832769187f893446e8d903633ebaffb7d5a4e6e737a6ea74f5f64fa2761857fd35a515b0bcdcabe6fc335dce808e3829d2d187cafc5d024abbe3471235dc0466945e687159d198d2b2591e953d882213e0c674ab71a0792cc0ea203c6491b64984c31003c6f2e27dc685d1b61999c03c826e6a8d4f003fd1b1fe411b2d2f427c17b8974f11b28bba38e23b47a40e401962e82af03e74b0b7ef5da5985809ee12b47c4fe62b7bd7808ad350eaebc91a6c348fd008bb6a01258daaf613987620de0b4020a7f3dca7fc146ded858a1eadcc8465f837f7592dfcd60b86645e7b1b9997b0e3960c1a12b5a3ef18f1e42142614698bbf7dad5c02bc1c3ca9618c9a539d6ea17bbc1d408fe9b93a45b63d7d59eaa8dcf0e7d46f1e046650890960d13287df3b584eccb7ba07790054cc9bd57d05aa2b94eab93c0b6dd6aedd33fcb2a03410d62f22530ef123fdb2925005d705a3e8c7b701ebc14e79a07bd99498eced33d7f6d1737530a0f4842977a784fec5cc7f7b131a9527de7493469b9325c185eaccf9537f3ac458e9976f3b6eb4b5b19ae72b1b60015dd4a9dc6f045778c01ee74f745dc3059448aaa7dd866b830b7c8795f8861c81e01ddcb9eeb46831508537c5d328b5b082cd379472546095931f49a5a5a38e17c690297a6a249cfafab0fb6ab2778a07b3671c971b93a47a7e0c7202cb40c519d0437107e9a4230546ac42b66a05e7639375b5a7506aef2b355bc11b7f855c9da89bd944562e06b1ed929dc119f795a4eb7bf11635a81797ded40ac2e328bd9f8f083619bca857a8e57380a297a2918a4e4fea1c729ccdac38f89dcdfa6ea9b882d07f87cd48f7890b6c2a7370fd1e656d14d7b64e6e42d4e8cc9be3f84e3cabfa509aa99a36c5fcc07c22ee7088bb535b84c2f5596fb7bc418c1cd6f55d81f9a73c93ab1c5b0c4b258a0f2d394d40868dad2c418566d655331f763979bd8cafb732debed14c8b60f211b9595e42bc3817745caa8ab64f282adc9a1cf047c0ade7c7c646d1d8eea28f4fab1fc7173218cf51dc0f48195e7feb3cf3e9cc99545e02636832a460593df52e48db25666cbbdcdd5462dec8566492d2b0189116215e4f05f7f16c525397b1ca5cfb9a803d4978eadb7e633a06af31ba8a12cc229bedc3d93fc5fa7a97d32d50cf4153daf1f0d0c4a5e955d4af9ca146352631de94c2e81644e66ef10f8ab32de122fda6e04f7589158c7855e455130955868e2dc5ebcc431881f8315532859ba721dd26af55cab344f2e726ce42b0aa5d1030a396eeb23c81b17e4465fa0c5177ea4f161090037e70c1dddb9eae857e679765367e3307f9b788a25214ab9ff5c4c9cd9f07e53f305c871c14daa7e4bf5b4e4cc5ce50defbcbfbd7dd956e399b59cdef6b5cd94d80a38078015bd5e12bfcef0e6cdf94f6c5d4a0f7e6e30ca389311cc2e3e3a40e4f9a4edecf84215b57fa3fe4f2cbdbdf9176b6306e88f571eda99fd640cf6282aa759d9df040dcf1e8eec344dd814791348216bea4e2fd73734e9045f561b94c9a93aa716af3561b1786b2a54d94ee0820c650b535e85663edb68f23b1a22060a632c1d56259261f7e48527f9e78da90721d7d1bb45324f0d2b0e614bb9902fa10c7017d023b629c260851c32f548b1b79334bdfca64015f4ef48be9b519053fc8d09c1d271e67e160ba265b297c3f6e137bdb3e4c40f06e42e7035f3b0ba7e344765dead90853cb927e22f92dcff047bea5c00cf742796f1cd26a5675134d05655f463362969d67506b707a948da32740542fa88c6316edd36b2da9761b1d53d886e1aa081cbc8f2caf85542a1ec2757885d150b4dcbd8f59aaa9096274361909155219f17a03e3a4ccac351f86d0f471bcad43a91431296f5f3a6435c1f37921760ab46790648af0dc7bdf246d43295fecf6078674771e9d9e9c0407f40dc5b60f0a790317eb76f3b9ef0d05355ba08c51f08e183a33faecffead4eabc9c36df5835298f4ab1e17fe85fede8be1d5993652ee92a5cc448cbbd768d7d669a1edf1ca5e60de618bedcc720465e6e82a4eb53a9d0c94f8a92792ae1d881a071f8cc7009a72ae72b0549e21afe484e3fb68c87932cdbbf4bd87f89f5ab75d85da52053317e3fe673065d2310b2eb387cd6c2bbe2e57229d7ee681e75885323b4eba383305817f380d59a6191bbd9d1767f8ea900df38f6a4c2c5e8864dcf0c1d107902acd59def60a73522aa5503700a6f09d662ba2a620179526bf611f071bf4c77ab9c5d19d2421f885ae72cdfe3d1087c67178f68aef66882e55eec23e6176173c2aba1eedef63128b6bb9782755ee36fa7af1039bd1297f90db2bb2535acbd86485b67820d9fca23d1cdf03ecc3a7bd749ed9ad7e71a1f8cefa2ea46c4ff673c1f9448676cb40f22262240c12fd9e8472d60338dc1a532ce6337af8c27df37c8aed59a81267f13b5b71a537ee13a86e33d30f75711fcf3f369f6f1962a76545c89803fe8928c4f551ae732a55efae55663bd6e12a13780a6e7652cfc05c32ec08124763156e11157fcd44e5ccde4bf17ace7a2a5e1cfb13832dd39e74ee7dabf290279901bf2a57b8fea17339960f21f5c4df711dcbec045271a2d92d06e2d3fbaa38f98d89b0c5c2f5de27f30e011fcdb9300de2ea94441ed21c0c9e7366ae61b2acc75ec6a34478ae9472d9eeed897ee3807aba580f94de55157792b768557016a30b69e60dc5230404f0e38a3f2d20ebc0ed261f0a1c3d2f6619abbebd3580792a88ca7d6fa99d784d96fd0db06567e5fd6d714735ce31cf04abd472bf0bb8e7abd3645b08c2c00bc216e6c05c7c0f92ddd963a7b75290a088a9aeabfbddfc604054de4147d6e983d53f3f5df2a4a8395f7e515ec0a7909f98b60371dd2ff8730dd786cf2d4b805cab37e5dcae387ef24ba48e2917956532f502e9ca0574d99d068c5c7a74c383195e5701aa36c353540fc44aa075037d826b58c2010524b68c1fe01d96366fbe0277b8092c9f4d281c27e63801dfa2636087208c8b5cafa0723dbdcefb17ae97a41b805590c11210324d8abc69155e35ffb5f090626a8ef59001af1d2bd3310d42c8c411aeb658548e20f6197b66d26ad4376bc5202216faa6fd5d64cd2cedf493283bbc15334ce754fc1f12feb140c6967fbeaa6cf1d8d74e9746dffd2bbbcb0f8ef77f03c9c2511a4d0979d8a3f22300c7186015c13cea6bf6e6a30e357b395d726b692d095a216ddd91c8a088949a35f03c186ddc503930c514848006fc26713f5069deb36200dc8ee050cfe85870fe04e8299693edd389c697838a99c9aa5267c6f6b0fd3bc9fdfa044fe0fe1355fa23d57635bb77d353c001ea49bc2fdcc216bda1cb06d8d6e74fa7f00c4e82212135367913aedc8168529447862ec240ed500c440fb593f06fa9d7f8a00826a1c346400dd5fcb64d6130e349a472509271bad0f495410f97bcb6f03d7e4d3a4ef2098b694475d451c3ee541572f72c89ba395c6acc3f652a6dd1796a885c3675b36a8a9f8dacb21b4966ecaa2a858f6f8bdde7adee0ef0791f0548f3a40497577ad6822f8b309c5e5a57fed89975582d7388fd5b216b673668f04f0aa1acc58e0fe6f0fe1faa8b25bbe133ec5da432f89dd5f8d7bee810509c3c4c953a542a800be3e1c9e3b08487c3ecd915efebc74705b18d8c49c54d875fb5f24f2b5efd6d4b3d2124398a5c443db76277bc79f35f070647c19a662434214df543ed564f95380ae38a6d7b649cfea862b5d663893f4f4e848a69125b7077d72a9a3229898a8b3a8c25bdd106b228c0da617691780b61e5b2a9109dd319fbd20964a116abbd6497989c687463f8583ae5fc5fe18242ce142ba83b8cc5ca4b63185fc0db9183771408dd0aa2387b50bd147dab4af038e13b9675fb712ff557d6ce08332f7c67700a66727ed224cd3c287f26b102ffe213b8f8f448b4402063003987a65f28c4f4d051ced7b7e4782814bed7a3f2c64c1affcfd087cec3298b28f4b9686851491d838a4e3486d44a0c4c6c6ee920832f41c924f57f9bf20b9b82ed6c98cc90d21843c1d1fe0d2559f1ce795516704432707e438a7cf0da32399ff83ef69a6c7cf7c75134d0214111dc7819354dfcdf1c1eb0f017f933ad8f8b3ac546dc1bf0194e9e81d0c69e9ddf58771e3fb36b5cdb2dddf85361e68dfee87bd997e2664ae606729fb4729f408aaf32f000db65f1680e45a3d09724209cebaa8d792048e381766bd2cc273fa5720e8357d612c1c6fa3182b1a6c70ab953412eac8f445521006d002996de643d06ae01c950d1b7f3e4b423dc2067e3fbf1e985b655bdd8d107ab8d96f67337033670619e5d914790aab526ef7075d87c158e92ade355ac5a642e64375904c509d9cee482bba6fded47c38bf887324ff19686502054c78c6927b20f432750436441e7160b94e506682f753f902710113dae5e13aff285c3c7c8f8cd3bf1992068b64fda4cda2db51d031630e1683df2aa5653ccb41e68b1e826807802a152acba211bf66df9424992e93c6ce511837bd53cbb7472649433656a6660b72c8935a7b66a1e49fc9123debf0b487294827eb878ecbd45be7b945aaa85ee3c3290732ba308d437ed26560bfdca89d807b5915beb25936daaccd9643c534374b90303b4ccd29f0b11bd5be0ccbc19ff614c0104d9ba86035c5b9c7ca251574eb1601f39f7a6f68bd8a085b482110458aa16b981b1eac88b3f7c2a2c243828f5e438fa73733ae627963d7c8633916a59eca48cd1d0ba063313a51e42c713ecc0b1cadc4fbc9010cd455ec6a54bc81bfc44afeb860ed14303f600305df9511b72ef4e75b639e2e0b4767e750f55dc8bf5a14a9003d4f2b6ba71767a53b9fbf01c27f91050ef22de1358e9d91ee63d1882b485237257c42b30fbc9f02d9562a1389f4e2654ca9c45044e4ce8d82f1d5fb7828f77b744d6b6b6fed5159466746109b28840551b5eec5d84392a1202e171f85515f4f92c4a9967541797c702b1bcfc82d1cb7756dfa5bd5d9dd0f476edd430656460b47cd64f93a58f7409888d30ab9a12539a3dae2b62692f6898ef1e3eb9d74d302133454af3a080ed1de3cae52e6b632a6478909ef98202c5a6993eada548d557512ed8043587e0118d3e2c780347d04ab07f6af594b1b1a24626d13ee2b5abf18dcfe7589d464fa200563a06066e44628ebad9d70d125a4a3bdf93e92f1a68e12dab6cd3814aea61afbc800bde3e5d33ac880a35d28695ba025b0f2733d07edec066bc5bd2c5662f3b1933491cc6729cf0e5c66bdcbd6b61533d4ed7270d38daa05b39f78903a1bc8e3759d5339730fed560f1e4099e6a5dd2881005114a27217ba420717c81705bde5f20673fd26ea75fd302b98ef2561630eddafcbf11775864fd26c23620a7b4f1c3a3f2deb99e03664508885e6fe3400b69a77e4e76d652ca2df886854e710de1ab6cae14fba54b80a2dc76c5b2427b3c2e3a61159725f854556875086ccf4b62472aa4480825d406d4c5def64a111a998dbfff6bad8d86687a58284d86a05cdca78945aa112bd992cb0769c01c9f423198cd80ae1910f0bd61cebe368c47a5b5a4de0e23aed9c0fc937ee411bf7fda8fa20d5b21186829c615e12a87d0f6791611af2a954e18c6cf69b1497ea2ae6b23767d48746bdc578b46f444aea787557390e637679aa7f8330544dd98456b0535bfa3d5d4a94595448dbb6613bdc3673815d66c96276e3211dc8f95dcac0245cc19854f240b143ea07482301203e5060fe7ce61733ef134f2c3a0e9c740a237a80df8db31c9a523b0a362345e7ebcd74bb39e3763c424e9e235831f7034913e6448ce776e96b62b5bf8091ddb6592de4867367afa3ceefb0408a21f66e3e3c499684957ffb6cbeeb9e88183abd77e3ce993a5cf022157d4edf398980aec72ea00d2b87e3a41cdb325b456204393f02c92710a87476e050f3245871659b89a60607530bef07785d254ac3434fffc93cee39ef4be8c828e31a1f7f031c3d8394255e49c7bb152843c042a4dd75afe8a375ef0d01abff3b122fbb6fb94955c55d44d06e18179795472b3efeccee64a4ebf099b16fef7a4dc11b2cbd6b211be1644b8bfccbf648d24bac6a26fabbfc78ad65313db2d291aa8820efbae9c609299bde86278486e3e13dfbbae71aeaf7c193775a0d9028348ef9bb6468eed077ad4fafd43d73c232922d0bc597fbc0d69c7bd2d4503230e967019b62311443102db13a0ce22b75d7a7f7decab63e135d2f4939bf0be7a4dad9f4bf04993924d7130382fb39e6f5353ea251e5b5011acf06a0258236ae2c2d8fbce1c7997b43e828c9e15e149fb985d025d3bd4dbae1a06b89ab2da983d169ba3a454e65367c011ef5a14be6f67f4caafb3602c8a92abb7dd16f740a326264a7578dd6ca2040f680bad09a80d4564ef675e5503cf0f1770a4370c4c84e5d9840a536f7b24a10c330c744359a5aa458002e0d737151a926d3371e6ab864b9555a0128775ecd86a77b7930d6e5025ab6dc3017afacdaecf6bb1ebdcbc325f93a63a32747666d6c51a69ec3ecf2915f056658328b8f77636d2a63d1c4c23d96ff81390319cd60c5451c72704128a0f970fe442d645262dc8200d88841f67c28392df9cb2f554fe226620b6c549cd03ddb1b7b3aa58bbaf97f01da079074f391c0040fb58b13583de49d0e326888858d2dbb77f879d719a0d8fccd336e71223c941a1a65e091099542e397f41014786c3ca50ea2ce945718d9bf5733dc6d93fc73cb43bb8cbde7605a1417221a734ff20d37888e7a4783afa2fad86735ce0a7371606420ee707d0ccca4060c28e48b4e2503a3db624bd42a991999b0625e80fd2644750b6b1efeead3e389c3c622534b400ef8dce9ae9716c8b616052a2eaa271cbf0a2c26393b60619162e25b0a154cd2bf0dc75723356416cf8e6623e13e3130c4cbc947615bc5b53542839f26eb9f9203558171abfdd287eabc37009b003badde9052534b4c2b94989a696e286e68759a4ac37387949f6facce81028905dfcca82c2f146484b804ff607b2fbe6c62a32c55448193626d0cb26063264dd909456a31810709e92fb4400bb73386f8978ceffb91449863083e2d0e0273fb34a523bf6af1c444758ab0955f5d2c25120b51f0c48ea561b10fb8910c61558544f1c383e5eb3c234d0e86f63a9e67f86681641c7c7365b79fc5151d9d15ba1286a821698e1fa8177a8699a449f6930ff8e19ff4fda4ef93b6ec1c663b5c791e8a960785cb6a3e5e12784ccb65c0ece7a2bcb7343e04950938c0fcc5c62f2c132733171aa40e951bc1608e5c669bf3bc81870e7aacdc1165fbfff3822468736b08fcfd3b86a1a052759914e5997246b991eb8bed96fb41e49d56d3086951a162c627f267f523e676d8399108bffb7358ad3c45e1b62e9b80b7b1ea2dff431efeefecf4e0a6614d280da102b1ec331c252d384633040a9fa43b1887070604208dbe040e56a0b2eda053b5a8e57ae41e772cf2e662fa56680cdd29c0bbe45103d6d3ff427e5eb68d73aaba8d7aecaef6b3a10cb1075435ed51a5ec866f64567e7b80227c773dc7b483da33999ca3e68f790b97718fb37fce3fef7dc3365502eaf997e41138b42bc167ba14aa5d35d1a2544b61ff5e1093b0cff2e8888067f9e52a59c1cc8aace5c5bee5afd994c1df13e7e5e26a2219bb7992a90d58a44423e10110bb901849be3285c784d24d166121af4606ad9f281da089cb70d8553c227754bcae0a4a78ed8b554a8c5a88eb1263644c1daa75c6419d4dcc2e18fb4418124b2c198a7dab935fec4f8c1768f39b372b7f0b926ec3e39160d601f2364c22afd8f5999040e1f482ab85effe273857752966ef955c6b92c9a4c4ac9e5d8d8d1a0100a07c355ff633a71851ea0146376b8aecb7bfbb5321d70ab8b99e8535822d4b685615765fdb9736ee59bb90a6a9564a2ac32258fe45b90351bd66f74704b2e5315fc3e020f09229d58658d539281aa508b8ab3552f582840ac96b3929d8f05d6ab53233b57e51bef0fb72d96a5510852db3f1a63ab3be100a4bca9e3b01691a9446109c2de4a9f8bc94208d933095dc8f2da89af5b6fe317e7e05e5d2bf17a5f5e8f5158df7c6c370d3297eceff86b2fd6812f23e2d25d4398b1be567af0761644e8f6729e835c92e620da12d863a97a004adf579a00a8a79542a836b81959e4b5f07c46fa98efb10b44d7e4db54f00d4d4ceb4d07b4512ca9c0f456e750b5d1e362e46accae1d9584588f0c0e7e4240bba63d9c6182020a7ecfc29adccb1fc5f456445e3c0ec183f7365bd8e92e4d5b653501b5ed1b5bcb6f2f8dc5d8c4763c46b9a200d724100182f6b66f85e4af234a01e1cfb1c0363672943fbaf486339d75dd04182410107ab01e445fc03dcb0d6bae5b5705d3347d7406831eb9ac27974ed505bb477cc655db981ebd0bc1175fbe7f59b0a11180e89caa4e365cd464e339116713df68d743b526749ffcd8107db5dcae035d68b1e03e94e02399dcc444536c55ab04d5dbd7412339a50ba8f67233c76572e917f9c1a5a6593ec76c7a3833deae1852fa546768a03ab73a2e536c474ca69d3e1ec70849cf0e018b38714bcfd118a29a547c989f09b5edf0d755691c774d115efa203a3bda2472a69c81f791663542917d79690973cc093acf1d4c96d7154ba989b232433eb45351350cd321fad843d98d844b71ff0f0a83c3370e4a1500974bc574802e785d496a639d29f23929ed22a4e1acd208fc0bbf70f32a59e07e6565fdbf888d2d3026db9b8e7eaac54d262f8a37fe9d0929569a1cbd0bab41e0ad40c5b47d20721e8f464687b4a3fa39610826de525c464b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
