<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5774f4af9142e12af36524a5be7cfa8fda5d6283f0199e75979c0db8ba72ac3a64b8118fd754e9475ccfe5792e6029bb44afc5264440c4605426a695b6d2bd8ea41ed3d6ba6ff96052cf5ec27fd6ffde9262428f0568b77af45eb85486235f5ef103366d35636bb31fdab2907dd1f6078972c292f046ae39d76d626f530d300b18e93eddcd22b2b04bbe09eae7f5edfcd9ecdc60e557fe60e4661e3250935bc12deed925782908472176451d5499ceb891a94cebbc53b1efe0f401d3c5f804caf5f8aca4dc982e3211c5ba1238b1d8a27b255aa43f76aeea513fbdc6266a06d8c883744f76fbfbbfcdda1f28b2ad809d7c9aac64b81ebd5f35ac60ffe3361062d9e14a23bcfafbad21fcd9ba873ad6c9d140561ca2f2c44652d14ab7f29687bf91b6a58c622116efd7b2ffa864766d39735482c29a748c9ea23fc0bc096db296a702bfc88fb1f4566572c39c36902fa3fec880fc062f6fcb5df5cda35813095558ec4b56f76c9a9202d1354da87821eec64aa87b704f14d10990c42b9f53f18b276b06b2794dc4dc76d1032389131c5a36cc52e4a568dbd36b1cee3f26ba40a5220ae4718732c76ea7e79329971fd70a379214160f34dfba995f25cc9adff234f63023690bf62834b552ed94b78a6d1b5092dc815449824e6a46d9dd96b49fbcfd6bd062aa967c70efd97b6e235e40ff6e34a9c2b42bd096de28cf7927ddd33b30bcffa1c2ec486f1da0d8f0ecbea186e999b92b01e41ff433dd9419e0c117c6e8a00850d6414dfd021c2d7c5a49dd0c37081bec06cab1e396d0b907a9a72a6e52aba6b7085f95b1749fa6f6a7cdc63e15a34aaaeece68c8a7571d376792cbd81fd7ce9099249e91d49073081b541079b85082a926e1d8797f897163db4b59bf167f44f2a417dd378782be19dc1ceeeee0e359e33b2433521f447ac682f7f7e782e98d0ff37e49a73c04e4ca2c74de2b3090c43d76ed3a09f3a7fe8a1292fba2da2a9da15748d8e57460c7cec5ec9515377b6573ddbc635dbe3c9664d29c339408e1297a8a811bd7c7f15c249ef1e7e3b14e3f2d0d35ec9d2721d6a33e2a5d56ec99a3cfcc25cc5205c6d5d45fba9835e060b4b6350abef3ec561d738cf076fc70e31882e79799d7fc4f91dc88c9cadf7767048981379bc1607e0f14d782c4339d28b6db05ab622586f368264bf45ac3e4a6dbec5b71a14c77e49858c8c27e94eb9420cd79f33d6ed803f6029a093d8a6ef700410d270e128ce134c31bc3380271f66fb1811f4b32ebe5375bc02905ea823a384c14f98d9a61525b2289538d2226ce30d88135965feab43669545dd7b669735207d48a76dd80f0d1e31a1c61247849d8218af771b5215db3c79b4e0a8ae10aef78c185e12cb7ba2b49af3dcb05cfab0d90d1ffc14b5751f48cc37535e5ebb6796d701646e94a837b42dda41e5301f3e6f21f02309fac8b13994df6ff3b0fe35e49945af4800aeddd141b3e0d31a360869b1ecf5771c940f4daf2de2a802ac0f56f5685fd9e4d994e901f462df821e502f3de573cca9895a8c8607e684dca7f530cc6acb34c2f7e67d04e88ca5763b0ca9289b1e81077408fb3fe135df487d7abcbae9069accff381752963181c852deec2a4b461c1886e3aa519e7de4ae23ef312442cb515f84ae1013a5a1f4d3f92e64b38d2a53d38b92d61e49c3b9b292b899b1a5b1dc0e2a76ddf319ee878c3ccac2f00fe667512ed338298e1c60c38115cc86d3ef22be1222d946a98ecc690f0099302e7aef6d97dd3a73da0340e9b7523126fd929dce513f7595ee07adab5659daebce703c246b7e52be009d8aa42be287486241492d7eb168345df22df99a96335d14dc905ef8a2fa5e825956cb637274c50c317713cd3f65362ff4abdfe0be7ec7e5b8af5525b2040c9f22e4a65fc81b4ba9cbff72916c95cd061af843055137c3aee56f6ca4772ab49d72ad8bec48b9fb240e3f4752fcafb7991f7f2bad6aebecbea8fb72d0587311064c8dbd4137d4ac0ba2605420739170ecf01ba0d3364125f5ff2118959f05fd9a9cba9ebdcab1b0515cdee8656dc3e7b63fd5b148d6110fa6c478ba6101c43a09c9e38a9cf1dca44cf6e4a7da82c779bd33e6af0bb8eff53b054e65ad3b13401d83b9cb3305cf62f8ecdf251f7b563bc9af29264ac9e6f85835302adf95108f82f81494829cc8acc4565940f450db21228ecabbee19955d1b691861921aa2c534199c98284fad3d2bab60d93346a9f6c6828d61d203659a21fa62da2170fc391a6ea6c68f33d9e4d4e445bbf9877ef2aa5f61a36ef8041fb7970568063aa7f6d70dda6e1c1d07217b31ba4adc442506bfed6c71b07366500c09066ac476492e018dfffffd24558efcdd2ecd38dc9bc72414357e451a06fcff2d9887f7dbc43d23a1b80476be4e6ae712c6d5d4431db8332227c3a9acf1a1effa823034a399e89c3b8d579ff255531ecf4e1272ea7df21cd2e8792205644cbd7389d302f78d214a5e66e19990aade2283e5b9691451332fb76ac69d1dd4b19ed07941f80d939a332ae7c575e48b24206449eb135ade000166b0c57a5041ca78aab26fc3aeaf20145bb86fd60011688d4f8a5fac41a711ca456420c017dffdde247bb1946812ad4834f646a479ad85e32799754e13c474313c4ae6099d7d57d97fdbee392bbe3ad37f0750b03d1760b2b67cb6bc146698d75b6490e36a592ab675bbc1fbdac4169ec1182cf8acbb570ec98c12dcdbbe6af373d973c47004e7dfa099fc8ab8065f95581c98ceadf3bdf997ffad05fc5f2032c552dcf306c8d7c2366b40ca60cf4ea05247b83b95c06d97d93c05253dd20065496008635c61b18ecf7eb82438f6be95e4b24cf69578496c80f7b8a2cec5bc6a3397e058233b65e662354f266885d9c314167d4a1eecf6055a5187b2dc37f05177968b33d09b0a263dc8af7c8bf00ffc384334406e13d313a2cf47163c7df30795e4ab7aa3a74c4333b058057d879162f72836214119264b7e6969279a53d3e3be9915d9e4e2e884ffeccb9cbd311d18045c51daede22e7468e9a41a086dad989ef134786f974bf3b71af8edd2695773bc686dfef617622bd81135b15b53db0491fd5fb8c6c3fc764d5efc2e768e1aaabbf0ffc8f70b21f6059946eeef7f11ca108e6420e9f85809df65690229854260bdc314d8a168c4ef6c8960a9f244cb5d3792a0a7bfae3666826a8ba50071c3d31376f5d6347da9c7425aaac1131dae206a17842a461c38a62dc8549ecf7d4d9a88e6dcf3da3cf7299c9e67b5f86d0c1d8c80453a1c7d4dd69f8f369c4d7aed1d112bc5a0e5145f366742d038c9a1c5904cdb991b7e5fa26ee9c404c37679b73acc83c02be6b7ac7f0393e48c79015e792d2007a70d6293cf2071946bb81205c1a778d85cbdb048100f6dfd7c0847dfa35243f10146b441eb07f57dad0d43ecd4eef76523af4cc1715d99b0d76c4b36ae1801f8e50681fc57efee4903709818fa8f76ff4ab79c2c2b68a49f9182d60c5512462d78853b36ee6307f9be69c6e764af71d0d9ae2abe2e40c3a24d89555ef39fef3d79825e3687f83ada63bfeb08debd4c7688294e6e62e3ef2d87be0378296b381458757f7e505a352b337e9c2ea02107da0073d14099636035ad3139394481d885efef8d6a9737ad5c24277fddaa6ea621ec690fe957712f8464b35797651926374d05358a20749d9f0c80cb13e6263d1b59a58efda89f5ccaff1232b3279fb97a4f82de0ac8549feb5e442f5740d675ce1b08798bdacd24bb44f020766d8eaf77514203150fc185c2c375b0a693e67940f735433bdef29b2ff5f9e3f7c3e5ddbc214e5300a02744b2892144a23355fdc9994a803640b92811d41d57331aafe8ffd3f8c0a31b50a32cce852206f703fbfaf78f85e15b3a7b101bbc6898c3fab8ec15a35f8fe5c4e8846f100c8aa24248d82f445a3a9807077ec2281609e749792892ed152b463163a77b0d710ace50dc09af38d71e11c9cf4f87ec8c175d35d5d417c4085a7141557524d00fca4972a421a9439625a8cba4c1bed276b9ea4af2a8f8a3f6140f6e2a0bbb3c3e9a914e5700bf5f74c8b9b40981acc1b663ff721d655017d6517304a6029eec433ac05bdc36c9c1b975f9332b3f64b400df774e4a09a7462021ac449f9e627d63e4d73668be20c4975471b7a9359aa20a68ef121d04f8b217e368083ede0409fea1a8d76348ce30f8b8a8ce6e3b693c65dc8ab6a5cc2597b0dbf10f5bcffbd3a6f13171e0a7705dc54c715b3cdeac3d029f5d934f626940f940fff5141e95e53b33b5890100aa5c35c9dcaab41c56e0b19cf7eb04a76d3dea49b0de9a23b1f4f5c2d8572758b8150b70e434c709c43eb73203dbcefd5499eb962ac08835efc49b8e11a398d52d9aef3e732560a299a3fb5f447ce9ced96009a1d7ddd550897ff67d9c32042a66c7d16cae72ccbe03e520bf09c7dd30da638905354af7bf42052ee10a112ebcf9b6088fa0f63d5ece1c3927f75d848579791b7668ac72a5ae6b63e100e039915a63091f87de9375449395bf10881462a91cbbc7631ce5b2946a2c28e5bc69b2a2884b7f556b8db92e26b18663c49834a64ed4210799305c204d442325cc8ce28b5c5c8366fe90ab08b8e425496dbbb7ba772ed104d632ceaff6b3db311dc7e0cfeb6d4cb20a1aed9d4587f23d52459df11ac8ea1fc192c32c2105bdbc0da36dd808d5c05a998e8da67c7428118b37a3b1062e8e11ab9bdde4ad9d4eca653cac45437f60099055d93778db73030ce089a53ad7410246cd747ea8cf12bd06ce44891a8dd095003233edcdce314e00aba1e16b233dbde3fb47bb8183e7aadcc7ea9fd46fe2e75257ffcb51a41da37a1c7f726d4475fc4dabf73f3f46877201bda0b617fde3f40ab0c81b2661c39f810a12f651c63cdbb0a7978a191bf56b9561c3831012f1a14659e7a14d382b5ad519f0b6a01b4a9cfb07590c9deab32c649961834f995c6ffda78d9ae087cd69095def811055a1d767b12fef0807f42f4c3da9f5ac85f283b1ad0668a43dce01a45c16044ae3c13fe8fd88ebd3500fb77ecc4035896b80652739fe74daac780762ed69544fc6fa49a6afdf038d70fb2cbbed3b80f6ee0a7d8e648f7deeab888c4887caaf2fb2f302ec4c8c39c96561556f3bb653fa3a18132340b428bc570cd0f14c64ae78c07c00296ca01d7665a5d09fb89dab510d249b75be1c4fb210b581c06819a978fcdfd3deb45ce79e12511ad1eb9fd0aa0f5a6297381d7c6bf9f63c2e969222835841768d7f49195075681f4a4e99cbe80a815fb925d9c6c833ec80a49c32c283ac1d529b8300e66a388a6fbd6355f2be184633834f509d40a0d65b0f2a3a466701bca1374c9a7b4be46f87e30ecd3709a4319ff5aba3fae9e6975df311c1cc08b9aac1a3c53fbdcfeb508d4ccc55f8d44d5d278c4b5e5864779021d60fe48f421f54daad423ae59bd5e12f5ec4e12fb4cb657f70c18fb9dbcd30d52ac3cf595a7c5ec9073aed82e53b482c5ecb10ed5ce39c7334b36d4309b860ff66a7ad77940562e9024385015556b2c59a82a8fcc990444dde60481f57f5e4f4e4c42778a3e5dc3fbea4a85dabf3b2d39eccd8800f007c2efb31058848c987fb8bc905e9d65f868bbe52fc84d6d73fe0297d56180dbb5542dd3408e4d1aa07157eb423de6af04c34cc525ffaad3a25a3e7a7e65f12d7f7ec6769f3d0bea751ffac9cfaf3480e460572a155d24663096c13d1931a8271128c527b6682e257cbe50777d546d0e153f646162c5dd5ceb16b0c97c420ebe6f700f4c2ede28cd89d13465f18b195054a35a0a2bc5c236bffad4fbb7946104dfa8c3eeb8c34519a8ecc4a507feb2c7940868becf88a6b77ea8091d52481793a3614d43f8b89fc3e2539bd476b0561c61816c37d69f3b30e827ce46d2523161ae15a526dd7888a8728798b3f788200c3167a533b5cfcae58c682c4ab7a673a9fd46afed192c22a26b6f5ddfbec321b87cdf0bbd41e138e4dbc81b04d76b99a363d6d4f2d63174b8a49a911c3d918ed78e37e9f2268db9fe2bea9c48c3f5cf3646355bd727338d8494d1c6880c74103a85d6997d50418ce0085cb5b6dc949abed3de5a938eca6691b795e534af0ea79555c80e2fc4d29e4189c12dc477aabe584266f2510b71e339ecbad5d05822018d5b7857e5fc0afd73b1862890ddc90c16268f76a81500d233b9ac47011e1cb360d338b366b453dd83f66ed729ab20860aa61cb226d73c9a6cb57852967a84caac0dad0fc9480a796a254d8db128b4960455ee678f3b932cba4b3d5d51c95e7102df361b3369041d1cc1d59552b76dc0ae068cfa6c1426f45b4c6ec14822d3f65bab808a7d818e60ebe258e4ce6f7919d8ed8b098be61739d97c97d13006b24ceb446313a7eb3132410e43a15508f1be05c48d1d01483fe808c11e6e9ab4d2d660af4840ca11579dcb3bbc64a333e012919006bd2c674efee848e839d6e0df7ea19bb9d8d6ae6096a20676a420c5cd902ce5247519bfed2815ab9077247e7707efa3c1d5714465d2c1eff342acd207420bbe131a88cbc6c4f98291fd9413220f981065f7f384492ce3b8ac1f05a01bef67df42ec95b4f9582c9e76ac5e409102a32cd2edea3485cea8142ca40a737ddc7f26a69346d32ff288e1d4bc3d441c704d397505f7c0c92175977716357b59112b689a5403a31c9a8f47537af81260c3338ebaabb7a345c877e5f22d74ac4d0705cbb3c0e45a1853a07a78ee493f9e63519dbea99612be6d42ec62694e4da763a53582969e5ea5f16a3e3e0adb94516ecfe064a62d3740efd77abd16b29daf367283bf7191be8707d45ab8154014a35c0aab96b97757f6c755f1898e0f766b4c6d72296d8267c7f91e08368e81affc0b47c76b1622dfa2dd6e1847ff0e78eb2f278d5576ee4c7f4ff58438807536d6fa3a146fe6e163ca61a90f21ac84153332d7fc7ff8d14866c80145ec2ba08b3ffdfb3f08bc1bbbdde1a59c9eba5494d65f7542c03dfc67560602219217438970329aad6fd4cf53926e9f46dc1dc7e2faaeab7d262d4f87dc689254624d4045962b0bd414bfb057b98def1b4dc71403e188aa9db90da18fd628e4bee5e1cc7509f4bd49745fb93f554e8edeab38ef8b9a78a2a1339101bc5cf218e431a83e4297473afc58d9f008ac9b03f220594900738d7b457032055a9f164960ca138239df989024ea92d74cae05d20c776155f3b1191f4f24dc96bcb1b1944da74802f44059b510b4470bdf0ef2287f4260d0a802fee32096b27c8a0ff8f5ef01b25f3ccfefe5518002c138084bae3f36f1f979cc5d23b696a2f981677995a40f614af3a98d57cb3b799d39a244d22b4584fe573849f3fcec19017d9caf3f8189ef7b3fab8d840792a657d01c6fcf5e145661790b21ae9825c779082d4bb14883da3a212aa1cfbdfc417daf17f2ad43c607af932c172832bb5a09f0efefc1c839efca81aeb4a7ad3c41358f1226d9f9bba528cdff48c7256c6a228e22b2c7faaafac7b1cce045d315f7bf4c9dafbde5d358c3b6196698515f5cecc5e933cc0d37c07a79420c1a089a8e7a2c6a8bc685376eb196dc7091f4856c9bb969a57d34e0b45c2b362bd4fde1e3d2a574454dbbef49ebbe07db0a170f8383551f1faef2e634ce9299081c10772284655062cdc54a2080a05ddc29c1d411f0fab76c4a0615616256f38104640ca937a56edf37d16706e62f4d625cfa743cfb304cd8c8196a713b00bfb65f8ba49c4d2341832b3a5e9a80a66e7027b51ffcaceae0664ccfd40910a121dbcdf10ca83b15b0e4523baf0ed89697101f6a9c76223824ee383a50f8887693ae7f0c5d58f571b6f1f9cad98b49d99aebd0871539c18314a22e1051bfe4a3c8d9aa699a5f87dfe3adce1c8d243975a291a2431cef087452282c700b07012aadffa1b123117481dbfd41bed17506050c31e869da5ea06866e8cffd8697b900f35048c515f5c05978fc339d89d87376660faadc1483e528c89d3cffca48ce3c668af3b89e84d2496a085cfa73dcafab6702a9790b887a2bcf065c78bc81ef76e5878a8b56cbf5574358745bf8ae500efcd590c27d026e5574a961bf31bae04d0af80af90d8774a85daa1bbf042af044d615411f900e56177d1191a45558436ce6ff9e061892e2edef0c1abdac35881dcd629994c0a70f0448bb6164bbde1859d001110f97357a2fcdc751979c7f8b4c2e06d1b0e0f98c58d2a31564722d109df6173efbd77e9957d58ab42799c57fe6b1263fc1d2cc6d56b23f5f2a255d3f7246a82d40ca5e12380d7a61ca5aceb59b616cbbbbd6ad049624bb110d504ff6b0f81d8cef884c1f570178b73c1fd5c98f87863c7640661fbf771b68f486a13ccbb5a5cf5bfe93395b776c859aa06d2c7dc3fc1658dc4287ade6672e0ef0f4f4dd3d73c93ef1bacbe426733a8a25cf129759e8e7323e4b971b3253f9d17dee77b6a3ac57cc009fab1e33d22d28d00418c848c04d47428b70a33c0e3544febc2fad2ce8efe35aad4027db4debf33f8d1b76d2d7dfd07522e7d521bae617ce518eecf36b86fbb82edabfcc8008cbbc1b147986263f1445dd1ac9e33365c4394cdc282e8d49328a227458ed318d95f586e2eb472a48c8801382e652afdaf125c8fccd9452ab45acc46a307fba11f2f35ba784db0fa4ed3deb30707f09e9dbfb8dfd199f14a4d5a5c12eeb1c29eeebb2e49a5f718c7e6eb07b52e574a28905976a8429d8365e28ce4e63100263ee3b3230047b5d9fcb8d5c23952b683c0c19a4a3be1c17ae7ecd8df2b1b08f1dea913af923a20f7588304b3fd95a05084b5b6c7efa537fbdcc6cb35045724bf15757dd0b876eedf69fb480fdda6926b2a9a96800f3793dfe9ec6ead437d527bab1b4a88d08eb2d40e9fdc8786d6a45f063f6815fc55f30cc8a40c7d4a2aa92fc949c3a0d18e5d29b7e479177ff622d54c864162c1713afaea588fae8d81f16552a7972567a38f7efa1a71e0493d743befcd7134520a6ee2e4e8c0fedffa187bd3bc5f6801d7cabc3fc3f8942f0c6302f5d14fbbc0971e84d4817512c9f2498516c80c6a1b39c55bad4279c24d3aef451692f37f44458a003c4028bdc26b2be6dd50210b7cd467319610b78f08050e66a46a50abea0cd62b07f41e388369c7c0076fcab54f3ee4cfe7c1ee24e765c587f463afa00c66a33a6881066f2d852d0d99f2ec4ce19eaa2283eb234ec81fca1a8841ba937b847324c8a727f3c01ae4c29c74d322c703b84f84fcb2d417af09fba0b046d339623fc2016088a47e8690a749c750ab34d5552bc9d6f26885200afb82b3bb11ee077cd74a006257d0e5dd3c2c52ff52a7503a4e80eac474604eda7364101c3d2c61180c2010473fd290e5a97a69bb912f45083717946fbeee04c41f07dfcf9c9404f66098ee037bf5817a875816a948b266377dbc988981a5626dfeb692ec3f06d45496a7d9f79ce9f39bb96fe3bdf23784669f3a7c8b9c9b0db2ef3e7156928dbec0f18d3ec4a6089cbb11b8322f4d5b558dee47ff0b6047db9d2f23d9450a7e78ebf4c4eea1f3caa6261da54ab77fa220df36809600ba0a414f6dbd5bf60ab1845ffc6298c790dce66845c17f0d5f184236e5a15c9333dfd431e0086171a2e92883e8de89403a7bf4ec2a9119c2e8c1eae9376d097d1de0cd7e26620a1c41710c6569e28af88bd4aa6ea2b9322f1722a4dd5fe7f605d162f0a979b8a87ab14e30295017f76b1c197669849e528e2e57cc3d05fbf51c262189c91631055fe72ecc58db9773d5d98c30f9ffd462e94634d5628bb0b605d4e44144daeeba4b0b076705609110a37a43b35ce1ff22cd30f879bd57a43c904c20b33ed24508dca22e536f0545526664eca029c0f4f1e1fa84f8fdc119837e4c31489cb25c576ff003d3528205d63c81d4714bd4e9e24a8ae9f85309933987e180b325ab0d05abba0968989615145c046606b3bfe93ae26c740b48406558ce0c1dcdf4a29512a5b8393afb6277174c1b6a9241031e4cdaba45607954a7da3f1807b129f6e5938d230d8a7a056184ca073671d12250be7ca56ee42c83edd25ac7f4932ef2eac5913db553bf7ef935df766ef2cc7423307ef6480c1599148bccda37899555fb6940352be8bbd685c1f449128ce96fa6898aeefcc4c512f9374f321fb2bd7fe6b59795a7b0f68bc2d8a7a80547a46c54f0b358cea8b7408230bee0c21ad5be532899c80658026ca917025ede6d8c06c05f185687d1e6fe4f5364ed7b256843663fe1d8c2c2f62c4be7e9b598e8b76b7b259bc55cc48384be6e1b90f9422d35eae67751f43a152d32563331fcb591bdf141866f277431191657ce5eb5721174c138b8e7b7cf7dd563c983c68c5a49d13a11e0c05c812ee8be9197dda0f2621d840da0eec4790868fdd5cb9f2f69b42514654854b4f386d7f26b0980c1e8248502b4eb5f05c1c301acbe2b51a49eb0a84897fdec6712dadd69ff472e9c39dba8dea3135e23a8d479a621c3e85051bda203fe0041dc946566c99cc1573b3228da778bd242a66072d00025319c8b3edb8b3392999f2869bc321e30a9a8c8d77849c7a71419c9201a411948080025697293a056b192018fdcc891f9328d60b1d2b33f074301947ea7ebf82ec0891f03d76cfc8dd4bad2c644319bc5576b5160670027022274908c29212295d1e4228a935015dbf09a91319aef6f18f0da6ea49366fb515803d9a0d64d92b20367a3e47b3b201241a5f5a5ae6135973cabbcc913018e95eb5665c1c1f5b1f9f9990f1a3d6e201682e9acf3338b9cb576cff5d4920c8a072d972a59dbc5d577dfed39bb59c92431a06b0b1fa79c47d9bb398abb41eb4b654a07750ca2d4fe7500273208a5e565773ec5e8c9f340bc96c47d41e4fba84fd0be4dadde9991087287acc745cf6fbceb03dea9b7924aea57069e2536282cf5962001f0f2f5a9c547ca2dd7354e4eadf2e2ec148b9ec882e75f21b93c0a9ad55e4ff758c028e265c97a22bdd64c320d6a20b35470d26371c51b846acf068f6d09afd7db65e52d66c7e84137fc24b0688a5b078ab5a1b9e46f1b1115c724cb81ce2e3ab9abc28c28614a2cedb17d70f7f1e2ba71c53884ecd8aa9a1823b04c524c365edbb91eecc447f4331c8a25c1d781988af80153824af167a0dfb55e33b56b7eaec5d81689cbf389a164abd3fd94985ad44a269d48f8fe9aea33019e27fc7224ee5b766fd4a6da09b03f92a2d27ecedafcb6a9c9c741b6c9dacf420ed14c447751a78f5358431f6d1b97f8e6364546c13c8a2f3f76fdc1012d41466c211a27547a2e7fad89ae275f75daf152c756b4b73dd304cdc0608a5f6a5da8d80fa8d57ab1083499d42b72e996850df736e951ad726deb1e8c63aa666346f00fcdfcc71c77b5b78f498234bd4f156ae034cd8a762952de13712a192bdf0a767e44be12523e4f62354a5acb28d03fb77119fce9f8564e9905c241be481fa454d947061eb3df89d3c8bb9dbc3c54a7753eb9fcf8782b76311cd629c59119e0a334cf5d63f8c807f67877434a89ded35d3b6499ad1c8c306d776415bc4be256f7181b6e52481df9a57a1be7d77500aadcf9747480ffeb0a35ca13a70e57d036c9183e8aa0c902100baad95953b76b1154a3c4d353b3e84eebfb8524b91523d39c0ec5976e7cf17c51b39f971898d1469e209de880fe837c7ad49433aa2c026ceab1e57b922ae7ffccb5ef880b61257ac45a8cc35d710542c6955a16bd0ddf57aaadbac47762720aa9b240da0964177f467ff5286acc192215c4945d919238274a388473c576b89811cd37644d5be14959d72f0761860b75e927dae918c6a2e92091a38a7421d919caced01d92eb961fbc31bba21db9f228a35c369a977dafcd7f7994bf568633ac16ec049d0cc053ed6c1c779c14bb9c4f920cbc0f737bcfa0274e1361089846f6d0323e68d725b26a45234f42f1ce6a638a54507b240012182b5f1fc4c1e21d3a5a71dca0fb0d76dc7649052da712ec99c14e09aa09d5dfd7037166edbaeac491263760591ea3a6ac231311414f65572445fcb95d5d7738399c5fd03df0824c5b5c11fd67657b582548763ddeadf930c193dcda1e92341e49078b57138b7b2d795eb6ddb9bf938ae7420abfd80c3d30f6cccd9a74a54edf660ff9677ddf3d440ec6871db46d786761d817ec8f2cfd5c67cb7353f16f4f83d409cf194273a830bc4bcf95f15debcd8ed150528c6240f652585e2b941941ab8435d4104901f2cc7895eb5d97b1c5927d841a821d7762a1bb318a968a8b79dc618720c6e9fbae01d545387698443a59d1c0fa52bd947be338b4059aa2bb7affe545d08a6b76a8035d6e4ffac274b86caf85d24deb7ad66176e00bf2f40491e7da57f03d80db8a62f3269be1fc0ff24477d18afe801197d5c47ed3ed1efcb8d55ac5185a58e2a296e8a6770871ce2c637eb4d7c4857b7421133daaebcdf1961beee42f0ad4ee5e7b5d4cc5a35386271588d4e7ac898662153d95e491cfb0710501f6cd0f296581a3ea7c97b7b49db90b240b06522b713db97b54f369e483f2c6f9a1cb7ce42448d760bf8638ce01d1ee831eee881cbb23c0827d8b45dc503289a1956f257ab5eff6714b9f4aae8dbc33e2d366d7b47a161d27e22445947e4612f892cec3c8475e1426f7598b50b4d4a437cbc5a96ec5f61cd2cf5ed0c78d31cc2c2702401edd945177f4e915bbbf289270ed54085149b58157c6a2ce7629e783df595c40fc3aa24bd4d343424987acb082233fafe0aba4b336018295f2db6efe8a3f44c1cd0fa5adf5f6ff944b5e269325abc7cd1343733e1fb688d26ecaa184ebda50351d98a3b0ecceb7031c81192570ff899450f70bc946441268b05fedcf3a04308ae3e9b2c1b1593591711a21c88305ade0c10eac525b6db3d437f7ac88cbdf853f1acbd37326345f654e0cc8761cc13139d541cc37ac04730f4dacaac722b51e57fc46b4d9103ae66fc5318629b023561b7dcfb44092fd268c11b1c2876a42c4867b2f19ccb34aff9bc3ed7bbb353c7dd5fe512e3886789f47c005f5481bf8fb4a774060676f61726c1019aab397c06f3ed3480511a5d5c0eef4b325d62b3add0787fbd34c3ca40a45fc80dc288b39c119a0ff9cb447aed7bdf2f8fea3cc96667a927273940acd6e4b4738f4af23c22404fb9cca302c2ca95d44ca072b12d8d270073dc64243b5531a68b4a1db99932fc040174b1b5c0631e5399d7166444950437965e5336d65d909e94524231f7339e153fbbed652be7527106c6479c71f67f71cf9af7a73afa0ad56a726deb39d2797a784ec2f611811c5f8299cc54729bb9e46e2f2d08707e5dcf477130946000995d2ab39c3d32568b0a1e040b3a35f57e2bfd96785ed7613678f6a67f9b8fb08c88619f78e44a94a269192ed6d32889652354b80e2af9779234171d48044fe0e51a95b4d9d304c62f205000b7ff574e3c4b2b0e80b08a31aaf8476e19455268996844b856a7f07b625e65e1fe780d95c98c0fb4bcf148f3d9503111e068f0b10932ea45c0885b74f249c3d0d01e803d9d78e67ea32453daa088b8a2ebc938f1354f3a5fa5f70b56b4c3273d5e853073d6b5c34ebeea894527effbc83631868078206f543398b42b07ecd34fc4cd8a785827421d426d7ba37fe07d9d76e7d319d26e39248949577568caa6827fd2b5cc894b5e324dd62fcc035441717636a5cfaf38494af97c31ede1a9d3ee0d39906502bc244290c112fbb0f72d886438fccd536ed801a6f93e5df5759eac4b943789e251c7a65981613fb6e22e93995709395702f3ff2fdd2ffa8803db9895c34a49cf7b01e55713e645ef840c57a606555a2b3108849e9ed0f5adaf22ef2e1b01b0a52ea4d9bdba84c615327d40614f90b26991d6c093486a10cb0fd34294e30d96e97eaa01a2d873ca9d764a79b802e6aa75c3753ab33f8795bed4a17861f47a3c9a6fe68424b839ef3066c80393acab935dd89cb3f5c4924a9249b6d824ab95769c34a37d5b160b88960ad10656f0c5a8c7b0c65b97d7175c7641b638b5f8aa5095d7de9aec7ac56eacaccb73a292e8ac512533bf84413f60781dcafaca31c073be71d95cc1411c1dd40dc692d58534c477d12d970419fd67ef359a5bca083db92e493be6b48d1c7217ed40ff7ca0d4d0a89829f8a79e34b9c352dfe3299788bee2c7edc346adb43629f6384b4ab2a30a5b554a4692111dbdbff2543f7f4c46de161765ee082def8cfd85f9bc93d23ed1519e8a1463da96d1e2ea4969327232087f38b4de1e5869564a65b516028200fad42978feaf7d21989eb4c8da861fc3d4e1640e763cf673b82e5051b4916f3a178c0a6900a6e27a901e11f8547be3b960afa8042de915540799375416ebfb95c60a024f38085e377c97325cdbe03c171cf893eb576ba0de72269d1f3441bff7c9c094f5256f4546cbf11d6d599adbd964ac6f2319244a5a10e6e8dcb7301141e7856450bd48d1e15652e52559929eb47232e3ad728c8d23c828189995a88bdf7b259e55b1cfbcfc07fc9d653dd5dc6afb811955b4e024543ed26cda718b43699848451ec11a573220979f06112d680a0fd513381288db858c31c3981cff8dfb6901b9ab7ab25733eb4d026596ed0d4ec71f791110584e62c1d18411b21fcee9f8178f881296b728e1eedbc0d1e96f53ef0a3dfa4718b1f8ade11d748da905b3111fe667854a0984065c7d021e08b1d064a48004ec9582d739cc8593602cc6be1e7dcb2709bc365a3dce517e851e6f18c0c192324f0312830a0b61f9d5c44fd1e5c0000f48d4b88fe800f5f051a8a348c4de8003ae0a8c866507ce5d06a148718be5d8e8051ce62ab81ec77d129f13e0ca9f805d37e784d69e63a8bd2de9664a9f04cc31543046d211ae08819dacf1589885f6b35697a107bc4fbcffe712f3efe044e199e19ad0490d627c1640c655f5eb9f1b43a301d2da2222089eac4b1e93414ddd511561ca81c3e21d453c9a2cc7ee32012218b003c80b6d3d0994c9d43735b61c8c889de7e2d5025a071d76d3f3d49e5a42ce1ecd94d8f55d5c9b06d598d88f67111b1e63db8ca7e5ea948ac43663abfebaa4c5d1f07b535ee9fd0647bde010ea8279c42e499891349c56b12699fde1f342158202e60dc013c802d7fdb5afa2063b9d8f0458a7d3429fa9725582b800b76877b47c424721b4aa1a38e006d05cb9e34e8ff296986ca5edfb527cd8c40aeec52263e380b4ee5fa6c98bb8da7691420c5ef5d563fe18353ad8a677e5baa6fe1a9e681a1417241e1b8fb9036cd8cbc0e3274bde085e57b67c98aa1ac5d16fcc6fde4986c605cfbac4e0b4e35ff1b0263b98e6c7fbec28d290f532aa2034288104426436f2134be5a1bd4507f0eebe431066896a2896365cb5e25bca4b5def45396ec5e852cfc04a50294c9031fc8410b7aa31e86cfca552452390abcdc73120bd982964dada637c0ae0b16ba7cbc3ba1a4f8270ea3964b63a6aad8d6dc3322528080dacf6d5ca519e3413ab2b5a64505a5f4cce3e4275969db446c877a48ca612adc5bec4a3fea289adcd68678a4916ece5872c2b9b38196ba5774b440434766206238f3e39581edd612e9b6a74b2cd4f657be5a1709716c5a6d0353d7e5cfdc54fade5ca0d1ffa922dc2d8f6a92c6c0f865a32cbf121cf729832ca672f45949d70d0d47ee9d8f3774b0360b036b9f00973f56c9beb3f4efa7307490a7aa2ce0159d2acef84e594f5eee9c4c63bc3a7b6c52b0d657fe8499637f6f039e5f7e6efcee5143b958ec98c46ae8b7f71fa556bca143968c50a8751401bd8b4920eb1d72a0c0951f2f85e0ef01bcae6ab9f29a3f3c7a43b0da496367d670fcaab513b7415b2187d9e86faa9dc2d91a674ba481283e63ac3d6a54af70ccd7c879d4c7b56a1a2771e98f70467917677c9da4a63ea21c2b2a29ad39684a5acd1781988cc1a260831c7404d36419e2d66f766a9e8a8999d9d794b6a3516b129b687039009b3b5ad3b7d5c2ef33e2bee6cd6ad2f7be75b1a536174ab7f90501a488f6d52748a663e905b2f9bb845c00d7194e3f25321a80c8f8062b2d7631c1ebb48954a79f96d298ac59e159b7e3b17f9d3cc6078a4ece24ef21860685945ac25525f6bad1fa75db69aae6bc181c6e0308f55835bc3475dac9518b2ce5f4d0a5fa1d08365d736d3a6fb5b487f13acdd143ba1190314c3082d4d51d5ff400d46600f95e84c6210d710748c1bfbf3389d09acd7b17bc0bf1392d5c118cbe5e5f0992403b20388ad05a8c51242b4695ada55d77526ef7c9ec1c00d7deaf5283d071220026ebbd5485f2e57373d49c851c9fb728f531ab580b63c0283c21087932b275dde05650d7eced4d30da4d8fc60cc67af53fdc6ca6f626041f50112626be4076d1aa029f0a83076c04572f979107127a20d7c58317aaed54f4cefd144f62dc02c71963312985f86c5a780f38cb26764549ec6406e4cd24e8cc41ea51989bc2afec90b9d1168f25acba1eba13d08f38710f50568b5f787de8bf1d339cff925bff6e086cb2f9b4959c09db5fcb2faf3a0a329c5b0477574ec3ba4622df0709ae1fa40b72348464eeb0b93b0f52008bea552cbf94cd715ea44d02f72cd75e13c4b957ffb87910364d2d86bbc696c2269172bedcb49779a96526a9fa2ac0c1b1e4a3913a00cf5668167b1bf5b114f92fe65e39b139d4fa1b1eceadf8519fe218e89398615a3233a4a1a6db638bd86f6984ae0c9d14ac51f4305b2d7b25dff301d5020ff1a196793f082ea2e75e16a23704528f40a64b4bd041a708edee6043149b06f28b022f043d8e42b02b11af21f20ae238f653406866e702a64ecc6c318c64c658f8b8e2b2f2adbd4e3a4346f24cda8944aa4a98ae9a4fa852236c470097845f9f7048b32ffc2a13d0d7c12e6601bd0aff54466f1254d11dd74d0637a79c2043803b1a3784662e533880c574f6aae60b75a4795f5d331b7ae92f4d8b73df8a3f83539214212bc59468f9c154bde86ef27e232b4b040f0e52b42b1226e881293203a8374385eeb8122f67ee7ae9cacec1595662ffebef9d82ea590bcd7c1cefb1d177c35611f10baf0fcd95ac6cedc68783d4661bc3c2179b4c0caa810d278be22bf8d5791436f1753dce58b6f2c1dcc18d81f167e4ec7468babcef1c66cb2d31452caaf2ad034b8cbb6e2268dc399553ef9ad4f816a20ad23d62b8b2c1a60d4fff6be9e47a3d771b04cb10bff34aee014dc7f2d8884e46e7f56a74bb268c3dc62ab8f6f271cf533e6273a12304d540d93ba8c24594358a46cb6210e8722e9d0ae2ead86fc242599f020491576dfcfc57cc96c285a308beae3b84f52a0a0f14bb8150bc956838f87b7db870d4b9eff6a18410c557a44ce9cdf254dcc1db17d877a2a1687ebd44fd59c40a8506f885fbc4b9370e9bc802b006be87871fd29cf4fce5fc11658f991038a9d9542a080cacee6938c8b6241ef361e18dab80e8ff7c29db9df62a48379691143cc41d9e652ad49ebcc8e6e1afca57d9b21a410aa05f7fe71b3e509eb3749f9c42ea693d749cb13768382b497ad759313ff12dc807a08ae5b3c4ea1cd25f20bf8cf4462c8f469efe8e8b27bc19f5dc58ef1e5f9f966a2b53f9f4eb245bb5e209a734d4c4830b3297e03c9ecd5703b1ca512205ef2a94441a721b49d4b041c204b91821e935127dfe1f30a574989512d1f8c15e0d001243779ba571cedfb05c64a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"68e8692d376c161961edb60da275ad21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
